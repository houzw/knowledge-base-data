[
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.barscale.html", "name": "d.barscale", "definition": "- Displays a barscale on the graphics monitor.", "keywords": ["display", "cartography"], "synopsis": "d.barscale [-ftn]  [style=string]   [at=x,y]   [length=integer]   [units=string]   [label=string]   [segment=integer]   [color=name]   [bgcolor=name]   [text_position=string]   [width_scale=float]   [fontsize=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Use feet/miles instead of meters Draw the scale bar without text Display north-arrow symbol. Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Draw the scale bar without text Display north-arrow symbol. Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Display north-arrow symbol. Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "style", "flag": "style", "dataType": "String", "optional": true, "explanation": "Type of barscale to draw", "defaultValue": "classic", "alternatives": ["classic", "line", "solid", "hollow", "full_checker", "part_checker", "mixed_checker", "tail_checker", "up_ticks", "down_ticks", "both_ticks", "arrow_ends"], "isInputFile": false, "isOutputFile": false}, {"parameter": "at", "flag": "at", "dataType": "String", "optional": true, "explanation": "Screen coordinates of the rectangle's top-left corner", "defaultValue": "0.0,10.0", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "length", "flag": "length", "dataType": "String", "optional": true, "explanation": "Length of barscale in map units", "defaultValue": "0", "alternatives": ["0-"], "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Barscale units to display", "defaultValue": null, "alternatives": ["meters", "kilometers", "feet", "miles"], "isInputFile": false, "isOutputFile": false}, {"parameter": "label", "flag": "label", "dataType": "String", "optional": true, "explanation": "Custom label of unit", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "segment", "flag": "segment", "dataType": "String", "optional": true, "explanation": "Number of segments", "defaultValue": "10", "alternatives": ["1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Bar scale and text color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color (drawn behind the bar)", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "text_position", "flag": "text_position", "dataType": "String", "optional": true, "explanation": "Text position", "defaultValue": "right", "alternatives": ["under", "over", "left", "right"], "isInputFile": false, "isOutputFile": false}, {"parameter": "width_scale", "flag": "width_scale", "dataType": "String", "optional": true, "explanation": "Scale factor to change bar width", "defaultValue": "1", "alternatives": ["0.5-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "fontsize", "flag": "fontsize", "dataType": "String", "optional": true, "explanation": "Font size", "defaultValue": "12", "alternatives": ["1-360"], "isInputFile": false, "isOutputFile": false}], "description": "\n  d.barscale  displays a barscale on the graphics monitor at the\n given screen coordinates. If no coordinates are given it will draw the\n barscale in the bottom left of the display.\n The barscale can drawn in a number of styles (see  style \n parameter for their previews).\n ", "notes": "\n  d.barscale  will not work in Lat/Lon locations as the horizontal\n scale distance changes with latitude.\n Try  d.grid  instead.\n ", "see_also": ["d.graph", "d.grid", "d.legend", "d.northarrow", "g.region"], "authors": ["unknown, but from USACE/CERL."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.barscale"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.rast.edit.html", "name": "d.rast.edit", "definition": "- Edits cell values in a raster map.", "keywords": ["display", "editing", "raster"], "synopsis": "d.rast.edit input=name output=name  [aspect=name]   [width=integer]   [height=integer]   [size=integer]   [rows=integer]   [cols=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "aspect", "flag": "aspect", "dataType": "String", "optional": true, "explanation": "Name of input aspect raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Width of display canvas", "defaultValue": "640", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "height", "flag": "height", "dataType": "String", "optional": true, "explanation": "Height of display canvas", "defaultValue": "480", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Minimum size of each cell", "defaultValue": "12", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rows", "flag": "rows", "dataType": "String", "optional": true, "explanation": "Maximum number of rows to load", "defaultValue": "100", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cols", "flag": "cols", "dataType": "String", "optional": true, "explanation": "Maximum number of columns to load", "defaultValue": "100", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  d.rast.edit  program allows users to interactively\n edit cell category values in a raster map layer displayed to the\n graphics monitor using a mouse cursor.\n  USAGE \n  Note: this help page refers to the old Tcl/Tk version of this\n program. Parts of it may be out of date or wrong. \n  Overview window \n An overview window shows the entire map with a box showing the current\n editing region. The edit window shows the cells within the selected area.\n Click on a new spot on the overview window to move the editing area.\n Moving the editing view can take a while.\n  Mouse and menus \n Cell editing is done using a mouse cursor to choose menu selections\n and indicate areas on the displayed raster map that are to be edited.\n  Selections available at the top of the edit window are  Save  and\n  Exit .\n As the mouse travels over the cells in the edit window you are shown the\n current coordinates and current cell values under the cursor.\n  To change the value of a cell put the new value to use in the \"New value\"\n box at the bottom left of the edit window under the coordinate information\n bar. A value of \"*\" indicates a NULL value should be used.\n  Arrows \n This function is available for users editing aspect maps.  The\n  d.rast.arrow  program is\n called, which draws arrows over the displayed\n cells to indicate the downslope direction of the cell.\n You can set the aspect map to use on the command line.\n Aspect maps are expected to be in regular \"GRASS\" format, as produced by\n  r.slope.aspect ; i.e. degrees\n counter-clockwise from east.\n ", "notes": "\n There is no \"undo\" command or way to exit edit mode without saving\n changes.\n  Any MASK in place will be respected when writing the new raster map layer,\n including any edits to the MASKed areas.\n  Geographic Region Concerns \n  d.rast.edit  reads the region definition for the raster map layer\n being edited from its internal cell header file. The new, edited copy of\n the raster layer will be created with the same resolution and region\n dimensions.\n  The primary bane of the  d.rast.edit  program involves large map\n layers with lots of rows and columns) and/or slow computers,\n since the program must read and write raster map layers row by row for\n the full size of the map layer as dictated by its region size and resolution.\n (The current region settings of north, south, east, and west\n will not limit the size of the edited copy of the map layer,\n since by use of the overview selection these values may change several\n times during the editing session).\n  TODO \n It would be nice to incorporate a scrollable version of  \n  d.legend \n (such that one could see a label legend for files with many categories on\n a standard size sub-frame).  It would be even nicer to be able\n to select the category values from a graphical legend when editing\n cell values (thereby saving a trip to the text frame to type in the\n new value).\n  Perhaps method(s) for multiple  or mass cell edits would be useful.\n This could be done by providing modes in which the user may:\n   edit a block of cells to a given value by drawing a box; \n   be able to choose a given value which is automatically used as\n the new value on each cell chosen until a different value is desired. \n  There is no interrupt handling.   This could leave files in .tmp\n or (rarely) result in half-baked raster maps.  The original file\n would survive unscathed by an interrupt at most any point in execution.\n Beware of exiting the program\n by means other than using  exit  on the  Main Menu .\n ", "see_also": ["d.rast.arrow", "d.rast.num"], "authors": ["Tcl/Tk and wxPython versions: Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.rast.edit"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.rast.arrow.html", "name": "d.rast.arrow", "definition": "- Draws arrows representing cell aspect direction for a raster map containing aspect data.", "keywords": ["display", "map annotations", "raster"], "synopsis": "d.rast.arrow [-a] map=name  [type=string]   [color=name]   [grid_color=name]   [null_color=name]   [unknown_color=name]   [skip=integer]   [magnitude_map=string]   [scale=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Align grids with raster cells Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster aspect map to be displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of existing raster aspect map", "defaultValue": "grass", "alternatives": ["grass", "compass", "drainage", "agnps", "answers"], "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Color for drawing arrows", "defaultValue": "green", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "grid_color", "flag": "grid_color", "dataType": "String", "optional": true, "explanation": "Color for drawing drawing grid", "defaultValue": "gray", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_color", "flag": "null_color", "dataType": "String", "optional": true, "explanation": "Color for drawing null values (X symbol)", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "unknown_color", "flag": "unknown_color", "dataType": "String", "optional": true, "explanation": "Color for showing unknown information (? symbol)", "defaultValue": "red", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "skip", "flag": "skip", "dataType": "String", "optional": true, "explanation": "Draw arrow every Nth grid cell", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "magnitude_map", "flag": "magnitude_map", "dataType": "String", "optional": true, "explanation": "Raster map containing values used for arrow length", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Scale factor for arrows (magnitude map)", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.rast.arrow \n is designed to help users better visualize surface water flow direction,\n as indicated in an aspect raster map layer.  There are two ways to specify\n the aspect layer the program is to use.  The first is to display the aspect\n map layer on the graphics monitor before running  d.rast.arrow .\n The second method involves setting the  map  parameter\n to the name of the desired aspect map.\n This allows the arrows to be drawn over any other maps already displayed\n on the graphics monitor.\n  d.rast.arrow  will draw an arrow over each displayed cell\n to indicate in which direction the cell slopes. If the aspect\n layer has a category value denoting locations of \"unknown\" aspect,\n  d.rast.arrow  draws a question mark over the displayed cells\n of that category.\n Cells containing null data will be marked with an \"X\".\n You can disable drawing of null data and unknown aspect values by\n setting its color to \" none \".\n  When specifying the  magnitude_map  option, arrow lengths\n denoting magnitude will be extracted from the cell values of the specified\n map. In this case the tail of the arrow will be centered on the source cell.\n You may adjust the overall scale using the  scale  option.\n  d.rast.arrow  will ignore NULL and negative magnitudes, and will\n warn you if the debug level is set at 5 or higher. Be aware. If your application\n uses negative values for magnitude, you can use\n  r.mapcalc  to prepare the magnitude map to\n suit your needs (absolute value, inverted direction and so on).\n ", "notes": "\n By default, arrows are drawn at the size of a cell and cannot be seen if\n the raster map is relatively close in scale. You can use the  skip \n option to draw arrows every n-th cell in both directions if you are working\n with relatively high resolutions. It may be useful to disable the grid in\n this case, which is accomplished by setting its color to \" none \".\n  For GRASS and Compass type aspect maps, the cell values of the aspect map\n will determine the corresponding direction in 360 degrees. ANSWERS type aspect\n maps will be plotted in multiples of 15 degrees counterclockwise from east, and\n AGNPS and Drainage type aspect maps will be displayed in D8 representation,\n i.e. the eight multiples of 45 degrees. Cell values are 1 to 8 clockwise from\n north for AGNPS and 1 to 8 counterclockwise from north east for Drainage. See\n  r.watershed  for more details about the\n Drainage aspect.\n  GRASS aspect maps are measured using Cartesian conventions, i.e. in degrees\n counterclockwise from east. e.g.:\n 90  North\n 180 West\n 270 South\n 0,360 East\n They can be created from a raster elevation map with\n  r.slope.aspect .\n  Compass type aspect maps are measured in degrees clockwise from north.\n  This module uses oceanographic conventions, i.e. arrows point downslope or\n direction \"to\", as opposed to atmospheric conventions (direction \"from\").\n  EXAMPLE \n Convert U,V velocity component maps into magnitude,direction maps for use\n with  d.rast.arrow :\n r.mapcalc \"magnitude = sqrt(U_map^2 + V_map^2)\"\n r.mapcalc \"direction = atan(U_map, V_map)\"\n d.rast.arrow map=direction type=grass magnitude_map=magnitude skip=3 grid=none\n  \n  Sea wind speed (magnitude) and direction shown in the Tasmanian Sea \n ", "see_also": ["d.frame", "d.rast", "d.rast.edit", "d.rast.num", "g.region", "r.slope.aspect", "r.watershed"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.rast.arrow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.profile.html", "name": "d.profile", "definition": "- Plots profile of a transect.", "keywords": ["display", "profile", "raster"], "synopsis": "d.profile [-r] map=name coordinates=east,north[,east,north,...]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Use map's range recorded range Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Raster map to be profiled", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "Profile coordinate pairs", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This command displays the profile for a specified transect.\n ", "notes": "", "see_also": ["d.where", "r.profile", "r.transect", "wxGUI profile tool"], "authors": ["Glynn Clements This program has been completely re-written for 7.0. It bears no relation to the interactive d.profile module in previous versions."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.profile"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.polar.html", "name": "d.polar", "definition": "- Draws polar diagram of angle map such as aspect or flow directions", "keywords": ["display", "diagram"], "synopsis": "d.polar [-x] map=name  [undef=float]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "x", "flag": "-x", "explanation": "Plot using Xgraph Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster angle map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "undef", "flag": "undef", "dataType": "String", "optional": true, "explanation": "Pixel value to be interpreted as undefined (different from NULL)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for optional EPS output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  d.polar  calculates and displays a polar diagram of an\n angle raster map such as aspect, wind direction, or flow.\n The input angle map orientation must be counter-clockwise (CCW)\n from east, and the angle map units must be degrees. This refers\n to the standard orientation of GRASS (e.g., see  r.slope.aspect ).\n  The radius of the outer circle is defined by the total number\n of pixels in the map. If the polar diagram does not reach the\n outer circle, no data (NULL) pixels were found in the map.\n  The vector in the diagram indicates a prevailing direction, its length\n the strength of such direction. In case all angle vectors are oriented\n along the same direction, the length for the vector is maximal (in fact \n it is equal to length of the most populated bin of the underlying histogram).\n  As a side effect, the quality of the angle map can be derived from\n the diagram. Strong spikes may indicate an over-representation of\n the related angle(s) which happens in particular if integer maps\n are used.\n ", "notes": "\n If the  output  parameter is used, the diagram is generated\n as EPS file. If the  -x  flag is used  xgraph  is launched.\n Otherwise  d.polar  will use  d.graph  to draw the plot\n in the current display frame.\n  If  d.polar  is used on an aspect map generated by\n  r.slope.aspect , the  undef  parameter should be\n set to 0 to distinguish NO DATA (NULL) areas from areas where\n aspect is undefined (i.e. flat areas).\n  \n  Polar diagram of aspect map \n  EXAMPLE \n In this example, the polar diagram of the 'aspect' angle map in the\n North Carolina sample dataset location is generated:\n g.region raster=aspect -p\n d.polar aspect\n ", "see_also": ["d.graph", "d.histogram", "d.rast.arrow", "r.slope.aspect"], "authors": ["Markus Neteler, ITC-irst, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.polar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.path.html", "name": "d.path", "definition": "- Finds shortest path for selected starting and ending node.", "keywords": ["display", "network", "shortest path"], "synopsis": "d.path [-gb] map=name  [arc_type=string[,string,...]]  coordinates=x1,y1,x2,y2  [arc_layer=string]   [node_layer=string]   [arc_column=string]   [arc_backward_column=string]   [node_column=string]   [color=string]   [highlight_color=string]   [bgcolor=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Render bold lines Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Render bold lines Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_type", "flag": "arc_type", "dataType": "String", "optional": true, "explanation": "Arc type", "defaultValue": "line,boundary", "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "Starting and ending coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Original line color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "highlight_color", "flag": "highlight_color", "dataType": "String", "optional": true, "explanation": "Highlight color", "defaultValue": "red", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.path  enables shortest path vector networking.\n Costs may be either line lengths, or attributes saved in a database table.\n Supported are cost assignments for both arcs and nodes, and also different\n in both directions of a vector line. For areas cost will be calculated along\n boundary lines. \n ", "notes": "\n The user needs to display a vector map before using d.path. If no graphics monitor\n is open, a file  map.png  is generated in the current directory.\n The 'from' and 'to' points are entered by mouse into the map displayed in the GRASS monitor,\n or if the  coordinates  option is used they can be specified non-interactively.\n The actions bound to the mouse buttons are described in the terminal\n window when running the command.\n  To calculate shortest path non-interactively and save the path to a new vector\n map, use the  v.net.path  module.\n  EXAMPLES \n Interactive shortest path routing on road network (North Carolina sample dataset):\n g.region vector=roadsmajor -p\n d.vect roadsmajor\n d.path roadsmajor coordinates=668646.15,224447.16,668348.83,235894.02\n Non-interactive shortest path routing on road network (North Carolina sample dataset):\n d.path -b roadsmajor coordinates=668646.15,224447.16,668348.83,235894.02 \n ", "see_also": ["v.net.path"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.path"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.out.file.html", "name": "d.out.file", "definition": "- Saves the contents of the active display monitor to a graphics file.", "keywords": ["display", "export"], "synopsis": "d.out.file output=name format=string  [size=width,height]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": false, "explanation": "Graphics file format", "defaultValue": "png", "alternatives": ["png", "jpg", "bmp", "gif", "tif"], "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Width and height of output image", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.out.file  saves the content of the currently selected\n monitor into graphic file. The active monitor can be selected\n with  d.mon .  d.out.file  can be run from GUI\n Console tab, too.\n ", "notes": "", "see_also": ["d.redraw", "d.erase", "d.rast", "d.vect", "d.mon"], "authors": ["Anna Petrasova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.out.file"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.northarrow.html", "name": "d.northarrow", "definition": "- Displays a north arrow on the graphics monitor.", "keywords": ["display", "cartography"], "synopsis": "d.northarrow [-twr]  [style=string]   [at=x,y]   [rotation=float]   [label=string]   [color=name]   [fill_color=name]   [text_color=name]   [width=float]   [fontsize=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Draw the symbol without text Do not rotate text with symbol Use radians instead of degrees for rotation Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Do not rotate text with symbol Use radians instead of degrees for rotation Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Use radians instead of degrees for rotation Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "style", "flag": "style", "dataType": "String", "optional": true, "explanation": "North arrow style", "defaultValue": "1a", "alternatives": ["1a", "1b", "2", "3", "4", "5", "6", "7a", "7b", "8a", "8b", "9", "fancy_compass", "basic_compass", "arrow1", "arrow2", "arrow3", "star"], "isInputFile": false, "isOutputFile": false}, {"parameter": "at", "flag": "at", "dataType": "String", "optional": true, "explanation": "Screen coordinates of the rectangle's top-left corner", "defaultValue": "85.0,15.0", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "rotation", "flag": "rotation", "dataType": "String", "optional": true, "explanation": "Rotation angle in degrees (counter-clockwise)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label", "flag": "label", "dataType": "String", "optional": true, "explanation": "Displayed letter on the top of arrow", "defaultValue": "N", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Line color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fill_color", "flag": "fill_color", "dataType": "String", "optional": true, "explanation": "Fill color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "text_color", "flag": "text_color", "dataType": "String", "optional": true, "explanation": "Text color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Line width", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fontsize", "flag": "fontsize", "dataType": "String", "optional": true, "explanation": "Font size", "defaultValue": "14", "alternatives": ["1-360"], "isInputFile": false, "isOutputFile": false}], "description": "\n  d.northarrow  displays a north arrow symbol at\n the given screen coordinates. If no coordinates are given it will draw the\n north arrow in the bottom right of the display. It can draw the north arrow\n in a number of styles (see the\n   wiki\n page  for details).\n With certain styles of north arrow label 'N' is displayed by default,\n and can be changed with option  label , for example for different languages.\n The label can be hidden with  -t  flag.\n North arrow can be rotated, for example to align with true north, not grid north.\n The angle in degrees counter-clockwise (or radians with  -r  flag)\n can be specified with option  rotation . Label is rotated together with the\n arrow, unless flag  -w  is specified.\n  EXAMPLES \n Display a north arrow symbol as a basic compas with label NORTH,\n rotated by 8 degrees with label, with black line and gray fill: \n d.mon wx0\n d.northarrow style=basic_compas rotation=8 label=NORTH -w color=black fill_color=gray\n d.mon -r\n ", "notes": "", "see_also": ["d.barscale", "d.graph", "d.grid", "d.legend"], "authors": ["Hamish Bowman,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.northarrow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.mon.html", "name": "d.mon", "definition": "- Controls graphics display monitors from the command line.", "keywords": ["display", "graphics", "monitors"], "synopsis": "d.mon [-lpcgsrtux]  [start=string]   [stop=string]   [select=string]   [width=value]   [height=value]   [resolution=value]   [bgcolor=name]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "List running monitors and exit Print name of currently selected monitor and exit Print commands for currently selected monitor and exit Print path to support files of currently selected monitor and exit Do not automatically select when starting Release and stop currently selected monitor and exit Disable true colors Open output file in update mode Requires --overwrite flag Launch light-weight wx monitor without toolbars and statusbar Requires 'start=wx0-7' Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print name of currently selected monitor and exit Print commands for currently selected monitor and exit Print path to support files of currently selected monitor and exit Do not automatically select when starting Release and stop currently selected monitor and exit Disable true colors Open output file in update mode Requires --overwrite flag Launch light-weight wx monitor without toolbars and statusbar Requires 'start=wx0-7' Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Print commands for currently selected monitor and exit Print path to support files of currently selected monitor and exit Do not automatically select when starting Release and stop currently selected monitor and exit Disable true colors Open output file in update mode Requires --overwrite flag Launch light-weight wx monitor without toolbars and statusbar Requires 'start=wx0-7' Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print path to support files of currently selected monitor and exit Do not automatically select when starting Release and stop currently selected monitor and exit Disable true colors Open output file in update mode Requires --overwrite flag Launch light-weight wx monitor without toolbars and statusbar Requires 'start=wx0-7' Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Do not automatically select when starting Release and stop currently selected monitor and exit Disable true colors Open output file in update mode Requires --overwrite flag Launch light-weight wx monitor without toolbars and statusbar Requires 'start=wx0-7' Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Release and stop currently selected monitor and exit Disable true colors Open output file in update mode Requires --overwrite flag Launch light-weight wx monitor without toolbars and statusbar Requires 'start=wx0-7' Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Disable true colors Open output file in update mode Requires --overwrite flag Launch light-weight wx monitor without toolbars and statusbar Requires 'start=wx0-7' Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "u", "flag": "-u", "explanation": "Open output file in update mode Requires --overwrite flag Launch light-weight wx monitor without toolbars and statusbar Requires 'start=wx0-7' Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "x", "flag": "-x", "explanation": "Launch light-weight wx monitor without toolbars and statusbar Requires 'start=wx0-7' Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "start", "flag": "start", "dataType": "String", "optional": true, "explanation": "Name of monitor to start", "defaultValue": null, "alternatives": ["wx0", "wx1", "wx2", "wx3", "wx4", "wx5", "wx6", "wx7", "png", "ps", "html", "cairo"], "isInputFile": false, "isOutputFile": false}, {"parameter": "stop", "flag": "stop", "dataType": "String", "optional": true, "explanation": "Name of monitor to stop", "defaultValue": null, "alternatives": ["wx0", "wx1", "wx2", "wx3", "wx4", "wx5", "wx6", "wx7", "png", "ps", "html", "cairo"], "isInputFile": false, "isOutputFile": false}, {"parameter": "select", "flag": "select", "dataType": "String", "optional": true, "explanation": "Name of monitor to select", "defaultValue": null, "alternatives": ["wx0", "wx1", "wx2", "wx3", "wx4", "wx5", "wx6", "wx7", "png", "ps", "html", "cairo"], "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Width for display monitor if not set by GRASS_RENDER_WIDTH", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "height", "flag": "height", "dataType": "String", "optional": true, "explanation": "Height for display monitor if not set by GRASS_RENDER_HEIGHT", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "resolution", "flag": "resolution", "dataType": "String", "optional": true, "explanation": "Dimensions of display monitor versus current size", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (when starting new monitor)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  d.mon  allows the user to start, select, list, release, and\n stop available graphics monitors.\n  Starting a monitor \n In order to display on-screen GRASS graphics, the user must\n  start  and  select  a graphics monitor. By default,\n the  start  command actually runs two commands, to both start and\n select whatever monitor is named by the user. The user can get a list\n of running monitors by setting the  -l  flag on the command\n line. Note that some monitor  drivers  use environment\n  variables  or the specific\n  driver documentation .\n  When a monitor is  started , it is therefore also\n (automatically)  selected  for output, unless the\n  -s  flag is set by the user; the user can also\n explicitly  select  a monitor that has been started.\n  The desired monitor should be started once and need not be restarted\n unless it is stopped for some reason. A monitor may continue to run\n for any length of time, even when no GRASS session is being run.\n  Stopping a monitor \n A graphics monitor has two different types of status: monitor\n program  not running , and monitor  running . A monitor\n that has been started and/or selected will be listed as running; a\n monitor that has been stopped (or not started) will be listed as not\n running.  The  -l  flag will list all currently running monitors.\n  Selecting a monitor \n When the user  starts  a monitor, it is also\n (automatically)  selected  for graphics output unless the user\n sets the  -s  flag.  In order to use (direct graphics output to)\n a monitor, the user must  select  that monitor for use, either\n by simply starting the monitor without the  -s  flag or by\n explicitly selecting the monitor for output. Only running monitors can\n be selected for graphics output.\n  The user can run multiple graphics monitors by simply starting each of\n the graphics monitors the user wishes to direct output to.\n  Releasing (unselecting) a monitor \n Currently  selected  a monitor can be released by  -r \n flag.\n ", "notes": "\n  d.mon  is designed for interactive use. If non-interactive use\n is needed (e.g., in a script) set  GRASS_RENDER_IMMEDIATE=png \n (or  =cairo ) and use the related environment\n  variables  to control output size etc.\n  EXAMPLES \n  wx0 monitor \n To start the interactive  wxGUI map\n display , run\n d.mon start=wx0\n  \n  Figure: The initialization of display monitor wx0 \n All subsequently displayed data will be rendered on monitor  wx0 .\n g.region raster=elevation -p\n d.rast map=elevation\n  \n  Figure: The display wx0 showing an elevation raster map \n  CAIRO file renderer monitor \n A CAIRO monitor can be started (and selected) by\n d.mon start=cairo output=out.pdf\n From this moment on all displayed data will be rendered into\n file  output.pdf . \n  List running monitors \n To list the currently running monitors, use\n d.mon -l\n List of running monitors:\n wx0\n cairo\n  Show currently selected monitor \n To identify the currently selected monitor, use\n d.mon -p\n cairo\n  Switching between monitors \n To switch back to interactive display mode, here to an earlier started and\n still running wxGUI monitor, use\n d.mon select=wx0\n  Stopping a monitor \n To close the wxGUI monitor, run\n d.mon stop=wx0\n ", "see_also": ["d.erase", "d.redraw", "d.rast", "d.vect", "d.frame"], "authors": ["Martin Landa, OSGeoREL, Czech Technical University in Prague, Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.mon"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.linegraph.html", "name": "d.linegraph", "definition": "- Generates and displays simple line graphs in the active graphics monitor display frame.", "keywords": ["display", "cartography"], "synopsis": "d.linegraph [-xysl] x_file=string y_file=string[,string,...]  [directory=string]   [y_color=string[,string,...]]   [color_table=style]   [width=integer[,integer,...]]   [title_color=string]   [x_title=string]   [y_title=string]   [title=string]   [y_range=min,max]   [y_tics=float[,float,...]]   [x_scale=float]   [y_scale=float]   [icon=string]   [point_size=float]   [secondary_color=name]   [secondary_width=float[,float,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "x", "flag": "-x", "explanation": "Scale only X labels, not values Scale only Y labels, not values Draw points Do not draw lines Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "y", "flag": "-y", "explanation": "Scale only Y labels, not values Draw points Do not draw lines Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Draw points Do not draw lines Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Do not draw lines Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "x_file", "flag": "x_file", "dataType": "String", "optional": false, "explanation": "Name of data file for X axis of graph", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y_file", "flag": "y_file", "dataType": "String", "optional": false, "explanation": "Name of data file(s) for Y axis of graph", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "directory", "flag": "directory", "dataType": "String", "optional": true, "explanation": "Path to files", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y_color", "flag": "y_color", "dataType": "String", "optional": true, "explanation": "Color for Y data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color_table", "flag": "color_table", "dataType": "String", "optional": true, "explanation": "Name of color table", "defaultValue": null, "alternatives": ["aspect", "aspectcolr", "bcyr", "bgyr", "blues", "byg", "byr", "celsius", "corine", "curvature", "differences", "elevation", "etopo2", "evi", "fahrenheit", "gdd", "grass", "greens", "grey", "grey.eq", "grey.log", "grey1.0", "grey255", "gyr", "haxby", "kelvin", "ndvi", "ndwi", "oranges", "population", "population_dens", "precipitation", "precipitation_daily", "precipitation_monthly", "rainbow", "ramp", "random", "reds", "roygbiv", "rstcurv", "ryb", "ryg", "sepia", "slope", "soilmoisture", "srtm", "srtm_plus", "terrain", "viridis", "water", "wave"], "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Width of the lines", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title_color", "flag": "title_color", "dataType": "String", "optional": true, "explanation": "Color for axis, tics, numbers, and title", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "x_title", "flag": "x_title", "dataType": "String", "optional": true, "explanation": "Title for X data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y_title", "flag": "y_title", "dataType": "String", "optional": true, "explanation": "Title for Y data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for Graph", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y_range", "flag": "y_range", "dataType": "String", "optional": true, "explanation": "Minimum and maximun value for Y axis (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y_tics", "flag": "y_tics", "dataType": "String", "optional": true, "explanation": "Tic values for the Y axis", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "x_scale", "flag": "x_scale", "dataType": "String", "optional": true, "explanation": "Scale for X values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y_scale", "flag": "y_scale", "dataType": "String", "optional": true, "explanation": "Scale for Y values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "icon", "flag": "icon", "dataType": "String", "optional": true, "explanation": "Symbol for point", "defaultValue": "basic/circle", "alternatives": ["basic/arrow", "basic/arrow1", "basic/arrow2", "basic/arrow3", "basic/box", "basic/circle", "basic/cross1", "basic/cross2", "basic/cross3", "basic/diamond", "basic/hexagon", "basic/marker", "basic/octagon", "basic/pin", "basic/pin_dot", "basic/point", "basic/pushpin", "basic/star", "basic/triangle", "basic/x", "demo/muchomurka", "demo/smrk", "extra/4pt_star", "extra/adcp", "extra/airport", "extra/alpha_flag", "extra/bridge", "extra/dim_arrow", "extra/dive_flag", "extra/fiducial", "extra/fish", "extra/half-box", "extra/half-circle", "extra/offbox_ne", "extra/offbox_nw", "extra/offbox_se", "extra/offbox_sw", "extra/pentagon", "extra/ping", "extra/ring", "extra/simple_zia", "extra/target", "geology/circle_cross", "geology/half-arrow_left", "geology/half-arrow_right", "geology/strike_box", "geology/strike_circle", "geology/strike_cleavage", "geology/strike_half-bowtie", "geology/strike_line", "geology/strike_parallel", "geology/strike_triangle", "legend/area", "legend/area_curved", "legend/line", "legend/line_crooked", "n_arrows/basic_compass", "n_arrows/fancy_compass", "n_arrows/n_arrow1a", "n_arrows/n_arrow1b", "n_arrows/n_arrow2", "n_arrows/n_arrow3", "n_arrows/n_arrow4", "n_arrows/n_arrow5", "n_arrows/n_arrow6", "n_arrows/n_arrow7a", "n_arrows/n_arrow7b", "n_arrows/n_arrow8a", "n_arrows/n_arrow8b", "n_arrows/n_arrow9"], "isInputFile": false, "isOutputFile": false}, {"parameter": "point_size", "flag": "point_size", "dataType": "String", "optional": true, "explanation": "Point size", "defaultValue": "5", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "secondary_color", "flag": "secondary_color", "dataType": "String", "optional": true, "explanation": "Color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "secondary_width", "flag": "secondary_width", "dataType": "String", "optional": true, "explanation": "Width of point symbol lines", "defaultValue": "0.1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.linegraph  is a module to draw simple x,y line graphs\n (plots) based on numerical data contained in separate files.\n  Data format \n The X and Y data files for the graph are essentially a column of numbers in\n each file, with one input number per line.  The program expects that each X\n value will have a corresponding Y value, therefore the number of lines in\n each data input file should be the same.  Essentially, the X data becomes\n the X axis reference to which the Y data is plotted as a line. Therefore,\n the X data should be a monotonically increasing progression of numbers (i.e.\n \"1,2,3,...\"; \"0, 10, 100, 1000,...\"; \"...-5,-1,0,1,5...\").  If multiple Y\n data files are used, the Y axis scale will be based on the range of minimum\n and maximum values from all Y files, then all Y data given will be graphed\n according to that Y scale. Therefore, if multiple Y data inputs are used\n with dissimilar units, the graph produced comparing the two will be\n deceptive.\n  File inputs \n If the  directory  option is provided, the paths to files can (and\n should) be only relative paths to these files. While this is not recommended\n for scripting, it can be advantageous when typing the paths\n manually. For example when all files are stored in the directory\n  /home/john/data , the user can provide the following in the command\n line:\n d.linegraph directory=/home/john/data x_file=x.txt y_file=y1.txt,y2.txt\n  Managing colors \n The user can specify the  y_color  option, the  color_table \n option or just leave the defaults to influence the color of the\n plotted lines.\n Colors specified by  y_color  option are used for drawing the lines\n in the graph. If multiple Y data files are used, an equal number of\n colors may be used to control the colors of the lines. Colors will be\n assigned to Y data in respect to the sequence of instantiation on the\n command line. It can be one of GRASS GIS named colors or the RGB\n values from 0-255 separated by colons (RRR:GGG:BBB).\n Alternatively, the user can use the  color_table  option to specify one\n of the GRASS GIS predefined color tables.\n By default, a series of colors will be chosen by the module if none are\n provided upon invocation. The order of default colors is red, green,\n violet, blue, orange, gray, brown, magenta, white, and indigo. The user is\n advised not to rely on the order of default colors but to either use the\n  y_color  or the  color_table  option to obtain predictable and\n reproducible results.\n The color to be used for titles, axis lines, tics, and scale numbers\n is determined by the  title_color  option. The user can provide\n one of the GRASS GIS named colors (such as gray, white, or black)\n or use the GRASS GIS colon-separated format for RGB (RRR:GGG:BBB).\n  Titles, labels, and tics \n The  title  option specifies the text for the title of the graph.\n It will be centered over the top of graph.\n The  x_title  option is a text to describe data for X axis. It will be\n centered beneath the graph. Default is no text unless there is a need\n for a unit descriptor determined by the  d.linegraph  module,\n then string such as \"in hundreds\" is generated.\n The  y_title  option is a text to describe data for Y axis. It\n will be centered beneath the X data description. Similarly, to the\n  x_title  option, default is no text unless there is a need for an\n auto-generated description. In the case of graphs with multiple lines\n (multiple inputs for Y axis), user may wish to use more specific text\n placement using the  d.text  or\n  v.label  programs.\n ", "notes": "\n For historical reasons, the  d.linegraph  module accepts\n titles of more than one word where the underscore character (\"_\")\n is used to represent spaces (\" \"). For example \"Census_data_1990\" would be\n printed over the graph as \"Census data 1990\". The use of underscores is not\n necessary to use as long as the parameter is quoted in the command line.\n In general, use of underscores is not recommended and there is no need to use\n it at all in the GUI or when using  d.linegraph  in Python scripts.\n The way the program locates and labels tic marks is less than perfect:\n 1) although distances between Y tics are proportional to the value, they are\n not proportional on the X axis;\n 2) decimal values between -1 and 1 can be printed on the X axis, but not\n on Y. (With respect to the later, the input for Y values can all be\n multiplied by a factor of 10 before graphing).\n Depending on the user's needs, it might be easier or more appropriate\n to use a 3rd party tool such as xgraph, gnuplot, Matplotlib in Python,\n or R instead of  d.linegraph .\n For a more general solution for plotting in GRASS GIS, the user is\n advised to use the  d.graph  module.\n  EXAMPLE \n The following can be executed in Bash to create the input data for this\n example. The user can just create these files in a text editor, save\n them and specify path to them.\n cat > x.txt <<EOF\n 1\n 3\n 4\n 6\n 9\n EOF\n cat > y1.txt <<EOF\n 50\n 58\n 65\n 34\n 27\n EOF\n cat > y2.txt <<EOF\n 10\n 20\n 35\n 50\n 45\n EOF\n The next command sequence creates a file  plot.png  in the current\n directory which is the drawing made by  d.linegraph .\n d.mon start=cairo output=plot.png width=400 height=400\n d.linegraph x_file=x.txt y_file=y1.txt,y2.txt\n d.mon stop=cairo\n ", "see_also": ["d.frame", "d.text", "v.label", "d.graph", "d.histogram"], "authors": ["Chris Rewerts, Agricultural Engineering, Purdue University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.linegraph"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.legend.vect.html", "name": "d.legend.vect", "definition": "- Displays a vector legend in the active graphics frame.", "keywords": ["display", "cartography", "vector", "legend"], "synopsis": "d.legend.vect [-b]  [at=left,top]   [columns=integer]   [title=string]   [symbol_size=integer]   [border_color=name]   [bgcolor=name]   [border_width=integer]   [font=string]   [fontsize=float]   [title_font=string]   [title_fontsize=float]   [sub_font=string]   [sub_fontsize=float]   [fontcolor=name]   [separator=character]   [input=name]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "b", "flag": "-b", "explanation": "Display legend background Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "at", "flag": "at", "dataType": "String", "optional": true, "explanation": "Screen position of legend to be drawn (percentage, [0,0] is lower left)", "defaultValue": "10,40", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Number of legend columns", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Legend title", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "symbol_size", "flag": "symbol_size", "dataType": "String", "optional": true, "explanation": "Symbol size", "defaultValue": "20", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "border_color", "flag": "border_color", "dataType": "String", "optional": true, "explanation": "Border color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "border_width", "flag": "border_width", "dataType": "String", "optional": true, "explanation": "Background border width", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "font", "flag": "font", "dataType": "String", "optional": true, "explanation": "Font name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fontsize", "flag": "fontsize", "dataType": "String", "optional": true, "explanation": "Font size", "defaultValue": null, "alternatives": ["1-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "title_font", "flag": "title_font", "dataType": "String", "optional": true, "explanation": "Title font name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title_fontsize", "flag": "title_fontsize", "dataType": "String", "optional": true, "explanation": "Title font size", "defaultValue": null, "alternatives": ["1-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "sub_font", "flag": "sub_font", "dataType": "String", "optional": true, "explanation": "Subtitle font name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sub_fontsize", "flag": "sub_fontsize", "dataType": "String", "optional": true, "explanation": "Subtitle font size", "defaultValue": null, "alternatives": ["1-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "fontcolor", "flag": "fontcolor", "dataType": "String", "optional": true, "explanation": "Font color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator for input file", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Input legend file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Output csv file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n Module  d.legend.vect  draws vector legend of currently displayed vector maps.\n Parameter  at  defines the screen position of upper-left legend corner.\n Parameter  columns  defines the number of legend columns.\n User can specify a title of the legend using parameter  title .\n The font of the title can be changed with  title_font ,  title_fontsize .\n Flag  -b  is used to draw background of specified color ( bgcolor ),\n border color and border width ( border_color  and  border_width ).\n Parameter  symbol_size  defines the size of line and area symbols.\n The size of point symbols is based on currently set symbology of vector maps using\n  d.vect  or\n  d.vect.thematic .\n  Module  d.vect.legend  supports subtitles (see section Notes).\n Their font and font size can be set using parameters  sub_font \n and  sub_fontsize .\n  Changing legend symbols and labels \n Symbols for vector areas and lines, and labels for individual vector labels\n can be changed in the symbology setting of each vector map in\n  d.vect  or\n  d.vect.thematic \n module (in Legend tab). Use its parameters\n  icon_area  and  icon_line  to pick from available symbols.\n By using parameter  legend_label  of  d.vect  module, users can change\n the default label, which is the map name.\n  Modifying the order of legend entries and omitting certain vector maps\n from legend \n Modules  d.vect  and \n  d.vect.thematic \n have a flag  -s \n which removes the particular vector or thematic vector from vector legend.\n  The order of entries is defined by the order in Layer Manager (if used\n in GRASS GIS GUI). If that's not desired, one can export the legend file\n into a text file using parameter  output , change the order of entries\n (see section Notes for format description) and then upload the modified file\n with parameter  input .\n Parameter  output  defines path to the file where the internal legend\n file will be saved to,  input  defines the input file which\n the vector legend will be based on (input file must have correct format).\n ", "notes": "\n Module  d.legend.vect  draws vector legend based on legend file defined\n in shell environment variable GRASS_LEGEND_FILE.\n This file is automatically created and updated whenever\n  d.vect  command is used.\n User can create custom legend file and then use \n  export GRASS_LEGEND_FILE=path/to/file  in shell.\n GRASS GUI and MONITORS create the legend file automatically.\n By default the legend file is stored in grassdata/location/mapset/.tmp/user\n directory (in case of d.mon deeper in /monitor_name directory). \n Legend file has this format:\n label|symbol_name|size|color_type|feature_color|fill_color|line_width|geometry_type|feature_count\n Color type can be 'lf' or 'ps'. Based on color type color columns are interpreted\n as line color and fill colors (lf), or primary and secondary colors (ps).\n Module d.vect always uses 'lf' and d.vect.thematic 'ps'.\n Here is an example of legend file with subtitles:\n Infrastructure||||||||\n major roads|legend/line|5|lf|black|200:200:200|2|line|355\n bridges|extra/bridge|15|lf|black|black|1|point|10938\n Hydrology||||||||\n streams|legend/line_crooked|5|lf|30:144:255|200:200:200|3|line|8554\n water bodies|legend/area_curved|5|lf|none|30:144:255|1|area|27764\n  EXAMPLES \n Open cairo monitor to render to file:\n g.region vector=nc_state\n d.mon cairo\n d.vect map=nc_state color=26:26:26 fill_color=229:229:229 width=2 legend_label=\"state boundaries\"\n d.vect map=urbanarea color=none fill_color=127:127:127 width=1 legend_label=\"urban areas\"\n d.vect map=railroads color=red width=1\n d.vect map=hospitals color=77:77:77 fill_color=0:187:0 width=1 icon=basic/cross3 size=10\n d.legend.vect -b at=2,40 title=\"Hospitals in North Carolina\" symbol_size=26 fontsize=16 title_fontsize=20\n  \n ", "see_also": ["d.vect", "d.vect.thematic", "d.legend"], "authors": ["Adam Laza, during GSoC 2016 Mentors: Anna Petrasova, Vaclav Petras, Martin Landa"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.legend.vect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.legend.html", "name": "d.legend", "definition": "- Displays a legend for a 2D or 3D raster map in the active frame of the graphics monitor.", "keywords": ["display", "cartography", "legend"], "synopsis": "d.legend [-vctnsfdbl]  [raster=name]   [raster_3d=name]   [title=string]   [title_fontsize=float]   [lines=integer]   [thin=integer]   [units=string]   [labelnum=integer]   [label_values=float[,float,...]]   [label_step=float]   [digits=integer]   [at=bottom,top,left,right]   [use=float[,float,...]]   [range=min,max]   [color=name]   [font=string]   [fontsize=float]   [path=name]   [charset=string]   [border_color=name]   [bgcolor=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "v", "flag": "-v", "explanation": "Do not show category labels Do not show category numbers Draw legend ticks for labels Skip categories with no label Draw smooth gradient Flip legend Add histogram to smoothed legend Show background Use logarithmic scale Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Do not show category numbers Draw legend ticks for labels Skip categories with no label Draw smooth gradient Flip legend Add histogram to smoothed legend Show background Use logarithmic scale Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Draw legend ticks for labels Skip categories with no label Draw smooth gradient Flip legend Add histogram to smoothed legend Show background Use logarithmic scale Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Skip categories with no label Draw smooth gradient Flip legend Add histogram to smoothed legend Show background Use logarithmic scale Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Draw smooth gradient Flip legend Add histogram to smoothed legend Show background Use logarithmic scale Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Flip legend Add histogram to smoothed legend Show background Use logarithmic scale Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Add histogram to smoothed legend Show background Use logarithmic scale Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Show background Use logarithmic scale Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Use logarithmic scale Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster_3d", "flag": "raster_3d", "dataType": "String", "optional": true, "explanation": "Name of 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Legend title", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title_fontsize", "flag": "title_fontsize", "dataType": "String", "optional": true, "explanation": "Title font size", "defaultValue": null, "alternatives": ["1-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "lines", "flag": "lines", "dataType": "String", "optional": true, "explanation": "Number of text lines (useful for truncating long legends)", "defaultValue": "0", "alternatives": ["0-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "thin", "flag": "thin", "dataType": "String", "optional": true, "explanation": "Thinning factor (thin=10 gives cats 0,10,20...)", "defaultValue": "1", "alternatives": ["1-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Units to display after labels (e.g. meters)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "labelnum", "flag": "labelnum", "dataType": "String", "optional": true, "explanation": "Number of text labels for smooth gradient legend", "defaultValue": "5", "alternatives": ["2-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "label_values", "flag": "label_values", "dataType": "String", "optional": true, "explanation": "Specific values to draw ticks", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label_step", "flag": "label_step", "dataType": "String", "optional": true, "explanation": "Display label every step", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "digits", "flag": "digits", "dataType": "String", "optional": true, "explanation": "Number of digits after decimal point", "defaultValue": null, "alternatives": ["0-6"], "isInputFile": false, "isOutputFile": false}, {"parameter": "at", "flag": "at", "dataType": "String", "optional": true, "explanation": "Size and placement as percentage of screen coordinates (0,0 is lower left)", "defaultValue": null, "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "use", "flag": "use", "dataType": "String", "optional": true, "explanation": "List of discrete category numbers/values for legend", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "range", "flag": "range", "dataType": "String", "optional": true, "explanation": "Use a subset of the map range for the legend (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Text color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "font", "flag": "font", "dataType": "String", "optional": true, "explanation": "Font name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fontsize", "flag": "fontsize", "dataType": "String", "optional": true, "explanation": "Font size", "defaultValue": null, "alternatives": ["1-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "path", "flag": "path", "dataType": "String", "optional": true, "explanation": "Path to font file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "charset", "flag": "charset", "dataType": "String", "optional": true, "explanation": "Text encoding (only applicable to TrueType fonts)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "border_color", "flag": "border_color", "dataType": "String", "optional": true, "explanation": "Border color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.legend  displays a legend for a user-specified raster map or\n 3D raster map layer in the active frame on the graphics monitor.  \n The legend's default size is based on the dimensions of the\n active frame, specifically its height.   d.legend  will only\n obscure those portions of the active frame that directly underlie the legend.\n ", "notes": "\n When using the  at  to size & place the legend, a user may\n create a horizontal legend by making the box wider than it is tall.\n Raster maps based on floating point values will display smoothed, from greatest\n to smallest value, while categorical raster maps will display in order, from\n top to bottom. Horizontal legends will always be smoothed. If the box is defined\n with inverted y-values or an inverted  range , the legend will automatically\n flip. If this is not the desired result, the  -f  flag may be used to flip\n it back.\n If the user attempts to display a very long legend in a relatively short \n display frame, the legend may appear in unreadably small text, or even revert\n to a smooth gradient legend. Use the  lines ,  thin ,  use ,  range ,\n and/or  -n  options to reduce the number of categories to be displayed,\n or the  -s  flag to force a smooth gradient legend. \n The  lines  option will display the first number of categories, as defined\n by  value , contained in the raster map. When used with the  -n  flag,\n it takes on a new meaning: \"up to category #\". When used with both\n  thin  and the  -n  flag, its meaning becomes more obscure. When\n using  lines , auto-scaled text similar to \"4 of 16 categories\" will be placed at \n the bottom of the legend.\n The  thin  option sets the thinning factor. For raster maps with a 0th\n category,  thin= 10  gives cats [0,10,20,...]. For raster maps \n starting at category 1,  thin= 10  gives cats [1,11,21,...].\n The  use  option lets the user create a legend made up of arbitrary category\n values. e.g.\u00a0 use= 1000,100,10,0,-10,-100,-1000 \n The  range  option lets the user define the minimum and maximum categories\n to be used in the legend. It may also be used to define the limits of a smooth\n gradient legend created from a raster containing floating point values. Note\n the color scale will remain faithful to the category values as defined with\n  r.colors , and the  range  may be\n extended to the limits defined by the  r.colors \n color map.\n The flag  -n  is useful for categorial maps, as it suppresses the\n drawing of non-existing categories (otherwise the full range is shown).\n Vertical legends produced with  d.legend  will place text labels to the\n right of the legend box, horizontal legends will place text below. This text\n will be auto-scaled to fit within the frame, reducing the size of the legend\n if necessary. Legends positioned with the  at  option\n will not auto-scale text, in order to provide more control to the user.\n Smaller text may be obtained in this case by reducing the height of the box\n or by using the  fontsize  option. The  -c  and  -v  flags may\n be used to suppress the display of category numbers and labels respectively,\n or used together to suppress all text of categorial raster maps.\n The text produced from floating-point raster maps will automatically create\n output with a meaningful number of significant digits. For very small values,\n numbers will be expressed in scientific notation, e.g.\u00a0\"1.7e-9\". Option\n  digits  can be used to determine how many digits after decimal point\n will be displayed.\n When the  -d  flag is used to display a histogram distribution along\n side the smoothed gradient legend, note that the statistics are calculated\n on the  current computational region  settings set by  g.region .\n The default  range  however covers the entire natural bounds of the input map.\n If the histogram appears empty, check your region settings.\n If the raster map's  units  metadata has been set with the\n  r.support  module then it will be displayed along side the legend.\n The option  title  will display the custom title at the top of the legend. \n In case of vertical legend the title is aligned to the left edge of legend, in case\n of horizontal legend the title is aligned to the center.  title_fontsize  can\n be used to set the size of legend title. By default the legend title font size is\n the same as labels font size. \n There are different options to customize displayed labels. The  labelnum  set\n the number of labels which are displayed in regular intervals. The  label_values \n will specify the values where the labels will be displayed. The  label_step  will\n display labels at values which are divisible by this value.\n The flag  -t  will show ticks at labels.\n The flag  -b  will show the background. Options  bgcolor  and  border_color  can be\n used to choose the color of border and background fill.\n The flag  -l  will switch to logarithmic scale. In case this flag is used,\n the provided step in  label_step  is interpreted in the logarithmic space.\n  EXAMPLE \n Displaying the legend along with a histogram (North Carolina Sample dataset):\n g.region raster=elevation -p\n d.rast elevation\n d.legend -d elevation\n  \n Displaying the legend with custom labels and background:\n g.region raster=elevation -p\n d.rast elevation\n d.legend raster=elevation -t label_step=20 label_values=108 title=Legend -b bgcolor=255:255:204 border_color=gray\n  \n Displaying the legend with logarithmic scale:\n g.region raster=elevation -p\n r.watershed -a elevation=elevation threshold=1000 accumulation=flowacc\n d.rast flowacc\n d.legend raster=flowacc -t -l label_step=1\n  \n ", "see_also": ["d.barscale", "d.colortable", "d.font", "d.grid", "d.rast", "d.rast.leg", "d.text", "d.vect.thematic", "r.reclass", "r.stats", "r3.stats"], "authors": ["Bill Brown, U.S. Army Construction Engineering Research Laboratories"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.legend"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.labels.html", "name": "d.labels", "definition": "- Displays text labels (created with v.label) to the active frame on the graphics monitor.", "keywords": ["display", "paint labels"], "synopsis": "d.labels [-i] labels=string  [minreg=float]   [maxreg=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Ignore rotation setting and draw horizontally Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "labels", "flag": "labels", "dataType": "String", "optional": false, "explanation": "Name of label file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "minreg", "flag": "minreg", "dataType": "String", "optional": true, "explanation": "Minimum region size (diagonal) when labels are displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxreg", "flag": "maxreg", "dataType": "String", "optional": true, "explanation": "Maximum region size (diagonal) when labels are displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.labels  displays a  paint  label file in the \n active display frame on the graphics monitor. Each label has components \n which determine the text, the location of the text on the image, its \n size, and the background for the text. This file can be generated with \n the  v.label  program or simply created \n by the user as an ASCII file (using a text editor) and placed in the \n appropriate directory under the user's current mapset and location \n (i.e.  $MAPSET/paint/labels/ ).\n ", "notes": "\n Some of the information stored in the label file is unused by \n  d.labels .\n This extra information is used by such programs as \n  ps.map .\n  This module was formerly known as  d.paint.labels .\n The the old version of  d.labels  from GRASS 5, which provided\n interactive placement and modification of paint labels, still needs to \n have its functionality merged into this module.\n ", "see_also": ["d.font", "d.text", "d.title", "ps.map", "v.label"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.labels"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.info.html", "name": "d.info", "definition": "- Displays information about the active display monitor.", "keywords": ["display", "graphics", "monitors"], "synopsis": "d.info [-rdfebg]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Display screen rectangle (left, right, top, bottom) Display screen dimensions (width, height) Display active frame rectangle Display frame dimensions (width, height) Display screen rectangle of current region Display geographic coordinates and resolution of entire frame Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Display screen dimensions (width, height) Display active frame rectangle Display frame dimensions (width, height) Display screen rectangle of current region Display geographic coordinates and resolution of entire frame Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Display active frame rectangle Display frame dimensions (width, height) Display screen rectangle of current region Display geographic coordinates and resolution of entire frame Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Display frame dimensions (width, height) Display screen rectangle of current region Display geographic coordinates and resolution of entire frame Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Display screen rectangle of current region Display geographic coordinates and resolution of entire frame Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Display geographic coordinates and resolution of entire frame Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "\n  d.info  displays information about the active display\n monitor. Display monitors are maintained\n by  d.mon .\n  EXAMPLES \n d.mon start=cairo\n d.info -r\n rectangle: 0.000000 640.000000 0.000000 480.000000\n ", "notes": "\n Units are screen pixels (except for  -g  flag where map units are\n used).\n  Where two numbers are given the format is: width, height.\n  Where four numbers are given the format is: left, right, top, bottom.\n Note: GRASS display pixel coordinates are measured from the top left.\n ", "see_also": ["d.mon", "d.vect", "d.rast"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.info"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.histogram.html", "name": "d.histogram", "definition": "- Displays a histogram in the form of a pie or bar chart for a user-specified raster map.", "keywords": ["display", "histogram", "statistics"], "synopsis": "d.histogram [-nc] map=name  [style=string]   [color=name]   [bgcolor=name]   [nsteps=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Display information for null cells Report for ranges defined in cats file (fp maps only) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Report for ranges defined in cats file (fp maps only) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Raster map for which histogram will be displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "style", "flag": "style", "dataType": "String", "optional": true, "explanation": "Indicate if a pie or bar chart is desired", "defaultValue": "bar", "alternatives": ["pie", "bar"], "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Color for text and axes", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nsteps", "flag": "nsteps", "dataType": "String", "optional": true, "explanation": "Number of steps to divide the data range into (fp maps only)", "defaultValue": "255", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.histogram  displays the category-value distribution for a\n user-specified raster map layer, in the form of a bar chart or a pie chart. \n The display will be displayed in the active display frame on the graphics\n monitor, using the colors in the raster map layer's color table.  The\n program determines the raster map's category value distribution by counting\n cells.\n ", "notes": "\n  d.histogram  respects the current geographic region settings \n and the current MASK (if one exists). \n  d.histogram  uses the colors in the map's color look-up table\n (i.e., the map's  colr  or  colr2  file).\n  EXAMPLES \n Running the command below will generate the bar graph shown in the figure:\n g.region raster=elevation -p\n d.mon wx0\n d.histogram map=elevation\n  \n  Figure: Bar graph histogram for elevation map \n Running the command below will generate the pie graph shown in the figure:\n g.region raster=landuse96_28m -p\n d.histogram map=landuse96_28m style=pie  \n  \n  Figure: Pie graph histogram for landuse map \n ", "see_also": ["d.colortable", "d.frame", "d.graph", "d.linegraph", "d.mon", "d.polar", "g.region", "r.stats"], "authors": ["Dave Johnson"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.histogram"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.histogram.html", "name": "d.histogram", "definition": "- Displays a histogram in the form of a pie or bar chart for a user-specified raster map.", "keywords": ["display", "histogram", "statistics"], "synopsis": "d.histogram [-nc] map=name  [style=string]   [color=name]   [bgcolor=name]   [nsteps=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Display information for null cells Report for ranges defined in cats file (fp maps only) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Report for ranges defined in cats file (fp maps only) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Raster map for which histogram will be displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "style", "flag": "style", "dataType": "String", "optional": true, "explanation": "Indicate if a pie or bar chart is desired", "defaultValue": "bar", "alternatives": ["pie", "bar"], "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Color for text and axes", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nsteps", "flag": "nsteps", "dataType": "String", "optional": true, "explanation": "Number of steps to divide the data range into (fp maps only)", "defaultValue": "255", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.histogram  displays the category-value distribution for a\n user-specified raster map layer, in the form of a bar chart or a pie chart. \n The display will be displayed in the active display frame on the graphics\n monitor, using the colors in the raster map layer's color table.  The\n program determines the raster map's category value distribution by counting\n cells.\n ", "notes": "\n  d.histogram  respects the current geographic region settings \n and the current MASK (if one exists). \n  d.histogram  uses the colors in the map's color look-up table\n (i.e., the map's  colr  or  colr2  file).\n  EXAMPLES \n Running the command below will generate the bar graph shown in the figure:\n g.region raster=elevation -p\n d.mon wx0\n d.histogram map=elevation\n  \n  Figure: Bar graph histogram for elevation map \n Running the command below will generate the pie graph shown in the figure:\n g.region raster=landuse96_28m -p\n d.histogram map=landuse96_28m style=pie  \n  \n  Figure: Pie graph histogram for landuse map \n ", "see_also": ["d.colortable", "d.frame", "d.graph", "d.linegraph", "d.mon", "d.polar", "g.region", "r.stats"], "authors": ["Dave Johnson"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.histogram"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.his.html", "name": "d.his", "definition": "- Displays the result obtained by combining hue, intensity, and saturation (HIS) values from user-specified input raster map layers.", "keywords": ["display", "graphics", "color transformation", "RGB", "HIS", "IHS"], "synopsis": "d.his [-n] hue=string  [intensity=string]   [saturation=string]   [brighten=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Respect NULL values while drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "hue", "flag": "hue", "dataType": "String", "optional": false, "explanation": "Name of layer to be used for hue", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "intensity", "flag": "intensity", "dataType": "String", "optional": true, "explanation": "Name of layer to be used for intensity", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "saturation", "flag": "saturation", "dataType": "String", "optional": true, "explanation": "Name of layer to be used for saturation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "brighten", "flag": "brighten", "dataType": "String", "optional": true, "explanation": "Percent to brighten intensity channel", "defaultValue": "0", "alternatives": ["-99-99"], "isInputFile": false, "isOutputFile": false}], "description": "\n  HIS  stands for hue, intensity, and saturation.\n This program produces a raster map layer providing a\n visually pleasing combination of hue, intensity, and\n saturation values from two or three user-specified raster\n map layers.\n The human brain automatically interprets the vast amount of\n visual information available according to basic rules. \n Color, or  hue , is used to categorize objects. \n Shading, or  intensity , is interpreted as\n three-dimensional texturing. Finally, the degree of\n haziness, or  saturation , is associated with\n distance or depth. This program allows data from up to\n three raster map layers to be combined into an image which\n retains the original information in terms of  hue ,\n  intensity , and  saturation .\n  OPTIONS \n This program can be run non-interactively or\n interactively.  It will run non-interactively if the user\n specifies on the command line the name of a map containing\n hue values ( hue ), and the name(s) of map(s)\n containing intensity values ( intensity ) and/or\n saturation values ( saturation ).  The resulting image will\n be displayed in the active display frame on the graphics\n monitor.\n Alternately, the user can run the program interactively by\n typing  d.his  without naming parameter values on the\n command line.  In this case, the program will prompt the\n user for parameter values using the standard GRASS \n GUI interface.\n While any raster map layer can be used to represent the hue\n information, map layers with a few very distinct colors\n work best.  Only raster map layers representing\n continuously varying data like elevation, aspect, weights,\n intensities, or amounts can suitably be used to provide\n intensity and saturation information.\n For example, a visually pleasing image can be\n made by using a watershed map for the  hue  factor,\n an aspect map for the  intensity  factor, and an\n elevation map for  saturation .  (The user may wish\n to leave out the elevation information for a first try.)\n Ideally, the resulting image should resemble the view from\n an aircraft looking at a terrain on a sunny day with a bit\n of haze in the valleys.\n  The  brighten  option does not truly represent a percentage,\n but calling it that makes the option easy to understand, and it\n sounds better than  Normalized Scaling Factor .\n  THE PROCESS \n Each map cell is processed individually. First, the working\n color is set to the color of the corresponding cell in the\n map layer chosen to represent  hue .  Second, this\n color is multiplied by the  red  intensity of that\n cell in the  intensity  map layer.  This map layer\n should have an appropriate gray-scale color table\n associated with it. You can ensure this by using the color\n manipulation capabilities of\n  r.colors .\n Finally, the color is made somewhat gray-based on the\n  red  intensity of that cell in the\n  saturation  map layer.  Again, this map layer\n should have a gray-scale color table associated with it.\n ", "notes": "\n The name is misleading. The actual conversion used is\n    H .i.s +  G .(1-s)\n where\n    H    is the R,G,B color from the hue map\n   i   is the red value from the intensity map\n   s   is the red value from the saturation map\n    G    is 50% gray (R = G = B = 0.5)\n Either (but not both) of the intensity or the saturation\n map layers may be omitted. This means that it is possible\n to produce output images that represent combinations of\n  his, hi,  or  hs .\n  Users wishing to store the result in new raster map layers\n instead of displaying it on the monitor should use the\n command  r.his .\n  EXAMPLE \n g.region raster=elevation\n r.relief input=elevation output=elevation_shaded_relief\n d.mon wx0\n d.his hue=elevation intensity=elevation_shaded_relief brighten=50\n ", "see_also": ["d.colortable", "d.frame", "d.rgb", "d.shade", "r.colors", "r.his", "i.his.rgb", "i.rgb.his"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.his"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.grid.html", "name": "d.grid", "definition": "- Overlays a user-specified grid in the active display frame on the graphics monitor.", "keywords": ["display", "cartography", "graticule", "grid"], "synopsis": "d.grid [-agwcdfnbt] size=value  [origin=east,north]   [direction=string]   [width=float]   [color=name]   [border_color=name]   [text_color=name]   [bgcolor=name]   [fontsize=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Align the origin to the east-north corner of the current region Draw geographic grid (referenced to current ellipsoid) Draw geographic grid (referenced to WGS84 ellipsoid) Draw '+' marks instead of grid lines Draw '.' marks instead of grid lines Draw fiducial marks instead of grid lines Disable grid drawing Disable border drawing Disable text drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Draw geographic grid (referenced to current ellipsoid) Draw geographic grid (referenced to WGS84 ellipsoid) Draw '+' marks instead of grid lines Draw '.' marks instead of grid lines Draw fiducial marks instead of grid lines Disable grid drawing Disable border drawing Disable text drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Draw geographic grid (referenced to WGS84 ellipsoid) Draw '+' marks instead of grid lines Draw '.' marks instead of grid lines Draw fiducial marks instead of grid lines Disable grid drawing Disable border drawing Disable text drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Draw '+' marks instead of grid lines Draw '.' marks instead of grid lines Draw fiducial marks instead of grid lines Disable grid drawing Disable border drawing Disable text drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Draw '.' marks instead of grid lines Draw fiducial marks instead of grid lines Disable grid drawing Disable border drawing Disable text drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Draw fiducial marks instead of grid lines Disable grid drawing Disable border drawing Disable text drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Disable grid drawing Disable border drawing Disable text drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Disable border drawing Disable text drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Disable text drawing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": false, "explanation": "Size of grid to be drawn (in map units)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "origin", "flag": "origin", "dataType": "String", "optional": true, "explanation": "Lines of the grid pass through this coordinate", "defaultValue": "0,0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "direction", "flag": "direction", "dataType": "String", "optional": true, "explanation": "Draw only east-west lines, north-south lines, or both", "defaultValue": "both", "alternatives": ["both", "east-west", "north-south"], "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Grid line width", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Grid color", "defaultValue": "gray", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "border_color", "flag": "border_color", "dataType": "String", "optional": true, "explanation": "Border color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "text_color", "flag": "text_color", "dataType": "String", "optional": true, "explanation": "Text color", "defaultValue": "gray", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fontsize", "flag": "fontsize", "dataType": "String", "optional": true, "explanation": "Font size for gridline coordinate labels", "defaultValue": "9", "alternatives": ["1-72"], "isInputFile": false, "isOutputFile": false}], "description": "\n  d.grid  overlays a grid of user-defined size and\n color in the active display frame on the graphics monitor.\n The grid can be created as a standard rectangular grid or\n a geographic grid.\n If the user provides a  -g  flag a geographic (projected) grid\n will be drawn. With the  -g  flag the  size \n argument accepts both decimal degrees and colon separated\n ddd:mm:ss coordinates (eg.  00:30:00  for half of a degree).\n A geographic grid cannot be drawn for a  latitude/longitude  \n or  XY  projection.\n Colors may be standard named GRASS colors (red, green, aqua, etc.) or\n a numerical R:G:B triplet, where component values range from 0-255.\n Grid color can be set with option  color . Options  text_color  and \n  bgcolor  set the color of the text and its background.\n The grid drawing may be turned off by using the  -n  flag. \n The border drawing may be turned off by using the  -b  flag. \n The coordinate text may be turned off by using the  -t  flag. \n To draw grid lines at different intervals, e.g. at high latitudes, you\n can run the module twice, once with  direction = east-west \n at one interval  size , and again with\n  direction = north-south  at another interval  size .\n  EXAMPLES \n To draw a red geographic grid with 30 minute grid spacing, run \n one of the following commands:\n d.grid -g size=00:30:00 color=red\n or\n d.grid -g size=0.5 color=255:0:0\n  \n  Figure: Showing a geographic grid in red line color \n To draw a blue standard rectangular grid at a 500 (meter) spacing run the following:\n d.grid size=500 color=blue\n  \n  Figure: Showing a rectangular grid in blue line color \n ", "notes": "", "see_also": ["d.barscale", "d.legend", "d.geodesic", "d.rhumbline", "d.erase", "d.frame", "d.rast", "v.mkgrid"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.grid"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.graph.html", "name": "d.graph", "definition": "- Program for generating and displaying simple graphics on the display monitor.", "keywords": ["display", "cartography"], "synopsis": "d.graph [-m]  [input=name]   [color=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Coordinates are given in map units Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of file containing graphics commands, if not given reads from standard input", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Color to draw with, either a standard GRASS color or R:G:B triplet", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.graph \n draws graphics that are described either from standard input (default), \n or within a file (if an  input  file name is identified on the \n command line). If graphics commands are entered from standard input, \n a  CTRL-d  is used to signal the end of input to  d.graph .\n Coordinates are given either as a percentage of frame height and width\n (default) or in geographic coordinates (with the  -m  flag).\n The program can be run interactively or non-interactively. \n The user can run the program completely non-interactively \n by specifying the name of a graphics file containing the \n  d.graph  graphics commands. If run non-interactively the\n  d.graph  command is saved to the display's dedraw history.\n The user can also elect to run the program partially interactively, \n by specifying any/all of the parameters  except  \n the graphics file  input= name  parameter on the command line. \n In this case,  d.graph  will expect the user to input  d.graph  \n graphics commands from standard input (i.e., the keyboard) and \n will (silently) prompt the user for these graphics commands. \n  Alternately, the user can simply type  d.graph  on the command line, \n and be prompted for the values of all parameters . In this case, the user is presented with the standard \n GRASS GUI interface.\n  The default coordinate system used is 0-100 percent of the active frame \n in x and similarly 0-100 in y,\n regardless of the graphics monitor display frame size and aspect. \n The (0,0) location is the lower left corner of the active graphics \n monitor display frame. All values may be floating point.\n If the  -m  flag is given, geographic coordinates will be used instead.\n  COMMANDS \n  The graphics language is simple, and uses the following commands: \n  [\n  # \u00a0|\n  move \u00a0|\n  draw \u00a0|\n  polygon \u00a0|\n  polyline \u00a0|\n  color \u00a0|\n  text \u00a0|\n  size \u00a0|\n  symbol \u00a0|\n  rotation \u00a0|\n  icon \u00a0|\n  width \n ] \n  #   comment \n  A line of comment which is ignored in the processing. \n  move   xpos ypos \n  The current location is updated to  xpos ypos . \n Unless the  -m  flag is used,\n values are stated as a percent of the active display frame's \n horizontal ( xpos ) and vertical ( ypos ) size, \n and may be floating point values. Values are between 0-100. \n  Note.  A space must separate  xpos  and  ypos . \n  draw   xpos ypos \n  A line is drawn in the current color from the current location to the new \n location  xpos ypos , which then becomes the current location. \n Unless the  -m  flag is used,\n values are stated as a percent of the active display frame's \n horizontal ( xpos ) and vertical ( ypos ) size, \n and may be floating point values. Values are between 0-100. \n  Note.  A space must separate  xpos  and  ypos . \n  polygon  \n  \u00a0\u00a0  xpos ypos  \n  \u00a0\u00a0  xpos ypos  \n  \u00a0\u00a0... \n  The coordinates appearing beneath the word  polygon , \n one pair per line, \n circumscribe a polygon that is to be filled with the current color. \n  polyline  \n  \u00a0\u00a0  xpos ypos  \n  \u00a0\u00a0  xpos ypos  \n  \u00a0\u00a0... \n  The coordinates appearing beneath the word  polyline , \n one pair per line, \n circumscribe a polygon that is not to be filled with color. \n  color   color \n  Sets the current color to that stated; subsequent graphics will be drawn \n in the stated color, until the current color is set to a different color. \n Options are  red , \n  orange ,\n  yellow ,\n  green ,\n  blue ,\n  indigo ,\n  violet ,\n  brown ,\n  magenta ,\n  gray ,\n  white ,\n  black ,\n an R:G:B triplet (separated by colons),\n or the word \"none\" (draws in the default background color). \n  text   line-of-text \n  The stated text is drawn at the current location using the current color, \n and the new current location is then positioned at the end of the text string. \n  size   xper yper \n  Subsequent text will be drawn such that the text is \n  xper  percent of the graphics monitor display frame wide and \n  yper  percent of the frame high. By default, the text size is set to\n 5 percent of the active frame's width and 5 percent of the frame's height.\n If only one value is given, then that value will be used for both x and y \n scaling.\n  Note.  A space must separate  xper  and  yper . \n  symbol   type size xper yper [line_color [fill_color]] \n  A symbol is drawn at the given size on the display monitor. The\n  xper  and  yper  options define the center of the icon and\n are given as a percentage of the display frame ( 0,0  is lower left).\n The symbol can be any of those stored in  $GISBASE/etc/symbol/ \n (e.g.  basic/circle ) or stored in the user's mapset directory in the\n form  $MAPSET/symbol/ type/name .\n The colors may be either a standard color name, an R:G:B triplet,\n or \"none\". If using an R:G:B triplet, each color value can range from 0-255.\n If not specified the default  line_color  is black and the default \n  fill_color  is grey. \n  rotation   angle \n  Subsequent text and symbols will be drawn such that they are rotated \n  angle  degrees counter-clockwise from east. \n  icon   type size x y \n  Draws an icon of types  o ,  x , or  +  \n with specified  size  (in %) at location  x,y . \n Note: type  o  designates a square. \n  width   value \n  Subsequent lines (including non-FreeType text) will be drawn with\n the given pixel thickness.\n  The default value is 0. \n  EXAMPLES \n For an example use of  d.graph , examine the contents of the  \n command file  grass_logo.txt \n located in the  d.graph  source code directory. It will draw the\n CERL GRASS logo using the  d.graph  graphing commands stored in the file. \n Note that the coordinates in the  grass_logo.txt  file were \n taken directly off an image drawn by hand on graph paper. \n  A dynamic example can be found in the  d.polar  shell script.\n  Draw a \"star\" symbol at a given map coordinate \n echo \"symbol basic/star 20 2264417 5413182 black red\" | d.graph -m\n  Split the screen into quadrants: \n d.frame -s full_screen\n d.graph << EOF\n   color 80:80:120\n   polygon\n    0 49.75\n    0 50.25\n    100 50.25\n    100 49.75\n   polygon\n    49.85 0\n    50.15 0\n    50.15 100\n    49.85 100\n EOF\n ", "notes": "\n  d.graph  remembers the last screen location ( xpos ypos ) to which \n the user moved, even after the user erases the display frame. \n If the user runs  d.graph  repeatedly, and wishes to start anew with \n the default (xpos ypos) screen location, the user should  clear  the \n display frame between runs of  d.graph .\n  LIMITATIONS \n There are no automated ways of generating graphic images. It is anticipated \n that GRASS user sites will write programs to convert output from a resident \n graphics editor into GRASS  d.graph  format.\n (e.g. EPS ->  d.graph , perhaps with the help of a\n  pstoedit  plugin)\n ", "see_also": ["d.font", "d.labels", "d.polar", "d.text", "d.where"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.graph"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.geodesic.html", "name": "d.geodesic", "definition": "- Displays a geodesic line, tracing the shortest distance between two geographic points along a great circle, in a longitude/latitude data set.", "keywords": ["display", "distance", "great circle", "shortest path"], "synopsis": "d.geodesic coordinates=lon1,lat1,lon2,lat2  [line_color=name]   [text_color=name]   [units=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "Starting and ending coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "line_color", "flag": "line_color", "dataType": "String", "optional": true, "explanation": "Line color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "text_color", "flag": "text_color", "dataType": "String", "optional": true, "explanation": "Text color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Units", "defaultValue": "meters", "alternatives": ["meters", "kilometers", "feet", "miles"], "isInputFile": false, "isOutputFile": false}], "description": "\n  d.geodesic  displays a geodesic line in the active frame on the user's \n graphics monitor. This is also known as the great circle line and traces the \n shortest distance between two user-specified points on the curved surface of \n a longitude/latitude data set. The two coordinate locations named must fall \n within the boundaries of the user's current geographic region. \n  OPTIONS \n By default black line color and red text color will be used. \n By indicating the starting and ending coordinates \n of the geodesic, the line and its length (by default in meters) are displayed to \n the graphical output. If the text color is set to  none ,\n the great circle distance is not displayed.\n  EXAMPLE \n A geodesic line if shown over the political map of the world\n (demolocation dataset):\n g.region vector=country_boundaries -p\n d.mon wx0\n d.vect country_boundaries type=area\n # show additionally a 20 degree grid\n d.grid 20\n d.geodesic coordinates=55:58W,33:18S,26:43E,60:37N \n    line_color=yellow text_color=red units=kilometers\n  Geodesic line (great circle line) \n ", "notes": "\n This program works only in GRASS locations with longitude/latitude \n coordinate system. \n ", "see_also": ["d.rhumbline", "d.grid", "m.measure"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.geodesic"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.frame.html", "name": "d.frame", "definition": "- Manages display frames on the user's graphics monitor.", "keywords": ["display", "graphics", "monitors", "frame"], "synopsis": "d.frame [-cepa] frame=name  [at=bottom,top,left,right]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Create a new frame if doesn't exist and select Remove all frames, erase the screen and exit Print name of current frame and exit Print names of all frames including 'at' position and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Remove all frames, erase the screen and exit Print name of current frame and exit Print names of all frames including 'at' position and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print name of current frame and exit Print names of all frames including 'at' position and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Print names of all frames including 'at' position and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "frame", "flag": "frame", "dataType": "String", "optional": false, "explanation": "Frame to be selected or created (if -c flag is given)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "at", "flag": "at", "dataType": "String", "optional": true, "explanation": "Screen coordinates in percent where to place the frame (0,0 is lower-left)", "defaultValue": null, "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}], "description": "\n  d.frame  manages display frames on the current user's graphics\n monitor. Graphics are displayed in rectangular frames on whatever\n graphics monitor the user is currently directing GRASS display output\n to (defined by  d.mon  module). These\n frames are created and managed with this module.\n Note that GRASS frame contents  are not  retained when one\n frame covers another. You cannot shuffle frames from top to bottom and\n then back again. They simply define rectangular areas on the screen\n where subsequent drawing will occur.\n ", "notes": "\n The coordinates for the  at  option are stated in the form\n  top,bottom,left,right  values are in percent. The upper-left\n corner of the graphics monitor always is at location 0,0 while the\n monitor's lower-right corner is always at 100,100.\n If the user has created multiple display frames that overlap one another, \n whatever the user displays in the active frame will overwrite \n those portions of the underlying frame where these frames overlap. \n  EXAMPLE \n # start a new graphics monitor, the data will be rendered to\n # /tmp/map.png image output file of size 600x540px\n d.mon cairo out=/tmp/map.png width=600 height=540 --o\n # set up region\n g.region raster=elevation\n # remove all frames and erase the current graphics monitor\n d.frame -e\n # create a first frame and display 'landuse96_28m' raster map including text label\n d.frame -c frame=first at=0,50,0,50\n d.rast landuse96_28m\n d.text text='Landuse' bgcolor=220:220:220 color=black size=6\n # create a second frame and display 'streams' vector map\n d.frame -c frame=second at=0,50,50,100\n d.vect streams color=blue\n d.text text='Streams' bgcolor=220:220:220 color=black size=6\n # create a third frame and display 'elevation' raster map including text label and scale\n d.frame -c frame=third at=50,100,0,50\n d.rast elevation\n d.text text='Elevation' bgcolor=220:220:220 color=black size=6\n d.barscale at=0,10 style=line bgcolor=none\n # create a fourth frame and display RGB composition map including text label\n d.frame -c frame=fourth at=50,100,50,100\n d.rgb red=lsat7_2002_30 green=lsat7_2002_20 blue=lsat7_2002_10\n d.text text='RGB true colors' bgcolor=220:220:220 color=black size=6\n # release the current graphics monitor\n d.mon -r\n    \n    Figure: d.frame example \n ", "see_also": ["d.erase", "d.info", "d.mon", "d.redraw"], "authors": ["Martin Landa, Czech Technical University in Prague, Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.frame"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.fontlist.html", "name": "d.fontlist", "definition": "- Lists the available fonts.", "keywords": ["display", "settings"], "synopsis": "d.fontlist [-lv]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "List fonts (default; provided for compatibility with d.font) List fonts verbosely Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "List fonts verbosely Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "\n  d.fontlist  outputs a list of available fonts for use with\n GRASS display commands.\n ", "notes": "", "see_also": ["d.text"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.fontlist"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.font.html", "name": "d.font", "definition": "- Selects the font in which text will be displayed on the user's graphics monitor.", "keywords": ["display", "settings"], "synopsis": "d.font [-lv]  [font=string]   [path=name]   [charset=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "List fonts List fonts verbosely Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "List fonts verbosely Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "font", "flag": "font", "dataType": "String", "optional": true, "explanation": "Choose new current font", "defaultValue": "romans", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "path", "flag": "path", "dataType": "String", "optional": true, "explanation": "Path to Freetype-compatible font including file name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "charset", "flag": "charset", "dataType": "String", "optional": true, "explanation": "Character encoding", "defaultValue": "UTF-8", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.font  allows the user to select use of a specific text font for \n display of text on the graphics monitor. \n If the user does not specify a font when using other GRASS programs \n that display text, the font type  romans  is used by default. \n  The user can run this program either non-interactively or interactively. \n If the user specifies a font type name on the command line the program will \n run non-interactively. \n Alternately, the user can simply type  d.font  on the command line; \n in this case, the program will prompt the user for a display \n text font type.\n  Parameter:  \n  font= name \n  Name of a font type, from among the font types italicized below. \n Default:  romans  \n Options: (italized) \n  cyrilc  Cyrillic \n  gothgbt  Gothic Great Britain triplex \n  gothgrt  Gothic German triplex \n  gothitt  Gothic Italian triplex \n  greekc  Greek complex \n  greekcs  Greek complex script \n  greekp  Greek plain \n  greeks  Greek simplex \n  italicc  Italian complex \n  italiccs  Italian complex small \n  italict  Italian triplex \n  romanc  Roman complex \n  romancs  Roman complex small \n  romand  Roman duplex \n  romanp  Roman plain \n  romans  Roman simplex \n  romant  Roman triplex \n  scriptc  Script complex \n  scripts  Script simplex \n ", "notes": "\n The font type \n  romans \n is the fastest font type to display to the graphics monitor. \n ", "see_also": ["d.text", "d.title"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.font"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.erase.html", "name": "d.erase", "definition": "- Erases the contents of the active graphics display frame with user defined color.", "keywords": ["display", "graphics", "monitors"], "synopsis": "d.erase [-f]  [bgcolor=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Remove all frames and erase the screen Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.erase  erases the contents of the active graphics frame, and\n replaces it with the color black (by default) or by whatever color is\n specified by the user.\n ", "notes": "", "see_also": ["d.mon", "d.redraw", "d.rast", "d.vect"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.erase"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.correlate.html", "name": "d.correlate", "definition": "- Prints a graph of the correlation between raster maps (in pairs).", "keywords": ["display", "statistics", "raster", "diagram", "correlation"], "synopsis": "d.correlate map=name[,name,...]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.correlate  displays graphically the results of a\n  r.stats  analysis run on two raster map layers. This module\n highlights the correlation (or lack of it) among data\n layers (scattergram).\n  The results are displayed in the active display frame on\n the user's graphics monitor.  d.correlate  erases\n the active frame before displaying results. If no graphics monitor\n is open, a file  map.png  is generated in the current directory.\n ", "notes": "\n If three or four map layers are specified, the correlation\n among each combination of two data layers is displayed.\n  EXAMPLE \n Scatterplot of two LANDSAT TM7 channels (North Carolina sample dataset):\n g.region raster=lsat7_2002_30 -p\n d.correlate map=lsat7_2002_30,lsat7_2002_40\n Scatterplot of two LANDSAT TM7 channels\n ", "see_also": ["d.text", "d.graph", "r.coin", "r.regression.line", "r.stats"], "authors": ["Michael Shapiro,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.correlate"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.colortable.html", "name": "d.colortable", "definition": "- Displays the color table associated with a raster map layer.", "keywords": ["display", "raster", "color table"], "synopsis": "d.colortable [-n] map=name  [color=name]   [lines=integer]   [columns=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Do not draw a collar showing the NULL color in FP maps Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map whose color table is to be displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Color of lines separating the colors of the color table", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lines", "flag": "lines", "dataType": "String", "optional": true, "explanation": "Number of lines to appear in the color table", "defaultValue": null, "alternatives": ["1-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Number of columns to appear in the color table", "defaultValue": null, "alternatives": ["1-1000"], "isInputFile": false, "isOutputFile": false}], "description": "\n  d.colortable  is used to display the color table associated\n with a raster map in the active frame on the graphics\n monitor. The  map  name should be an available raster map in the\n user's current mapset search path and location.\n  If the  values  of both  lines  and  columns  are\n not specified by the user,  d.colortable  divides the active\n frame equally among the number of categories present in the named\n raster map. If one option is specified, the other is automatically set\n to accommodate all categories.  If both are specified, as many\n categories as possible are displayed.\n  If the user specifies the name of a map on the command line but does not \n specify the values of other parameters, parameter default values will be used. \n Alternately, if the user types simply  d.colortable  on the command line \n without any program arguments, the program will prompt the user for parameter \n settings using the standard GRASS parser interface.\n  EXAMPLE \n The user running the command: \n d.colortable map=soils color=red lines=1 columns=3\n would see the active graphics frame divided into three columns\n extending the full frame height. The lines dividing the color table\n associated with the  soils  map would be displayed in red. The\n user would see, at most, only three of the colors from\n the  soils  color table displayed in the active frame (because\n the user requested that this frame be divided into three sections).\n ", "notes": "\n If the user wishes to display the entire color table associated with \n a map, the user should either stipulate a number of lines (rows) and \n columns (cols) sufficient to accommodate the number of categories \n in the map's color table, or fail to assign values to one or both of \n  lines  and/or  columns .\n If the user runs  d.colortable  using the default number of \n lines and columns (the full graphics frame), all categories from the \n map's color table will be displayed. However, if the user requests \n that the color table associated with a map which has 10 data categories \n be displayed in a graphics frame with only 3 lines (rows) and 2 columns \n (a total of six cells), \n only six of the ten map categories will be displayed. \n  The user should run  d.erase \n between runs of  d.colortable  to avoid confusion.\n ", "see_also": ["d.erase", "d.legend", "d.rast"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.colortable"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.colorlist.html", "name": "d.colorlist", "definition": "- Outputs a list of all available display colors.", "keywords": ["display", "settings", "colors"], "synopsis": "d.colorlist  [separator=character]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "comma", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  d.colorlist  report the available color names.\n The list contains all available display colors with a configurable \n separator (default is comma).\n ", "notes": "", "see_also": ["r.colors"], "authors": ["Andreas Lange"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.colorlist"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.drivers.html", "name": "db.drivers", "definition": "- Lists all database drivers.", "keywords": ["database", "connection settings"], "synopsis": "db.drivers [-fp]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Full output Print drivers and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print drivers and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "\n  db.drivers  lists all database drivers (DBMI backends).\n  EXAMPLE \n Show all installed GRASS database drivers:\n db.drivers -p\n pg\n ogr\n sqlite\n dbf\n ", "notes": "", "see_also": ["db.connect", "db.describe", "db.drivers", "db.droptable", "db.execute", "db.login", "db.tables", "GRASS SQL interface"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.drivers"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.describe.html", "name": "db.describe", "definition": "- Describes a table in detail.", "keywords": ["database", "attribute table"], "synopsis": "db.describe [-ct] table=name  [driver=name]   [database=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Print column names only instead of full column descriptions Print table structure Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Print table structure Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": false, "explanation": "Name of attribute table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.describe  displays table information. If parameter  -c \n is used only column names instead of full column descriptions is given. \n ", "notes": "\n If parameters for database connection are already set with \n  db.connect , they are taken as default values and\n do not need to be spcified each time.\n  EXAMPLES \n  List column descriptions of table in SQLite database (note that this\n is the default setting) \n db.describe driver=sqlite table=hospitals \n     database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'\n # or simply\n db.describe myarchsites\n  DBF example \n db.describe -c table=hospitals database='$GISDBASE/$LOCATION_NAME/PERMANENT/dbf/' \n              driver=dbf\n ncols: 16\n nrows: 160\n Column 1: cat:INTEGER:11\n Column 2: OBJECTID:INTEGER:11\n Column 3: AREA:DOUBLE PRECISION:20\n [...]\n db.describe table=hospitals database='$GISDBASE/$LOCATION_NAME/PERMANENT/dbf/' \n              driver=dbf\n table:hospitals\n description:\n insert:yes\n delete:yes\n ncols:16\n nrows:160\n column:cat\n description:\n type:INTEGER\n len:11\n scale:0\n precision:10\n default:\n nullok:yes\n select:yes\n update:yes\n column:OBJECTID\n description:\n type:INTEGER\n [...]\n ", "see_also": ["db.columns", "db.droptable", "db.execute", "db.login", "db.tables", "GRASS SQL interface"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.describe"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.databases.html", "name": "db.databases", "definition": "- Lists all databases for a given driver and location.", "keywords": ["database", "attribute table", "SQL"], "synopsis": "db.databases  [driver=name]   [location=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Location", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.databases  lists all databases for a given  driver \n and optionally  location . \n ", "notes": "\n Currently supported database drivers are\n  SQLite ,  PostgreSQL ,\n and  ODBC .\n Default  location  for SQLite driver is the full path for the\n current mapset. For PostgreSQL driver it's empty connection string.\n  EXAMPLES \n List SQLite databases in the current mapset:\n db.databases driver=sqlite\n List SQLite databases in a given directory:\n db.databases driver=sqlite location=/opt/sqlite\n List PostgreSQL databases from database server running on given port:\n db.databases driver=pg location=\"host=server_name port=5333\"\n ", "see_also": ["db.columns", "db.describe", "db.drivers", "db.execute", "db.login", "db.tables"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.databases"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.createdb.html", "name": "db.createdb", "definition": "- Creates an empty database.", "keywords": ["database", "attribute table", "SQL"], "synopsis": "db.createdb driver=name database=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": false, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": false, "explanation": "Name of database", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.createdb  allows the user to create a new empty database\n through different drivers. A working database connection needs to be\n established, see  db.login .\n Currently only  SQLite \n and  PostgreSQL  database drivers are\n supported.\n  EXAMPLES \n  Create a new SQLite file-based database \n Note that the standard GRASS GIS SQLite database is by default\n generated in the user's current mapset. This example shows an\n out-of-mapset database file creation:\n db.createdb driver=sqlite database=/opt/sqlite.db\n  Create a new PostgreSQL database \n Create a new PostgreSQL database (after the PostgreSQL connection got\n established through the  pg  driver):\n db.createdb driver=pg database=grassdb\n Create a new PostgreSQL database (after the PostgreSQL connection got\n established through the  odbc  driver):\n db.createdb driver=odbc database=grassdb\n  TODO \n Support other database drivers, too.\n ", "notes": "", "see_also": ["db.columns", "db.connect", "db.describe", "db.drivers", "db.dropdb", "db.droptable", "db.execute", "db.login", "db.tables"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.createdb"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.copy.html", "name": "db.copy", "definition": "- Copy a table.", "keywords": ["database", "attribute table", "SQL"], "synopsis": "db.copy  [from_driver=name]   [from_database=name]   [from_table=name]   [to_driver=name]   [to_database=name]  to_table=name  [where=sql_query]   [select=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "from_driver", "flag": "from_driver", "dataType": "String", "optional": true, "explanation": "Input driver name", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "from_database", "flag": "from_database", "dataType": "String", "optional": true, "explanation": "Input database name", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "from_table", "flag": "from_table", "dataType": "String", "optional": true, "explanation": "Input table name (only, if 'select' is not used)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "to_driver", "flag": "to_driver", "dataType": "String", "optional": true, "explanation": "Output driver name", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "to_database", "flag": "to_database", "dataType": "String", "optional": true, "explanation": "Output database name", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "to_table", "flag": "to_table", "dataType": "String", "optional": false, "explanation": "Output table name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "select", "flag": "select", "dataType": "String", "optional": true, "explanation": "Full select statement (only, if 'from_table' and 'where' is not used)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.copy  allows the user to copy a table between two databases.\n Databases can be connected through different drivers (see examples below).\n ", "notes": "\n Attribute tables can be copied using  db.copy  and, when to be\n associated to a vector map, assigned to the map with\n  v.db.connect . Current connection \n settings are saved in the file  $LOCATION/vector_map/dbln .  \n  EXAMPLES \n  From DBF to PostgreSQL \n  Storing table 'geonames.dbf' (in current directory) into PostgreSQL\n through ODBC: \n db.copy from_driver=dbf from_database='$GISDBASE/$LOCATION_NAME/PERMANENT/dbf' \n    from_table=geonames to_driver=pg to_database=\"host=pgserver,dbname=testdb\" \n    to_table=geonames \n  From PostgreSQL to DBF \n db.copy from_driver=pg  from_database=\"host=pgserver.example.org,dbname=testdb\" \n    from_table=origtable to_driver=dbf \n    to_database='$GISDBASE/$LOCATION_NAME/$MAPSET/dbf' to_table=origtable\n  From PostgreSQL to PostgreSQL with condition \n db.copy from_driver=pg  from_database=\"host=localhost,dbname=testdb\" \n    from_table=geonames to_driver=pg to_database=\"host=localhost,dbname=testdb\" \n    to_table=selection where=\"cat < 500\" \n  From DBF to SQLite \n db.copy from_driver=dbf from_database='$GISDBASE/$LOCATION_NAME/PERMANENT/dbf' \n     from_table=geonames_features to_driver=sqlite \n     to_database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db' to_table=geonames_features\n # convenient viewer:\n sqlitebrowser $HOME/grassdata/nc_spm_08/user1/sqlite/sqlite.db\n  From SQLite to DBF \n db.copy from_driver=sqlite from_database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db' \n     from_table=ammprv to_driver=dbf to_database='$GISDBASE/$LOCATION_NAME/$MAPSET/dbf/' \n     to_table=ammprv\n ", "see_also": ["db.connect", "db.drivers", "db.login", "v.db.connect", "v.clean"], "authors": ["Radim Blazek, ITC-irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.copy"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.connect.html", "name": "db.connect", "definition": "- Prints/sets general DB connection for current mapset.", "keywords": ["database", "attribute table", "connection settings"], "synopsis": "db.connect [-pgcd]  [driver=name]   [database=name]   [schema=name]   [group=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print current connection parameters and exit Substitute variables in database settings Print current connection parameters using shell style and exit Check connection parameters, set if uninitialized, and exit Set from default settings and exit Overwrite current settings if already initialized Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print current connection parameters using shell style and exit Check connection parameters, set if uninitialized, and exit Set from default settings and exit Overwrite current settings if already initialized Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Check connection parameters, set if uninitialized, and exit Set from default settings and exit Overwrite current settings if already initialized Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Set from default settings and exit Overwrite current settings if already initialized Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "schema", "flag": "schema", "dataType": "String", "optional": true, "explanation": "Database schema", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": true, "explanation": "Default group of database users to which select privilege is granted", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.connect  allows the user to set database connection parameters.\n These parameters are then taken as default values by modules so that the\n user does not need to enter the parameters each time.\n The default database backend in GRASS GIS 7\n is  SQLite .\n ", "notes": "\n Values are stored in the mapset's  VAR  file;\n the connection is not tested for validity.\n  The  -p  flag will display the current connection parameters. \n  The  -c  flag will silently check if the connection parameters have\n been set, and if not will set them to use GRASS's default values.\n (useful in scripts before you attempt to create a new database table)\n  To connect a vector map to a database table,\n use  v.db.connect  or\n  v.db.addtable .\n  EXAMPLES \n  SQLite (default backend) \n Local storage:\n db.connect -d\n db.connect -p\n db.tables -p\n  The SQLite database file is created automatically when used the first time.\n  See  SQLite  database driver for details.\n  PostgreSQL (local connection) \n Local storage, database tables stored in database \"mydb\"\n (may require the use of  db.login ):\n db.connect driver=pg database=mydb\n db.login user=myname pass=secret\n db.connect -p\n db.tables -p\n  See  PostgreSQL  database driver for details.\n  PostgreSQL (network connection) \n Network storage, database tables stored in database \"mydb\"\n (may require the use of  db.login ):\n db.connect driver=pg database=mydb\n db.login user=myname pass=secret host=myserver.com port=6666\n db.connect -p\n db.tables -p\n  See  PostgreSQL  database driver for details.\n  MySQL (local connection) \n Local storage, database tables stored in database \"mydb\" (may require\n the use of  db.login ):\n db.connect driver=mysql database=mydb\n db.login user=myname pass=secret\n db.connect -p\n db.tables -p\n  See  MySQL  database driver for details.\n  MySQL (network connection) \n Network storage, database tables stored in database \"mydb\"\n (may require the use of  db.login ):\n db.connect driver=mysql database=mydb\n db.login user=myname pass=secret host=myserver.com\n db.connect -p\n db.tables -p\n  See  MySQL  database driver for details.\n   \n  ODBC \n Network storage, database tables stored in database \"mydb\"\n (may require the use of  db.login ):\n   \n db.connect driver=odbc database=mydb\n db.login user=myname pass=secret\n db.connect -p\n db.tables -p\n  See  ODBC  database driver for details.\n  DBF (local, not recommended) \n Local storage (the dbf/ subdirectory in the mapset must exist or must be\n created by the user):\n db.connect driver=dbf database='$GISDBASE/$LOCATION_NAME/$MAPSET/dbf/'\n db.tables -p\n  See  DBF  database driver for details.\n   \n ", "see_also": ["db.columns", "db.copy", "db.drivers", "db.login", "db.tables", "v.db.addtable", "v.db.connect"], "authors": ["Main author: Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.connect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.columns.html", "name": "db.columns", "definition": "- List all columns for a given table.", "keywords": ["database", "attribute table"], "synopsis": "db.columns table=name  [driver=name]   [database=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": false, "explanation": "Name of attribute table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.columns  lists all columns for a give table. Connection to \n databases are supported through dbf, shp, odbc and pg drivers.  \n ", "notes": "\n If parameters for database connection are already set with\n  db.connect , they are taken as default values\n and do not need to be spcified each time.\n  EXAMPLES \n  List columns of a PostgreSQL attribute table \n db.columns table=zipcodes_wake driver=pg database=grassdb\n  If the database parameters are already set, the columns can be listed\n directly \n db.columns table=zipcodes_wake\n  List columns from Shape file with DBF attribute table \n db.columns table=zipcodes_wake driver=dbf database=/grassdata/nc_spm_08/PERMANENT/dbf/\n  List columns of table in SQLite database \n Note that the SQLite backend is the default setting.\n db.columns driver=sqlite table=archsites database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'\n ", "see_also": ["db.connect", "db.describe", "db.drivers", "db.droptable", "db.execute", "db.login", "db.tables", "GRASS SQL interface"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.columns"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.where.html", "name": "d.where", "definition": "- Identifies the geographic coordinates associated with point locations given in display coordinates.", "keywords": ["display", "sampling", "position", "querying"], "synopsis": "d.where [-dlwf]  [at=x,y[,x,y,...]]   [input=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Output lat/long in decimal degree Output lat/long referenced to current ellipsoid Output lat/long referenced to WGS84 ellipsoid using datum transformation parameters defined in current location (if available) Output frame coordinates of current display monitor (percentage) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Output lat/long referenced to current ellipsoid Output lat/long referenced to WGS84 ellipsoid using datum transformation parameters defined in current location (if available) Output frame coordinates of current display monitor (percentage) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Output lat/long referenced to WGS84 ellipsoid using datum transformation parameters defined in current location (if available) Output frame coordinates of current display monitor (percentage) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Output frame coordinates of current display monitor (percentage) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "at", "flag": "at", "dataType": "String", "optional": true, "explanation": "Display coordinates to convert", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "File from which to read coordinates (\"-\" to read from stdin)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}], "description": "\n  d.where  is an  interactive  program that\n allows the user, using the pointing device (mouse), to\n identify the geographic coordinates associated with point\n locations within the current geographic region in the\n active display frame on the graphics monitor.\n  Each mouse click will output the easting and northing of the point\n currently located beneath the mouse pointer. \n A mouse-button menu is presented so the user knows which\n mouse buttons to use. The output is always printed to the\n terminal screen; if the output is redirected into a file,\n it will be written to the file as well.\n  Mouse buttons:\n      Left:   where am i\n      Middle: draw to/from here\n      Right:  quit this\n The left mouse button prints the coordinates at the selected point,\n the middle mouse button allows you to query two points (they are connected\n by a line for convenience). Use the right mouse button to exit the module.\n ", "notes": "\n This program uses the current geographic region setting and active frame. \n It is not necessary, although useful, to have displayed a map in the current \n frame before running  d.where . The  -d  flag allows the user to\n optionally output latitude/longitude coordinates pair(s) in decimal degree\n rather than DD:MM:SS format. The  -w  flag is only valid\n if a datum is defined for the current location.\n If the  -f  flag is given the x,y frame coordinates of the active display \n monitor will be returned (as a percentage, 0,0 is bottom left).\n  EXAMPLE \n Query position in map (North Carolina sample dataset):\n d.rast elevation\n d.where\n ", "see_also": ["d.what.rast", "d.what.vect", "g.region", "v.what.rast", "v.what.vect"], "authors": ["James Westervelt,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.where"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.what.vect.html", "name": "d.what.vect", "definition": "- Allows the user to interactively query vector map layers at user-selected locations.", "keywords": ["display", "vector"], "synopsis": "d.what.vect map=name[,name,...]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of input vector map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}], "description": "\n  d.what.vect  d.what.vect outputs the category value(s)\n associated with user-specified location(s) in user-specified vector map layer(s).\n The active monitor can be selected with  d.mon .\n ", "notes": "", "see_also": ["d.what.rast", "d.redraw", "d.erase", "d.rast", "d.vect", "d.mon"], "authors": ["Anna Petrasova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.what.vect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.what.rast.html", "name": "d.what.rast", "definition": "- Allows the user to interactively query raster map layers at user-selected locations.", "keywords": ["display", "vector"], "synopsis": "d.what.rast map=name[,name,...]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}], "description": "\n  d.what.rast  d.what.rast outputs the category value(s)\n associated with user-specified location(s) in user-specified raster map layer(s).\n The active monitor can be selected with  d.mon .\n ", "notes": "", "see_also": ["d.what.vect", "d.redraw", "d.erase", "d.rast", "d.vect", "d.mon"], "authors": ["Anna Petrasova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.what.rast"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.vect.thematic.html", "name": "d.vect.thematic", "definition": "- Displays a thematic vector map in the active graphics frame.", "keywords": ["display", "cartography", "choropleth map", "legend"], "synopsis": "d.vect.thematic [-lnes] map=name  [layer=string]  column=name  [breaks=string[,string,...]]   [algorithm=string]   [nclasses=integer]  colors=string[,string,...]  [where=sql_query]   [boundary_width=integer]   [boundary_color=name]   [icon=string]   [size=float]   [icon_line=string]   [icon_area=string]   [legend_title=string]   [legendfile=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "Create legend information and send to stdout Do not draw map, only output the legend information [DEPRECATED] When printing legend info, include extended statistical info from classification algorithm Do not show this layer in vector legend Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Do not draw map, only output the legend information [DEPRECATED] When printing legend info, include extended statistical info from classification algorithm Do not show this layer in vector legend Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "[DEPRECATED] When printing legend info, include extended statistical info from classification algorithm Do not show this layer in vector legend Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Do not show this layer in vector legend Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column to be classified", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "breaks", "flag": "breaks", "dataType": "String", "optional": true, "explanation": "Class breaks, without minimum and maximum", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "algorithm", "flag": "algorithm", "dataType": "String", "optional": true, "explanation": "Algorithm to use for classification", "defaultValue": null, "alternatives": ["int", "std", "qua", "equ", "dis"], "isInputFile": false, "isOutputFile": false}, {"parameter": "nclasses", "flag": "nclasses", "dataType": "String", "optional": true, "explanation": "Number of classes to define", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "colors", "flag": "colors", "dataType": "String", "optional": false, "explanation": "Colors (one per class)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "boundary_width", "flag": "boundary_width", "dataType": "String", "optional": true, "explanation": "Boundary width", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "boundary_color", "flag": "boundary_color", "dataType": "String", "optional": true, "explanation": "Boundary color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "icon", "flag": "icon", "dataType": "String", "optional": true, "explanation": "Point and centroid symbol", "defaultValue": "basic/x", "alternatives": ["basic/arrow", "basic/arrow1", "basic/arrow2", "basic/arrow3", "basic/box", "basic/circle", "basic/cross1", "basic/cross2", "basic/cross3", "basic/diamond", "basic/hexagon", "basic/marker", "basic/octagon", "basic/pin", "basic/pin_dot", "basic/point", "basic/pushpin", "basic/star", "basic/triangle", "basic/x", "demo/muchomurka", "demo/smrk", "extra/4pt_star", "extra/adcp", "extra/airport", "extra/alpha_flag", "extra/bridge", "extra/dim_arrow", "extra/dive_flag", "extra/fiducial", "extra/fish", "extra/half-box", "extra/half-circle", "extra/offbox_ne", "extra/offbox_nw", "extra/offbox_se", "extra/offbox_sw", "extra/pentagon", "extra/ping", "extra/ring", "extra/simple_zia", "extra/target", "geology/circle_cross", "geology/half-arrow_left", "geology/half-arrow_right", "geology/strike_box", "geology/strike_circle", "geology/strike_cleavage", "geology/strike_half-bowtie", "geology/strike_line", "geology/strike_parallel", "geology/strike_triangle", "legend/area", "legend/area_curved", "legend/line", "legend/line_crooked", "n_arrows/basic_compass", "n_arrows/fancy_compass", "n_arrows/n_arrow1a", "n_arrows/n_arrow1b", "n_arrows/n_arrow2", "n_arrows/n_arrow3", "n_arrows/n_arrow4", "n_arrows/n_arrow5", "n_arrows/n_arrow6", "n_arrows/n_arrow7a", "n_arrows/n_arrow7b", "n_arrows/n_arrow8a", "n_arrows/n_arrow8b", "n_arrows/n_arrow9"], "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Symbol size", "defaultValue": "5", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "icon_line", "flag": "icon_line", "dataType": "String", "optional": true, "explanation": "Legend symbol for lines", "defaultValue": "legend/line", "alternatives": ["basic/arrow", "basic/arrow1", "basic/arrow2", "basic/arrow3", "basic/box", "basic/circle", "basic/cross1", "basic/cross2", "basic/cross3", "basic/diamond", "basic/hexagon", "basic/marker", "basic/octagon", "basic/pin", "basic/pin_dot", "basic/point", "basic/pushpin", "basic/star", "basic/triangle", "basic/x", "demo/muchomurka", "demo/smrk", "extra/4pt_star", "extra/adcp", "extra/airport", "extra/alpha_flag", "extra/bridge", "extra/dim_arrow", "extra/dive_flag", "extra/fiducial", "extra/fish", "extra/half-box", "extra/half-circle", "extra/offbox_ne", "extra/offbox_nw", "extra/offbox_se", "extra/offbox_sw", "extra/pentagon", "extra/ping", "extra/ring", "extra/simple_zia", "extra/target", "geology/circle_cross", "geology/half-arrow_left", "geology/half-arrow_right", "geology/strike_box", "geology/strike_circle", "geology/strike_cleavage", "geology/strike_half-bowtie", "geology/strike_line", "geology/strike_parallel", "geology/strike_triangle", "legend/area", "legend/area_curved", "legend/line", "legend/line_crooked", "n_arrows/basic_compass", "n_arrows/fancy_compass", "n_arrows/n_arrow1a", "n_arrows/n_arrow1b", "n_arrows/n_arrow2", "n_arrows/n_arrow3", "n_arrows/n_arrow4", "n_arrows/n_arrow5", "n_arrows/n_arrow6", "n_arrows/n_arrow7a", "n_arrows/n_arrow7b", "n_arrows/n_arrow8a", "n_arrows/n_arrow8b", "n_arrows/n_arrow9"], "isInputFile": false, "isOutputFile": false}, {"parameter": "icon_area", "flag": "icon_area", "dataType": "String", "optional": true, "explanation": "Legend symbol for areas", "defaultValue": "legend/area", "alternatives": ["basic/arrow", "basic/arrow1", "basic/arrow2", "basic/arrow3", "basic/box", "basic/circle", "basic/cross1", "basic/cross2", "basic/cross3", "basic/diamond", "basic/hexagon", "basic/marker", "basic/octagon", "basic/pin", "basic/pin_dot", "basic/point", "basic/pushpin", "basic/star", "basic/triangle", "basic/x", "demo/muchomurka", "demo/smrk", "extra/4pt_star", "extra/adcp", "extra/airport", "extra/alpha_flag", "extra/bridge", "extra/dim_arrow", "extra/dive_flag", "extra/fiducial", "extra/fish", "extra/half-box", "extra/half-circle", "extra/offbox_ne", "extra/offbox_nw", "extra/offbox_se", "extra/offbox_sw", "extra/pentagon", "extra/ping", "extra/ring", "extra/simple_zia", "extra/target", "geology/circle_cross", "geology/half-arrow_left", "geology/half-arrow_right", "geology/strike_box", "geology/strike_circle", "geology/strike_cleavage", "geology/strike_half-bowtie", "geology/strike_line", "geology/strike_parallel", "geology/strike_triangle", "legend/area", "legend/area_curved", "legend/line", "legend/line_crooked", "n_arrows/basic_compass", "n_arrows/fancy_compass", "n_arrows/n_arrow1a", "n_arrows/n_arrow1b", "n_arrows/n_arrow2", "n_arrows/n_arrow3", "n_arrows/n_arrow4", "n_arrows/n_arrow5", "n_arrows/n_arrow6", "n_arrows/n_arrow7a", "n_arrows/n_arrow7b", "n_arrows/n_arrow8a", "n_arrows/n_arrow8b", "n_arrows/n_arrow9"], "isInputFile": false, "isOutputFile": false}, {"parameter": "legend_title", "flag": "legend_title", "dataType": "String", "optional": true, "explanation": "Thematic map title", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "legendfile", "flag": "legendfile", "dataType": "String", "optional": true, "explanation": "[DEPRECATED] Output legend file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.vect.thematic  draws thematic choropleth vector maps based \n on an attribute column or an expression involving several columns. \n It takes a list of class  breaks  (excluding the minimum and maximum \n values) and a list of  colors  to apply to the classes (has to be the \n number of class breaks + 1).\n Instead of a list of class breaks, the user can also chose a\n classification  algorithm  and a number of classes\n ( nbclasses ). See the\n  v.class  for more information on\n these different algorithms.\n ", "notes": "\n The  -l  flag instructs the module to print legend information\n in vector legend format as described in  d.legend.vect \n  to standard output for further use in graphical software.\n When combined with the verbose flag, the legend information will\n be extended with some additional statistical information. If the\n  -n  flag is set, the module will only print the legend \n information without drawing the map.\n  Option  legendfile , is deprecated, instead\n use the GRASS_LEGEND_FILE environmental variable\n (see  d.legend.vect )\n to save legend into a file.\n Flag  -e  is deprecated, instead use verbose flag.\n  EXAMPLES \n  Thematic map with classes \n d.vect.thematic -l map=communes3 column=pop \n    breaks=111393.250000,222785.500000,334177.750000 \n    colors=\"255:0:0,0:255:0,0:0:255,0,0,0\"\n  Thematic map with calculated class breaks \n The following example uses a calculated attribute ( density = \n pop/area ) and the standard deviation algorithm to calculate class \n breaks for 5 classes:\n d.vect.thematic -l map=communes2 column=pop/area algorithm=std \n    nbclasses=5 colors=\"0:0:255,50:100:255,255:100:50,255:0:0,156:0:0\"\n  Thematic map with legend \n Example for the North Carolina sample dataset, colorizing basin polygons by\n average elevation and displaying school capacity:\n # create watersheds from elevation map\n g.region raster=elevation\n r.watershed elevation=elevation threshold=10000 basin=basins_10k\n # convert raster to vector\n r.to.vect input=basins_10k output=basins_10k type=area column=basin_num\n # upload raster statistics to each polygon in vector map\n v.rast.stats map=basins_10k raster=elevation column_prefix=elev\n # open a graphical display\n d.mon wx0\n # draw thematic polygons and specify legend title\n d.vect.thematic map=basins_10k column=elev_average algorithm=int \n    nclasses=5 colors=0:195:176,39:255:0,251:253:0,242:127:11,193:126:60 \n    legend_title=\"Average elevation (m)\"\n # draw thematic points and specify legend title\n d.vect.thematic map=schools_wake@PERMANENT column=CORECAPACI algorithm=std \n    nclasses=3 colors=149:203:255,45:143:240,0:81:161 icon=basic/circle size=15 \n    legend_title=\"School capacity\"\n # and finally draw legend\n d.legend.vect -b at=2,80 font=Sans symbol_size=25\n  Thematic map of average elevation and school capacity \n ", "see_also": ["v.class", "d.legend.vect", "d.vect", "d.graph", "v.univar"], "authors": ["Moritz Lennert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.vect.thematic"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.vect.html", "name": "d.vect", "definition": "- Displays user-specified vector map in the active graphics frame.", "keywords": ["display", "graphics", "vector", "level1"], "synopsis": "d.vect [-cirs] map=name  [layer=string]  display=string[,string,...]  [type=string[,string,...]]   [cats=range]   [where=sql_query]   [color=name]   [fill_color=name]   [rgb_column=name]   [zcolor=style]   [width=integer]   [width_column=name]   [width_scale=float]   [icon=string]   [size=float]   [size_column=name]   [rotation_column=name]   [icon_area=string]   [icon_line=string]   [legend_label=string]   [label_layer=string]   [attribute_column=name]   [label_color=name]   [label_bgcolor=name]   [label_bcolor=name]   [label_size=integer]   [font=string]   [encoding=string]   [xref=string]   [yref=string]   [minreg=float]   [maxreg=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Random colors according to category number (or layer number if 'layer=-1' is given) Use values from 'cats' option as feature id Use square root of the value of size_column This makes circle areas proportionate to the size_column values instead of circle radius Do not show this layer in vector legend Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Use values from 'cats' option as feature id Use square root of the value of size_column This makes circle areas proportionate to the size_column values instead of circle radius Do not show this layer in vector legend Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Use square root of the value of size_column This makes circle areas proportionate to the size_column values instead of circle radius Do not show this layer in vector legend Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Do not show this layer in vector legend Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "display", "flag": "display", "dataType": "String", "optional": false, "explanation": "Display", "defaultValue": "shape", "alternatives": ["shape", "cat", "topo", "vert", "dir", "zcoor"], "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,area,face", "alternatives": ["point", "line", "boundary", "centroid", "area", "face"], "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Feature color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fill_color", "flag": "fill_color", "dataType": "String", "optional": true, "explanation": "Area fill color", "defaultValue": "200:200:200", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rgb_column", "flag": "rgb_column", "dataType": "String", "optional": true, "explanation": "Colorize features according to color definition column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zcolor", "flag": "zcolor", "dataType": "String", "optional": true, "explanation": "Colorize point or area features according to z-coordinate", "defaultValue": null, "alternatives": ["aspect", "aspectcolr", "bcyr", "bgyr", "blues", "byg", "byr", "celsius", "corine", "curvature", "differences", "elevation", "etopo2", "evi", "fahrenheit", "gdd", "grass", "greens", "grey", "grey.eq", "grey.log", "grey1.0", "grey255", "gyr", "haxby", "kelvin", "ndvi", "ndwi", "oranges", "population", "population_dens", "precipitation", "precipitation_daily", "precipitation_monthly", "rainbow", "ramp", "random", "reds", "roygbiv", "rstcurv", "ryb", "ryg", "sepia", "slope", "soilmoisture", "srtm", "srtm_plus", "terrain", "viridis", "water", "wave"], "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Line width", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "width_column", "flag": "width_column", "dataType": "String", "optional": true, "explanation": "Name of numeric column containing line width", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "width_scale", "flag": "width_scale", "dataType": "String", "optional": true, "explanation": "Scale factor for width_column", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "icon", "flag": "icon", "dataType": "String", "optional": true, "explanation": "Point and centroid symbol", "defaultValue": "basic/x", "alternatives": ["basic/arrow", "basic/arrow1", "basic/arrow2", "basic/arrow3", "basic/box", "basic/circle", "basic/cross1", "basic/cross2", "basic/cross3", "basic/diamond", "basic/hexagon", "basic/marker", "basic/octagon", "basic/pin", "basic/pin_dot", "basic/point", "basic/pushpin", "basic/star", "basic/triangle", "basic/x", "demo/muchomurka", "demo/smrk", "extra/4pt_star", "extra/adcp", "extra/airport", "extra/alpha_flag", "extra/bridge", "extra/dim_arrow", "extra/dive_flag", "extra/fiducial", "extra/fish", "extra/half-box", "extra/half-circle", "extra/offbox_ne", "extra/offbox_nw", "extra/offbox_se", "extra/offbox_sw", "extra/pentagon", "extra/ping", "extra/ring", "extra/simple_zia", "extra/target", "geology/circle_cross", "geology/half-arrow_left", "geology/half-arrow_right", "geology/strike_box", "geology/strike_circle", "geology/strike_cleavage", "geology/strike_half-bowtie", "geology/strike_line", "geology/strike_parallel", "geology/strike_triangle", "legend/area", "legend/area_curved", "legend/line", "legend/line_crooked", "n_arrows/basic_compass", "n_arrows/fancy_compass", "n_arrows/n_arrow1a", "n_arrows/n_arrow1b", "n_arrows/n_arrow2", "n_arrows/n_arrow3", "n_arrows/n_arrow4", "n_arrows/n_arrow5", "n_arrows/n_arrow6", "n_arrows/n_arrow7a", "n_arrows/n_arrow7b", "n_arrows/n_arrow8a", "n_arrows/n_arrow8b", "n_arrows/n_arrow9"], "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Symbol size", "defaultValue": "5", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size_column", "flag": "size_column", "dataType": "String", "optional": true, "explanation": "Name of numeric column containing symbol size", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rotation_column", "flag": "rotation_column", "dataType": "String", "optional": true, "explanation": "Name of numeric column containing symbol rotation angle", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "icon_area", "flag": "icon_area", "dataType": "String", "optional": true, "explanation": "Area/boundary symbol for legend", "defaultValue": "legend/area", "alternatives": ["basic/arrow", "basic/arrow1", "basic/arrow2", "basic/arrow3", "basic/box", "basic/circle", "basic/cross1", "basic/cross2", "basic/cross3", "basic/diamond", "basic/hexagon", "basic/marker", "basic/octagon", "basic/pin", "basic/pin_dot", "basic/point", "basic/pushpin", "basic/star", "basic/triangle", "basic/x", "demo/muchomurka", "demo/smrk", "extra/4pt_star", "extra/adcp", "extra/airport", "extra/alpha_flag", "extra/bridge", "extra/dim_arrow", "extra/dive_flag", "extra/fiducial", "extra/fish", "extra/half-box", "extra/half-circle", "extra/offbox_ne", "extra/offbox_nw", "extra/offbox_se", "extra/offbox_sw", "extra/pentagon", "extra/ping", "extra/ring", "extra/simple_zia", "extra/target", "geology/circle_cross", "geology/half-arrow_left", "geology/half-arrow_right", "geology/strike_box", "geology/strike_circle", "geology/strike_cleavage", "geology/strike_half-bowtie", "geology/strike_line", "geology/strike_parallel", "geology/strike_triangle", "legend/area", "legend/area_curved", "legend/line", "legend/line_crooked", "n_arrows/basic_compass", "n_arrows/fancy_compass", "n_arrows/n_arrow1a", "n_arrows/n_arrow1b", "n_arrows/n_arrow2", "n_arrows/n_arrow3", "n_arrows/n_arrow4", "n_arrows/n_arrow5", "n_arrows/n_arrow6", "n_arrows/n_arrow7a", "n_arrows/n_arrow7b", "n_arrows/n_arrow8a", "n_arrows/n_arrow8b", "n_arrows/n_arrow9"], "isInputFile": false, "isOutputFile": false}, {"parameter": "icon_line", "flag": "icon_line", "dataType": "String", "optional": true, "explanation": "Line symbol for legend", "defaultValue": "legend/line", "alternatives": ["basic/arrow", "basic/arrow1", "basic/arrow2", "basic/arrow3", "basic/box", "basic/circle", "basic/cross1", "basic/cross2", "basic/cross3", "basic/diamond", "basic/hexagon", "basic/marker", "basic/octagon", "basic/pin", "basic/pin_dot", "basic/point", "basic/pushpin", "basic/star", "basic/triangle", "basic/x", "demo/muchomurka", "demo/smrk", "extra/4pt_star", "extra/adcp", "extra/airport", "extra/alpha_flag", "extra/bridge", "extra/dim_arrow", "extra/dive_flag", "extra/fiducial", "extra/fish", "extra/half-box", "extra/half-circle", "extra/offbox_ne", "extra/offbox_nw", "extra/offbox_se", "extra/offbox_sw", "extra/pentagon", "extra/ping", "extra/ring", "extra/simple_zia", "extra/target", "geology/circle_cross", "geology/half-arrow_left", "geology/half-arrow_right", "geology/strike_box", "geology/strike_circle", "geology/strike_cleavage", "geology/strike_half-bowtie", "geology/strike_line", "geology/strike_parallel", "geology/strike_triangle", "legend/area", "legend/area_curved", "legend/line", "legend/line_crooked", "n_arrows/basic_compass", "n_arrows/fancy_compass", "n_arrows/n_arrow1a", "n_arrows/n_arrow1b", "n_arrows/n_arrow2", "n_arrows/n_arrow3", "n_arrows/n_arrow4", "n_arrows/n_arrow5", "n_arrows/n_arrow6", "n_arrows/n_arrow7a", "n_arrows/n_arrow7b", "n_arrows/n_arrow8a", "n_arrows/n_arrow8b", "n_arrows/n_arrow9"], "isInputFile": false, "isOutputFile": false}, {"parameter": "legend_label", "flag": "legend_label", "dataType": "String", "optional": true, "explanation": "Label to display after symbol in vector legend", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label_layer", "flag": "label_layer", "dataType": "String", "optional": true, "explanation": "Layer number for labels (default: the given layer number)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "attribute_column", "flag": "attribute_column", "dataType": "String", "optional": true, "explanation": "Name of column to be displayed as a label", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label_color", "flag": "label_color", "dataType": "String", "optional": true, "explanation": "Label color", "defaultValue": "red", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label_bgcolor", "flag": "label_bgcolor", "dataType": "String", "optional": true, "explanation": "Label background color", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label_bcolor", "flag": "label_bcolor", "dataType": "String", "optional": true, "explanation": "Label border color", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label_size", "flag": "label_size", "dataType": "String", "optional": true, "explanation": "Label size (pixels)", "defaultValue": "8", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "font", "flag": "font", "dataType": "String", "optional": true, "explanation": "Font name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "encoding", "flag": "encoding", "dataType": "String", "optional": true, "explanation": "Text encoding", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "xref", "flag": "xref", "dataType": "String", "optional": true, "explanation": "Label horizontal justification", "defaultValue": "left", "alternatives": ["left", "center", "right"], "isInputFile": false, "isOutputFile": false}, {"parameter": "yref", "flag": "yref", "dataType": "String", "optional": true, "explanation": "Label vertical justification", "defaultValue": "center", "alternatives": ["top", "center", "bottom"], "isInputFile": false, "isOutputFile": false}, {"parameter": "minreg", "flag": "minreg", "dataType": "String", "optional": true, "explanation": "Minimum region size (average from height and width) when map is displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxreg", "flag": "maxreg", "dataType": "String", "optional": true, "explanation": "Maximum region size (average from height and width) when map is displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.vect  displays vector maps in the active frame on the\n graphics monitor.\n ", "notes": "\n  d.vect  can simply be used typing  d.vect\n map=vector_map . There are a large variety of optional parameters\n which allow the user to specify vector type, colors, data fields, SQL\n queries, label size and justification, etc.\n  By default  d.vect  areas are filled with  fill_color  and \n outlined with  color . Area outlines can be suppressed with\n d.vect map=vector_map color=none\n and areas can be made transparent with\n d.vect map=vector_map fill_color=none\n  In order to display attributes in the map,  attribute_column  must\n be specified.\n  Feature colors may be specified\n by  v.colors  in a form of color\n table or in an attribute table column containing  RRR:GGG:BBB \n values.\n  A table for a vector map might look like this:\n db.select sql=\"select * from testisola\"\n cat|label|GRASSRGB\n 0|no data|255:255:255\n 90|FRASSILONGO|23:245:67\n 104|LEVICO|23:145:67\n 139|PERGINE VALSUGANA|223:45:237\n 168|SANT'ORSOLA|223:45:67\n 190|TENNA|123:45:67\n  To add the GRASSRGB color column, use  v.db.addcolumn :\n v.db.addcolumn map=testisola columns=\"GRASSRGB varchar(11)\"\n  To add/change a color, use  v.db.update :\n v.db.update map=testisola column=GRASSRGB value=\"123:45:237\" where=\"cat=139\"\n  A much simpler method of color coding is by using the  -c  flag\n which displays vector elements of like category number with a random\n color.\n  This module can use FreeType/TrueType fonts if they have already been selected with\n  d.font .\n  Parameter  width  is set by default to '0'. XDRIVER specifies the\n precise behaviour for non-zero line width, but drivers have some\n freedom as to how zero-width lines are handled, so they can use the\n hardware's \"thin line\" drawing primitive, if it has one. A\n width of zero can potentially result in significantly faster operation. On\n drivers where there is no such thing as a \"thin\" line, the driver will\n use a sensible default (which might not be the same as '1').\n  EXAMPLES \n Spearfish examples:\n # display roads with category numbers:\n d.vect map=roads display=shape,cat label_color=green\n # display randomly colorized soils map with attributes\n d.vect -c map=soils attribute_column=label\n # display randomly colorized selected vectors from soils map\n d.vect -c map=soils where=\"label='VBF'\" display=shape attribute_column=label\n  3D points, 3D lines and 3D polygons colorized according to z height:\n g.region raster=elevation.10m\n r.random input=elevation.10m n=5000 vector=random3d -d\n d.mon start=x0\n # display as black points\n d.vect map=random3d\n # display 3D points colorized according to z height\n d.vect map=random3d zcolor=gyr\n # 3D contour lines\n r.contour input=elevation.10m output=contour20m step=20\n d.vect map=contour20m zcolor=gyr\n # generate 3D triangles\n v.delaunay input=random3d output=random3d_del\n # display 3D polygons colorized according to z height\n d.vect map=random3d_del type=area zcolor=gyr\n ", "see_also": ["v.colors", "d.erase", "d.rast", "v.colors", "v.db.addcolumn", "v.db.update"], "authors": ["CERL"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.vect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.vect.chart.html", "name": "d.vect.chart", "definition": "- Displays charts of vector data in the active frame on the graphics monitor.", "keywords": ["display", "cartography", "chart maps"], "synopsis": "d.vect.chart [-cl3] map=name  [type=string[,string,...]]   [layer=string]   [chart_type=string]  columns=name[,name,...]  [size_column=name]   [size=integer]   [scale=float]   [outline_color=name]   [colors=name[,name,...]]   [max_ref=float[,float,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Center the bar chart around a data point Create legend information and send to stdout Create 3D charts Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Create legend information and send to stdout Create 3D charts Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "3", "flag": "-3", "explanation": "Create 3D charts Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "chart_type", "flag": "chart_type", "dataType": "String", "optional": true, "explanation": "Chart type", "defaultValue": "pie", "alternatives": ["pie", "bar"], "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": false, "explanation": "Attribute columns containing data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size_column", "flag": "size_column", "dataType": "String", "optional": true, "explanation": "Column used for pie chart size", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Size of chart (diameter for pie, total width for bar)", "defaultValue": "40", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Scale for size (to get size in pixels)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "outline_color", "flag": "outline_color", "dataType": "String", "optional": true, "explanation": "Outline color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "colors", "flag": "colors", "dataType": "String", "optional": true, "explanation": "Colors used to fill charts", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max_ref", "flag": "max_ref", "dataType": "String", "optional": true, "explanation": "Maximum value used for bar plot reference", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.vect.chart  displays charts for GRASS vector data in the active\n frame on the graphics monitor.\n ", "notes": "\n The charts are positioned as follows:\n   vector points: on point position,\n   vector lines: on line centers,\n   vector areas: on area centroids.\n Bar charts are placed with their lower edge starting from the y-coordinate\n of the feature being symbolized, and centered with respect to the x-coordinate.\n The  -c  flag can be used to center the bar chart in both x and y\n directions.\n The 'sizecol' parameter is proportionate to the radius.\n The optional  max_ref  parameter accepts a list of values that\n represent the maximum value for each column listed in the values for the\n parameter  columns . These values are used to create a framed bar\n plot if  chart_type  is  bar  (See Example 2).\n  EXAMPLES \n  Example 1 \n Pie-charts of monthly winter precipitation (North Carolina sample dataset):\n g.region vector=nc_state -p\n d.vect nc_state\n d.vect.chart precip_30ynormals chart_type=pie columns=nov,dec,jan,feb -l\n # show pie chart as 3D\n d.erase\n d.vect nc_state\n d.vect.chart precip_30ynormals chart_type=pie columns=nov,dec,jan,feb -l -3\n 2D pie-chart of monthly winter precipitation in North Carolina\n  \n 3D pie-chart of monthly winter precipitation in North Carolina\n  Example 2 \n Bar-chart of different census map values:\n d.vect.chart map=vectmap columns=cens51,cens61,cens71,cens81 chart_type=bar\n  Example 3 \n Creation of framed bar charts of an erodibiliy index from the Spearfish\n sample dataset:\n g.region raster=erode.index -p\n r.to.vect -s input=erode.index output=erode_index type=area \n v.extract input=erode_index output=erode_index_ctrds type=centroid \n d.rast aspect\n d.vect.chart map=erode_index_ctrds chart_type=bar columns=cat \n               size=10 max_ref=12 scale=0.05 colors=yellow \n d.vect erode_index_ctrds icon=basic/circle fcol=black col=black size=5\n Bar charts of an erodibiliy index (spatial subset)\n ", "see_also": ["d.erase", "d.vect", "d.vect.thematic", "d.what.vect", "d.rast"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.vect.chart"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.to.rast.html", "name": "d.to.rast", "definition": "- Saves the contents of the active display monitor to a raster map.", "keywords": ["display", "export", "raster"], "synopsis": "d.to.rast output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  d.to.rast  saves the content of the currently selected\n monitor into a raster map. The active monitor can be selected\n with  d.mon .  d.to.rast  can be run from GUI\n Console tab, too. This module is not sensitive to computational region settings.\n  EXAMPLE \n We combine different raster and vector map layers to create a composite layer\n which can be draped over elevation in 3D view.\n First, we add a couple of maps to layer manager:\n g.region raster=elevation\n d.rast map=elevation\n d.rast map=lakes\n d.vect map=roadsmajor width=4\n d.vect map=roadsmajor width=2 color=yellow\n # create a raster map from the display\n d.to.rast output=composite\n Then uncheck all layers except for elevation and switch to 3D view.\n In Data tab, set color map to the newly created composite map.\n  \n Figure: Raster map created by  d.to.rast  draped over digital elevation model.\n ", "notes": "", "see_also": ["d.out.file", "d.erase", "d.rast", "d.vect", "d.mon"], "authors": ["Anna Petrasova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.to.rast"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.title.html", "name": "d.title", "definition": "- Create a TITLE for a raster map in a form suitable for display with d.text.", "keywords": ["display", "cartography"], "synopsis": "d.title [-dfs] map=name  [color=string]   [size=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Draw title on current display Do a fancier title Do a simple title Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Do a fancier title Do a simple title Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Do a simple title Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Sets the text color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Sets the text size as percentage of the frame's height", "defaultValue": "4.0", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}], "description": "\n  d.title  generates to standard output a string which can be used by\n  d.text  to draw a TITLE for the raster map\n layer  name  in the active display frame on the graphics monitor. \n Output created by  d.title  can be redirected into a file, or piped\n directly into  d.text  to display the map\n TITLE created by  d.title .  The map TITLE created will include the\n map layer's name, TITLE, MAPSET, LOCATION_NAME, geographic region boundary\n coordinates, and cell resolution.\n If the  -d  draw flag is used, then  d.title  will call\n  d.text  for you and the title will be automatically rendered\n to the display.\n ", "notes": "\n The text created with \n  d.text  \n will not necessarily fit within the \n active display frame on the graphics monitor; \n the user should choose a text size appropriate to this frame. \n  EXAMPLES \n For example, a user wishing to create a suitable TITLE for the \n Spearfish, SD  soils  map layer and to display this TITLE in the \n active display frame on the graphics monitor might type the following: \n    d.title map= soils   color= red   size= 5   > TITLE.file \n    d.text  < TITLE.file  \n Alternately, the user might pipe  d.title  output directly \n into  d.text :  \n  d.title map= soils   color= red   size= 5  | \n  d.text \n  A file created by  d.title  can be displayed \n with  d.text .\n Information contained in this file takes precedence over the \n  color  and  size  parameters for \n  d.text .\n ", "see_also": ["d.font", "d.text"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.title"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.text.html", "name": "d.text", "definition": "- Draws text in the active display frame on the graphics monitor using the current font.", "keywords": ["display", "cartography"], "synopsis": "d.text [-pgbrs]  [text=string]   [input=name]   [color=string]   [bgcolor=string]   [rotation=float]   [linespacing=float]   [at=x,y]   [line=integer]   [align=string]   [font=string]   [size=float]   [path=name]   [charset=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Screen position in pixels ([0,0] is top left) Screen position in geographic coordinates Use bold text Use radians instead of degrees for rotation Font size is height in pixels Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Screen position in geographic coordinates Use bold text Use radians instead of degrees for rotation Font size is height in pixels Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Use bold text Use radians instead of degrees for rotation Font size is height in pixels Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Use radians instead of degrees for rotation Font size is height in pixels Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Font size is height in pixels Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "text", "flag": "text", "dataType": "String", "optional": true, "explanation": "Text to display", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Input file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Text color, either a standard GRASS color or R:G:B triplet", "defaultValue": "gray", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Text background color, either a standard GRASS color or R:G:B triplet", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rotation", "flag": "rotation", "dataType": "String", "optional": true, "explanation": "Rotation angle in degrees (counter-clockwise)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "linespacing", "flag": "linespacing", "dataType": "String", "optional": true, "explanation": "Line spacing", "defaultValue": "1.25", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "at", "flag": "at", "dataType": "String", "optional": true, "explanation": "Screen position at which text will begin to be drawn (percentage, [0,0] is lower left)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "line", "flag": "line", "dataType": "String", "optional": true, "explanation": "The screen line number on which text will begin to be drawn", "defaultValue": null, "alternatives": ["1-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "align", "flag": "align", "dataType": "String", "optional": true, "explanation": "Text alignment", "defaultValue": "ll", "alternatives": ["ll", "lc", "lr", "cl", "cc", "cr", "ul", "uc", "ur"], "isInputFile": false, "isOutputFile": false}, {"parameter": "font", "flag": "font", "dataType": "String", "optional": true, "explanation": "Font name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Height of letters in percentage of available frame height", "defaultValue": "5", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "path", "flag": "path", "dataType": "String", "optional": true, "explanation": "Path to font file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "charset", "flag": "charset", "dataType": "String", "optional": true, "explanation": "Text encoding (only applicable to TrueType fonts)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.text  draws text in the active display frame on\n the graphics monitor.  Text can be provided through\n standard input or redirected from a file (using the UNIX\n redirection mechanism).\n In addition to the options provided on the command line,\n colors, text size, font type, rotation angle, and boldness can be adjusted\n with commands in the standard input (i.e., if the user\n invokes  d.text  without options on the command\n line, and then assigns values to these options on lines\n within the standard input).\n  Commands: \n  .C   color  \n (where  color  is one of the available colors) causes text appearing on \n subsequent lines to be drawn in that color. \n  .G   color \n (where  color  is one of the available colors) causes the background of text\n appearing on subsequent lines to be drawn in that color.\n  .S    size \n (where  size  is a percentage within the range 0 to\n 100) adjusts text size.  Note that a size of 10 would allow\n 10 lines to be drawn in the active display frame, 5 would\n allow the drawing of 20 lines, and 50 would allow the\n drawing of 2 lines.\n  .F   font \n (where  font  is one of the fonts known by the GRASS program \n  d.font ) manipulates\n the font type. Available fonts are listed in the GRASS manual entry for \n  d.font . \n The default font type used (if unspecified by the user) \n is  romans .\n  .R    rotation \n (where  rotation  is an angle in degrees, counter-clockwise)\n to rotate the text.\n  .B 1 \n  stipulates that following text be printed in  bold .\n This command means  bold on .\n  .B 0 \n   turns  bold off  of all text appearing on lines beneath \n      it. ( Bold off  is used by default, if unspecified by the user.) \n  EXAMPLE \n The following command will print the short phrase \"This is\n a test of d.text\" in the active display frame using the\n color yellow, in bold, and using 4/100'ths (4%) of the\n active frame's vertical space per line:\n d.text text=\"This is a test of d.text\" color=yellow bgcolor=gray size=4\n  \n  Displayed Text \n ", "notes": "\n Note that the GRASS command \n  d.title  creates map TITLEs in a format \n suitable for input to  d.text .\n  d.text  needs escape sequences that can be used\n within lines to change colors, boldness, and perhaps size.\n ", "see_also": ["d.font", "d.title", "d.labels"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.text"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.shade.html", "name": "d.shade", "definition": "- Drapes a color raster over an shaded relief or aspect map.", "keywords": ["display", "elevation", "relief", "hillshade", "visualization"], "synopsis": "d.shade shade=name color=name  [brighten=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "shade", "flag": "shade", "dataType": "String", "optional": false, "explanation": "Name of shaded relief or aspect raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": false, "explanation": "Name of raster to drape over relief raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "brighten", "flag": "brighten", "dataType": "String", "optional": true, "explanation": "Percent to brighten", "defaultValue": "0", "alternatives": ["-99-99"], "isInputFile": false, "isOutputFile": false}], "description": "\n  d.shade  will drape a color raster map over a shaded relief map.\n In place of shaded relief, any raster map can be used including aspect or slope.\n The color raster map is usually an elevation raster map with colorful color\n table (as opposed to gray scale color table). However, any raster map can be\n used including categorical raster maps.\n The advantage of this module is that it allows visualizing the shaded map\n without a need to create a new raster which would combine both.\n Comparing to creating shaded relief as semi-transparent overlay on\n the color raster map, this module gives result with more saturated colors.\n The input for this module can be created for example using\n  r.slope.aspect  or\n  r.relief .\n ", "notes": "\n Refer to the  d.his  help page for more details;\n  d.shade  is simply a frontend to that module.\n  EXAMPLES \n In this example, the  aspect  map in the North Carolina sample\n dataset location is used to hillshade the  elevation  map:\n g.region raster=aspect -p\n d.mon wx0\n d.shade shade=aspect color=elevation\n Figure: A detail of raster created by applying shading effect of aspect\n to elevation raster map from North Carolina dataset elevation map\n In this next example, a shaded relief raster map is created\n and used to create a colorized hillshade:\n g.region raster=elevation\n r.relief input=elevation output=elevation_shaded_relief\n d.mon wx1\n d.shade shade=elevation_shaded_relief color=elevation\n Interesting visualizations can be created using different color tables for\n elevation raster map, for example using  haxby  color table.\n ", "see_also": ["d.his", "g.pnmcomp", "r.shade", "r.slope.aspect", "r.relief", "wxGUI 3D viewer (NVIZ)"], "authors": ["Unknown; updated to GRASS 5.7 by Michael Barton"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.shade"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.rhumbline.html", "name": "d.rhumbline", "definition": "- Displays the rhumbline joining two longitude/latitude coordinates.", "keywords": ["display", "distance", "rhumbline"], "synopsis": "d.rhumbline coordinates=lon1,lat1,lon2,lat2  [line_color=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "Starting and ending coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "line_color", "flag": "line_color", "dataType": "String", "optional": true, "explanation": "Line color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n A rhumbline (loxodrome) is a line following a constant angle of the\n compass (i.e., a line of constant direction). It crosses all meridians\n at the same angle, i.e. a path of constant bearing.\n  d.rhumbline  displays the\n rhumbline joining any two user-specified points in the\n active frame on the user's graphics monitor.  The named\n coordinate locations must fall within the boundaries of the\n user's current geographic region.\n  The user has to specify the starting and ending\n longitude/latitude coordinates of the rhumbline and\n (optionally) the color in which the rhumbline will be\n displayed; in this case, the program will run\n non-interactively.\n  EXAMPLE \n A geodesic line if shown over the political map of the world\n (demolocation dataset):\n g.region vector=country_boundaries -p\n d.mon wx0\n d.vect country_boundaries type=area\n d.rhumbline coordinates=55:58W,33:18S,26:43E,60:37N \n    line_color=yellow\n # show additionally 10 degree grid\n d.grid 10\n  Rhumbline (loxodrome) \n ", "notes": "\n This program works only in GRASS locations with longitude/latitude \n coordinate system. \n ", "see_also": ["d.geodesic", "d.grid", "m.measure"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.rhumbline"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.rgb.html", "name": "d.rgb", "definition": "- Displays three user-specified raster maps as red, green, and blue overlays in the active graphics frame.", "keywords": ["display", "graphics", "raster", "RGB"], "synopsis": "d.rgb [-n] red=name green=name blue=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Make null cells opaque Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <red>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <green>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <blue>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  RGB  stands for  red ,  green ,\n and  blue .  d.rgb  visually combines three raster maps to\n form a color image. For each map, the corresponding component from the\n layer's color table is used (e.g. for the red layer, the red component\n is used, and so on). In general, the input raster maps should use a\n grey-scale color table.\n ", "notes": "\n  d.rgb  does not attempt to quantize the combined image into a\n fixed number of colors. Nor does it have an option to generate a\n composite layer (see  r.composite  for that).\n The image and raster maps will not display properly if the graphics\n device does not have a reasonable sampling of the RGB color-space.\n If color quality of satellite image color composites seems to appear\n poor, run  i.colors.enhance \n on the selected satellite channels.\n An alternative is the assignment of grey color tables to each band with\n  r.colors :\n r.info -r image.1\n min=0\n max=255\n r.colors map=image.1 color=grey\n r.colors map=image.2 rast=image.1\n r.colors map=image.3 rast=image.1\n To write out the color composite to a combined R/G/B raster maps, use\n  r.composite .\n  EXAMPLE \n Visual color composite of a LANDSAT scene (North Carolina sample dataset):\n g.region raster=lsat7_2002_10 -p\n d.rgb blue=lsat7_2002_10 green=lsat7_2002_20 red=lsat7_2002_30\n  \n  Figure: Visual color composite of a LANDSAT scene (North Carolina sample dataset) \n ", "see_also": ["d.colortable", "d.his", "r.blend", "r.mapcalc", "r.colors", "r.composite"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.rgb"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.redraw.html", "name": "d.redraw", "definition": "- Redraws the content of currently selected monitor.", "keywords": ["display", "graphics", "monitors"], "synopsis": "d.redraw  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "\n  d.redraw  redraws the content of the currently selected\n monitor. The active monitor can be selected\n with  d.mon .\n ", "notes": "", "see_also": ["d.erase", "d.rast", "d.vect", "d.mon"], "authors": ["Martin Landa, Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.redraw"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.rast.num.html", "name": "d.rast.num", "definition": "- Overlays cell category values on a raster map displayed in the active graphics frame.", "keywords": ["display", "map annotations", "raster"], "synopsis": "d.rast.num [-af] map=name  [text_color=name]   [grid_color=name]   [precision=integer]   [font=string]   [path=name]   [charset=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Align grids with raster cells Get text color from cell color value Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Get text color from cell color value Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "text_color", "flag": "text_color", "dataType": "String", "optional": true, "explanation": "Text color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "grid_color", "flag": "grid_color", "dataType": "String", "optional": true, "explanation": "Grid color", "defaultValue": "gray", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Number of significant digits (floating point only)", "defaultValue": "1", "alternatives": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], "isInputFile": false, "isOutputFile": false}, {"parameter": "font", "flag": "font", "dataType": "String", "optional": true, "explanation": "Font name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "path", "flag": "path", "dataType": "String", "optional": true, "explanation": "Path to font file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "charset", "flag": "charset", "dataType": "String", "optional": true, "explanation": "Text encoding (only applicable to TrueType fonts)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.rast.num \n overlays cell category values onto a raster map layer displayed\n on the user's graphics monitor.\n Category values will be displayed in the text color given and scaled\n to fit within a single cell. A grid outlining each map cell will also \n be overlain in a user-specified color, unless it has been set to \"none\".\n  If no grid color is given the default will be used. If no map layer\n is specified, the program will use whatever raster map layer is\n currently displayed in the active frame on the graphics monitor.\n  If the  -f  flag is given the displayed number will take on the color \n of the base map in that cell.\n ", "notes": "\n The user is advised to set the current region to a relatively\n small area (i.e., less than 100 rows by 100 columns);\n otherwise, the individual cells being displayed will be small\n and the category value associated with each will be difficult to see.\n No data cells are indicated with \"Null\".\n  EXAMPLE \n A) Distance from the streams network (North Carolina sample dataset):\n g.region raster=streams_derived -p\n r.grow.distance input=streams_derived distance=dist_from_streams\n d.rast.num dist_from_streams -a\n  Euclidean distance from the streams network in meters (detail, numbers shown\n    with d.rast.num) \n ", "see_also": ["d.frame", "d.grid", "d.rast", "d.rast.arrow", "d.rast.edit", "g.region", "r.slope.aspect"], "authors": ["Raghavan Srinivasan, and Chris Rewerts,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.rast.num"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.rast.leg.html", "name": "d.rast.leg", "definition": "- Displays a raster map and its legend on a graphics window", "keywords": ["display", "cartography", "legend"], "synopsis": "d.rast.leg [-fns] map=name  [lines=integer]   [raster=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Flip legend Omit entries with missing label Draw smooth gradient Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Omit entries with missing label Draw smooth gradient Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Draw smooth gradient Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map to display", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lines", "flag": "lines", "dataType": "String", "optional": true, "explanation": "Number of lines to appear in the legend", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Name of input raster map to generate legend from", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}], "description": "\n  d.rast.leg  shows a raster map along with its legend.\n It first clears the entire screen, then divides it \n into a main (left) and a minor (right) frames, and displays a raster \n map in the main frame and the map legend in the minor frame. The main\n frame remains active when the program finishes.\n ", "notes": "\n The legend may be flipped with the  -f  flag.\n  If the  lines  parameter is not given then the legend frame will \n display as many lines as number of categories in the map, otherwise, it \n will display the first  lines  minus 1 categories with the\n rest being truncated.\n  The user may adjust the  lines  parameter or\n the size of graphics window to get an appropriate result.\n  The user may specify a second raster map with the  raster  parameter from\n which the legend is generated. This is useful to visualize (time) series of\n raster maps with a common static legend instead of the default dynamic legend.\n  To remove all frames when clearing the display, use\n  d.erase -f .\n  EXAMPLE \n In this example, the polar diagram of the 'aspect' angle map in the\n North Carolina sample dataset location is generated:\n g.region raster=landclass96 -p\n d.rast.leg landclass96\n ", "see_also": ["d.legend", "d.erase", "d.rast"], "authors": ["Jianping Xu, Scott Madry, Rutgers University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/d.rast.leg"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/d.rast.html", "name": "d.rast", "definition": "- Displays user-specified raster map in the active graphics frame.", "keywords": ["display", "graphics", "raster"], "synopsis": "d.rast [-ni] map=name  [values=value[-value][,value[-value],...]]   [bgcolor=color]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Make null cells opaque Invert value list Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Invert value list Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map to be displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "values", "flag": "values", "dataType": "String", "optional": true, "explanation": "List of categories or values to be displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color (for null)", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  d.rast  displays the specified raster map in the active\n display frame on the graphics monitor.\n  EXAMPLE \n Display raster map \"elevation\":\n d.rast map=elevation\n  \n  Figure: elevation raster map visualization \n Display raster map \"elevation\" but only the raster cells with\n values between 75 and 80 meters:\n d.rast map=elevation values=75-80\n  \n  Figure: elevation raster map showing values between 75 and 80 meters \n Display raster map \"landuse96_28m\" but only categories 1 and 2:\n d.rast landuse96_28m values=1,2\n  \n  Figure: landuse raster map showing categories 1 and 2 \n ", "notes": "", "see_also": ["d.rast.arrow", "d.rast.num", "d.rast.leg", "d.legend", "d.mon", "d.erase", "d.vect"], "authors": ["James Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/display/d.rast"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.gmodeler.html", "name": "g.gui.gmodeler", "definition": "- Graphical Modeler.", "keywords": ["general", "GUI", "graphical modeler", "workflow"], "synopsis": "g.gui.gmodeler  [file=name.gxm]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Name of model file to be loaded", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  Graphical Modeler  is a  wxGUI \n component which allows the user to create, edit, and manage simple and\n complex models using an easy-to-use interface.\n When performing analytical operations in GRASS GIS, the\n operations are not isolated, but part of a chain of operations. Using the\n Graphical Modeler, a chain of processes (i.e. GRASS GIS modules)\n can be wrapped into one process (i.e. model). Subsequently it is easier to\n execute the model later on even with slightly different inputs or parameters.\n Models represent a programming technique used in GRASS GIS to\n concatenate single steps together to accomplish a task. It is advantageous\n when the user see boxes and ovals that are connected by lines and\n represent some tasks rather than seeing lines of coded text. The Graphical\n Modeler can be used as a custom tool that automates a process. Created\n models can simplify or shorten a task which can be run many times and it can\n also be easily shared with others. Important to note is that models cannot\n perform specified tasks that one cannot also manually perform with GRASS\n GIS. It is recommended to first to develop the process manually, note down\n the steps (e.g. by using the  Copy  button in module dialogs) and later\n replicate them in model.\n The Graphical Modeler allows you to:\n    define data items (raster, vector, 3D raster maps) \n    define actions (GRASS commands) \n    define relations between data and action items \n    define loops (e.g. map series) and conditions (if-else statements) \n    define model variables \n    parameterize GRASS commands \n    define intermediate data \n    validate and run model \n    save model properties to a file ( GRASS Model File|*.gxm ) \n    export model to Python script \n    export model to image file \n  Main dialog \n The Graphical Modeler can be launched from the Layer Manager menu\n  File -> Graphical modeler  or from the main\n toolbar  . It's also\n available as stand-alone module  g.gui.gmodeler .\n The main Graphical Modeler menu contains options which enable the user\n to fully control the model. Directly under the main menu one can find\n toolbar with buttons (see figure below). There are options including\n ( 1 ) Create new model,\n ( 2 ) Load model from file,\n ( 3 ) Save current model to file,\n ( 4 ) Export model to image,\n ( 5 ) Export model to Python script,\n ( 6 ) Add command (GRASS modul) to model,\n ( 7 ) Add data to model,\n ( 8 ) Manually define relation between\n data and commands,\n ( 9 ) Add loop/series to model,\n ( 10 ) Add comment to model,\n ( 11 ) Redraw model canvas,\n ( 12 ) Validate model,\n ( 13 ) Run model,\n ( 14 ) Manage model variables,\n ( 15 ) Model settings,\n ( 16 ) Show manual,\n ( 17 ) Quit Graphical Modeler.\n  \n  Figure: Components of Graphical Modeler menu toolbar. \n There is also a lower menu bar in the Graphical modeler dialog where one can\n manage model items, visualize commands, add or manage model variables,\n define default values and descriptions. The Python editor dialog window\n allows seeing workflows written in Python code. The rightmost tab of\n the bottom menu is automatically triggered when the model is activated and\n shows all the steps of running GRASS modeler modules. In case of errors\n in the calculation process, it is written at that place.\n  Figure: Lower Graphical Modeler menu toolbar.\n  Components of models \n The workflow is usually established from four types of diagrams. Input and\n derived model data are usually represented with oval diagrams. This type of\n model elements stores path to specific data on the user's disk. It is\n possible to insert vector data, raster data, database tables, etc.\n The type of data is clearly distinguishable in the model by its color.\n Different model elements are shown in the figures below.\n     ( A ) raster data:  \n     ( B ) relation:  \n     ( C ) GRASS module:  \n     ( D ) loop:  \n     ( E ) database table:  \n     ( F ) 3D raster data:   \n     ( G ) vector data:    \n     ( H ) disabled GRASS module:   \n     ( I ) comment:    \n   \n  \n  Figure: A model to perform unsupervised classification using MLC\n ( i.maxlik ) and SMAP ( i.smap ).\n Another example:\n  \n  Figure: A model to perform estimation of average annual soil loss\n caused by sheet and rill erosion using The Universal Soil Loss\n Equation. \n Example as part of landslide prediction process:\n  \n  Figure: A model to perform creation of parametric maps used by geologists \n to predict landslides in the area of interest. \n  EXAMPLE \n In this example the  zipcodes_wake  vector data and the\n  elev_state_500m  raster data from the North Carolina\n sample dataset (original  raster  and\n  vector \n data) are used to calculate average elevation for every\n zone. The important part of the process is the Graphical Modeler, namely its\n possibilities of process automation.\n  The workflow shown as a series of commands \n In the command console the procedure looks as follows:\n # input data import\n r.import input=elev_state_500m.tif output=elevation \n v.import input=zipcodes_wake.shp output=zipcodes_wake \n # computation region settings\n g.region vector=zipcodes_wake  \n # raster statistics (average values), upload to vector map table calculation\n v.rast.stats -c map=zipcodes_wake raster=elevation column_prefix=rst method=average \n # univariate statistics on selected table column for zipcode map calculation\n v.db.univar map=zipcodes_wake column=rst_average \n # conversion from vector to raster layer (due to result presentation)\n v.to.rast input=zipcodes_wake output=zipcodes_avg use=attr attribute_column=rst_average \n # display settings\n r.colors -e map=zipcodes_avg color=bgyr                                         \n d.mon start=wx0 bgcolor=white                                                   \n d.barscale style=arrow_ends color=black bgcolor=white fontsize=10\n d.rast map=zipcodes_avg bgcolor=white                                                                                                 \n d.vect map=zipcodes_wake type=boundary color=black                                                     \n d.northarrow style=1a at=85.0,15.0 color=black fill_color=black width=0 fontsize=10\n d.legend raster=zipcodes_avg lines=50 thin=5 labelnum=5 color=black fontsize=10 \n  Defining the workflow in the Graphical Modeler \n To start performing above steps as an automatic process with the Graphical Modeler\n press the   icon or\n type  g.gui.gmodeler . The simplest way of inserting elements\n is by adding the complete GRASS command to the Command field in the GRASS command\n dialog (see figure below).  With full text search one can do faster\n module hunting. Next, the label and the command can be added. In case that only\n a module name is inserted, after pressing the  Enter  button, the\n module dialog window is displayed and it is possible to set all of the usual\n module options (parameters and flags).\n   \n  Figure: Dialog for adding GRASS commands to model. \n  Managing model parameters \n All used modules can be parameterized in the model. That causes launching the\n dialog with input options for model after the model is run. In this example,\n input layers ( zipcodes_wake  vector map and  elev_state_500m  \n raster map) are parameterized. Parameterized elements show their diagram border\n slightly thicker than those of unparameterized elements.\n  \n  Figure: Model parameter settings. \n The final model, the list of all model items, and the Python code window with\n  Save  and  Run  option are shown in the figures below.\n  \n  Figure: A model to perform average statistics for zipcode zones. \n  \n  Figure: Items with Python editor window. \n For convenience, this model for the Graphical Modeler is also available for download\n  here .\n The model is run by clicking the  Run  button\n  . When all inputs are set, the results can\n be displayed as shown in the next Figure:\n  \n  Figure: Average elevation for ZIP codes using North Carolina sample dataset as \n an automatic calculation performed by Graphical Modeler. \n  Managing model properties \n When one wants to run model again with the same data or the same names, it is \n necessary to use  --overwrite  option. It will cause maps with identical \n names to be overwritten. Instead of setting it for every \n module separately it is handy to change the Model Property settings globally.\n This dialog includes also metadata settings, where model name, model description \n and author(s) of the model can be specified.\n  \n  Figure: Model properties. \n  Defining variables \n Another useful trick is the possibility to set variables. Their content can be used \n as a substitute for other items. Value of variables can be values such as \n raster or vector data, integer, float, string value or they may constitute some \n region, mapset, file or direction data type.   \n Then it is not\n necessary to set any parameters for input data. The dialog with variable settings \n is automatically displayed after model is run. So, instead of model parameters \n (e.g.  r.import  a  v.import , see the Figure\n  Run model dialog  above) \n there are  Variables .\n  \n  Figure: Model with variable inputs. \n The key point is the usage of  %  before the substituting variable and \n settings in  Variables  dialog. For example, in case of a model variable \n  raster  that points to an input file path and which value is required to be \n used as one of inputs for a particular model, it should be specified in the\n  Variables  dialog with its respective name ( raster ), data type,\n default value and description. Then it should be set in the module dialog as\n input called  %raster .\n  \n  Figure: Example of raster file variable settings. \n  Figure: Example of raster file variable usage. \n  Saving the model file \n Finally, the model settings can be stored as a GRASS GIS Model file with\n  *.gxm  extension. The advantage is that it can be shared as a\n reusable workflow that may be run also by other users with different data.\n For example, this model can later be used to calculate the average precipitation\n for every administrative region in Slovakia using the  precip  raster data from\n Slovakia precipitation dataset  and administration boundaries of Slovakia from \n  Slovak Geoportal \n (only with a few clicks).\n  Handling intermediate data \n There can be some data in a model that did not exist before the process and \n that it is not worth it to maintain after the process executes. They can \n be described as being  Intermediate  by single clicking using the right \n mouse button, see figure below. All such data should be deleted following \n model completion. The boundary of intermediate component is dotted line.\n  \n  Figure: Usage and definition of intermediate data in model. \n  Using the Python editor \n By using the Python editor in the Graphical Modeler one can add Python code and then \n run it with  Run  button or just save it as a Python script  *.py .\n The result is shown in the Figure below:\n  Figure: Python editor in the wxGUI Graphical Modeler. \n  Defining loops \n In the example below the  MODIS MOD13Q1 \n (NDVI) satellite data products are used in a loop. The original data are \n stored as coded integer values that need to be multiplied by the\n value  0.0001  to represent real  ndvi values . Moreover, GRASS GIS\n provides a predefined color table called  ndvi  to represent  ndvi data .  \n In this case it is not necessary to work with every image separately. \n The Graphical Modeler is an appropriate tool to \n process data in an effective way using loop and variables ( %map  for a \n particular MODIS image in mapset and  %ndvi  for original data name suffix). \n After the loop component is added to model, it is necessary to define series of maps\n with required settings of map type, mapset, etc.\n  \n  Figure: MODIS data representation in GRASS GIS after Graphical Modeler usage. \n When the model is supplemented by all of modules, these modules should be \n ticked in the boxes of loop dialog. The final model and its results are shown below.\n  \n  Figure: Model with loop. \n  \n  Figure: MODIS data representation in GRASS GIS after Graphical Modeler usage. \n The steps to enter in the command console of the Graphical Modeler would be as follows:\n # note that the white space usage differs from the standard command line usage\n # rename original image with preselected suffix\n g.rename raster = %map,%map.%ndvi\n # convert integer values\n r.mapcalc expression = %map = %map.%ndvi * 0.0001\n # set color table appropriate for nvdi data\n r.colors = map = %map color = ndvi\n ", "notes": "", "see_also": ["wxGUI", "wxGUI components"], "authors": ["Martin Landa, OSGeoREL, Czech Technical University in Prague, Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/gmodeler"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.gcp.html", "name": "g.gui.gcp", "definition": "- Georectifies a map and allows managing Ground Control Points.", "keywords": ["general", "GUI", "georectification", "GCP"], "synopsis": "g.gui.gcp  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "\n The  GCP Manager  is a  wxGUI \n extension which allows the user to create, edit, and manage\n Ground Control Points. It is available from the menu\n \"File | Manage Ground Control Points\".\n The  GCP Manager  provides an interactive graphical interface to\n manage and analyze Ground Control Points. A backup copy of the initial\n POINTS file is always maintained and updated only on request (Save GCPs\n to POINTS file). This guarantees that accidental changes are not\n permanent and can be undone by reloading the Ground Control Points.\n The GCP Manager must be started in the target location, not in the\n source location.\n The GCP Manager is structured into three panels:\n    The topmost panel shows a list of Ground Control Points. Tools to\n   manipulate and analyze GCPs are provided in the toolbar. This panel can\n   be moved out of the GCP manager window by either dragging with the\n   caption or by clicking on the pin button on the right in the caption.\n   This panel can also be placed below the map displays by dragging.\n    The two panels in the lower part are used for map and GCP display,\n   the left pane showing a map from the source location and the right\n   pane showing a reference map from the target location. Numbered Ground\n   Control Points are shown on both map displays.\n  Components of the GCP Manager \n    \n  Toolbars \n Two toolbars are provided with the GCP Manager, one for managing the map\n displays and one for managing the GCP list.\n  List of ground control points \n The list of Ground Control Points can be sorted by clicking on a column \n header. Clicking on a cloumn header will sort the GCPs ascending, a\n second click on the same column will sort the GCPs descending. Overall\n RMS error and individual RMS errors of all points are often improved if\n the GCP with the highest RMS error is adjusted. Individual coordinates\n can be edited by double-clicking on a row.\n The first column holds a checkbox and displays the point number. A GCP\n is only used for RMS error calculation and georectification if its\n checkbox on the left is checked. Uncheck to deactivate a GCP (mark as\n unused GCP).\n  Two panels for map display \n The left panel is used to display a map from the source location, the\n right panel to display a map from the target loaction. Zooming in and\n out is always possible with the mouse wheel and done for each map canvas\n separately.\n GCPs are displayed in different colors, depending on whether a GCP has\n a high RMS error, is currently unused or is currently selected. Optionally,\n currently unused GCPs are not shown on the map display.\n  Statusbar \n At the bottom of the GCP Manager is a statusbar providing several\n functions. The default is set to  Go to GCP No.  (see also below).\n Typing a number or using the up/down arrows will center the maps on the\n given GCP, useful with a high zoom.\n  GCP Map Display Toolbar \n  \u00a0\n    Display map \n  Displays maps for source and target canvas and re-renders any layers\n that have changed since the last time the display was updated. \n  \u00a0\n    Re-render map \n  Re-renders both source and target canvas regardless of whether they\n have changed or not. \n  \u00a0\n    Erase display \n  Erases both source and target canvas to a white background. \n  \u00a0\n    Define GCP (Ground Control Points) \n  On left mouse click, coordinates are defined for the currently\n selected GCP. \n  \u00a0\n    Pan \n  Interactive selection of a new center of view in the active\n display monitor. Drag the pan cursor while pressing the left mouse\n button to pan. Alternatively left-click on the new center. Panning\n changes the location of the region displayed but not the size of the\n area displayed or the resolution. \n  \u00a0\n    Zoom in \n  Interactive zooming with the mouse in the active map canvas (source \n or target). Drawing a box or just a left click with the mouse and zoom-in\n cursor causes the display to zoom in so that the area defined by the box\n fills the display. The map resolution is not changed. Clicking with the\n zoom-in cursor causes the display to zoom in by 30%, centered on the\n point where the mouse is clicked. Zooming changes the display region\n extents (both size and location of area displayed). \n  \u00a0\n    Zoom out \n  Interactive zooming with the mouse in the active map canvas (source \n or target). Drawing a box or just a left click with the mouse and zoom-out\n cursor causes the display to zoom out so that the area displayed\n shrinks to fill the area defined by the box. The map resolution is not\n changed. Clicking with the zoom-out cursor causes the display to zoom\n out by 30%, centered on the point where the mouse is clicked. Zooming\n changes the display region extents (both size and location of area\n displayed). \n  \u00a0\n    Adjust display zoom \n  Source and target display are adjusted by using the current GCPs for\n coordinate transformation:\n    \n      Adjust source display to target display \n      The extents of the source display are adjusted to the current\n     extents of the target display.\n      Adjust target display to source display \n      The extents of the source display are adjusted to the current\n     extents of the target display.\n    \n  Set active map canvas \n  Sets the currently active map canvas (source or target). Click \n to set active map canvas for  Return to previous zoom  or \n  Zoom to extent of currently displayed map . Alternatively, move\n the mouse over the map canvas to be used as active canvas. \n  \u00a0\n    Return to previous zoom \n  Returns to the previous zoom extent. Up to 10 levels of zoom back are\n maintained. \n  \u00a0\n  Zoom to extent of currently displayed map \n  Zoom to the extent of the currently displayed map in the active map\n canvas (source or target). \n  \u00a0\n  Settings \n  Shows a settings dialog for GCP management and display:  \n    \n      Symbology \n        Settings for map and GCP display: \n        \n          Highlight highest RMS error only \n            Only the GCP with the highest RMS error will be displayed in\n           a different colour, both in the list of GCPs and the GCP Map Display.\n          Factor for RMS error threshold = M + SD * factor: \n            All GCPs with an RMS error larger than mean RMS + RMS standard\n           deviation * this factor will be displayed in a different colour,\n           both in the list of GCPs and the GCP Map Display. As a rule of\n           thumb, GCPs with an RMS error larger than  M + SD * 2  are\n           most probably wrong. GCPs with an RMS error larger than\n            M + SD * 1  are worth closer inspection. This option is\n           only available if  Highlight highest RMS error only  is\n           unchecked. \n          Color \n            Set the color for GCPs on the GCP Map Display. \n          Color for high RMS error \n            Set the color for GCPs with a high RMS error on the GCP Map\n           Display. \n          Color for selected GCP \n            Set the color for the currently selected GCP on the GCP Map\n           Display. \n          Show unused GCPs \n            If unchecked, unused GCPs will not be shown on the GCP Map\n           Display. \n          Color for unused GCPs \n            Set the color for unused GCPs on the GCP Map Display. \n          Symbol size \n            Set the symbol size for GCPs on the GCP Map Display. \n          Line width \n            Set the line width for GCPs on the GCP Map Display. \n          Select source map to display \n            Select a source map for the left pane of the GCP Map Display. \n          Select target map to display \n            Select a target map for the right pane of the GCP Map Display. \n        \n        \n      Rectification \n        Settings for georectification: \n        \n          Select rectification method \n            Set the polynomial order for georectification. This order will\n           also be used for RMS error calculation. \n          Clip to computational region in target location \n            Clip raster maps to the current computational region in the\n           target location when georectifying. \n          Extension for output maps \n            Change the extension for output map names when doing the actual\n           georectification. \n        \n        \n    \n  \u00a0\n  Show Help \n  Show help page for the GCP Manager.\n  \u00a0\n  Quit \n  Quit the GCP Manager.\n  Toolbar for the GCP list \n  \u00a0\n  Save GCPs to POINTS file \n  The current list of GCPs is saved to the imagery group's POINTS file\n and to a backup copy. \n  \u00a0\n  Add new GCP \n  Adds a new Ground Control Point to the list and selects it for editing. \n  \u00a0\n  Delete selected GCP \n  Deletes the currently selected GCP from the list. \n  \u00a0\n  Clear selected GCP \n  Resets all coordinates of the currently selected GCP to 0 (zero). \n  \u00a0\n  Reload GCPs from POINTS file \n  Reloads GCPs from the imagery group's POINTS file. \n  \u00a0\n  Recalculate RMS error \n  Recalculates forward and backward RMS error for all GCP marked for\n use (activated checkbox in first row).\n  \u00a0\n  Georectify \n  Uses  i.rectify  to georectify\n all images in the source imagery group.\n  GCP Map Display Statusbar \n The GCP map display statusbar is similar to the statusbar in the regular\n GRASS GIS map display with two differences,  Go to  has been\n replaced with  Go to GCP No.  and  Projection  has been\n replaced with  RMS error .\n If  Go to GCP No.  is selected, a GCP number can be given in the\n left side of the statusbar and the source and target map canvas will be\n centered on the given GCP. Clicking on the map canvas will update\n coordinates for this GCP.\n If  RMS error  is selected, the overall forward and backward RMS\n error is displayed.\n ", "notes": "", "see_also": ["wxGUI", "wxGUI components"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/gcp"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.dbmgr.html", "name": "g.gui.dbmgr", "definition": "- Launches graphical attribute table manager.", "keywords": ["general", "GUI", "attribute table", "database"], "synopsis": "g.gui.dbmgr map=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  Attribute Table Manager  is\n a  wxGUI  compoment to query, edit,\n and manage attribute data for vector maps. The attribute table manager\n can be launched by clicking on icon   in the toolbar. It's also available as a stand-alone\n module  g.gui.dbmgr .\n  Attribute table manager  allows you to:\n    browse attribute data of vector map, perform SQL select\n   statements; \n    modify attribute data, insert new records to attribute table,\n   delete existing records; \n    highlight selected items in the Map Display Window; \n    extract selected items into a new vector map; \n    modify attribute table - add, drop, rename columns; \n    modify vector map DB connection settings - add, remove or\n   modify layers. \n  \n  Figure: Simple attribute filtering using Attribute Table Manager. \n  SQL Builder \n  Figure: Attribute filtering using Attribute Table Manager and SQL Builder. \n ", "notes": "", "see_also": ["wxGUI", "wxGUI components"], "authors": ["Martin Landa,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/dbmgr"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.datacatalog.html", "name": "g.gui.datacatalog", "definition": "- Tool for browsing, modifying and managing GRASS maps.", "keywords": ["general", "GUI", "map management"], "synopsis": "g.gui.datacatalog  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "\n The  Data Catalog  is a  wxGUI  component\n for browsing, modifying and managing GRASS maps.\n Data Catalog allows you to:\n    browse GRASS locations and mapsets in the current GIS directory \n    browse GRASS 2D/3D raster and vector maps \n    rename, copy, move and delete GRASS maps including reprojection between different locations \n    drag and drop maps for copying and moving \n    searching and fitering maps using regular expressions \n    display map in current location \n    show metadata of maps \n    \n    \n   Figure: Data Catalog integrated in wxGUI.\n ", "notes": "\n Some operations (copying, renaming, deleting) are by default enabled only within the current mapset.\n To allow changing data outside of your current mapset, you need to press  Unlock  button in Data Catalog toolbar.\n  WARNING \n When renaming, copying or deleting maps outside of Data Catalog, you need to reload\n the current mapset or entire database, because it is currently not synchronised.\n \n ", "see_also": ["wxGUI", "wxGUI components"], "authors": ["Anna Petrasova, NCSU GeoForAll Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/datacatalog"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.animation.html", "name": "g.gui.animation", "definition": "- Tool for animating a series of raster and vector maps or a space time raster or vector dataset.", "keywords": ["general", "GUI", "display", "animation"], "synopsis": "g.gui.animation  [raster=name[,name,...]]   [vector=name[,name,...]]   [strds=name]   [stvds=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Raster maps to animate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vector", "flag": "vector", "dataType": "String", "optional": true, "explanation": "Vector maps to animate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "strds", "flag": "strds", "dataType": "String", "optional": true, "explanation": "Space time raster dataset to animate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stvds", "flag": "stvds", "dataType": "String", "optional": true, "explanation": "Space time vector dataset to animate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  Animation Tool  is a  wxGUI  component\n for animating series of GRASS raster or vector maps or space time datasets (created by t.* modules).\n Animation Tool allows you to:\n    display up to 4 synchronized animations \n    each animation can consist of base map layer(s) and (multiple) series in arbitrary order\n       (for example, raising water level with elevation) \n    control the animation speed \n    interactively change active frame using a slider \n    visualize space time datasets with unequally spaced intervals \n    animate 3d view (partially implemented, not supported on Windows) \n    export animation as a series of images, animated GIF, AVI or SWF \n    choose format of time labels in case of animating maps with absolute time \n    choose background color \n    set starting and ending region in order to change region during animation\n   (alternatively you can set N-S/E-W values instead of the ending region;\n   these are used for making the region smaller or larger for each step) \n 3D view animation enables to animate raster (as an elevation map or a\n color map) or vector map (points, lines). Internally,\n module  m.nviz.image  is used.\n To display 3D view animation follow these steps:\n    open GRASS GUI, load maps and start 3D view \n    set view, light and other parameters as you like \n    save workspace file \n    add new animation in Animation Tool, choose 3D view mode \n    choose data (series of maps or space time dataset) used for animation \n    set workspace file \n    choose parameter (parameter\n   of  m.nviz.image ) to animate\n   (e.g. color_map) \n ", "notes": "\n The Animation Tool follows the computational region settings,\n so please be sure your computational region is set to the geographic extent of maps you are animating.\n You can change the computational region (using  g.region )\n and then reload the maps to update the animation.\n  EXAMPLES \n g.gui.animation raster=rmap1,rmap2,rmap3\n g.gui.animation vector=vmap1,vmap2,vmap3\n g.gui.animation strds=precipitation_2000_2010\n The loading of a series of maps into the Animation Tool can be simplified\n with  g.list  (back ticks syntax works for Linux and Mac only):\n g.gui.animation raster=`g.list type=raster mapset=. separator=comma pattern=\"precip*\"`\n Using extended regular expressions, the list of a series of raster maps can be subset by\n e.g., numeric range (here: precipitation for the years 1997-2012):\n g.gui.animation raster=`g.list -e type=raster mapset=. separator=comma pattern=\"precip_total.(199[7-9]|200[0-9]|201[0-2]).sum\"`\n ", "see_also": ["wxGUI", "wxGUI components"], "authors": ["Anna Kratochvilova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/animation"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gisenv.html", "name": "g.gisenv", "definition": "- Outputs and modifies the user's current GRASS variable settings.", "keywords": ["general", "settings", "variables", "scripts"], "synopsis": "g.gisenv [-sn]  [get=variable[,variable,...]]   [set=\"variable=value\"]   [unset=variable[,variable,...]]   [store=string]   [separator=character]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Use shell syntax (for \"eval\") Do not use shell syntax Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Do not use shell syntax Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "get", "flag": "get", "dataType": "String", "optional": true, "explanation": "GRASS variable to get", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "set", "flag": "set", "dataType": "String", "optional": true, "explanation": "GRASS variable to set", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "unset", "flag": "unset", "dataType": "String", "optional": true, "explanation": "GRASS variable to unset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "store", "flag": "store", "dataType": "String", "optional": true, "explanation": "Where GRASS variable is stored", "defaultValue": "gisrc", "alternatives": ["gisrc", "mapset"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Separator for multiple GRASS variables", "defaultValue": "newline", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n When a user runs GRASS, certain variables are set specifying the GRASS\n data base, location, mapset, peripheral device drivers, etc., being\n used in the current GRASS session. These variable name settings are\n recognized as long as the user is running a GRASS session.\n  OPTIONS \n No prompts are given to the user when running  g.gisenv .\n If run without arguments,  g.gisenv  lists all of the user's\n current GRASS variable settings. Results are sent to standard output,\n and may look like this:\n GISDBASE=/opt/grassdata/\n LOCATION_NAME=nc_spm_08_grass7\n MAPSET=/user1\n GUI=gui\n  If the user specifies a  get= variable_name  on the\n command line\n g.gisenv MAPSET\n only the value for that particular GRASS variable is output to\n standard output. Possible variable names depend on the user's system,\n see  variables list  for details. Note that\n the variable names are case-insensitive.\n  While other variables may be associated with each GRASS session (e.g.,\n GRASS_GUI, GIS_LOCK, and other variables), those stated below\n are essential.\n  GISDBASE \n  The  GISDBASE  is a directory in which all users' GRASS\n data are stored. Within the  GISDBASE , data are segregated\n into subdirectories (called \"locations\") based on the map\n coordinate system used and the geographic extent of the data.  Each\n \"location\" directory itself contains subdirectories called\n \"mapsets\"; each \"mapset\" stores \"data base\n elements\" - the directories (e.g.,\n the  cell ,  cellhd ,  vector , etc., directories)\n in which GRASS data files are actually stored.\n  LOCATION_NAME \n  The user must choose to work with the data under a single GRASS\n location within any given GRASS session; this location is then called\n the  current GRASS location , and is specified by the variable\n  LOCATION_NAME . The  LOCATION_NAME  is the GRASS data\n base location whose data will be affected by any GRASS commands issued\n during the user's current GRASS session, and is a subdirectory of the\n current  GISDBASE . Each \"location\" directory can\n contain multiple \"mapset\" directories (including the special\n mapset  PERMANENT ).  Maps stored under the same\n GRASS  LOCATION_NAME  (and/or within the same  MAPSET )\n must use the same coordinate system and typically fall within the\n boundaries of the same geographic region (aka, \"location\").\n  MAPSET \n  Each \"mapset\" contains a set of maps relevant to the\n  LOCATION_NAME  directory in which it appears.\n Each  LOCATION_NAME  can contain multiple mapsets. (Mapsets\n which fall under the same  LOCATION_NAME  all contain data\n geographically relevant to the  LOCATION_NAME , and all store\n data in the same map coordinate system.  Frequently, maps are placed\n into different mapsets to distinguish file ownership - e.g., each user\n might have one or more own mapset(s), storing any maps that the user has\n created and/or are relevant to the own work.) During each GRASS session, the\n user must choose one mapset to be the  current mapset ; the current\n mapset setting is given by  MAPSET , and is a subdirectory\n of  LOCATION_NAME .  During a single GRASS session, the user\n can use available data in any of the mapsets stored under the\n current  LOCATION_NAME  directory that are in the user's\n mapset search path and accessible by the user.  However, within a\n single GRASS session, the user only has  write  access to data\n stored under the  current mapset  (specified by the\n variable  MAPSET ).\n  Each \"mapset\" stores GRASS data base elements (i.e., the\n directories in which GRASS data files are stored).  Any maps created\n or modified by the user in the current GRASS session will be stored\n here. The  MAPSET  directory  PERMANENT  is generally\n reserved for the set of maps that form the base set for all users\n working under each  LOCATION_NAME .\n Once within a GRASS session, GRASS users have access only to the data\n under a single GRASS data base directory (the  current GRASS data\n base , specified by the variable  GISDBASE ), and to a\n single GRASS location directory (the  current location ,\n specified by the variable  LOCATION_NAME ).  Within a single\n session, the user may only  modify  the data in the\n  current mapset  (specified by the variable\n  MAPSET ), but may  use  data available under other\n mapsets under the same  LOCATION_NAME .\n  All of these names must be legal names on the user's current system.\n The full path to the current mapset is determined\n from  GISDBASE ,  LOCATION_NAME ,  MAPSET \n variables, in the example\n above:  /opt/grassdata/spearfish/PERMANENT . The full path can\n be printed using  g.gisenv  by providing multiple variables:\n g.gisenv get=GISDBASE,LOCATION_NAME,MAPSET sep='/'\n /opt/grassdata/nc_spm_08_grass7/user1\n ", "notes": "\n The output from\n  g.gisenv \n when invoked without arguments is directly usable by Bash.  The\n following command will cast each variable into the UNIX environment:\n eval `g.gisenv`\n This works only for  Bash . The format of the output is not\n compatible with other UNIX shells.\n By default the GRASS variables are stored in  gisrc  file\n (defined by environmental\n variable  GISRC ). If  store=mapset  is given than the\n variables are stored in  $GISDBASE/$LOCATION_NAME/$MAPSET/VAR .\n   \n  GRASS Debugging \n To print debugging messages, the variable  DEBUG  must be set to level\n equal or greater than 0:\n g.gisenv set=\"DEBUG=3\"\n Levels: (recommended levels)\n     0 - silence\n     1 - message is printed once or few times per module\n     3 - each row (raster) or line (vector)\n     5 - each cell (raster) or point (vector)\n To disable debugging messages:\n g.gisenv unset=\"DEBUG\"\n The variable DEBUG controls debugging messages from GRASS libraries\n and modules.\n Similarly  WX_DEBUG  controls debugging messages\n from  wxGUI .\n ", "see_also": ["g.access", "g.filename", "g.findfile", "g.mapsets"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.gisenv"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.findfile.html", "name": "g.findfile", "definition": "- Searches for GRASS data base files and sets variables for the shell.", "keywords": ["general", "map management", "scripts"], "synopsis": "g.findfile [-nl] element=string file=string  [mapset=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Do not add quotes List available elements and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available elements and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "element", "flag": "element", "dataType": "String", "optional": false, "explanation": "Name of an element", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": false, "explanation": "Name of an existing map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapset", "flag": "mapset", "dataType": "String", "optional": true, "explanation": "Name of a mapset (default: search path)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.findfile  is designed for Bourne shell or Python scripts\n that need to search for mapset  elements , including: raster,\n vector maps, region definitions\n and  imagery  groups.\n  The list of  element  names to search for is not fixed; any\n subdirectory of the mapset directory is a valid  element  name.\n  However, the user can find the list of standard GRASS  element \n names in the file  $GISBASE/etc/element_list . This is the file\n which  g.remove ,  g.rename \n and  g.copy  use to determine which files\n need to be deleted/renamed/copied for a given entity type.\n ", "notes": "\n  g.findfile  writes four lines to standard output:\n name=' file_name '\n mapset=' mapset_name '\n file=' unix_filename '\n fullname=' grass_fullname '\n The output is  Bash  commands to set the variable\n  name  to the GRASS data base file name,\n  mapset  to the mapset in which the file resides,\n and  file  to the full UNIX path name for the named\n file. These variables may be set in the  Bash \n as follows:\n eval `g.findfile element=name mapset=name file=name`\n  EXAMPLES \n  SHELL \n  Raster map example: \n eval `g.findfile element=cell file=elevation`\n If the specified file (here: raster map) does not exist, the variables\n will be set as follows:\n name=\n mapset=\n fullname=\n file=\n The following is a way to test for this case:\n if [ ! \"$file\" ]\n then\n \texit 1\n fi\n  Vector map example (including error message): \n eval `g.findfile element=vector file=\"$G_OPT_V_INPUT\"`\n if [ ! \"$file\" ] ; then\n    g.message -e \"Vector map  not found\"\n    exit 1\n fi\n  PYTHON \n See  Python\n Scripting Library  for more info.\n Note: The Python tab in the  wxGUI  can be used for entering the\n following code:\n import grass.script as gcore\n     \n gcore.find_file('elevation', element = 'cell')\n ", "see_also": ["g.filename", "g.gisenv", "g.mapsets", "g.parser"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.findfile"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.findetc.html", "name": "g.findetc", "definition": "- Searches for GRASS support files.", "keywords": ["general", "map management", "scripts"], "synopsis": "g.findetc file=string  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": false, "explanation": "Name of an file or directory", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.findetc  is designed for Bourne shell scripts that need to search\n for support data, programs and subfoldrs in any number of directories as\n specified in GRASS_ADDON_ETC, plus the GRASS application etc/ directory. This\n is designed for addon scripts that are installed outside the GRASS application\n directory, such as a user's home or a system addon directory.\n  OUTPUT \n  g.findetc  writes the full path to the file or directory to standard output\n ", "notes": "", "see_also": ["g.filename", "g.findfile", "g.gisenv", "g.mapsets"], "authors": ["William Kyngesburye"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.findetc"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.filename.html", "name": "g.filename", "definition": "- Prints GRASS data base file names.", "keywords": ["general", "map management", "scripts"], "synopsis": "g.filename element=string file=string  [mapset=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "element", "flag": "element", "dataType": "String", "optional": false, "explanation": "Name of an element", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": false, "explanation": "Name of a database file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapset", "flag": "mapset", "dataType": "String", "optional": true, "explanation": "Name of a mapset (default: current)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.filename  is designed for Bourne shell scripts that need to know \n the full file name, including it's path, for mapset elements, like raster,\n vector and site maps, region definitions and imagery groups.\n  The list of element names to search for is not fixed; any subdirectory of the\n mapset directory is a valid element name.\n  However, the user can find the list of standard GRASS GIS element names in\n the file  $GISBASE/etc/element_list . This is the file which\n g.remove/g.rename/g.copy use to determine which files need to be\n deleted/renamed/copied for a given entity type.\n  OUTPUT \n  g.filename \n writes one line to standard output:\n file=' full_file_pathname' \n The output is a  /bin/sh  command to set the\n variable specified by the file  name  to the full\n UNIX path name for the data base file.  This variable may\n be set in the  /bin/sh  as follows:\n eval `g.filename element=name mapset=name file=name`\n ", "notes": "\n This module generates the filename, but does not care if the file (or mapset\n or element) exists or not. This feature allows shell scripts to create new data\n base files as well as use existing ones.\n If the mapset is the current mapset,  g.filename \n automatically creates the  element  specified if it\n doesn't already exist.  This makes it easy to add new files\n to the data base without having to worry about the\n existence of the required data base directories.  (This\n program will not create a new mapset, however, if that\n specified does not currently exist.)\n  The program exits with a 0 if everything is ok;  it exits\n with a non-zero value if there is an error, in which case\n file= 'full_file_pathname'  is not output.\n ", "see_also": ["g.findfile", "g.gisenv"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.filename"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.extension.html", "name": "g.extension", "definition": "- Maintains GRASS Addons extensions in local GRASS installation.", "keywords": ["general", "installation", "extensions", "addons", "download"], "synopsis": "g.extension [-lcgasdift] extension=name operation=string  [url=url]   [prefix=path]   [proxy=proxy[,proxy,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "List available extensions in the official GRASS GIS Addons repository List available extensions in the official GRASS GIS Addons repository including module description List available extensions in the official GRASS GIS Addons repository (shell script style) List locally installed extensions Install system-wide (may need system administrator rights) Download source code and exit Do not install new extension, just compile it Force removal when uninstalling extension (operation=remove) Operate on toolboxes instead of single modules (experimental) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "List available extensions in the official GRASS GIS Addons repository including module description List available extensions in the official GRASS GIS Addons repository (shell script style) List locally installed extensions Install system-wide (may need system administrator rights) Download source code and exit Do not install new extension, just compile it Force removal when uninstalling extension (operation=remove) Operate on toolboxes instead of single modules (experimental) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "List available extensions in the official GRASS GIS Addons repository (shell script style) List locally installed extensions Install system-wide (may need system administrator rights) Download source code and exit Do not install new extension, just compile it Force removal when uninstalling extension (operation=remove) Operate on toolboxes instead of single modules (experimental) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "List locally installed extensions Install system-wide (may need system administrator rights) Download source code and exit Do not install new extension, just compile it Force removal when uninstalling extension (operation=remove) Operate on toolboxes instead of single modules (experimental) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Install system-wide (may need system administrator rights) Download source code and exit Do not install new extension, just compile it Force removal when uninstalling extension (operation=remove) Operate on toolboxes instead of single modules (experimental) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Download source code and exit Do not install new extension, just compile it Force removal when uninstalling extension (operation=remove) Operate on toolboxes instead of single modules (experimental) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Do not install new extension, just compile it Force removal when uninstalling extension (operation=remove) Operate on toolboxes instead of single modules (experimental) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Force removal when uninstalling extension (operation=remove) Operate on toolboxes instead of single modules (experimental) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Operate on toolboxes instead of single modules (experimental) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "extension", "flag": "extension", "dataType": "String", "optional": false, "explanation": "Name of extension to install or remove", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "operation", "flag": "operation", "dataType": "String", "optional": false, "explanation": "Operation to be performed", "defaultValue": "add", "alternatives": ["add", "remove"], "isInputFile": false, "isOutputFile": false}, {"parameter": "url", "flag": "url", "dataType": "String", "optional": true, "explanation": "URL or directory to get the extension from (supported only on Linux and Mac)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "prefix", "flag": "prefix", "dataType": "String", "optional": true, "explanation": "Prefix where to install extension (ignored when flag -s is given)", "defaultValue": "$GRASS_ADDON_BASE", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "proxy", "flag": "proxy", "dataType": "String", "optional": true, "explanation": "Set the proxy with: \"http=<value>,ftp=<value>\"", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.extension  downloads and installs, removes or updates\n extensions (addons) from the official\n  GRASS GIS Addons repository \n or from user-specified source code repositories into the local GRASS GIS\n installation.\n Two types of extensions are supported:\n  Python scripts: they are installed without the need of compilation or (usually)\n     the need of special dependencies. \n  Source code (mostly written in C programming language; may also be written\n     in C++, Fortran or other languages): while on MS-Windows systems the requested\n     GRASS GIS extension is downloaded pre-compiled from the GRASS GIS site, on Unix\n     based systems the installation is preceded by the automated download of the\n     extension's source code along with subsequent compilation and installation.\n     This requires a compiler environment to be present on the user's computer. \n  Managing installed extensions \n  Re-running  g.extension  on an installed GRASS GIS Addon\n extension re-installs the requested extension which may include\n updates.\n To bulk-update all locally installed GRASS GIS extensions, \n  g.extension.all  module\n is available.\n  Where the extensions are installed \n GRASS GIS extensions are installed by  g.extension  into a dedicated\n directory.\n The default is a directory for application data and settings inside\n the user's home directory. \n On GNU/Linux it is  $HOME/.grass7/addons ,\n on MS-Windows it is  $APPDATA\\GRASS7\\addons .\n The name of the directory is stored in the  GRASS_ADDON_BASE \n environmental variable.\n The flag  -s  changes this install target directory to the GRASS GIS\n installation directory\n (determined by  GISBASE  environmental variable, e.g.  /usr/ )\n rather than the default directory defined as per   GRASS_ADDON_BASE  \n (see also documentation for  variables ).\n  g.extension  checks if the user has permission to write to\n  GISBASE  or  GRASS_ADDON_BASE .\n The place where the extensions are installed can be customized by\n the option  prefix . Ensuring that these extensions will be accessible\n in GRASS GIS is in this case in the responsibility of the user.\n  Source code sources and repositories \n  GRASS GIS Addons SVN repository \n By default,  g.extension  installs extensions from the official\n GRASS GIS Addons SVN repository. However, different sources can be specified\n using the  url  option.\n Individual extensions can also be installed by providing a URL to the\n source code on OSGeo Trac. This, however, works only for certain directories\n where the download of ZIP files was enabled by project administrators of\n the trac server.\n  Local source code directory \n Optionally, new extension can be also installed from a source code placed\n in a local directory on disk. This is advantageous when developing\n a new module.\n To keep the directory clean, the directory content is copied\n to a temporary directory and the compilation happens there.\n  Local source code ZIP file \n In addition, new extension can be also installed from a ZIP file\n or an archive file from the TAR family (e.g.,  .tar.gz  or  .bz2 ).\n The file can be on disk (specified with a path), or on web (specified by\n an URL).\n  Online repositories: GitHub, GitLab and Bitbucket \n For well known general hosting services, namely GitHub, GitLab and Bitbucket,\n  g.extension  supports the download of a repository as a ZIP file.\n Here the user only needs to provide a base URL to the repository web page\n (with or without the  https://  part).\n For GitLab and Bitbucket, the latest source code in the default branch is \n downloaded, for GitHub, the latest source code in the master branch is downloaded.\n Of course, a user can still specify the full URL of a ZIP file\n and install a specific branch or release in this way (ZIP file mechanism\n will be applied).\n For the official repository,  g.extension  supports listing available\n extensions (addons) and few other metadata-related operations which\n depend on a specific infrastructure.\n For other sources and repositories, this is not supported because it is\n assumed that other sources contain only one extension, typically a module\n or group of modules.\n  Needed directory layout \n When none of the above sources is identified,  g.extension  assumes\n that the source is a Subversion repository and uses the  svn  command\n line tool to obtain the source code. The expected structure of the repository\n should be the same as the one of the official repository.\n Non-official sources are supported on all operating systems except for\n MS-Windows.\n  Compilation and installation \n On MS-Windows systems, where compilation tools are typically not readily\n locally installed,  g.extension  downloads a precompiled executable\n from the GRASS GIS project server. On all other operating systems\n where it is not difficult to install compilation tools,\n  g.extension  downloads the source code of the requested\n extension (addon) and compiles it locally.\n This applies for both C and Python modules\n as well as any other extensions. The reason is that more things such\n as manual page are compiled, not only the source code (which is really\n necessary to compile just in case of C).\n  EXAMPLES \n  Download and install of an extension \n Download and install  r.stream.distance  into current GRASS installation\n g.extension extension=r.stream.distance\n This installs the extension from the official repository.\n For convenience, a shorter syntax can be used:\n g.extension r.stream.distance\n  Download and install of an extension when behind a proxy \n Example for an open http proxy:\n # syntax: http://proxyurl:proxyport\n g.extension extension=r.stream.distance proxy=\"http://proxy.example.com:8080\"\n Example for a proxy with proxy authentication:\n # syntax: http://username:password@proxyurl:proxyport\n g.extension extension=r.stream.distance proxy=\"http://username:password@proxy.example.com:8080\"\n  Managing the extensions \n List all available extensions in the official GRASS GIS Addons repository:\n g.extension -l\n List all locally installed extensions:\n g.extension -a\n Removal of a locally installed extension:\n g.extension extension=r.stream.distance operation=remove\n  Installing from various online repositories: GitHub, GitLab, Bitbucket \n Simple URL to GitHub, GitLab, Bitbucket repositories:\n g.extension r.example url=github.com/johnsmith/r.example\n Simple URL to OSGeo Trac (downloads a ZIP file, requires download to be enabled in Trac):\n g.extension r.example url=trac.osgeo.org/.../r.example\n In general, when a ZIP file or other archive is provided, the full URL can be used:\n g.extension r.example url=http://example.com/.../r.example?format=zip\n Note that because of MS-Windows operating system architecture,\n only official repository is supported on this platform.\n  Installing when writing a module locally \n Having source code of a GRASS module in a directory on disk\n one can install it using:\n g.extension r.example url=/local/directory/r.example/\n  KNOWN ISSUES \n Toolboxes in the official repository cannot be downloaded.\n On MS-Windows, only the official repository is working\n because there is no way of compiling the modules\n (a Python replacement for Python scripts should be implemented).\n  TROUBLESHOOTING \n Since extensions have to be compiled on Unix based systems (Linux, Mac OSX etc.)\n unless a Python extension is installed, a full compiler environment must be\n present on the user's computer.\n  ERROR: Please install GRASS development package \n While GRASS GIS is available on the user's computer, the respective development\n package is lacking. If GRASS was installed from a (Linux) repository, also the\n grass-dev* package (commonly named \"grass-dev\" or \"grass-devel\", sometimes along\n with the version number) must be installed.\n ", "notes": "", "see_also": ["g.extension.all"], "authors": ["Markus Neteler (original shell script)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/g.extension"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.extension.all.html", "name": "g.extension.all", "definition": "- Rebuilds or removes all locally installed GRASS Addons extensions.", "keywords": ["general", "installation", "extensions"], "synopsis": "g.extension.all [-f]  [operation=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Force operation (required for removal) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "operation", "flag": "operation", "dataType": "String", "optional": true, "explanation": "Operation to be performed", "defaultValue": "rebuild", "alternatives": ["rebuild", "remove"], "isInputFile": false, "isOutputFile": false}], "description": "\n  g.extension.rebuild.all  reinstalls and updates all locally\n installed GRASS Addons extensions in local GRASS installation. The\n extensions can be installed\n by  g.extension . List of\n locally installed extensions can be printed by  g.extension\n -a .\n  EXAMPLES \n Rebuild locally installed extensions which were built against\n different GIS Library (see  g.version -r )\n g.extension.rebuild.all\n Force to rebuild all locally installed extensions\n g.extension.rebuild.all -f\n ", "notes": "", "see_also": ["g.extension"], "authors": ["Martin Landa, Czech Technical University in Prague, Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/g.extension.all"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.dirseps.html", "name": "g.dirseps", "definition": "- Internal GRASS utility for converting directory separator characters.", "keywords": ["general", "map management", "scripts"], "synopsis": "g.dirseps [-hg]  [path=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "h", "flag": "-h", "explanation": "Convert directory separators to native host format Convert directory separators to GRASS internal format Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Convert directory separators to GRASS internal format Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "path", "flag": "path", "dataType": "String", "optional": true, "explanation": "Path to be converted (read from stdin if not specified)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "", "notes": "", "see_also": [], "authors": ["Paul Kelly"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.dirseps"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.copy.html", "name": "g.copy", "definition": "- Copies available data files in the current mapset search path to the user's current mapset.", "keywords": ["general", "map management"], "synopsis": "g.copy  [raster=from,to]   [raster_3d=from,to]   [vector=from,to]   [label=from,to]   [region=from,to]   [group=from,to]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "raster map(s) to be copied", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster_3d", "flag": "raster_3d", "dataType": "String", "optional": true, "explanation": "3D raster map(s) to be copied", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vector", "flag": "vector", "dataType": "String", "optional": true, "explanation": "vector map(s) to be copied", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label", "flag": "label", "dataType": "String", "optional": true, "explanation": "paint label file(s) to be copied", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "region", "flag": "region", "dataType": "String", "optional": true, "explanation": "region definition(s) to be copied", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": true, "explanation": "imagery group(s) to be copied", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n A user may access data stored under the other mapsets listed in their\n mapset search path. However, the user may only modify data stored\n under their own current mapset.  g.copy  allows the user to copy\n existing data files  from  other mapsets  to  the user's\n current mapset ($MAPSET). The files to be copied must exist in the\n user's current mapset search path and location; output is sent to the\n relevant data element directory(ies) under the user's current mapset.\n  EXAMPLES \n If the user wished to copy the existing raster\n file  soils  to a file called  soils.ph  and\n to copy an existing vector map  roads  to a file\n called  rds.old , the user could type:\n g.copy raster=soils,soils.ph\n g.copy vector=roads,rds.old\n # or even combined:\n g.copy raster=soils,soils.ph vector=roads,rds.old\n Data files can also be specified by their mapsets.  For\n example, the below command copies the raster map named\n  soils  from the mapset  wilson  to a new\n file called  soils  to be placed under the user's\n current mapset:\n g.copy raster=soils@wilson,soils\n If no mapset name is specified,  g.copy  searches for the\n named  from  map in each of the mapset directories listed in the\n user's current mapset search path in the order in which mapsets are\n listed there (see  g.mapsets ).\n ", "notes": "", "see_also": ["g.access", "g.list", "g.mapsets", "g.remove", "g.rename"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.copy"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.access.html", "name": "g.access", "definition": "- Controls access to the current mapset for other users on the system.", "keywords": ["general", "map management", "permission"], "synopsis": "g.access  [group=string]   [other=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": true, "explanation": "Access for group", "defaultValue": null, "alternatives": ["grant", "revoke"], "isInputFile": false, "isOutputFile": false}, {"parameter": "other", "flag": "other", "dataType": "String", "optional": true, "explanation": "Access for others", "defaultValue": null, "alternatives": ["grant", "revoke"], "isInputFile": false, "isOutputFile": false}], "description": "\n This program allows the user to control access to the\n current mapset.  Normally, any user can read data from any\n GRASS mapset. But sometimes it is desirable to prohibit\n access to certain sensitive data. The  g.access \n command allows a user to restrict read and execute access\n to the current mapset (see UNIX  chmod  command).\n  g.access  will not modify write access to the\n current mapset.\n The user may, for example, allow only users in the same\n UNIX group to read data files in the mapset, or restrict\n the mapset to personal use only.\n ", "notes": "\n   Under GRASS, access to the mapset PERMANENT must be open to\n all users.  This is because GRASS looks for the user's default geographic\n region definition settings and the location TITLE in files that are stored\n under the PERMANENT mapset directory.  The  g.access  command,\n therefore, will not allow you to restrict access to the PERMANENT mapset.\n  The  g.mapsets  command isn't smart\n enough to tell if access to a specified mapset is restricted, and the user\n is therefore allowed to include the names of restricted mapsets in his\n search path.  However, the data in a restricted mapset is still protected;\n any attempts to look for or use data in a restricted mapset will fail.  The\n user will simply not see any data listed for a restricted mapset.\n  UNIX filesystem access controls and  g.access  actions are not \n supported by MS-Windows.\n ", "see_also": ["g.mapsets"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.access"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.univar.html", "name": "db.univar", "definition": "- Calculates univariate statistics on selected table column.", "keywords": ["database", "statistics", "attribute table"], "synopsis": "db.univar [-eg] table=name column=name  [database=name]   [driver=name]   [where=sql_query]   [percentile=float[,float,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Extended statistics (quartiles and 90th percentile) Print stats in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print stats in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": false, "explanation": "Name of attribute table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column on which to calculate statistics (must be numeric)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": null, "alternatives": ["dbf", "odbc", "ogr", "sqlite", "pg"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "percentile", "flag": "percentile", "dataType": "String", "optional": true, "explanation": "Percentile to calculate (requires extended statistics flag)", "defaultValue": "90", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}], "description": "\n  db.univar  calculates basic univariate statistics for numeric\n attributes in a data table. It will calculate minimum, maximum, range, mean,\n standard deviation, variance, coefficient of variation, quartiles, median, and\n 90th percentile.\n It uses  db.select  to create list values for statistical calculations.\n  NOTES \n If the database and driver are not specified, the default values set in\n  db.connect  will be used.\n  EXAMPLE \n In this example, random points are sampled from the elevation map\n (North Carolina sample dataset) and univariate statistics performed:\n g.region raster=elevation -p\n v.random output=samples n=100\n v.db.addtable samples column=\"heights double precision\"\n v.what.rast samples raster=elevation column=heights\n v.db.select samples\n db.univar samples column=heights\n ", "notes": "", "see_also": ["v.db.univar", "r.univar", "v.univar", "db.select", "d.vect.thematic"], "authors": ["Michael Barton, Arizona State University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/db.univar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.test.html", "name": "db.test", "definition": "- Test database driver, database must exist and set by db.connect.", "keywords": ["database", "attribute table"], "synopsis": "db.test test=string  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "test", "flag": "test", "dataType": "String", "optional": false, "explanation": "Test name", "defaultValue": null, "alternatives": ["test1"], "isInputFile": false, "isOutputFile": false}], "description": "\n  db.test  tests database driver and database server running \n set of SQL queries. Database must exist and connection must be set\n by db.connect.\n  EXAMPLE \n Test current SQL backend driver:\n db.connect -p\n db.test test=test1\n ", "notes": "", "see_also": ["GRASS SQL interface", "db.connect", "db.describe", "db.drivers"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/db.test"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.tables.html", "name": "db.tables", "definition": "- Lists all tables for a given database.", "keywords": ["database", "attribute table"], "synopsis": "db.tables [-ps]  [driver=name]   [database=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print tables and exit System tables instead of user tables Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "System tables instead of user tables Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.tables  lists all tables for a given database. \n ", "notes": "\n If parameters for database connection are already set with \n  db.connect , they are taken as default values and\n do not need to be spcified each time.\n  EXAMPLES \n  List all tables if database connection is already set \n db.tables -p\n  List all DBF tables \n db.tables driver=dbf database=/grassdata/nc_spm_08/user1/PERMANENT/dbf\n  List all tables in SQLite database (note that this is the default setting) \n db.tables -p driver=sqlite database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'\n ", "see_also": ["db.columns", "db.droptable", "db.login", "db.execute", "GRASS SQL interface"], "authors": ["Unknown"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.tables"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.select.html", "name": "db.select", "definition": "- Selects data from attribute table.", "keywords": ["database", "attribute table", "SQL"], "synopsis": "db.select [-cdvt]  [sql=sql_query]   [input=name]   [table=name]   [driver=name]   [database=name]   [separator=character]   [vertical_separator=character]   [null_value=string]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Do not include column names in output Describe query only (don't run it) Vertical output (instead of horizontal) Only test query, do not execute Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Describe query only (don't run it) Vertical output (instead of horizontal) Only test query, do not execute Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Vertical output (instead of horizontal) Only test query, do not execute Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Only test query, do not execute Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "sql", "flag": "sql", "dataType": "String", "optional": true, "explanation": "SQL SELECT statement", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of file containing SQL select statement(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": true, "explanation": "Name of table to query", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vertical_separator", "flag": "vertical_separator", "dataType": "String", "optional": true, "explanation": "Vertical record separator (requires -v flag)", "defaultValue": null, "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  db.select  prints result of selection from database based on\n SQL statement read from input file or from standard input to standard\n output. Each individual query has to be written on one single line and \n different queries have to be written on separate lines.\n ", "notes": "\n If parameters for database connection are already set with\n  db.connect , they are taken as\n default values and do not need to be specified each time. Output will\n be displayed to standard output or can be directed to a file\n (option  output ).\n  EXAMPLES \n  Basic usage \n db.select sql=\"select * from roads\"\n or\n echo \"select * from roads\" | db.select input=-\n or\n db.select input=file.sql\n or\n cat file.sql | db.select input=-\n Select all from table roads:\n db.select -c driver=odbc database=mydb table=hospitals \n            input=file.sql output=result.csv\n Select some string attribute, exclude others:\n db.select sql=\"SELECT * FROM archsites WHERE str1 <> 'No Name'\"\n Select some string attribute with ZERO length:\n db.select sql=\"SELECT * FROM archsites WHERE str1 IS NULL\"\n Select coordinates from PostGIS table:\n db.select sql=\"SELECT x(geo),y(geo) FROM localizzazione\"\n  Execute multiple SQL statements \n cat file.sql\n SELECT * FROM busstopsall WHERE cat = 1\n SELECT cat FROM busstopsall WHERE cat > 4 AND cat < 8\n db.select input=file.sql\n  Count number of cases falling into same position \n When multiple observation have the spatial coordinates, they can still\n be counted (if needed, coordinates can be uploaded to the attribute\n table by  v.to.db :\n   \n db.select sql=\"SELECT long,lat,site_id,department,obs,COUNT(long) as count_cases \n                 FROM diseases GROUP BY long,lat\"\n ", "see_also": ["db.connect", "db.describe", "db.drivers", "db.droptable", "db.execute", "db.login", "db.tables"], "authors": ["Original author unknown (probably CERL)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.select"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.out.ogr.html", "name": "db.out.ogr", "definition": "- Exports attribute tables into various formats.", "keywords": ["database", "export", "attribute table"], "synopsis": "db.out.ogr input=name output=name  [layer=string]  format=string  [table=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "GRASS table name", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output table file name or DB connection string", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": false, "explanation": "Table format", "defaultValue": "CSV", "alternatives": ["CSV", "DBF", "GML", "MySQL", "PostgreSQL", "SQLite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": true, "explanation": "Name for output table (default: input name)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  db.out.ogr  exports GRASS GIS attribute tables into various formats\n as supported by the OGR driver on the local system (CSV, DBF,\n PostgreSQL, SQLite, MySQL, ODBC, etc.).\n The  output  parameter is used to define the output file name (if\n the path is not defined, the module will attempt to write to the current\n directory). In case of a database connection as output, the connection\n string has to be specified.\n The  layer  parameter is needed if the attribute table to be exported\n is linked as non-default layer to a vector map.\n  EXAMPLES \n  Export of GRASS GIS attribute table to a CSV table file (default format) \n db.out.ogr input=precip_30ynormals output=precip_30ynormals.csv\n  Export of a GRASS GIS attribute table to a DBF table \n db.out.ogr input=precip_30ynormals output=precip_30ynormals.dbf format=DBF\n  Export of GRASS GIS attribute table into a PostgreSQL table \n db.out.ogr input=precip_30ynormals \n  \t   output=\"PG:host=localhost dbname=meteo user=neteler\" \n             format=PostgreSQL\n # verify\n echo \"SELECT * FROM precip_30ynormals\" | psql meteo\n ", "notes": "", "see_also": ["db.tables"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/db.out.ogr"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.login.html", "name": "db.login", "definition": "- Sets user/password for DB driver/database.", "keywords": ["database", "connection settings"], "synopsis": "db.login [-p] driver=name database=name  [user=string]   [password=string]   [host=string]   [port=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print connection settings and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": false, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": false, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "user", "flag": "user", "dataType": "String", "optional": true, "explanation": "Username", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "password", "flag": "password", "dataType": "String", "optional": true, "explanation": "Password", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "host", "flag": "host", "dataType": "String", "optional": true, "explanation": "Hostname", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "port", "flag": "port", "dataType": "String", "optional": true, "explanation": "Port", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.login  sets login parameters such an user name and\n optionally also a password, a hostname or a port for the connection to\n the selected  database  through the DB  driver .\n ", "notes": "\n Options  host  and  port  are related to only SQL database\n backends like  PostgreSQL ,\n  MySQL  or  ODBC .\n Note that the passwords are stored in a hidden,  unencrypted \n file in the user account, specifically\n   in the 'home' directory, i.e.  $HOME/.grass7/dblogin  (Unix-like systems) \n    %APPDATA%/GRASS7/dblogin  (MS-Windows) \n Only the file owner can access this file.\n  EXAMPLES \n Only username specified (assuming locally accessible PostgreSQL DB\n without password):\n db.login driver=pg database=mydb\n Username, password and hostname specified (note that the command lines\n history will store the password in this way):\n db.login driver=pg database=mydb user=bacava password=secret host=db.example.com\n Username and empty password specified:\n db.login driver=pg database=mydb user=bacava password=\"\"\n ", "see_also": ["db.connect", "db.test", "db.tables"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.login"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.in.ogr.html", "name": "db.in.ogr", "definition": "- Imports attribute tables in various formats.", "keywords": ["database", "import", "attribute table"], "synopsis": "db.in.ogr input=name  [db_table=name]   [output=name]   [key=string]   [encoding=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Table file to be imported or DB connection string", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "db_table", "flag": "db_table", "dataType": "String", "optional": true, "explanation": "Name of table from given DB to be imported", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "key", "flag": "key", "dataType": "String", "optional": true, "explanation": "Name for auto-generated unique key column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "encoding", "flag": "encoding", "dataType": "String", "optional": true, "explanation": "Encoding value for attribute data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.in.ogr  imports attribute tables in various formats as\n supported by the  OGR library \n on the local system (DBF, CSV, PostgreSQL, SQLite, MySQL, ODBC,\n etc.). Optionally a unique  key  (ID) column can be\n added to the table.\n  EXAMPLES \n  Import CSV file \n Limited type recognition can be done for Integer, Real, String, Date, Time and DateTime\n columns through a descriptive file with same name as the CSV file, but .csvt extension\n (see details  here ).\n # NOTE: create koeppen_gridcode.csvt first for automated type recognition\n db.in.ogr input=koeppen_gridcode.csv output=koeppen_gridcode\n db.select table=koeppen_gridcode\n  Import DBF table \n Import of a DBF table with additional unique key column (e.g., needed\n for  v.in.db ).\n db.in.ogr input=/path/to/mydata.dbf output=census_raleigh key=myid\n db.describe -c census_raleigh\n  Import of a SQLite table \n db.in.ogr input=/path/to/sqlite.db db_table=census_raleigh output=census_raleigh\n  Import of a PostgreSQL table \n # HINT: if the database contains spatial tables, but you want to import a non-spatial \n table, set the environmental variable PG_LIST_ALL_TABLES to YES before importing\n db.in.ogr input=\"PG:host=localhost dbname=ecad user=neteler\" \n            db_table=ecad_verona_tmean output=ecad_verona_tmean\n db.select table=ecad_verona_tmean\n db.describe -c ecad_verona_tmean\n  Import XLS file \n To force reading headers, define environmental\n variable  OGR_XLS_HEADERS='FORCE' . Parameter  db_table \n refers to the list within XLS file.\n export OGR_XLS_HEADERS='FORCE'\n db.in.ogr input=address.xls db_table=address_data\n ", "notes": "", "see_also": ["db.select", "v.in.ogr", "v.in.db"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/db.in.ogr"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.execute.html", "name": "db.execute", "definition": "- Executes any SQL statement.", "keywords": ["database", "attribute table", "SQL"], "synopsis": "db.execute [-i]  [sql=sql_query]   [input=name]   [driver=name]   [database=name]   [schema=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Ignore SQL errors and continue Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "sql", "flag": "sql", "dataType": "String", "optional": true, "explanation": "SQL statement", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of file containing SQL statement(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "schema", "flag": "schema", "dataType": "String", "optional": true, "explanation": "Database schema", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.execute  allows the user to execute SQL statements.  \n ", "notes": "\n  db.execute  only executes SQL statements and does not return \n any data. If you need data returned from the database, use \n  db.select .\n If parameters for database connection are already set with\n  db.connect , they are taken as default\n values and do not need to be specified each time.\n If you have a large number of SQL commands to process, it is much much\n faster to place all the SQL statements into a text file and\n use  input  file parameter than it is to process each statement\n individually in a loop. If multiple instruction lines are given, each\n SQL line must end with a semicolon.\n Please see the individual  GRASS SQL interface \n for how to create a new database.\n  EXAMPLES \n Create a new table with columns 'cat' and 'soiltype':\n db.execute sql=\"CREATE TABLE soils (cat integer, soiltype varchar(10))\"\n Create a new table using a file with SQL statements\n db.execute driver=odbc database=grassdb input=file.sql\n Insert new row into attribute table:\n db.execute sql=\"INSERT INTO mysites (id,name,east,north) values (30,'Ala',1657340,5072301)\"\n Update attribute entries to new value based on SQL rule:\n db.execute sql=\"UPDATE roads SET travelcost=5 WHERE cat=1\"\n Update attribute entries to new value based on SQL rule:\n db.execute sql=\"UPDATE dourokukan SET testc=50 WHERE testc is NULL\"\n Delete selected rows from attribute table:\n db.execute sql=\"DELETE FROM gsod_stationlist WHERE latitude < -91\"\n Add new column to attribute table:\n db.execute sql=\"ALTER TABLE roads ADD COLUMN length double\"\n Column type conversion - update new column from existing column (all\n drivers except for DBF):\n # 'z_value' is varchar and 'z' is double precision:\n echo \"UPDATE geodetic_pts SET z = CAST(z_value AS numeric)\" | db.execute input=-\n Drop column from attribute table:\n db.execute sql=\"ALTER TABLE roads DROP COLUMN length\"\n Drop table (not supported by all drivers):\n db.execute sql=\"DROP TABLE fmacopy\"\n Update attribute with multiple SQL instructions in file\n (e.g.,  file.sql , instruction line must end with a semicolon):\n UPDATE roads SET travelcost=5 WHERE cat=1;\n UPDATE roads SET travelcost=2 WHERE cat=2;\n db.execute input=file.sql\n Join table 'myroads' to table 'extratab' based on common 'cat' column\n values (not supported by DBF driver):\n db.execute sql=\"UPDATE extratab SET names=(SELECT label FROM myroads WHERE extratab.cat=myroads.cat)\"\n ", "see_also": ["db.columns", "db.describe", "db.drivers", "db.droptable", "db.login", "db.select", "db.tables"], "authors": ["CERL"], "source_code": null},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.droptable.html", "name": "db.droptable", "definition": "- Drops an attribute table.", "keywords": ["database", "attribute table"], "synopsis": "db.droptable [-f]  [driver=name]   [database=name]  table=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Force removal (required for actual deletion of files) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": false, "explanation": "Name of table to drop", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.droptable  drops an attribute table.  If the  -f \n force flag is not given then nothing is removed, instead a preview of\n the action to be taken is printed.\n ", "notes": "\n  db.droptable  is a front-end\n to  db.execute  to allow easier\n usage. To some extent it is verified if the table is connected to a\n vector map to avoid accidental table removal.\n  EXAMPLES \n  Removing an attribute table from default database \n # show default database\n db.connect -p\n # show available tables\n db.tables -p\n # this will show what would happen\n db.droptable table=sometable\n # actually drop the table\n db.droptable -f table=sometable\n  Removing an attribute table from given database \n  db.droptable  allows defining optionally  driver \n and  database  options different from default connection settings\n ( db.connect -p ).\n # drop the table from SQLite database\n db.droptable -f table=sometable driver=sqlite database=/opt/sqlite.db\n ", "see_also": ["db.dropdb", "db.dropcolumn", "db.execute", "db.login", "db.connect", "db.tables", "db.describe", "v.db.droptable"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/db.droptable"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.dropdb.html", "name": "db.dropdb", "definition": "- Removes an existing database.", "keywords": ["database", "attribute table", "SQL"], "synopsis": "db.dropdb driver=name database=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": false, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": false, "explanation": "Name of database", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.dropdb  removes an existing database using given database\n  driver . Currently only  SQLite \n and  PostgreSQL  database drivers are\n supported.\n  EXAMPLES \n  Drop (delete) an existing database connected through SQLite driver \n Note that the standard GRASS GIS SQLite database is by default\n found in the user's current mapset. This example shows an\n out-of-mapset database removal:\n db.dropdb driver=sqlite database=/opt/sqlite.db\n  Drop an existing database connected through PostgreSQL driver \n db.dropdb driver=pg database=grassdb\n  TODO \n Support other database drivers, too.\n ", "notes": "", "see_also": ["db.createdb", "db.describe", "db.droptable", "db.execute", "db.login", "db.tables"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/db/db.dropdb"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/db.dropcolumn.html", "name": "db.dropcolumn", "definition": "- Drops a column from selected attribute table.", "keywords": ["database", "attribute table"], "synopsis": "db.dropcolumn [-f] table=name column=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Force removal (required for actual deletion of files) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": false, "explanation": "Name of attribute table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  db.dropcolumn  drops a column from an attribute table.\n If the  -f  force flag is not given then nothing is removed, instead\n a preview of the action to be taken is printed.\n ", "notes": "\n  db.dropcolumn  is a front-end to  db.execute  to allow easier\n usage with a special workaround for the SQLite driver to support column\n drop also for SQLite tables.\n  EXAMPLE \n Dropping a column (North Carolina sample dataset):\n # work on own copy\n g.copy vect=roadsmajor,myroads\n db.describe -c myroads\n # only shows what would happen:\n db.dropcolumn myroads column=SHAPE_LEN\n # actually drops the column\n db.dropcolumn -f myroads column=SHAPE_LEN\n db.describe -c myroads\n ", "see_also": ["db.describe", "db.droptable", "db.execute", "v.db.dropcolumn", "GRASS SQL interface"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/db.dropcolumn"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.mapset.html", "name": "g.mapset", "definition": "- Changes/reports current mapset.", "keywords": ["general", "settings"], "synopsis": "g.mapset [-clp] mapset=name  [location=name]   [dbase=path]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Create mapset if it doesn't exist List available mapsets and exit Print current mapset and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available mapsets and exit Print current mapset and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print current mapset and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "mapset", "flag": "mapset", "dataType": "String", "optional": false, "explanation": "Name of mapset (default: current search path)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Location name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dbase", "flag": "dbase", "dataType": "String", "optional": true, "explanation": "GRASS GIS database directory", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.mapset  changes the current working MAPSET, LOCATION, or GISDBASE.\n This is a fairly radical maneuver to run mid-session, take care when running\n the GUI at the same time.\n With  g.mapset , the shell history (i.e.  .bash_history  file\n of the initial location will be used to record the command history.\n ", "notes": "\n By default, the shell continues to use the history for the old mapset.\n To change this behaviour the history can be switched to record in the new\n mapset's history file as follows:\n # bash example\n history -w\n history -r /\"$GISDBASE/$LOCATION/$MAPSET\"/.bash_history\n HISTFILE=/\"$GISDBASE/$LOCATION/$MAPSET\"/.bash_history\n  EXAMPLES \n  Print the name of the current mapset \n To print the name of the current mapset, use the  -p  command as\n shown below:\n g.mapset -p\n  List available mapsets \n To list available mapsets, use the  -l  command as shown below:\n g.mapset -l\n This should list all the mapsets, such as: \"landsat new PERMANENT user1.\"\n  Change the current mapset \n To change the current mapset to \"user1\" use the following command:\n g.mapset mapset=user1 location=nc_spm_08_grass7\n You should receive the following message: \"Mapset switched. Your shell\n continues to use the history for the old mapset.\" \n  Create a new mapset \n To create a new mapset, use the  -c  tag as shown below:\n g.mapset -c mapset=new location=nc_spm_08_grass7\n ", "see_also": ["g.gisenv", "g.mapsets"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.mapset"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.manual.html", "name": "g.manual", "definition": "- Displays the manual pages of GRASS modules.", "keywords": ["general", "manual", "help"], "synopsis": "g.manual [-itmo] entry=string  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Display index Display topics Display as MAN text page instead of HTML page in browser Display online manuals instead of locally installed Use online manuals available at http://grass.osgeo.org website. This flag has no effect when displaying MAN text pages. Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Display topics Display as MAN text page instead of HTML page in browser Display online manuals instead of locally installed Use online manuals available at http://grass.osgeo.org website. This flag has no effect when displaying MAN text pages. Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Display as MAN text page instead of HTML page in browser Display online manuals instead of locally installed Use online manuals available at http://grass.osgeo.org website. This flag has no effect when displaying MAN text pages. Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Display online manuals instead of locally installed Use online manuals available at http://grass.osgeo.org website. This flag has no effect when displaying MAN text pages. Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "entry", "flag": "entry", "dataType": "String", "optional": false, "explanation": "Manual entry to be displayed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.manual  display the manual pages of GRASS in HTML and MAN\n format.\n ", "notes": "\n The name of the browser is defined in the environment variable\n  GRASS_HTML_BROWSER . For most platforms this should be an\n executable in your PATH, or the full path to an executable. See\n  variables  for details.\n ", "see_also": [], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/g.manual"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.list.html", "name": "g.list", "definition": "- Lists available GRASS data base files of the user-specified data type optionally using the search pattern.", "keywords": ["general", "map management", "list", "search"], "synopsis": "g.list [-iretmpf] type=datatype[,datatype,...]  [pattern=string]   [exclude=string]   [mapset=name[,name,...]]   [separator=character]   [region=name]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Ignore case Use basic regular expressions instead of wildcards Use extended regular expressions instead of wildcards Print data types Print fully-qualified map names (including mapsets) Pretty printing in human readable format Verbose listing (also list map titles) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Use basic regular expressions instead of wildcards Use extended regular expressions instead of wildcards Print data types Print fully-qualified map names (including mapsets) Pretty printing in human readable format Verbose listing (also list map titles) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Use extended regular expressions instead of wildcards Print data types Print fully-qualified map names (including mapsets) Pretty printing in human readable format Verbose listing (also list map titles) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Print data types Print fully-qualified map names (including mapsets) Pretty printing in human readable format Verbose listing (also list map titles) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Print fully-qualified map names (including mapsets) Pretty printing in human readable format Verbose listing (also list map titles) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Pretty printing in human readable format Verbose listing (also list map titles) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Verbose listing (also list map titles) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": false, "explanation": "Data type(s)", "defaultValue": null, "alternatives": ["raster", "raster_3d", "vector", "label", "region", "group", "all"], "isInputFile": false, "isOutputFile": false}, {"parameter": "pattern", "flag": "pattern", "dataType": "String", "optional": true, "explanation": "Map name search pattern (default: all)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "exclude", "flag": "exclude", "dataType": "String", "optional": true, "explanation": "Map name exclusion pattern (default: none)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapset", "flag": "mapset", "dataType": "String", "optional": true, "explanation": "Name of mapset to list (default: current search path)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "newline", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "region", "flag": "region", "dataType": "String", "optional": true, "explanation": "Name of saved region for map search (default: not restricted)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  g.list  searches for data files matching a pattern given by\n wildcards or POSIX Extended Regular Expressions.\n ", "notes": "\n The output of  g.list  may be useful for other programs' parameter\n input (e.g. time series for  r.series )\n when used with  separator=comma .\n  EXAMPLES \n List all raster maps as continuous, sorted list:\n g.list type=rast\n List all vector maps as continuous, sorted list with MAPSET info (i.e.\n fully-qualified map names):\n g.list type=vector -m\n List all raster and vector maps ordered by mapset:\n g.list type=raster -p\n List all raster and vector maps as continuous, sorted list:\n g.list type=rast,vect\n List all available GRASS data base files:\n g.list type=all\n  Mapset search path \n If  mapset  is not specified than  g.list  searches for\n data files in the mapsets which are included in the search path\n (defined by  g.mapsets ),\n see  g.mapsets -p .\n g.list rast -p\n raster map(s) available in mapset <user1>:\n dmt\n ...\n raster map(s) available in mapset <PERMANENT>:\n aspect\n ...\n By option  mapset =. (one dot) can be listed only data files from\n the current mapset:\n g.list rast mapset=.\n ...\n Similarly  mapset =* (one asterisk) prints data files from all\n available mapsets also including those which are not listed in the\n current search path (see  g.mapsets -l ).\n g.list rast mapset=* -p\n raster map(s) available in mapset <landsat>:\n lsat5_1987_10\n ...\n raster map(s) available in mapset <user1>:\n dmt\n ...\n raster map(s) available in mapset <PERMANENT>:\n aspect\n ...\n  Wildcards \n List all vector maps starting with letter \"r\":\n g.list type=vector pattern=\"r*\"\n List all vector maps starting with letter \"r\" or \"a\":\n g.list type=vector pattern=\"[ra]*\"\n List all raster maps starting with \"soil_\" or \"landuse_\":\n g.list type=raster pattern=\"{soil,landuse}_*\"\n List certain raster maps with one variable character/number:\n g.list type=raster pattern=\"N45E00?.meters\"\n Use of  exclude  parameter:\n # without exclude:\n   g.list rast pat=\"r*\" mapset=PERMANENT\n   railroads\n   roads\n   rstrct.areas\n   rushmore\n # exclude only complete word(s):\n   g.list rast pat=\"r*\" exclude=roads mapset=PERMANENT\n   railroads\n   rstrct.areas\n   rushmore\n # exclude with wildcard:\n   g.list rast pat=\"r*\" exclude=\"*roads*\" mapset=PERMANENT\n   rstrct.areas\n   rushmore\n  Regular expressions \n List all soil maps starting with \"soils\" in their name:\n g.list -r type=raster pattern='^soils'\n List \"tmp\" if \"tmp\" raster map exists:\n g.list -r type=raster pattern='^tmp$'\n List \"tmp0\" ...\"tmp9\" if corresponding vector map exists\n (each map name linewise):\n g.list -r type=vector pattern='^tmp[0-9]$'\n List \"tmp0\"...\"tmp9\" if corresponding vector map exists\n (each map name comma separated):\n g.list -r type=vector separator=comma pattern='^tmp[0-9]$'\n  Extended regular expressions \n List all precipitation maps for the years 1997-2012, comma separated:\n g.list -e type=raster separator=comma pattern=\"precip_total.(199[7-9]|200[0-9]|201[0-2]).sum\"\n  Maps whose region overlaps with a saved region \n List all raster maps starting with \"tmp_\" whose region overlaps with\n the region of \"test\" raster map:\n g.region raster=test save=test_region\n g.list type=raster pattern='tmp_*' region=test_region\n List \"tmp0\"...\"tmp9\" vector maps whose region overlaps with\n the current region:\n g.list -r type=vector pattern='^tmp[0-9]$' region=.\n List all raster and vector maps whose region overlaps with the default region\n of the PERMANENT mapset in the current location (DEFAULT_WIND):\n g.list type=rast,vect region=*\n Note that, without  region=* ,  g.list type=rast,vect  simply\n lists all available raster and vector maps from the current search path\n regardless of their region.\n ", "see_also": ["r.series", "t.list", "t.rast.list", "t.vect.list"], "authors": ["Huidae Cho"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.list"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.vdigit.html", "name": "g.gui.vdigit", "definition": "- Interactive editing and digitization of vector maps.", "keywords": ["general", "GUI", "vector", "editing", "digitizer"], "synopsis": "g.gui.vdigit [-c] map=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Create new vector map if doesn't exist Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map to edit", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  vector digitizer  is a  wxGUI \n component intended for interactive editing and digitizing vector maps\n (see  v.edit  for non-interactive\n vector editing GRASS capabilities).\n Note that only vector maps stored or generated in the  current \n mapset can be opened for editing.\n The digitizer allows editing of 2D vector features (points, lines,\n centroids, boundaries, and areas).\n Vector features can be selected by mouse (bounding box or simply by\n mouse click, see select threshold\n in  Settings\u2192General\u2192Select threshold ), or by query\n (eg. by line length, see  Settings\u2192Query Tool ).\n  STARTING THE DIGITIZER \n The vector digitizer can be launched from Map Display toolbar by selecting\n \"Digitize\" from  Tools  combobox. Vector map is\n selectable for editing from Digitizer toolbar (\"Select vector\n map\" combobox, note that only vector maps from the current layer\n tree in Layer Manager are listed).\n The vector digitizer can alternatively be activated from the contextual\n menu in the Layer Manager by selecting \"Start editing\" on selected vector\n map in the layer tree, or directly from the Layer Manager\n toolbar  .\n The vector digitizer also can also be launched from the command line as a\n stand-alone application  g.gui.vdigit .\n  CREATING A NEW VECTOR MAP \n A new vector map can be easily created from the digitizer toolbar by\n selecting \"New vector map\" in \"Select vector map\"\n combobox. A new vector map is created, added to the current layer tree\n in Layer Manager and opened for editing. \"Select vector map\"\n combobox in the digitizer toolbar also allows easily switching between\n vector maps to be edited.\n  EDITING AN EXISTING VECTOR MAP \n An existing vector map selected in the digitizer toolbar in the\n \"Select vector map\" combobox. This map is then opened for editing\n and added to the current layer tree in the  Layer Manager . This\n \"Select vector map\" combobox in the digitizer toolbar also allows\n to easily switch between vector maps to be edited.\n  USING A RASTER BACKGROUND MAP \n In order to digitize from a raster map, simply load the map into the\n  Map Display  using the  Layer Manager . Then start digitizing,\n see below for details.\n  USING A VECTOR BACKGROUND MAP \n The vector digitizer allows you to select a \"background\" vector map.\n Loading it within the digitizer is different from simply loading it via \n  Layer Manager  since direct interaction with single vector features\n then becomes possible. \n Vector features may be copied from the background map by \"Copy features from\n (background) vector map\" tool from the \"Additional tools\" of the\n digitizer toolbar.\n Newly digitized vector features are snapped in the given threshold to the features\n from the background map.\n  DIGITIZER TOOLBAR \n    \u00a0\n      Digitize new point \n    Add new point to vector map and optionally define its\n     attributes. \n   \n    \u00a0\n      Digitize new line \n    Add new line to vector map and optionally define its\n     attributes. \n    \u00a0\n      Digitize new boundary \n    Add new boundary to vector map and optionally define its\n     attributes. \n   \n    \u00a0\n      Digitize new centroid \n    Add new centroid to vector map and optionally define its\n     attributes. \n    \u00a0\n      Digitize new area \n    Add new area (closed boundary and one centroid inside) to vector\n     map and optionally define its attributes. \n   \n    \u00a0\n      Move vertex \n    Move selected vertex of linear feature. Thus shape of linear\n     feature is changed. \n    \u00a0\n      Add vertex \n    Add new vertex to selected linear feature (shape not\n     changed). \n    \u00a0\n      Remove vertex \n    Remove selected vertex from linear feature. Thus shape of selected\n   feature can be changed. \n   \n    \u00a0\n      Edit line/boundary \n    Edit selected linear feature, add new segments or remove\n   existing segments of linear feature. \n    \u00a0\n      Move feature(s) \n    Move selected vector features. Selection can be done by mouse or\n     by query. \n    \u00a0\n      Delete feature(s) \n    Delete selected vector features (point, line, centroid, or\n   boundary). Selection can be done by mouse or by query. \n    \u00a0\n      Delete areas(s) \n    Delete selected vector areas. Selection can be done by mouse\n   or by query. \n    \u00a0\n      Display/update categories \n    Display categories of selected vector feature. Category settings\n   can be modified, new layer/category pairs added or already defined pairs\n   removed. \n    \u00a0\n      Display/update attributes \n    Display attributes of selected vector feature (based on its\n     category settings).  Attributes can be also modified. Same\n     functionality is accessible from Main toolbar \"Query vector map\n     (editable mode)\". \n    \u00a0\n      Additional tools \n    \n      \n        Break selected lines/boundaries at intersection  Split\n \tgiven vector line or boundary into two lines on given position\n \t(based on  v.clean ,\n \t tool=break ). \n        Connect two selected lines/boundaries  Connect selected\n \tlines or boundaries, the first given line is connected to the\n \tsecond one. The second line is broken if necessary on each intersection.\n \tThe lines are connected only if distance between them is not greater\n \tthan snapping threshold value. \n        Copy categories Copy category settings of\n \tselected vector feature to other vector\n \tfeatures. Layer/category pairs of source vector features are\n \tappended to the target feature category settings. Existing\n \tlayer/category pairs are not removed from category settings of\n \tthe target features. \n        Copy features from (background) vector map  Make identical copy of\n \tselected vector features. If a background vector map has been \n \tselected from the Layer Manager, copy features from background \n \tvector map, not from the currently modified vector map. \n        Copy attributes Duplicate attributes settings of\n \tselected vector feature to other vector features. New\n \tcategory(ies) is appended to the target feature category\n \tsettings and attributes duplicated based on category settings\n \tof source vector features. Existing layer/category pairs are\n \tnot removed from category settings of the target\n \tfeatures. \n        Feature type conversion  Change feature type of selected\n \tgeometry features. Points are converted to centroids,\n \tcentroids to points, lines to boundaries and boundaries to\n \tlines. \n        Flip selected lines/boundaries  Flip direction of\n \tselected linear features (lines or boundaries). \n        Merge selected lines/boundaries  Merge (at least two)\n \tselected vector lines or boundaries. The geometry of the\n \tmerged vector lines can be changed. If the second line from\n \ttwo selected lines is in opposite direction to the first, it\n \twill be flipped. See also\n \tmodule  v.build.polylines . \n        Snap selected lines/boundaries (only to nodes)  Snap\n \tvector features in given threshold. See also\n \tmodule  v.clean . Note that\n \tthis tool supports only snapping to nodes. Snapping to vector\n \tfeatures from background vector map is not currently\n \tsupported. \n        Split line/boundary Split selected line or boundary on\n       given position. \n        Query tool Select vector features by defining a threshold for\n         min/max length value (linear features or dangles). \n        Z-bulk labeling of 3D lines  Assign z coordinate values to 3D\n \tvector lines in bounding box. This is useful for labeling contour lines. \n      \n    \n    \u00a0\n      Undo \n    Undo previous operations. \n    \u00a0\n      Redo \n    Redo previous operations. \n    \u00a0\n      Settings \n    Digitizer settings. \n    \u00a0\n      Quit digitizing tool \n    Changes in vector map can be optionally discarded when\n   digitizing session is quited. \n ", "notes": "\n  Mouse button functions: \n \t Left    - select or deselect features \n \t Control+Left  - cancel action or undo vertex when digitizing lines \n \t Right   - confirm action \n  Dead (deleted)  features are only marked as 'dead' in the geometry file\n but remain there and occupy space. Any vector module\n used afterwards on this vector map which really reads and writes\n vector geometry (so not  g.copy )\n will write only features which are 'alive'.\n  Added or modified  vector features are  snapped  to\n existing vector features (Settings\u2192General\u2192Snapping). To\n disable snapping set the snapping threshold to '0'.\n If the digitizer crashes for some reason, the changes are\n automatically saved. Broken topology can be repaired by running\n  v.build .\n GRASS GIS uses a topological vector format, meaning that a common boundary of \n two polygons is only stored once. When digitizing polygons it is thus important\n to be able to only draw each boundary once. When drawing a polygon adjacent to an\n existing polygon, one has to first split the existing boundary at the points where \n the new boundary will be attached. Snapping should be set to ensure that the new \n boundaries are automatically attached to the chosen points.\n  REFERENCES \n    GRASS Vedit Library \n    Vector Database Management  (Wiki page) \n ", "see_also": ["wxGUI", "wxGUI components"], "authors": ["Martin Landa, FBK-irst (2007-2008), Trento, Italy, and Czech Technical University in Prague, Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/vdigit"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.tplot.html", "name": "g.gui.tplot", "definition": "- Plots the values of temporal datasets.", "keywords": ["general", "GUI", "temporal"], "synopsis": "g.gui.tplot [-h]  [stvds=name[,name,...]]   [strds=name[,name,...]]   [coordinates=east,north]   [cats=string]   [attr=string]   [output=name]   [csv=name]   [title=string]   [xlabel=string]   [ylabel=string]   [size=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "h", "flag": "-h", "explanation": "Set the header of CSV file, to be used with csv option Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "stvds", "flag": "stvds", "dataType": "String", "optional": true, "explanation": "Name of the input space time vector datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "strds", "flag": "strds", "dataType": "String", "optional": true, "explanation": "Name of the input space time raster datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Categories of vectores features", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "attr", "flag": "attr", "dataType": "String", "optional": true, "explanation": "Name of attribute", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output graphical file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "csv", "flag": "csv", "dataType": "String", "optional": true, "explanation": "Name for output CSV file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for plot", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "xlabel", "flag": "xlabel", "dataType": "String", "optional": true, "explanation": "Label for x axis", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ylabel", "flag": "ylabel", "dataType": "String", "optional": true, "explanation": "Label for y axis", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "The size for output image", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  Temporal Plot Tool  is a  wxGUI \n component that queries and plots the values of a point, defined by a coordinate\n pair, in one or more temporal datasets (strds, stvds, str3ds).\n Supported features:\n    temporal datasets with interval/point and absolute/relative time, \n    pop-up annotations with values information, \n    query and plot multiple points via the command line, \n    zoom and pan, \n    change labels to x and y axes, \n    add title to the plot, and \n    export the time series values to a CSV file. \n  Figure: Temporal Plot Tool \n To optionally add a title to the temporal plot and/or change the x and y\n axes labels, first type the desired text and then click  Draw  as\n showed below.\n  \n  Figure: Add title and labels to a time series plot \n To export the time series data to a text file (date and data values), type a\n name for the file and click  Draw  again. Optionally, set the \n check-box to print headers, as well.\n  \n  Figure: Export time series values to a text file \n ", "notes": "\n  g.gui.tplot  requires the Python plotting library \n  Matplotlib .\n ", "see_also": ["Temporal data processing", "wxGUI", "wxGUI components"], "authors": ["Luca Delucchi,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/tplot"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.timeline.html", "name": "g.gui.timeline", "definition": "- Allows comparing temporal datasets by displaying their temporal extents in a plot.", "keywords": ["general", "GUI", "temporal"], "synopsis": "g.gui.timeline [-3]  [inputs=name[,name,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "3", "flag": "-3", "explanation": "Show also 3D plot of spatio-temporal extents Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "inputs", "flag": "inputs", "dataType": "String", "optional": true, "explanation": "Name of the input space time datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  Timeline Tool  is a  wxGUI  component\n which allows the user to compare the extents of temporal datasets (strds, stvds,\n str3ds) in a plot.\n Supported features:\n    temporal datasets with interval/point and absolute/relative time \n    2D plots - temporal extent \n    3D plots - spatio-temporal extent (matplotlib >= 1.0.0) \n    pop-up annotations with basic metadata \n  \n ", "notes": "\n  g.gui.timeline  requires the Python plotting library \n  Matplotlib .\n ", "see_also": ["Temporal data processing", "wxGUI", "wxGUI components"], "authors": ["Anna Kratochvilova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/timeline"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.rlisetup.html", "name": "g.gui.rlisetup", "definition": "- Configuration tool for r.li modules.", "keywords": ["general", "GUI", "raster", "landscape structure analysis"], "synopsis": "g.gui.rlisetup  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "\n The  g.gui.rlisetup  is a  wxGUI \n component which allows the user to create a configuration file\n for the analytical  r.li  modules. For a general introduction, see \n the  r.li  overview.\n The configurations are raster map independent, it means that you can use\n a file created on a raster map for analyze any other you have.\n The program is completely interactive and uses a GUI to help you \n in your choices.\n  Analysis methods \n Definition of creation of sampling area:\n     Whole map layer: use entire area selected above, \n     Regions: select one to many subareas via mouse, \n     Sample units: automated selection of sampling area (for details see below)\n    \n       Random nonoverlapping, \n       Systematic contiguous, \n       Systematic noncontiguous, \n       Stratified random, \n       Centered over sites (vector points). \n    \n    \n     Moving window: rectangular or circular with size \n  \n Definition of region for analysis:\n     Whole map layer: entire map (current region), \n     Keyboard setting: based on keyboard selection for region definition, \n     Draw the sampling frame: based on interactive region selection via mouse. \n  Usage details \n The startup window shows your configuration files, you can: \n  TODO: description below needs further updates \n   View/Edit  (Load a file) from the shown list: the\n  configuration is shown in a small text editor window.\n   \n  Configuration files are saved in the folder \n   C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\  (MS-Windows) or \n   $HOME/.r.li/  (GNU/Linux) (the file name can be \n  defined by the user). The output or an analysis can either be a new raster\n  map (in case of using a \"moving window\" analysis) or be an ASCII text file \n  (when not performing a \"moving window\" analysis) containing the result. \n  Such text file will be saved in the folder \n   C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\  \n  (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n   \n   \n  All dimensions are percentages of raster rows or columns. \n   Create  a new configuration file: used for creating\n  a new configuration file in an interactive way, in three steps:\n    \n        Choose file name and maps to use for setting:\n \t \n \t     Name for new configuration file (required): the name\n \t  of new configuration file \n \t     Raster map name to use to select areas  (required):\n           the name of raster map used for selecting sampling areas \n \t     Vector map to overlay  (optional): name of a\n           vector map used for selecting sampling areas \n \t \n       \n        Set the sampling frame. The sample frame is a rectangular area \n      which contains all the areas to analyze. It can be defined in three \n      ways:\n \t \n \t    Whole map layer : the sample frame is the whole map \n \t    Keyboard setting : the user enters the coordinates in\n \t   cells of upper left corner of sampling frame and its length in\n \t   rows and columns. \n \t    Draw the sample frame : the user draws the sample frame\n \t   on map using mouse. \n \t \n       \n        Set the sample areas. The sample areas are simply the areas to \n        analyze. They can be defined in five ways (see the picture below):\n \t \n \t   Whole map layer : the sample area is the whole sample \n \t  frame \n \t   Regions : the user enters the number of areas and then \n \t  draws them using mouse.  \n \t   Sample units : they are areas of rectangular or circular \n \t  shape. The user can define them using keyboard or mouse.\n \t    \n \t       keyboard: the user define the shape of sample unists and \n \t      their disposition:\n \t           \n \t\t     Random non overlapping : the user specifies \n \t\t  the number of sample units and they are placed in a \n \t\t  random way at runtime. It is guaranteed that the \n \t\t  areas do not intersect themselves. \n \t\t     Systematic contiguous : the defined sample\n \t\t  is placed covering the sample frame, side by side \n \t\t  across rows. \n \t\t     Systematic non contiguous : the same as above, \n \t\t  but here ever rectangle is spaced from another by\n \t\t  a specified number of cells. \n \t\t     Stratified random : the sample frame is\n \t\t  divided in  n  strats of rows and  m  strats of columns \n \t\t  ( n  and  m  are given by user), then the specified \n \t\t  number of sample areas are placed in a random way, \n \t\t  one for every  m*n  areas defined by strats. \n \t\t     Centered over sites : the sample areas\n \t\t  are placed into sample frame centering them on points \n \t\t  in site file. \n \t\t   \n \t\t   \n \t       mouse: the user chooses the shape and then draws the \n \t      specified number of sample areas on map. \n \t    \n             \n \t   Moving Window:  the user defines a rectangular or \n \t circular area, it is moved over all the raster increasing only\n \t of a cell for every move(in columns if possible, if not in rows). \n \t It produces a new raster containing the result of all analysis. \n \t   Select areas from the overlaid vector map : \n \t the sample areas are defined by the vector map selected above.\n \t For every cat in vector map, the procedure prompts the \n \t user if they want to include it as sample area.\n \t The resulting configuration file can be used only with the \n \t specified raster map, and the procedure can be used only if\n \t whole map layer is selected as sampling frame. \n \t \n       \n   \n   \n    Remove a file  the selected file is deleted from the\n    available configuration files. \n    Help : open this help text. \n    Close  module window. \n ", "notes": "\n Configuration files are raster map independent because areas are saved using\n relative coordinates.\n Screenshots of the wizard window frames:\n    \n    \n      \n       \u00a0 \n        \n        \n        g.gui.rlisetup: First frame of wizard for selecting  \n          existing configuration files or creating a new one \n        \n      \n      \n       \u00a0 \n        \n        \n        g.gui.rlisetup: Frame for selecting maps \n        \n      \n    \n    \n      \n       \u00a0 \n        \n        \n        g.gui.rlisetup: Frame for inserting sampling areas \n        \n      \n      \n       \u00a0 \n        \n        \n        g.gui.rlisetup: Frame for defining rectangular moving window \n        \n      \n    \n    \n      \n       \u00a0 \n        \n        \n        g.gui.rlisetup: Frame for defining circular moving window \n        \n      \n      \n       \u00a0 \n        \n        \n        g.gui.rlisetup: Frame for choosing the sampling frame with keyboard \n        \n      \n    \n    \n      \n       \u00a0 \n        \n        \n        g.gui.rlisetup: Frame for drawing the sampling frame \n        \n      \n      \n       \u00a0 \n        \n        \n        g.gui.rlisetup: Summary frame before saving \n        \n      \n    \n    \n  EXAMPLES \n  Moving window analysis on full region \n  TODO: update examples to new g.gui.rlisetup dialog: \n Example for a 7x7 moving window analysis on full region, the output \n is a raster map:\n Click on \"New\", then:\n    Configuration file name: \"movwindow7\" \n    Raster map name to use to select areas: \"forests\" \n 1. Setup sampling frame:\n   Define a sampling frame (region for analysis): \"Whole map layer\", then \"OK\" \n 2. Setup sampling frame\n   Define sampling areas: \"Moving window\", then \"OK\" \n   Then click on \"Use keyboard to define moving window dimension\" \n Select type of shape:\n   [x] Rectangular \n   Width size (in cells)?: \"7\" \n   Height size (in cells)?: \"7\" \n   Then \"Save settings\" \n 3. Save settings: click on button\n (4.) Close\n Now an anaysis can be performed using one of the analytical modules, e.g.\n g.region raster=forests -p\n r.li.patchdensity input=forests conf=movwindow7 output=forests_p_dens7\n r.univar forests_p_dens7\n The result is the new raster map \"forests_p_dens7\" which shows (in this example)\n the patch density of the forest areas.\n See the respective modules for further examples.\n  Whole region analysis \n   \n Example for a whole region analysis, the output is a text file:\n Click on \"New\", then:\n    Configuration file name: \"whole_region\" \n    Raster map name to use to select areas: \"lsat7_2000_40\" \n 1. Setup sampling frame:\n   Define a sampling frame (region for analysis): \"Whole map layer\", then \"OK\" \n 2. Setup sampling frame\n   Define sampling areas: \"Whole map layer\", then \"OK\" \n 3. Save settings: click on button\n (4.) Close\n Now an anaysis can be performed using one of the analytical modules, e.g.\n g.region raster=lsat7_2002_40 -p\n r.li.shannon input=lsat7_2000_40 conf=whole_region output=lsat7_2000_40_shannon\n The result is the new text file \"forests_p_dens7\" (stored in folder  $HOME/.r.li/output/ .\n See the respective modules for further examples.\n ", "see_also": [ "r.li.daemon"], "authors": ["Luca Delucchi"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/rlisetup"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.psmap.html", "name": "g.gui.psmap", "definition": "- Tool for creating hardcopy map outputs.", "keywords": ["general", "GUI", "printing"], "synopsis": "g.gui.psmap  [file=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "File containing mapping instructions to load", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  wxGUI Cartographic Composer  also called  wx.psmap  is\n a  wxGUI  extension which allows the\n user to create interactively hardcopy map outputs. This tool\n generates  ps.map  configuration file\n and then runs  ps.map  to create\n PostScript output. There are two modes -  Draft mode  for map\n composing and  Preview mode \n (requires  Python\n Imaging Library ) to see how the result will look like. In draft\n mode map features (like legend or scalebar) are represented by a\n colored rectangle with a label.\n Possible output files:\n      ps.map  instructions file\n     PostScript/EPS file\n     PDF (using ps2pdf)\n Cartographic Composer enables to load in saved instructions file. It\n works better with files created by wx.psmap (more tested).\n Currently supported  ps.map  instructions:\n     paper\n     maploc\n     scale\n     border\n     raster\n     colortable\n     vpoints\n     vlines\n     vareas\n     vlegend\n     text\n     scalebar\n     mapinfo\n     point\n     line\n     rectangle\n     labels\n  CARTOGRAPHIC COMPOSER TOOLBAR \n    \u00a0\n      Generate instructions file \n    Generates and saves text file with mapping instructions. \n   \n    \u00a0\n      Load instructions file \n    Load text file with mapping instructions. \n   \n    \u00a0\n      Page setup \n    Specify paper size, margins and orientation. \n   \n    \u00a0\n      Pointer \n    Select object on the paper by clicking, drag the cursor while pressing the left mouse button to move it or resize object (currently only map frame) by clicking on a small black box in its bottom right corner. Double click to show object properties dialog \n     \n    \u00a0\n      Pan \n    Drag the pan cursor while pressing the left mouse button to move your view.  \n    \u00a0\n      Zoom in \n    Interactive zooming with the mouse in both draft and preview mode. Drawing a box or just a left click with the mouse and zoom-in cursor causes the display to zoom in so that the area defined by the box fills the display. \n    \u00a0\n      Zoom out \n    Interactive zooming with the mouse in both draft and preview mode. Drawing a box or just a left click with the mouse and zoom-out cursor causes the display to zoom out so that the area displayed shrinks to fill the area defined by the box. \n   \n    \u00a0\n      Zoom to page \n    Zoom to display the entire page  \n   \n   \n    \u00a0\n      Map frame \n    Click and drag to place map frame. If map frame is already drawn, open a dialog to set its properties.  \n   \n    \u00a0\n      Raster map \n    Shows a dialog to add or change the raster map. \n   \n    \u00a0\n      Vector map \n    Shows a dialog to add or change current vector maps and their properties:\n      \n        Data selection \n          Select data to draw:\n         \n          \n            Feature type \n               Select which data type to draw. In case of point data, points or centroids\n             can be drawn, in case of line data, lines or boundaries.  \n            Layer selection \n              Select layer and limit data by a SQL query or chose only certain categories. \n            Mask \n              Whether to use mask or not. \n           \n          \n       \n        Colors \n          Color settings:\n                 \n          \n            Outline \n               Select outline color and width in points. In case of lines, outline means highlighting. \n            Fill \n              Select fill color, one color for all vector elements or color from rgb column. \n           \n        \n        Size and style \n          \n         Sets size, style, symbols, pattern; depends on data type:\n         \n          \n            Symbology \n               Available for point data. Choose symbol or EPS file to draw points with. \n            Line style \n              Available for line data. Select line style (solid, dashed, ...) and the look of the ends of the line (butt, round, ...) \n            Pattern \n             Available for areas. Choose pattern file and set the width of the pattern. \n            Size \n             Available for point data. Choose size (number of times larger than the size in the icon file) as a single value or take the size from a map table column. \n            Rotation \n             Available for point data. Rotate symbols counterclockwise with the given value or with the value from a map table column \n            Width \n             Available for line data. Set line width in points or take the value from a map table column. \n           \n        \n   \n   \n      \n      \n   \n     \u00a0\n      Add overlays \n     Add overlays: vector labels, grid (not yet implemented)\n      \n        \u00a0\n          Add labels \n        Add vector labels created beforehand by v.label module. \n      \n     \n     \u00a0\n      Add map elements \n     Add map elements: legend, scalebar, map info, text \n      \n        \u00a0\n          Add legend \n        Add raster or vector legend or edit their properties. \n        \u00a0\n          Add map info \n        Add information about region, grid and scale or edit map info properties. \n        \u00a0\n          Add scalebar \n        Add scalebar or edit its properties. \n        \u00a0\n          Add text \n        Add text label.     \n      \n      \n    \u00a0\n      Remove selected element \n    Select an object and remove it. Pressing Delete key does the same.  \n   \n    \u00a0\n      Show preview \n     Generates output and switches to Preview mode to see the result. Be patient, it can take a while. \n   \n    \u00a0\n      Generate hardcopy map output in PS \n     Generates hardcopy map output in PostScript/EPS file. \n     \u00a0\n      Generate hardcopy map output in PDF \n     Generates hardcopy map output in PDF using ps2pdf. \n   \n ", "notes": "", "see_also": ["wxGUI", "wxGUI components"], "authors": ["Anna Kratochvilova, Czech Technical Univesity in Prague, Czech Republic (bachelor's final project 2011, mentor: Martin Landa)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/psmap"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.photo2image.html", "name": "g.gui.photo2image", "definition": "- Corrects scanning distortions of a paper photo.", "keywords": ["imagery", "aerial", "photo", "GUI"], "synopsis": "g.gui.photo2image group=name raster=name camera=string order=string extension=string  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "camera", "flag": "camera", "dataType": "String", "optional": false, "explanation": "The name of the camera (generated in i.ortho.camera)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": false, "explanation": "The rectification order (no of Fiducial=4 -> order=1, no of Fiducial=8 -> order=2)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "extension", "flag": "extension", "dataType": "String", "optional": false, "explanation": "The name of the output files extension (used in i.rectify)", "defaultValue": "_ip2i_out", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This module is based on  g.gui.gcp , the GCP manager of GRASS GIS.\n It is part of i.ortho.photo suite.\n The aim of this module is to give absolute location values to the fiducial \n points present (in number of 4 or 8) in a  scanned  aerial photo. \n This is necessary as (manual) scanning introduces distortions, rotations and also \n may not be limited to scan the boundary of the photo itself. It is thus necessary\n to give to each fiducial the exact coordinates in mm as given by the aerial \n photographic instrument design, which is unique per camera.\n This module requires you to have made a group with your aerial photo  (i.group) , a camera\n description file  (i.ortho.target)  and use them to launch the module. Additional requirements\n are the order of rectification (1 if no of Fiducials is 4, 2 if no of Fiducials is 8) and \n an extension file (if not given, defaults to \\$filename_ip2i_out)\n An example for Location  imagery60 :\n g.gui.photo2image group=aerial@PERMANENT raster=gs13.1@PERMANENT camera=gscamera order=2 extension=try --o\n  Screenshot of g.gui.photo2image \n  \n  Figure: Screenshot of g.gui.photo2image \n  For a detailed operation manual please read \n  wxGUI \n  wxGUI components \n See also  video\n tutorials  on GRASS Wiki.\n ", "notes": "", "see_also": ["i.ortho.photo", "i.group", "i.ortho.camera", "i.ortho.target", "i.rectify", "m.transform", "v.rectify"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/photo2image"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.mapswipe.html", "name": "g.gui.mapswipe", "definition": "- Interactively compares two maps by swiping a visibility bar.", "keywords": ["general", "GUI", "display"], "synopsis": "g.gui.mapswipe  [first=name]   [second=name]   [mode=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "first", "flag": "first", "dataType": "String", "optional": true, "explanation": "First (top/right) raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "second", "flag": "second", "dataType": "String", "optional": true, "explanation": "Second (bottom/left) raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mode", "flag": "mode", "dataType": "String", "optional": true, "explanation": "View mode", "defaultValue": "swipe", "alternatives": ["swipe", "mirror"], "isInputFile": false, "isOutputFile": false}], "description": "\n The  Map Swipe  is a  wxGUI  component\n which allows the user to interactively compare two raster maps of the same\n area by revealing different parts of the raster maps.\n It is useful e.g. for comparing raster maps from different time periods.\n Map Swipe can be launched from the menu  File -> Map Swipe .\n Map Swipe allows you to:\n    switch orientation of the swipe line (horizontal or vertical) \n    zooming, panning \n    automatically load maps when opening Map Swipe with two selected raster maps in Layer Manager \n    compare 2 raster maps or load different combinations of raster\n       and vector maps and set transparency (advanced mode) \n    save display to graphics file \n    display text labels with map names \n    choose between 'swipe' mode (default) and 'mirror' mode (synchronized maps displayed side by side)  \n    change the appearance of cursor in 'mirror' mode (available in Map Swipe settings) \n Pre and post disaster images of the tsunami in Japan in 2011. The upper MODIS image\n taken on February 26, 2011, shows the coastline under normal conditions while the lower\n MODIS image on March 13, 2011, shows a clear view of tsunami flooding along the coastline.\n Water, black and dark blue in these false-color images, still covers the ground as much\n as five kilometers (three miles) from the coast.\n Source:  Earth Observatory/NASA \n ", "notes": "", "see_also": ["wxGUI", "wxGUI components"], "authors": ["Anna Kratochvilova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/mapswipe"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.image2target.html", "name": "g.gui.image2target", "definition": "- Georectifies a map and allows managing Ground Control Points for 3D correction.", "keywords": ["imagery", "aerial", "photo", "georectification", "GCP", "GUI"], "synopsis": "g.gui.image2target  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "\n The  GCP Manager  is a  wxGUI \n extension which allows the user to create, edit, and manage\n Ground Control Points. It is available from the menu\n \"File | Manage Ground Control Points\".\n The  GCP Manager  provides an interactive graphical interface to\n manage and analyze Ground Control Points. A backup copy of the initial\n POINTS file is always maintained and updated only on request (Save GCPs\n to POINTS file). This guarantees that accidental changes are not\n permanent and can be undone by reloading the Ground Control Points.\n The GCP Manager must be started in the target location, not in the\n source location.\n The GCP Manager is structured into three panels:\n    The topmost panel shows a list of Ground Control Points. Tools to\n   manipulate and analyze GCPs are provided in the toolbar. This panel can\n   be moved out of the GCP manager window by either dragging with the\n   caption or by clicking on the pin button on the right in the caption.\n   This panel can also be placed below the map displays by dragging.\n    The two panels in the lower part are used for map and GCP display,\n   the left pane showing a map from the source location and the right\n   pane showing a reference map from the target location. Numbered Ground\n   Control Points are shown on both map displays.\n  Components of the GCP Manager \n    \n  Toolbars \n Two toolbars are provided with the GCP Manager, one for managing the map\n displays and one for managing the GCP list.\n  List of ground control points \n The list of Ground Control Points can be sorted by clicking on a column \n header. Clicking on a cloumn header will sort the GCPs ascending, a\n second click on the same column will sort the GCPs descending. Overall\n RMS error and individual RMS errors of all points are often improved if\n the GCP with the highest RMS error is adjusted. Individual coordinates\n can be edited by double-clicking on a row.\n The first column holds a checkbox and displays the point number. A GCP\n is only used for RMS error calculation and georectification if its\n checkbox on the left is checked. Uncheck to deactivate a GCP (mark as\n unused GCP).\n  Two panels for map display \n The left panel is used to display a map from the source location, the\n right panel to display a map from the target loaction. Zooming in and\n out is always possible with the mouse wheel and done for each map canvas\n separately.\n GCPs are displayed in different colors, depending on whether a GCP has\n a high RMS error, is currently unused or is currently selected. Optionally,\n currently unused GCPs are not shown on the map display.\n  Statusbar \n At the bottom of the GCP Manager is a statusbar providing several\n functions. The default is set to  Go to GCP No.  (see also below).\n Typing a number or using the up/down arrows will center the maps on the\n given GCP, useful with a high zoom.\n  GCP Map Display Toolbar \n  \u00a0\n    Display map \n  Displays maps for source and target canvas and re-renders any layers\n that have changed since the last time the display was updated. \n  \u00a0\n    Re-render map \n  Re-renders both source and target canvas regardless of whether they\n have changed or not. \n  \u00a0\n    Erase display \n  Erases both source and target canvas to a white background. \n  \u00a0\n    Define GCP (Ground Control Points) \n  On left mouse click, coordinates are defined for the currently\n selected GCP. \n  \u00a0\n    Pan \n  Interactive selection of a new center of view in the active\n display monitor. Drag the pan cursor while pressing the left mouse\n button to pan. Alternatively left-click on the new center. Panning\n changes the location of the region displayed but not the size of the\n area displayed or the resolution. \n  \u00a0\n    Zoom in \n  Interactive zooming with the mouse in the active map canvas (source \n or target). Drawing a box or just a left click with the mouse and zoom-in\n cursor causes the display to zoom in so that the area defined by the box\n fills the display. The map resolution is not changed. Clicking with the\n zoom-in cursor causes the display to zoom in by 30%, centered on the\n point where the mouse is clicked. Zooming changes the display region\n extents (both size and location of area displayed). \n  \u00a0\n    Zoom out \n  Interactive zooming with the mouse in the active map canvas (source \n or target). Drawing a box or just a left click with the mouse and zoom-out\n cursor causes the display to zoom out so that the area displayed\n shrinks to fill the area defined by the box. The map resolution is not\n changed. Clicking with the zoom-out cursor causes the display to zoom\n out by 30%, centered on the point where the mouse is clicked. Zooming\n changes the display region extents (both size and location of area\n displayed). \n  \u00a0\n    Adjust display zoom \n  Source and target display are adjusted by using the current GCPs for\n coordinate transformation:\n    \n      Adjust source display to target display \n      The extents of the source display are adjusted to the current\n     extents of the target display.\n      Adjust target display to source display \n      The extents of the source display are adjusted to the current\n     extents of the target display.\n    \n  Set active map canvas \n  Sets the currently active map canvas (source or target). Click \n to set active map canvas for  Return to previous zoom  or \n  Zoom to extent of currently displayed map . Alternatively, move\n the mouse over the map canvas to be used as active canvas. \n  \u00a0\n    Return to previous zoom \n  Returns to the previous zoom extent. Up to 10 levels of zoom back are\n maintained. \n  \u00a0\n  Zoom to extent of currently displayed map \n  Zoom to the extent of the currently displayed map in the active map\n canvas (source or target). \n  \u00a0\n  Settings \n  Shows a settings dialog for GCP management and display:  \n    \n      Symbology \n        Settings for map and GCP display: \n        \n          Highlight highest RMS error only \n            Only the GCP with the highest RMS error will be displayed in\n           a different colour, both in the list of GCPs and the GCP Map Display.\n          Factor for RMS error threshold = M + SD * factor: \n            All GCPs with an RMS error larger than mean RMS + RMS standard\n           deviation * this factor will be displayed in a different colour,\n           both in the list of GCPs and the GCP Map Display. As a rule of\n           thumb, GCPs with an RMS error larger than  M + SD * 2  are\n           most probably wrong. GCPs with an RMS error larger than\n            M + SD * 1  are worth closer inspection. This option is\n           only available if  Highlight highest RMS error only  is\n           unchecked. \n          Color \n            Set the color for GCPs on the GCP Map Display. \n          Color for high RMS error \n            Set the color for GCPs with a high RMS error on the GCP Map\n           Display. \n          Color for selected GCP \n            Set the color for the currently selected GCP on the GCP Map\n           Display. \n          Show unused GCPs \n            If unchecked, unused GCPs will not be shown on the GCP Map\n           Display. \n          Color for unused GCPs \n            Set the color for unused GCPs on the GCP Map Display. \n          Symbol size \n            Set the symbol size for GCPs on the GCP Map Display. \n          Line width \n            Set the line width for GCPs on the GCP Map Display. \n          Select source map to display \n            Select a source map for the left pane of the GCP Map Display. \n          Select target map to display \n            Select a target map for the right pane of the GCP Map Display. \n        \n        \n      Rectification \n        Settings for georectification: \n        \n          Select rectification method \n            Set the polynomial order for georectification. This order will\n           also be used for RMS error calculation. \n          Clip to computational region in target location \n            Clip raster maps to the current computational region in the\n           target location when georectifying. \n          Extension for output maps \n            Change the extension for output map names when doing the actual\n           georectification. \n        \n        \n    \n  \u00a0\n  Show Help \n  Show help page for the GCP Manager.\n  \u00a0\n  Quit \n  Quit the GCP Manager.\n  Toolbar for the GCP list \n  \u00a0\n  Save GCPs to POINTS file \n  The current list of GCPs is saved to the imagery group's POINTS file\n and to a backup copy. \n  \u00a0\n  Add new GCP \n  Adds a new Ground Control Point to the list and selects it for editing. \n  \u00a0\n  Delete selected GCP \n  Deletes the currently selected GCP from the list. \n  \u00a0\n  Clear selected GCP \n  Resets all coordinates of the currently selected GCP to 0 (zero). \n  \u00a0\n  Reload GCPs from POINTS file \n  Reloads GCPs from the imagery group's POINTS file. \n  \u00a0\n  Recalculate RMS error \n  Recalculates forward and backward RMS error for all GCP marked for\n use (activated checkbox in first row).\n  \u00a0\n  Georectify \n  Uses  i.rectify  to georectify\n all images in the source imagery group.\n  GCP Map Display Statusbar \n The GCP map display statusbar is similar to the statusbar in the regular\n GRASS GIS map display with two differences,  Go to  has been\n replaced with  Go to GCP No.  and  Projection  has been\n replaced with  RMS error .\n If  Go to GCP No.  is selected, a GCP number can be given in the\n left side of the statusbar and the source and target map canvas will be\n centered on the given GCP. Clicking on the map canvas will update\n coordinates for this GCP.\n If  RMS error  is selected, the overall forward and backward RMS\n error is displayed.\n ", "notes": "", "see_also": ["wxGUI", "wxGUI components"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/image2target"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.iclass.html", "name": "g.gui.iclass", "definition": "- Tool for supervised classification of imagery data.", "keywords": ["general", "GUI", "classification", "supervised classification", "signatures"], "synopsis": "g.gui.iclass [-m]  [group=name]   [subgroup=name]   [map=name]   [trainingmap=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Maximize window Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": true, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "subgroup", "flag": "subgroup", "dataType": "String", "optional": true, "explanation": "Name of input imagery subgroup", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": true, "explanation": "Name of raster map to load", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "trainingmap", "flag": "trainingmap", "dataType": "String", "optional": true, "explanation": "Ground truth training map to load", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  Supervised Classification Tool  (wxIClass) is\n a  wxGUI  compoment which allows the\n user to create training areas and generate spectral signatures.  The\n resulting signature file can be used as input for\n  i.maxlik \n or as a seed signature file for\n  i.cluster .\n  WxIClass  can be launched from the Layer Manager\n menu  Imagery \u2192 Classify image \u2192 Interactive input for\n supervised classification  or via command line\n as  g.gui.iclass .\n  wxIClass  currently allows you to:\n    create training areas\n   (using customized  vector\n   digitizer ) \n    show histograms for each band and class (category) \n    show coincidence plots for each band \n    show raster cells that match training areas\n    (within the number of standard deviations specified) \n    specify color of class \n    write signature file \n    import vector map \n    export vector map with attribute table \n  wxIClass  performs the first pass in the GRASS two-pass supervised image\n classification process; the GRASS module\n  i.maxlik  executes the second pass.\n Both programs must be run to generate a classified map in GRASS\n raster format.\n  wxIClass  is an interactive program that allows the user to create\n multiple training areas for multiple classes and calculate the spectral\n signatures based on the cells that are within the training areas.\n During this process the user will be\n shown histograms for each image band.\n The user can also display the cells of the image bands which fall within\n a user-specified number of standard deviations from the means in the spectral signature.\n By doing this, the user can see how much of the image\n is likely to be put into the class associated with the signature.\n The spectral signatures are composed of region means and covariance matrices.\n These region means and covariance matrices are used in\n the second pass ( i.maxlik )\n to classify the image.\n Alternatively, the spectral signatures generated by  wxIClass  can be\n used for seed means for the clusters in\n  i.cluster .\n ", "notes": "", "see_also": ["wxGUI", "wxGUI components", "Interactive Scatter Plot Tool"], "authors": ["Anna Kratochvilova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/gui/wxpython/iclass"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.gui.html", "name": "g.gui", "definition": "- Launches a GRASS graphical user interface (GUI) session.", "keywords": ["general", "GUI", "user interface"], "synopsis": "g.gui [-fdn]  [ui=string]   [workspace=name.gxw]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Start GUI in the foreground By default the GUI starts in the background and control is immediately returned to the caller. When GUI runs in foregreound, it blocks the command line Update default user interface settings Do not launch GUI after updating the default user interface settings Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Update default user interface settings Do not launch GUI after updating the default user interface settings Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Do not launch GUI after updating the default user interface settings Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "ui", "flag": "ui", "dataType": "String", "optional": true, "explanation": "User interface", "defaultValue": "wxpython", "alternatives": ["wxpython", "text", "gtext"], "isInputFile": false, "isOutputFile": false}, {"parameter": "workspace", "flag": "workspace", "dataType": "String", "optional": true, "explanation": "Name of workspace file to load on start-up", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  g.gui  module allows user to start the Graphical User \n Interface (GUI) from the command line prompt or to change the \n default User Interface (UI) settings.\n GRASS GIS 7 comes with both a wxPython-based GUI\n aka  wxGUI  ( ui=wxpython ) and\n command line text-based UI ( ui=text ).\n ", "notes": "\n If the  -d  update flag is given or the  GRASS_GUI  \n environmental  variable  is unset, then \n the GRASS internal variable  GUI  is permanently changed and \n the selected  ui  will be used as the default UI from then on.\n All GRASS internal variables (see  g.gisenv )\n are stored in the user's home directory in a hidden file called\n  $HOME/.grass7/rc  on Unix-based operating systems\n and  %APPDATA%\\GRASS7\\rc  on MS Windows. Note that these GRASS\n internal variables are not the shell environment variables and the\n  rc  file is not a classic UNIX run command file, it just\n contains persistent GRASS variables.\n The\n old  gis.m \n and  d.m \n Tcl/Tk-based GUIs known from GRASS GIS 6 have been dropped in GRASS\n GIS 7.\n  EXAMPLES \n Set default user interface setting to command line, text-based UI:\n g.gui -d ui=text\n Set default user interface setting to the graphical user interface\n (GUI) and  launch  the GUI:\n g.gui -d ui=wxpython\n Set default user interface setting to the graphical user interface\n (GUI) but  do not launch  the GUI:\n g.gui -dn ui=wxpython\n ", "see_also": ["wxGUI", "g.gisenv", "GRASS variables"], "authors": ["Martin Landa, FBK-irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.gui"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.colors.enhance.html", "name": "i.colors.enhance", "definition": "- Performs auto-balancing of colors for RGB images.", "keywords": ["imagery", "RGB", "satellite", "colors"], "synopsis": "i.colors.enhance [-fprs] red=name green=name blue=name  [strength=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Extend colors to full range of data on each channel Preserve relative colors, adjust brightness only Reset to standard color range Process bands serially (default: run in parallel) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Preserve relative colors, adjust brightness only Reset to standard color range Process bands serially (default: run in parallel) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Reset to standard color range Process bands serially (default: run in parallel) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Process bands serially (default: run in parallel) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": false, "explanation": "Name of red channel", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": false, "explanation": "Name of green channel", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": false, "explanation": "Name of blue channel", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "strength", "flag": "strength", "dataType": "String", "optional": true, "explanation": "Cropping intensity (upper brightness level)", "defaultValue": "98", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.colors.enhance  auto-balances and enhances the color channels of a\n RGB image (e.g. from Landsat) to provide a more natural color mixture. Only\n the color table of each image band is modified, the base data remains untouched.\n The module works by calculating a histogram for each color channel and \n removing an adjustable amount of outliers from either end before recalibrating\n the color scale with  r.colors .\n It will work with any 8-bit RGB imagery set and the script is easily modified\n to work with other datasets of greater band-depth.\n ", "notes": "\n Depending on the image, it may or may not be advantageous to use the  -p \n flag to preserve the relative color scaling. You will have to experiment\n with the different options to find a setting that works best for your\n particular imagery.\n The  strength  option should generally be set in the 90-99 range. The\n lower the number, the more saturated the image becomes. It represents the\n percentage cut-off for the top end of the color histogram curve. The lower\n end is fixed at 2% of the area under the curve.\n For quicker execution of this module on large images you can achieve largely\n similar results by switching to a coarser resolution before the running of\n the module (using  g.region ) and then back to the original resolution\n afterwards.\n  EXAMPLE \n North Carolina sample dataset example with Landsat data:\n g.region raster=lsat7_2002_10 -p\n d.rgb blue=lsat7_2002_10 green=lsat7_2002_20 red=lsat7_2002_30\n d.barscale at=55.3125,93.125 bcolor=white text_pos=over\n i.colors.enhance blue=lsat7_2002_10 green=lsat7_2002_20 red=lsat7_2002_30 strength=95\n d.rgb blue=lsat7_2002_10 green=lsat7_2002_20 red=lsat7_2002_30\n d.barscale at=55.3125,93.125 bcolor=white text_pos=over\n Uncorrected RGB composite of Landsat ETM channels B/G/R\n Color corrected RGB composite of Landsat ETM channels B/G/R\n  TODO \n The  strength  option requires further refinement.\n ", "see_also": ["d.rgb", "g.region", "i.oif", "r.colors", "r.composite", "r.univar"], "authors": ["Markus Neteler, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/i.colors.enhance"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.cluster.html", "name": "i.cluster", "definition": "- Generates spectral signatures for land cover types in an image using a clustering algorithm.", "keywords": ["imagery", "classification", "signatures"], "synopsis": "i.cluster group=name subgroup=name signaturefile=name classes=integer  [seed=name]   [sample=row_interval,col_interval]   [iterations=integer]   [convergence=float]   [separation=float]   [min_size=integer]   [reportfile=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "subgroup", "flag": "subgroup", "dataType": "String", "optional": false, "explanation": "Name of input imagery subgroup", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "signaturefile", "flag": "signaturefile", "dataType": "String", "optional": false, "explanation": "Name for output file containing result signatures", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "classes", "flag": "classes", "dataType": "String", "optional": false, "explanation": "Initial number of classes", "defaultValue": null, "alternatives": ["1-255"], "isInputFile": false, "isOutputFile": false}, {"parameter": "seed", "flag": "seed", "dataType": "String", "optional": true, "explanation": "Name of file containing initial signatures", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sample", "flag": "sample", "dataType": "String", "optional": true, "explanation": "Sampling intervals (by row and col); default: ~10,000 pixels", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "iterations", "flag": "iterations", "dataType": "String", "optional": true, "explanation": "Maximum number of iterations", "defaultValue": "30", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "convergence", "flag": "convergence", "dataType": "String", "optional": true, "explanation": "Percent convergence", "defaultValue": "98.0", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separation", "flag": "separation", "dataType": "String", "optional": true, "explanation": "Cluster separation", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "min_size", "flag": "min_size", "dataType": "String", "optional": true, "explanation": "Minimum number of pixels in a class", "defaultValue": "17", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "reportfile", "flag": "reportfile", "dataType": "String", "optional": true, "explanation": "Name for output file containing final report", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.cluster  performs the first pass in the two-pass\n unsupervised classification of imagery, while the GRASS module  \n  i.maxlik  executes the second pass.\n Both commands must be run to complete the unsupervised classification.\n  i.cluster  is a clustering algorithm (a modification of the\n  k -means clustering algorithm) that reads through the (raster) imagery\n data and builds pixel clusters based on the spectral reflectances of the\n pixels (see Figure).\n The pixel clusters are imagery categories that can be related\n to land cover types on the ground. The spectral distributions of the\n clusters (e.g., land cover spectral signatures) are influenced by six\n parameters set by the user. A relevant parameter set by the user is the\n initial number of clusters to be discriminated.\n  Fig.: Land use/land cover clustering of LANDSAT scene (simplified) \n  \n  i.cluster  starts by generating spectral signatures\n for this number of clusters and \"attempts\" to end up with\n this number of clusters during the clustering process.  The\n resulting number of clusters and their spectral\n distributions, however, are also influenced by the range of\n the spectral values (category values) in the image files\n and the other parameters set by the user.  These parameters\n are:  the minimum cluster size, minimum cluster separation,\n the percent convergence, the maximum number of iterations,\n and the row and column sampling intervals.\n The cluster spectral signatures that result are composed of\n cluster means and covariance matrices.  These cluster means\n and covariance matrices are used in the second pass \n ( i.maxlik ) to\n classify the image.  The clusters or spectral classes\n result can be related to land cover types on the ground.\n The user has to specify the name of group file, the name of subgroup\n file, the name of a file to contain result signatures, the\n initial number of clusters to be discriminated, and\n optionally other parameters (see below)\n where the  group  should contain the imagery files\n that the user wishes to classify.  The  subgroup  is\n a subset of this group.  The user must create a group and\n subgroup by running the GRASS program\n  i.group  \n before running  i.cluster .  The subgroup should\n contain only the imagery band files that the user wishes to\n classify.  Note that this subgroup must contain more than\n one band file.  The purpose of the group and subgroup is to\n collect map layers for classification or analysis. The\n  signaturefile  is the file to contain result signatures\n which can be used as input for\n  i.maxlik . \n The classes value is the initial number of clusters to be\n discriminated; any parameter values left unspecified are\n set to their default values.\n  Parameters: \n  group= name  \n  The name of the group file which contains the imagery\n files that the user wishes to classify.\n  subgroup= name  \n  The name of the subset of the group specified in group\n option, which must contain only imagery band files and more\n than one band file. The user must create a group and a\n subgroup by running the GRASS program \n  i.group  \n before\n running  i.cluster .\n  signaturefile= name  \n  The name assigned to output signature file which\n contains signatures of classes and can be used as the input\n file for the GRASS program \n  i.maxlik  \n for an unsupervised classification.\n  classes= value  \n  The number of clusters that will initially be\n identified in the clustering process before the iterations\n begin.\n  seed= name  \n  The name of a seed signature file is optional. The seed\n signatures are signatures that contain cluster means and\n covariance matrices which were calculated prior to the\n current run of  i.cluster . They may be acquired\n from a previously run of  i.cluster  or from a\n supervised classification signature training site section\n (e.g., using the signature file output by\n  g.gui.iclass ). \n The purpose of seed signatures is to optimize the cluster\n decision boundaries (means) for the number of clusters\n specified.\n  sample= row_interval,col_interval  \n  These numbers are optional with default values based on\n the size of the data set such that the total pixels to be\n processed is approximately 10,000 (consider round up).\n  iterations= value  \n  This parameter determines the maximum number of\n iterations which is greater than the number of iterations\n predicted to achieve the optimum percent convergence. The\n default value is 30. If the number of iterations reaches\n the maximum designated by the user; the user may want to\n rerun  i.cluster  with a higher number of iterations\n (see  reportfile ).\n Default: 30\n  convergence= value \n  A high percent convergence is the point at which\n cluster means become stable during the iteration process.\n The default value is 98.0 percent.  When clusters are being\n created, their means constantly change as pixels are\n assigned to them and the means are recalculated to include\n the new pixel.  After all clusters have been created,\n  i.cluster  begins iterations that change cluster\n means by maximizing the distances between them.  As these\n means shift, a higher and higher convergence is\n approached.  Because means will never become totally\n static, a percent convergence and a maximum number of\n iterations are supplied to stop the iterative process.  The\n percent convergence should be reached before the maximum\n number of iterations. If the maximum number of iterations\n is reached, it is probable that the desired percent\n convergence was not reached. The number of iterations is\n reported in the cluster statistics in the report file\n (see  reportfile ).\n Default: 98.0\n  separation= value  \n  This is the minimum separation below which clusters\n will be merged in the iteration process. The default value\n is 0.0. This is an image-specific number (a \"magic\" number)\n that depends on the image data being classified and the\n number of final clusters that are acceptable. Its\n determination requires experimentation. Note that as the\n minimum class (or cluster) separation is increased, the\n maximum number of iterations should also be increased to\n achieve this separation with a high percentage of\n convergence\n (see  convergence ).\n Default: 0.0\n  min_size= value  \n  This is the minimum number of pixels that will be used\n to define a cluster, and is therefore the minimum number of\n pixels for which means and covariance matrices will be\n calculated.\n Default: 17\n  reportfile= name \n  The reportfile is an optional parameter which contains\n the result, i.e., the statistics for each cluster. Also\n included are the resulting percent convergence for the\n clusters, the number of iterations that was required to\n achieve the convergence, and the separability matrix.\n ", "notes": "\n  Sampling method \n  i.cluster  does not cluster all pixels, but only a sample (see\n parameter  sample ). The result of that clustering is not that all\n pixels are assigned to a given cluster; essentially, only signatures which are\n representative of a given cluster are generated. When running  i.cluster \n on the same data asking for the same number of classes, but with different\n sample sizes, likely slightly different signatures for each cluster are\n obtained at each run.\n  Algorithm used for i.cluster \n The algorithm uses input parameters set by the user on the\n initial number of clusters, the minimum distance between clusters, and the\n correspondence between iterations which is desired, and minimum size for\n each cluster. It also asks if all pixels to be clustered, or every \"x\"th row\n and \"y\"th column (sampling), the correspondence between iterations\n desired, and the maximum number of iterations to be carried out.\n In the 1st pass, initial cluster means for each band are defined by giving\n the first cluster a value equal to the band mean minus its standard\n deviation, and the last cluster a value equal to the band mean plus its\n standard deviation, with all other cluster means distributed equally\n spaced in between these. Each pixel is then assigned to the class which it\n is closest to, distance being measured as Euclidean distance. All clusters\n less than the user-specified minimum distance are then merged. If a\n cluster has less than the user-specified minimum number of pixels, all those\n pixels are again reassigned to the next nearest cluster. New cluster means\n are calculated for each band as the average of raster pixel values in that\n band for all pixels present in that cluster.\n In the 2nd pass, pixels are then again reassigned to clusters based on new\n cluster means. The cluster means are then again recalculated.  This\n process is repeated until the correspondence between iterations reaches a\n user-specified level, or till the maximum number of iterations specified is\n over, whichever comes first.\n  EXAMPLE \n Preparing the statistics for unsupervised classification of\n a LANDSAT subscene in North Carolina:\n g.region raster=lsat7_2002_10 -p\n # store VIZ, NIR, MIR into group/subgroup (leaving out TIR)\n i.group group=lsat7_2002 subgroup=lsat7_2002 \n    input=lsat7_2002_10,lsat7_2002_20,lsat7_2002_30,lsat7_2002_40,lsat7_2002_50,lsat7_2002_70\n # generate signature file and report\n i.cluster group=lsat7_2002 subgroup=lsat7_2002 \n    signaturefile=sig_cluster_lsat2002 \n    classes=10 reportfile=rep_clust_lsat2002.txt\n To complete the unsupervised classification,  i.maxlik  is subsequently used.\n See example in its manual page.\n ", "see_also": [], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.cluster"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.cca.html", "name": "i.cca", "definition": "- Canonical components analysis (CCA) program for image processing.", "keywords": ["imagery", "statistics", "CCA", "canonical components analysis"], "synopsis": "i.cca group=name subgroup=name signature=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "subgroup", "flag": "subgroup", "dataType": "String", "optional": false, "explanation": "Name of input imagery subgroup", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "signature", "flag": "signature", "dataType": "String", "optional": false, "explanation": "File containing spectral signatures", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output raster map prefix name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.cca  is an image processing program that takes any number of\n (raster) band files and a signature file, and outputs the same number of\n raster band files transformed to provide maximum separability of the\n categories indicated by the signatures.  This implementation of the\n canonical components transformation is based on the algorithm contained in\n the  LAS image\n processing system . CCA is also known as \"Canonical components\n transformation\".\n Typically the user will use the \n  g.gui.iclass \n program to collect a set of signatures and then pass those\n signatures along with the raster band files to\n  i.cca .  The raster band file names are specified\n on the command line by giving the group and subgroup that\n were used to collect the signatures.\n The output raster map names are built by appending a \".1\",\n \".2\", etc. to the output raster map name specified on the\n command line.\n  Parameters: \n  group= name  \n  Name of the  imagery  group\n to which the raster band files used belong.\n  subgroup= name  \n  Name of the  imagery \n subgroup to which the raster band files used\n belong.\n  signature= name  \n  Name of an ASCII file containing spectral signatures.\n  output= name  \n  Output raster map prefix name.  The output raster map\n layer names are built by appending a \".1\", \".2\", etc. onto\n the  output  name specified by the user.\n ", "notes": "\n  i.cca  respects the current geographic region definition\n and the current mask setting while performing the transformation.\n ", "see_also": ["g.gui.iclass", "i.pca", "r.covar", "r.mapcalc"], "authors": ["David Satnik, GIS Laboratory, Central Washington University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.cca"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.biomass.html", "name": "i.biomass", "definition": "- Computes biomass growth, precursor of crop yield calculation.", "keywords": ["imagery", "biomass", "FPAR", "yield"], "synopsis": "i.biomass fpar=name lightuse_efficiency=name latitude=name dayofyear=name transmissivity_singleway=name water_availability=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "fpar", "flag": "fpar", "dataType": "String", "optional": false, "explanation": "Name of fPAR raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lightuse_efficiency", "flag": "lightuse_efficiency", "dataType": "String", "optional": false, "explanation": "Name of light use efficiency raster map (UZB:cotton=1.9)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "latitude", "flag": "latitude", "dataType": "String", "optional": false, "explanation": "Name of degree latitude raster map [dd.ddd]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dayofyear", "flag": "dayofyear", "dataType": "String", "optional": false, "explanation": "Name of Day of Year raster map [1-366]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "transmissivity_singleway", "flag": "transmissivity_singleway", "dataType": "String", "optional": false, "explanation": "Name of single-way transmissivity raster map [0.0-1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "water_availability", "flag": "water_availability", "dataType": "String", "optional": false, "explanation": "Value of water availability raster map [0.0-1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output daily biomass growth raster map [kg/ha/d]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.biomass  calculates the biomass growth for a day after [1][2]. \n Input:\n   fPAR, the modified Photosynthetic Active Radiation for crops.\n   Light Use Efficiency [0.0-1.0], in Uzbekistan cotton is at 1.9 most of the time.\n   Latitude [0.0-90.0], from  r.latlong .\n   DOY [1-366].\n   Transmissivity of the atmosphere single-way [0.0-1.0], mostly around 0.7+ in clear sky.\n   Water availability [0.0-1.0], possibly using direct output from  i.eb.evapfr .\n ", "notes": "\n  i.biomass  can use the output of  i.eb.evapfr  directly\n as water availability input.\n  TODO \n Remove Latitude, DOY and Tsw from input and replace with a raster \n input compatible with  r.sun  output.\n ", "see_also": ["i.eb.evapfr", "r.latlong", "r.sun"], "authors": ["Yann Chemin, Bec de Mortagne, France"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.biomass"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.atcorr.html", "name": "i.atcorr", "definition": "- Performs atmospheric correction using the 6S algorithm.", "keywords": ["imagery", "atmospheric correction", "radiometric conversion", "radiance", "reflectance", "satellite"], "synopsis": "i.atcorr [-irab] input=name  [range=min,max]   [elevation=name]   [visibility=name]  parameters=name output=name  [rescale=min,max]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Output raster map as integer Input raster map converted to reflectance (default is radiance) Input from ETM+ image taken after July 1, 2000 Input from ETM+ image taken before July 1, 2000 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Input raster map converted to reflectance (default is radiance) Input from ETM+ image taken after July 1, 2000 Input from ETM+ image taken before July 1, 2000 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Input from ETM+ image taken after July 1, 2000 Input from ETM+ image taken before July 1, 2000 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Input from ETM+ image taken before July 1, 2000 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "range", "flag": "range", "dataType": "String", "optional": true, "explanation": "Input range", "defaultValue": "0,255", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Name of input elevation raster map (in m)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "visibility", "flag": "visibility", "dataType": "String", "optional": true, "explanation": "Name of input visibility raster map (in km)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "parameters", "flag": "parameters", "dataType": "String", "optional": false, "explanation": "Name of input text file with 6S parameters", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "rescale", "flag": "rescale", "dataType": "String", "optional": true, "explanation": "Rescale output raster map", "defaultValue": "0,255", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  i.atcorr  performs atmospheric correction on the input raster\n map using the 6S algorithm ( Second Simulation of Satellite Signal\n in the Solar Spectrum ). A detailed algorithm description is\n available at the\n  Land Surface\n Reflectance Science Computing Facility website .\n  Important: Current region settings are ignored!  The \n region is adjusted to cover the input raster map before the atmospheric \n correction is performed. The previous settings are restored afterwards.\n  If the  -r  flag is used, the input raster map is treated as\n  reflectance . Otherwise, the input raster map is treated\n as  radiance  values and it is converted to reflectance at\n the  i.atcorr  runtime. The output data are always reflectance.\n  The satellite overpass time has to be specified in Greenwich\n Mean Time (GMT).\n  An example of the 6S parameters could be:\n 8                            - geometrical conditions=Landsat ETM+\n 2 19 13.00 -47.410 -20.234   - month day hh.ddd longitude latitude (\"hh.ddd\" is in decimal hours GMT)\n 1                            - atmospheric model=tropical\n 1                            - aerosols model=continental\n 15                           - visibility [km] (aerosol model concentration)\n -0.600                       - mean target elevation above sea level [km] (here 600 m asl)\n -1000                        - sensor height (here, sensor on board a satellite)\n 64                           - 4th band of ETM+ Landsat 7\n If the position is not available in longitude-latitude (WGS84), the\n  m.proj  conversion module can be\n used to reproject from a different reference system.\n  6S CODE PARAMETER CHOICES \n  A. Geometrical conditions \n  Code \n  Description \n  Details \n  1 \n  meteosat  observation \n  enter month,day,decimal hour (universal time-hh.ddd)\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n n. of column,n. of line. (full scale 5000*2500)\u00a0 \n  2 \n  goes east  observation \n  enter month,day,decimal hour (universal time-hh.ddd)\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n n. of column,n. of line. (full scale 17000*12000)c \n  3 \n  goes west  observation \n  enter month,day,decimal hour (universal time-hh.ddd)\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n n. of column,n. of line. (full scale 17000*12000) \n  4 \n  avhrr  (PM noaa) \n  enter month,day,decimal hour (universal time-hh.ddd)\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n n. of column(1-2048),xlonan,hna\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n give long.(xlonan) and overpass hour (hna) at\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n the ascendant node at equator \n  5 \n  avhrr  (AM noaa) \n  enter month,day,decimal hour (universal time-hh.ddd)\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n n. of column(1-2048),xlonan,hna\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n give long.(xlonan) and overpass hour (hna) at\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n the ascendant node at equator \n  6 \n  hrv  (spot) \n  enter month,day,hh.ddd,long.,lat. * \n  7 \n  tm  (landsat) \n  enter month,day,hh.ddd,long.,lat. * \n  8 \n  etm+  (landsat7) \n  enter month,day,hh.ddd,long.,lat. * \n  9 \n  liss  (IRS 1C) \n  enter month,day,hh.ddd,long.,lat. * \n  10 \n  aster \n  enter month,day,hh.ddd,long.,lat. * \n  11 \n  avnir \n  enter month,day,hh.ddd,long.,lat. * \n  12 \n  ikonos \n  enter month,day,hh.ddd,long.,lat. * \n  13 \n  RapidEye \n  enter month,day,hh.ddd,long.,lat. * \n  14 \n  VGT1 (SPOT4) \n  enter month,day,hh.ddd,long.,lat. * \n  15 \n  VGT2 (SPOT5) \n  enter month,day,hh.ddd,long.,lat. * \n  16 \n  WorldView 2 \n  enter month,day,hh.ddd,long.,lat. * \n  17 \n  QuickBird \n  enter month,day,hh.ddd,long.,lat. * \n  18 \n  LandSat 8 \n  enter month,day,hh.ddd,long.,lat. * \n  19 \n  Geoeye 1 \n  enter month,day,hh.ddd,long.,lat. * \n  20 \n  Spot6 \n  enter month,day,hh.ddd,long.,lat. * \n  21 \n  Spot7 \n  enter month,day,hh.ddd,long.,lat. * \n  22 \n  Pleiades1A \n  enter month,day,hh.ddd,long.,lat. * \n  23 \n  Pleiades1B \n  enter month,day,hh.ddd,long.,lat. * \n  24 \n  Worldview3 \n  enter month,day,hh.ddd,long.,lat. * \n  25 \n  Sentinel-2A \n  enter month,day,hh.ddd,long.,lat. * \n  26 \n  Sentinel-2B \n  enter month,day,hh.ddd,long.,lat. * \n  \n  NOTE : for HRV, TM, ETM+, LISS and ASTER experiments,\n longitude and latitude are the coordinates of the scene\n center. Latitude must be > 0 for northern hemisphere and < 0 for\n southern. Longitude must be > 0 for eastern hemisphere and < 0 for\n western.\n  B. Atmospheric model \n  Code \n  Meaning \n  0 \n  no gaseous absorption \n  1 \n  tropical \n  2 \n  midlatitude summer \n  3 \n  midlatitude winter \n  4 \n  subarctic summer \n  5 \n  subarctic winter \n  6 \n  us standard 62 \n  7 \n  Define your own atmospheric model as a set of the following 5 parameters\n per each measurement: \n  altitude [km]\n  pressure [mb]\n  temperature [k]\n  h2o density [g/m3]\n  o3 density [g/m3] \n  For example: there is one radiosonde measurement for each altitude of\n 0-25km at a step of 1km, one measurment for each altitude of 25-50km at a step\n of 5km, and two single measurements for altitudes 70km and 100km. This makes 34\n measurments. In that case, there are 34*5 values to input. \n  8 \n  Define your own atmospheric model providing values of the water vapor and\n ozone content:\n  uw [g/cm2]\n  uo3 [cm-atm]\n   The profile is taken from us62. \n  C. Aerosols model \n  Code \n  Meaning \n  Details \n  0 \n  no aerosols \n  \u00a0 \n  1 \n  continental model \n  \u00a0 \n  2 \n  maritime model \n  \u00a0 \n  3 \n  urban model \n  \u00a0 \n  4 \n  shettle model for background desert aerosol \n  \u00a0 \n  5 \n  biomass burning \n  \u00a0 \n  6 \n  stratospheric model \n  \u00a0 \n  7 \n  define your own model \n  Enter the volumic percentage of each component:\n  c(1) = volumic % of dust-like\n  c(2) = volumic % of water-soluble\n  c(3) = volumic % of oceanic\n  c(4) = volumic % of soot\n  All values should be between 0 and 1. \n  8 \n  define your own model \n  Size distribution function: Multimodal Log Normal (up to 4 modes). \n  9 \n  define your own model \n  Size distribution function: Modified gamma. \n  10 \n  define your own model \n  Size distribution function: Junge Power-Law. \n  11 \n  define your own model \n  Sun-photometer measurements, 50 values max, entered as:\n  r and d V / d (logr)\n  where r is the radius [micron], V is the volume, d V / d (logr) [cm3/cm2/micron].\n  Followed by:\n  nr and ni for each wavelength\n  where nr and ni are respectively the real and imaginary part of the\n refractive index. \n  D. Aerosol concentration model (visibility) \n If you have an estimate of the meteorological parameter visibility\n v, enter directly the value of v [km] (the aerosol optical depth (AOD) \n will be computed from a standard aerosol profile).\n  If you have an estimate of aerosol optical depth, enter 0 for the\n visibility and in a following line enter the aerosol optical depth at 550nm\n (iaer means 'i' for input and 'aer' for aerosol), for example: \n 0                            - visibility\n 0.112                        - aerosol optical depth at 550 nm\n  NOTE: if iaer is 0, enter -1 for visibility.\n  E. Target altitude (xps), sensor platform (xpp) \n Target altitude (xps, in negative [km]):\n  xps >= 0 means the target is at the sea level.\n  otherwise xps expresses the altitude of the target (e.g., mean elevation)\n in [km], given as negative value\n Sensor platform (xpp, in negative [km] or -1000):\n  xpp = -1000 means that the sensor is on board a satellite.\n  xpp = 0 means that the sensor is at the ground level.\n  -100 < xpp < 0 defines the altitude of the sensor expressed in [km];\n  this altitude is given  relative to the target  altitude as negative value.\n  For aircraft simulations only (xpp is neither equal to 0 nor equal to -1000):\n puw,po3 (water vapor content,ozone content between the aircraft and the surface)\n  taerp (the aerosol optical thickness at 550nm between the aircraft and the\n surface)\n  If these data are not available, enter negative values for all of them.\n puw,po3 will then be interpolated from the us62 standard profile according\n to the values at the ground level; taerp will be computed according to a 2 km\n exponential profile for aerosol.\n  F. Sensor band \n  There are two possibilities: either define your own spectral conditions\n (codes -2, -1, 0, or 1) or choose a code indicating the band of one of the\n pre-defined satellites.\n  Define your own spectral conditions:\n  Code \n  Meaning \n  -2 \n  Enter wlinf, wlsup.\n  The filter function will be equal to 1 over the whole band (as iwave=0)\n but step by step output will be printed. \n  -1 \n  Enter wl (monochr. cond, gaseous absorption is included). \n  0 \n  Enter wlinf, wlsup.\n  The filter function will be equal to 1 over the whole band. \n  1 \n  Enter wlinf, wlsup and user's filter function s (lambda) by step of \n 0.0025 micrometer. \n  Pre-defined satellite bands:\n  Code Band name (peak response) \n  2 meteosat  vis band (0.350-1.110) \n  3 goes east  band vis (0.490-0.900) \n  4 goes west  band vis (0.490-0.900) \n  5 avhrr  (noaa6) band 1 (0.550-0.750) \n  6 avhrr (noaa6) band 2 (0.690-1.120) \n  7 avhrr (noaa7) band 1 (0.500-0.800) \n  8 avhrr (noaa7) band 2 (0.640-1.170) \n  9 avhrr (noaa8) band 1 (0.540-1.010) \n  10 avhrr (noaa8) band 2 (0.680-1.120) \n  11 avhrr (noaa9) band 1 (0.530-0.810) \n  12 avhrr (noaa9) band 1 (0.680-1.170) \n  13 avhrr (noaa10) band 1 (0.530-0.780) \n  14 avhrr (noaa10) band 2 (0.600-1.190) \n  15 avhrr (noaa11) band 1 (0.540-0.820) \n  16 avhrr (noaa11) band 2 (0.600-1.120) \n  17 hrv1  (spot1) band 1 (0.470-0.650) \n  18 hrv1 (spot1) band 2 (0.600-0.720) \n  19 hrv1 (spot1) band 3 (0.730-0.930) \n  20 hrv1 (spot1) band pan (0.470-0.790) \n  21 hrv2 (spot1) band 1 (0.470-0.650) \n  22 hrv2 (spot1) band 2 (0.590-0.730) \n  23 hrv2 (spot1) band 3 (0.740-0.940) \n  24 hrv2 (spot1) band pan (0.470-0.790) \n  25 tm  (landsat5) band 1 (0.430-0.560) \n  26 tm (landsat5) band 2 (0.500-0.650) \n  27 tm (landsat5) band 3 (0.580-0.740) \n  28 tm (landsat5) band 4 (0.730-0.950) \n  29 tm (landsat5) band 5 (1.5025-1.890) \n  30 tm (landsat5) band 7 (1.950-2.410) \n  31 mss  (landsat5) band 1 (0.475-0.640) \n  32 mss (landsat5) band 2 (0.580-0.750) \n  33 mss (landsat5) band 3 (0.655-0.855) \n  34 mss (landsat5) band 4 (0.785-1.100) \n  35 MAS  (ER2) band 1 (0.5025-0.5875) \n  36 MAS (ER2) band 2 (0.6075-0.7000) \n  37 MAS (ER2) band 3 (0.8300-0.9125) \n  38 MAS (ER2) band 4 (0.9000-0.9975) \n  39 MAS (ER2) band 5 (1.8200-1.9575) \n  40 MAS (ER2) band 6 (2.0950-2.1925) \n  41 MAS (ER2) band 7 (3.5800-3.8700) \n  42 MODIS  band 1 (0.6100-0.6850) \n  43 MODIS band 2 (0.8200-0.9025) \n  44 MODIS band 3 (0.4500-0.4825) \n  45 MODIS band 4 (0.5400-0.5700) \n  46 MODIS band 5 (1.2150-1.2700) \n  47 MODIS band 6 (1.6000-1.6650) \n  48 MODIS band 7 (2.0575-2.1825) \n  49 avhrr  (noaa12) band 1 (0.500-1.000) \n  50 avhrr (noaa12) band 2 (0.650-1.120) \n  51 avhrr (noaa14) band 1 (0.500-1.110) \n  52 avhrr (noaa14) band 2 (0.680-1.100) \n  53 POLDER  band 1 (0.4125-0.4775) \n  54 POLDER band 2 (non polar) (0.4100-0.5225) \n  55 POLDER band 3 (non polar) (0.5325-0.5950) \n  56 POLDER band 4 P1 (0.6300-0.7025) \n  57 POLDER band 5 (non polar) (0.7450-0.7800) \n  58 POLDER band 6 (non polar) (0.7000-0.8300) \n  59 POLDER band 7 P1 (0.8100-0.9200) \n  60 POLDER band 8 (non polar) (0.8650-0.9400) \n  61 etm+ (landsat7)  band 1 blue (435nm - 517nm) \n  62 etm+ (landsat7) band 2 green (508nm - 617nm) \n  63 etm+ (landsat7) band 3 red (625nm - 702nm) \n  64 etm+ (landsat7) band 4 NIR (753nm - 910nm) \n  65 etm+ (landsat7) band 5 SWIR (1520nm - 1785nm) \n  66 etm+ (landsat7) band 7 SWIR (2028nm - 2375nm) \n  67 etm+ (landsat7) band 8 PAN (505nm - 917nm) \n  68 liss  (IRC 1C) band 2 (0.502-0.620) \n  69 liss (IRC 1C) band 3 (0.612-0.700) \n  70 liss (IRC 1C) band 4 (0.752-0.880) \n  71 liss (IRC 1C) band 5 (1.452-1.760) \n  72 aster  band 1 (0.480-0.645) \n  73 aster band 2 (0.588-0.733) \n  74 aster band 3N (0.723-0.913) \n  75 aster band 4 (1.530-1.750) \n  76 aster band 5 (2.103-2.285) \n  77 aster band 6 (2.105-2.298) \n  78 aster band 7 (2.200-2.393) \n  79 aster band 8 (2.248-2.475) \n  80 aster band 9 (2.295-2.538) \n  81 avnir  band 1 (408nm - 517nm) \n  82 avnir band 2 (503nm - 612nm) \n  83 avnir band 3 (583nm - 717nm) \n  84 avnir band 4 (735nm - 922nm) \n  85 Ikonos  Green band (408nm - 642nm) \n  86 Ikonos Red band (448nm - 715nm) \n  87 Ikonos NIR band (575nm - 787nm) \n  88 RapidEye  Blue band (440nm - 512nm) \n  89 RapidEye Green band (515nm - 592nm) \n  90 RapidEye Red band (628nm - 687nm) \n  91 RapidEye Red edge band (685nm - 735nm) \n  92 RapidEye NIR band (750nm - 860nm) \n  93 VGT1 (SPOT4)  band 0 (420nm - 497nm) \n  94 VGT1 (SPOT4) band 2 (603nm - 747nm) \n  95 VGT1 (SPOT4) band 3 (740nm - 942nm) \n  96 VGT1 (SPOT4) MIR band (1540nm - 1777nm) \n  97 VGT2 (SPOT5)  band 0 (423nm - 492nm) \n  98 VGT2 (SPOT5) band 2 (600nm - 737nm) \n  99 VGT2 (SPOT5) band 3 (745nm - 945nm) \n  100 VGT2 (SPOT5) MIR band (1523nm - 1757nm) \n  101 WorldView2  Panchromatic band (448nm - 812nm) \n  102 WorldView2 Coastal Blue band (395nm - 457nm) \n  103 WorldView2 Blue band (440nm - 517nm) \n  104 WorldView2 Green band (503nm - 587nm) \n  105 WorldView2 Yellow band (583nm - 632nm) \n  106 WorldView2 Red band (623nm - 695nm) \n  107 WorldView2 Red edge band (698nm - 750nm) \n  108 WorldView2 NIR1 band (760nm - 905nm) \n  109 WorldView2 NIR2 band (853nm - 1047nm) \n  110 QuickBird  Panchromatic band (385nm - 1060nm) \n  111 QuickBird Blue band (420nm - 585nm) \n  112 QuickBird Green band (448nm - 682nm) \n  113 QuickBird Red band (560nm - 747nm) \n  114 QuickBird NIR1 band (650nm - 935nm) \n  115 Landsat 8  Coastal aerosol band (433nm - 455nm) \n  116 Landsat 8 Blue band (448nm - 515nm) \n  117 Landsat 8 Green band (525nm - 595nm) \n  118 Landsat 8 Red band (633nm - 677nm) \n  119 Landsat 8 Panchromatic band (498nm - 682nm) \n  120 Landsat 8 NIR band (845nm - 885nm) \n  121 Landsat 8 Cirrus band (1355nm - 1390nm) \n  122 Landsat 8 SWIR1 band (1540nm - 1672nm) \n  123 Landsat 8 SWIR2 band (2073nm - 2322nm) \n  124 GeoEye 1  Panchromatic band (448nm - 812nm) \n  125 GeoEye 1 Blue band (443nm - 525nm) \n  126 GeoEye 1 Green band (503nm - 587nm) \n  127 GeoEye 1 Red band (653nm - 697nm) \n  128 GeoEye 1 NIR band (770nm - 932nm) \n  129 Spot6  Blue band (440nm - 532nm) \n  130 Spot6 Green band (515nm - 600nm) \n  131 Spot6 Red band (610nm - 710nm) \n  132 Spot6 NIR band (738nm - 897nm) \n  133 Spot6 Pan band (438nm - 760nm) \n  134 Spot7  Blue band (445nm - 532nm) \n  135 Spot7 Green band (525nm - 607nm) \n  136 Spot7 Red band (610nm - 727nm) \n  137 Spot7 NIR band (745nm - 902nm) \n  138 Spot7 Pan band (443nm - 760nm) \n  139 Pleiades1A  Blue band (433nm - 560nm) \n  140 Pleiades1A Green band (500nm - 617nm) \n  141 Pleiades1A Red band (590nm - 722nm) \n  142 Pleiades1A NIR band (740nm - 945nm) \n  143 Pleiades1A Pan band (460nm - 845nm) \n  144 Pleiades1B  Blue band 438nm - 560nm) \n  145 Pleiades1B Green band (498nm - 615nm) \n  146 Pleiades1B Red band (608nm - 727nm) \n  147 Pleiades1B NIR band (750nm - 945nm) \n  148 Pleiades1B Pan band (460nm - 845nm) \n  149 Worldview3  Pan band (445nm - 812nm) \n  150 Worldview3 Coastal blue band (395nm - 455nm) \n  151 Worldview3 Blue band (443nm - 517nm) \n  152 Worldview3 Green band (508nm - 587nm) \n  153 Worldview3 Yellow band (580nm - 630nm) \n  154 Worldview3 Red band 625nm - 697nm) \n  155 Worldview3 Red edge band (698nm - 752nm) \n  156 Worldview3 NIR1 band (760nm - 902nm) \n  157 Worldview3 NIR2 band (855nm - 1042nm) \n  158 Worldview3 SWIR1 band (1178nm - 1242nm) \n  159 Worldview3 SWIR2 band (1545nm - 1600nm) \n  160 Worldview3 SWIR3 band (1633nm - 1687nm) \n  161 Worldview3 SWIR4 band (1698nm - 1762nm) \n  162 Worldview3 SWIR5 band (2133nm - 2195nm) \n  163 Worldview3 SWIR6 band (2170nm - 2235nm) \n  164 Worldview3 SWIR7 band (2225nm - 2295nm) \n  165 Worldview3 SWIR8 band (2283nm - 2377nm) \n  166 Sentinel2A  Coastal blue band B1 (430nm - 455nm) \n  167 Sentinel2A Blue band B2 (440nm - 530nm) \n  168 Sentinel2A Green band B3 (540nm - 580nm) \n  169 Sentinel2A Red band B4 (648nm - 682nm) \n  170 Sentinel2A Red edge band B5 (695nm - 712nm) \n  171 Sentinel2A Red edge band B6 (733nm - 747nm) \n  172 Sentinel2A Red edge band B7 (770nm - 795nm) \n  173 Sentinel2A NIR band B8 (775nm - 905nm) \n  174 Sentinel2A Red edge band B8A (850nm - 880nm) \n  175 Sentinel2A Water vapour band B9 (933nm - 957nm) \n  176 Sentinel2A SWIR Cirrus band B10 (1355nm - 1392nm) \n  177 Sentinel2A SWIR band B11 (1558nm - 1667nm) \n  178 Sentinel2A SWIR band B12 (2088nm - 2315nm) \n  179 Sentinel2B  Coastal blue band B1 (430nm - 455nm) \n  180 Sentinel2B Blue band B2 (440nm - 530nm) \n  181 Sentinel2B Green band B3 (538nm - 580nm) \n  182 Sentinel2B Red band B4 (648nm - 682nm) \n  183 Sentinel2B Red edge band B5 (695nm - 712nm) \n  184 Sentinel2B Red edge band B6 (730nm - 747nm) \n  185 Sentinel2B Red edge band B7 (768nm - 792nm) \n  186 Sentinel2B NIR band B8 (778nm - 905nm) \n  187 Sentinel2B Red edge band B8A (850nm - 877nm) \n  188 Sentinel2B Water vapour band B9 (930nm - 955nm) \n  189 Sentinel2B SWIR Cirrus band B10 (1358nm - 1397nm) \n  190 Sentinel2B SWIR band B11 (1555nm - 1667nm) \n  191 Sentinel2B SWIR band B12 (2075nm - 2300nm) \n  EXAMPLES \n  Atmospheric correction of a Sentinel-2 band \n  This example illustrates how to perform atmospheric correction of a \n Sentinel-2 scene in the North Carolina location.\n  Let's assume that the Sentinel-2 L1C scene \n  S2A_OPER_PRD_MSIL1C_PDMC_20161029T092602_R054_V20161028T155402_20161028T155402 \n was downloaded and imported with region cropping \n (see  r.import ) \n into the  PERMANENT  mapset of the North Carolina location. The \n computational region was set to the extent of the  elevation  \n map in the North Carolina dataset. Now, we have 13 individual bands\n ( B01-B12 ) that we want to apply the atmospheric correction to. \n The following steps are applied to each band separately.\n  Create the parameters file for i.atcorr \n  In the first step we create a file containing the 6S parameters for a\n particular scene and band. To create a 6S file, we need to obtain the \n following information:\n   \n       geometrical conditions, \n       moth, day, decimal hours in GMT, decimal longitude and latitude of measurement,\n       atmospheric model,\n \t  aerosol model,\n       visibility or aerosol optical depth,\n \t  mean target elevation above sea level,\n       sensor height and,\n       sensor band.\n  Geometrical conditions \n  For Sentinel-2A, the geometrical conditions take the value  25  and for \n Sentinel-2B, the geometrical conditions value is  26  (See table A). \n Our scene comes from the Sentinel-2A mission (the file name begins with \n S2A_...).\n  Day, time, longitude and latitude of measurement \n  Day and time of the measurement are hidden in the filename (i.e., the\n second datum in the file name with format  YYYYMMDDTHHMMSS ), \n and are also noted in the metadata file, which is included in the \n downloaded scene (file with .xml extension). Our sample scene was taken on \n October 28th (20161028) at 15:54:02 (155402). Note \n that the time has to be specified in decimal hours in Greenwich Mean \n Time (GMT). Luckily, the time in the scene name is in GMT and we can \n convert it to decimal hours as follows: 15 + 54/60 + 2/3600 = 15.901.\n  Longitude and latitude refer to the centre of the computational region\n (which can be smaller than the scene), and must be in WGS84 decimal \n coordinates. To obtain the coordinates of the centre, we can run: \n g.region -bg\n  The longitude and latitude of the centre are stored in  ll_clon \n and  ll_clat . In our case,  ll_clon=-78.691  and \n  ll_clat=35.749 .\n  Atmospheric model \n  We can choose between various atmospheric models as defined at the \n beginning of this manual. For North Carolina, we can choose  2 - \n midlatitude summer .\n  Aerosol model \n  We can also choose between various aerosol models as defined at the \n beginning of this manual. For North Carolina, we can choose  1 - \n continental model .\n  Visibility or Aerosol Optical Depth \n  For Sentinel-2 scenes, the visibility is not measured, and therefore \n we have to estimate the aerosol optical depth instead, e.g. from \n  AERONET . With a bit of luck,\n you can find a station nearby your location, which measured the Aerosol\n Optical Depth at 500 nm at the same time as the scene was taken. In our\n case, on 28th October 2016, the  EPA-Res_Triangle_Pk  station \n measured AOD = 0.07 (approximately).\n  Mean target elevation above sea level \n  Mean target elevation above sea level refers to the mean elevation \n of the computational region. You can estimate it from the digital \n elevation model, e.g. by running:\n r.univar -g elevation\n  The mean elevation is stored in  mean . In our case, \n  mean=110 . In the 6S file it will be displayed in [-km], \n i.e.,  -0.110 .\n  Sensor height \n  Since the sensor is on board a satellite, the sensor height will be \n set to  -1000 .\n  Sensor band \n  The overview of satellite bands can be found in table F (see above).\n For Sentinel-2A, the band numbers span from 166 to 178, and for \n Sentinel-2B, from 179 to 191.\n  Finally, here is what the 6S file would look like for Band 02 of our \n scene. In order to use it in the  i.atcorr  module, we can save \n it in a text file, for example  params_B02.txt .\n 25\n 10 28 15.901 -78.691 35.749\n 2\n 1\n 0\n 0.07\n -0.110\n -1000\n 167\n  Compute atmospheric correction \n  In the next step we run  i.atcorr  for the selected band \n  B02  of our Sentinel 2 scene. We have to specify the following \n parameters:\n   \n      input  = raster band to be processed, \n      parameters  = path to 6S file created in the previous step (we could also enter the values directly),\n      output  = name for the output corrected raster band,\n \t range  = from 1 to the  QUANTIFICATION_VALUE  stored in the metadata file. It is  10000  for both Sentinel-2A and Sentinel-2B.\n \t rescale  = the output range of values for the corrected bands. This is up to the user to choose, for example: 0-255, 0-1, 1-10000.\n  If the data is available, the following parameters can be specified \n as well:\n   \n      elevation  = raster of digital elevation model,\n      visibility  = raster of visibility model.\n     \n  Finally, this is how the command would look like to apply atmospheric \n correction to band  B02 :\n i.atcorr input=B02 parameters=params_B02.txt output=B02.atcorr range=1,10000 rescale=0,255 elevation=elevation\n  To apply atmospheric correction to the remaining bands, only the last\n line in the 6S parameters file (i.e., the sensor band) needs to be changed.\n The other parameters will remain the same.\n  \n  Figure: Sentinel-2A Band 02 with applied atmospheric correction (histogram equalization grayscale color scheme) \n  Atmospheric correction of a Landsat-7 band \n This example is also based on the North Carolina sample dataset (GMT -5 hours).\n First we set the computational region to the satellite map, e.g. band 4:\n g.region raster=lsat7_2002_40 -p\n  It is important to verify the available metadata for the sun position\n which has to be defined for the atmospheric correction. An option is to \n check the satellite overpass time with sun position as reported in the\n  metadata \n file ( file copy ; North Carolina\n sample dataset). In the case of the North Carolina sample dataset, these\n values have been stored for each channel and can be retrieved with:\n r.info lsat7_2002_40\n In this case, we have: SUN_AZIMUTH = 120.8810347, SUN_ELEVATION = 64.7730999.\n  If the sun position metadata are unavailable, we can also calculate\n them from the overpass time as follows\n ( r.sunmask \n uses  SOLPOS ):\n r.sunmask -s elev=elevation out=dummy year=2002 month=5 day=24 hour=10 min=42 sec=7 timezone=-5\n # .. reports: sun azimuth: 121.342461, sun angle above horz.(refraction corrected): 65.396652\n If the overpass time is unknown, use the\n  NASA LaRC Satellite Overpass Predictor .\n  Convert digital numbers (DN) to radiance at top-of-atmosphere (TOA) \n For Landsat and ASTER, the conversion can be conveniently done with\n  i.landsat.toar  or \n  i.aster.toar , respectively.\n  In case of different satellites, the conversion of DN (digital number\n = pixel values) to radiance at top-of-atmosphere (TOA) can also be done \n manually, using e.g. the formula:\n # formula depends on satellite sensor, see respective metadata\n L\u03bb = ((LMAX\u03bb - LMIN\u03bb)/(QCALMAX-QCALMIN)) * (QCAL-QCALMIN) + LMIN\u03bb\n where,\n   L\u03bb = Spectral Radiance at the sensor's aperture in Watt/(meter squared * ster * \u00b5m), the\n       apparent radiance as seen by the satellite sensor; \n   QCAL = the quantized calibrated pixel value in DN; \n   LMIN\u03bb = the spectral radiance that is scaled to QCALMIN in watts/(meter squared * ster * \u00b5m); \n   LMAX\u03bb = the spectral radiance that is scaled to QCALMAX in watts/(meter squared * ster * \u00b5m); \n   QCALMIN = the minimum quantized calibrated pixel value (corresponding to LMIN\u03bb) in DN; \n   QCALMAX = the maximum quantized calibrated pixel value (corresponding to LMAX\u03bb) in DN=255. \n LMIN\u03bb and LMAX\u03bb are the radiances related to the minimal \n and maximal DN value, and they are reported in the metadata file of each \n image. High gain or low gain is also reported in the metadata file of each\n satellite image. For Landsat ETM+, the minimal DN value (QCALMIN) is 1 \n (see  Landsat handbook , chapter 11),\n and the maximal DN value (QCALMAX) is 255. QCAL is the DN value for every\n separate pixel in the Landsat image.\n  We extract the coefficients and apply them in order to obtain the \n radiance map:\n CHAN=4\n r.info lsat7_2002_${CHAN}0 -h | tr '\\n ' ' ' | sed 's+ ++g' | tr ':' '\\n ' | grep \"LMIN_BAND${CHAN}\\|LMAX_BAND${CHAN}\"\n LMAX_BAND4=241.100,p016r035_7x20020524.met\n LMIN_BAND4=-5.100,p016r035_7x20020524.met\n QCALMAX_BAND4=255.0,p016r035_7x20020524.met\n QCALMIN_BAND4=1.0,p016r035_7x20020524.met\n Conversion to radiance (this calculation is done for band 4, for the \n other bands, the numbers will need to be replaced with their related\n values):\n r.mapcalc \"lsat7_2002_40_rad = ((241.1 - (-5.1)) / (255.0 - 1.0)) * (lsat7_2002_40 - 1.0) + (-5.1)\"\n Again, the  r.mapcalc  calculation is only needed when working \n with satellite data other than Landsat or ASTER.\n  Create the parameters file for i.atcorr \n The underlying 6S model is parametrized through a control file, \n indicated with the  parameters  option. This is a text file \n defining geometrical and atmospherical conditions of the satellite \n overpass.\n Here we create a control file  icnd_lsat4.txt  for band 4 (NIR), \n based on metadata. For the overpass time, we need to define decimal \n hours: 10:42:07 NC local time = 10.70 decimal hours (decimal minutes: \n 42 * 100 / 60) which is 15.70 GMT.\n 8                            - geometrical conditions=Landsat ETM+\n 5 24 15.70 -78.691 35.749    - month day hh.ddd longitude latitude (\"hh.ddd\" is in GMT decimal hours)\n 2                            - atmospheric model=midlatitude summer\n 1                            - aerosols model=continental\n 50                           - visibility [km] (aerosol model concentration)\n -0.110                       - mean target elevation above sea level [km]\n -1000                        - sensor on board a satellite\n 64                           - 4th band of ETM+ Landsat 7\n Finally, run the atmospheric correction (-r for reflectance input map; \n -a for date > July 2000):\n i.atcorr -r -a lsat7_2002_40_rad elevation=elevation parameters=icnd_lsat4.txt output=lsat7_2002_40_atcorr\n Note that the altitude value from 'icnd_lsat4.txt' file is read at the \n beginning to compute the initial transform. Therefore, it is necessary\n to provide a value that might be the mean value of the elevation model \n ( r.univar elevation ). For the atmospheric correction per se, the \n elevation values from the raster map are used.\n  Note that the process is computationally intensive. Note also, that \n  i.atcorr  reports solar elevation angle above horizon rather \n than solar zenith angle.\n  REMAINING DOCUMENTATION ISSUES \n The influence and importance of the visibility value or map should be\n explained, also how to obtain an estimate for either visibility or aerosol\n optical depth at 550nm.\n ", "notes": "", "see_also": [], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.atcorr"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.aster.toar.html", "name": "i.aster.toar", "definition": "- Calculates Top of Atmosphere Radiance/Reflectance/Brightness Temperature from ASTER DN.", "keywords": ["imagery", "radiometric conversion", "radiance", "reflectance", "brightness temperature", "satellite", "ASTER"], "synopsis": "i.aster.toar [-rabcde] input=name[,name,...] dayofyear=float sun_elevation=float output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Output is radiance (W/m2) VNIR is High Gain SWIR is High Gain VNIR is Low Gain 1 SWIR is Low Gain 1 SWIR is Low Gain 2 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "VNIR is High Gain SWIR is High Gain VNIR is Low Gain 1 SWIR is Low Gain 1 SWIR is Low Gain 2 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "SWIR is High Gain VNIR is Low Gain 1 SWIR is Low Gain 1 SWIR is Low Gain 2 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "VNIR is Low Gain 1 SWIR is Low Gain 1 SWIR is Low Gain 2 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "SWIR is Low Gain 1 SWIR is Low Gain 2 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "SWIR is Low Gain 2 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Names of ASTER DN layers (15 layers)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "dayofyear", "flag": "dayofyear", "dataType": "String", "optional": false, "explanation": "Day of Year of satellite overpass [0-366]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sun_elevation", "flag": "sun_elevation", "dataType": "String", "optional": false, "explanation": "Sun elevation angle (degrees, < 90.0)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Base name of the output layers (will add .x)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.aster.toar  calculates the Top Of Atmosphere (TOA) reflectance\n for Terra-ASTER L1B in the visible, NIR and SWIR bands (9+1 bands) and\n brigthness temperature for the TIR bands (5 bands), all from L1B DN values. \n It is useful to apply after import of original ASTER imagery that\n is generally in standard DN values range.\n The order of input bands is\n   VNIR: 1,2,3N,3B\n   SWIR: 4,5,6,7,8,9\n   TIR: 10,11,12,13,14\n in one comma-separated list.\n ", "notes": "\n Internally, a gain code is defined to modify gains according to spectral\n bands following the GeoSystems GmbH ATCOR Ver. 2.0 Calibration Files.\n The function is defined in gain_aster.c file.\n /*Gain Code*/\n     /*0 - High (Not Applicable for band 10-14: TIR)*/\n     /*1 - Normal*/\n     /*2 - Low 1(Not Applicable for band 10-14: TIR)*/\n     /*3 - Low 2(Not Applicable for Band 1-3N/B and 10-14)*/\n ", "see_also": ["i.landsat.toar", "r.in.aster"], "authors": ["Yann Chemin, CSU, Australia"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.aster.toar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.albedo.html", "name": "i.albedo", "definition": "- Computes broad band albedo from surface reflectance.", "keywords": ["imagery", "albedo", "reflectance", "satellite", "Landsat", "ASTER", "AVHRR", "MODIS"], "synopsis": "i.albedo [-mnl8acd] input=name[,name,...] output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "MODIS (7 input bands:1,2,3,4,5,6,7) NOAA AVHRR (2 input bands:1,2) Landsat 5+7 (6 input bands:1,2,3,4,5,7) Landsat 8 (7 input bands:1,2,3,4,5,6,7) ASTER (6 input bands:1,3,5,6,8,9) Aggressive mode (Landsat) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Soft mode (MODIS) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "NOAA AVHRR (2 input bands:1,2) Landsat 5+7 (6 input bands:1,2,3,4,5,7) Landsat 8 (7 input bands:1,2,3,4,5,6,7) ASTER (6 input bands:1,3,5,6,8,9) Aggressive mode (Landsat) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Soft mode (MODIS) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Landsat 5+7 (6 input bands:1,2,3,4,5,7) Landsat 8 (7 input bands:1,2,3,4,5,6,7) ASTER (6 input bands:1,3,5,6,8,9) Aggressive mode (Landsat) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Soft mode (MODIS) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "8", "flag": "-8", "explanation": "Landsat 8 (7 input bands:1,2,3,4,5,6,7) ASTER (6 input bands:1,3,5,6,8,9) Aggressive mode (Landsat) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Soft mode (MODIS) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "ASTER (6 input bands:1,3,5,6,8,9) Aggressive mode (Landsat) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Soft mode (MODIS) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Aggressive mode (Landsat) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Soft mode (MODIS) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Soft mode (MODIS) Albedo dry run to calculate some water to beach/sand/desert stretching, a kind of simple atmospheric correction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.albedo  calculates the albedo, that is the Shortwave surface\n reflectance in the range of 0.3-3 micro-meters.  It takes as input\n individual bands of surface reflectance originating from MODIS, AVHRR, Landsat\n or Aster satellite sensors and calculates the albedo for those.  This is\n a precursor to  r.sun  and any energy-balance processing.\n ", "notes": "\n It uses for Landsat 8 the weighted average reflectance (temporary solution\n until an algorithm is found).\n It assumes MODIS product surface reflectance in [0;10000].\n  EXAMPLE \n The following example creates the raster map \"albedo_lsat7_1987\" from the \n LANDSAT-TM5 bands in the North Carolina dataset:\n g.region raster=lsat5_1987_10 -p\n i.albedo -l input=lsat5_1987_10,lsat5_1987_20,lsat5_1987_30,lsat5_1987_40,lsat5_1987_50,lsat5_1987_70 output=albedo_lsat7_1987\n  \n  Figure: Resulting albedo map from LANDSAT 5 \n The following example creates the raster map \"albedo_lsat7_2000\" from the \n LANDSAT-TM7 bands in the North Carolina dataset:\n g.region raster=lsat7_2000_10 -p\n i.albedo -l input=lsat7_2000_10,lsat7_2000_20,lsat7_2000_30,lsat7_2000_40,lsat7_2000_50,lsat7_2000_70 output=albedo_lsat7_2000\n  \n  Figure: Resulting albedo map from LANDSAT 7 \n  TODO \n Maybe change input requirement of MODIS to [0.0-1.0]?\n ", "see_also": ["r.sun", "i.vi"], "authors": ["Yann Chemin"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.albedo"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.version.html", "name": "g.version", "definition": "- Displays GRASS GIS version info.", "keywords": ["general", "support", "citing", "copyright", "version", "license"], "synopsis": "g.version [-cxbreg]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Print also the copyright message Print also the citation options Print also the build information Print also the GIS library revision number and date Print also extended info for additional libraries GDAL/OGR, PROJ.4, GEOS Print info in shell script style (including SVN revision number) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "x", "flag": "-x", "explanation": "Print also the citation options Print also the build information Print also the GIS library revision number and date Print also extended info for additional libraries GDAL/OGR, PROJ.4, GEOS Print info in shell script style (including SVN revision number) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Print also the build information Print also the GIS library revision number and date Print also extended info for additional libraries GDAL/OGR, PROJ.4, GEOS Print info in shell script style (including SVN revision number) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Print also the GIS library revision number and date Print also extended info for additional libraries GDAL/OGR, PROJ.4, GEOS Print info in shell script style (including SVN revision number) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Print also extended info for additional libraries GDAL/OGR, PROJ.4, GEOS Print info in shell script style (including SVN revision number) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print info in shell script style (including SVN revision number) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "\n  g.version  prints to standard output the GRASS version number,\n date, the GRASS GIS copyright ( -c  flag), and GRASS build information\n ( -b  flag).\n ", "notes": "\n This program requires no command line arguments; the user simply types\n  g.version  on the command line to see the version number and\n date of the GRASS GIS software currently being run by the user.\n Information about GRASS GIS\n core  GIS\n Library  can be printed by  -r  flag.\n Version numbers of additional libraries\n like  PROJ.4 ,  GDAL/OGR \n or  GEOS  are printed\n by  -e  flag.\n See also function  version() \n from  Python\n Scripting Library .\n import grass.script as gcore\n print gcore.version()\n ", "see_also": [], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.version"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.tempfile.html", "name": "g.tempfile", "definition": "- Creates a temporary file and prints it's file name.", "keywords": ["general", "support", "scripts"], "synopsis": "g.tempfile [-d] pid=integer  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Dry run - don't create a file, just prints it's file name Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "pid", "flag": "pid", "dataType": "String", "optional": false, "explanation": "Process id to use when naming the tempfile", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.tempfile \n is designed for shell scripts that need to use large temporary files. \n GRASS provides a mechanism for temporary files that does not depend on \n /tmp. GRASS temporary files are created in the data base with the assumption \n that there will be enough space under the data base for large files. \n GRASS periodically removes temporary files that have been left behind \n by programs that failed to remove them before terminating. \n  g.tempfile \n creates an unique file and prints the name. The user is required to provide \n a process-id which will be used as part of the name of the file. \n Most Unix shells provide a way to get the process id of the current shell. \n For /bin/sh and /bin/csh this is $$. \n It is recommended that $$ be specified as the process-id for \n  g.tempfile .\n  EXAMPLE \n For /bin/sh scripts the following syntax should be used: \n temp1=`g.tempfile pid=$$`\n temp2=`g.tempfile pid=$$`\n For /bin/csh scripts, the following can be used: \n set temp1=`g.tempfile pid=$$`\n set temp2=`g.tempfile pid=$$`\n ", "notes": "", "see_also": [], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.tempfile"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.search.modules.html", "name": "g.search.modules", "definition": "- Search in GRASS modules using keywords", "keywords": ["general", "modules", "search"], "synopsis": "g.search.modules [-anmkcgj] keyword=string[,string,...]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Display only modules where all keywords are available (AND), default: OR Invert selection (logical NOT) Search in manual pages too (can be slow) Search only for the exact keyword in module keyword list Instead of full text search, search only in actual keywords Use colorized (more readable) output to terminal Shell script format JSON format Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Invert selection (logical NOT) Search in manual pages too (can be slow) Search only for the exact keyword in module keyword list Instead of full text search, search only in actual keywords Use colorized (more readable) output to terminal Shell script format JSON format Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Search in manual pages too (can be slow) Search only for the exact keyword in module keyword list Instead of full text search, search only in actual keywords Use colorized (more readable) output to terminal Shell script format JSON format Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "k", "flag": "-k", "explanation": "Search only for the exact keyword in module keyword list Instead of full text search, search only in actual keywords Use colorized (more readable) output to terminal Shell script format JSON format Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Use colorized (more readable) output to terminal Shell script format JSON format Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Shell script format JSON format Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "j", "flag": "-j", "explanation": "JSON format Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "keyword", "flag": "keyword", "dataType": "String", "optional": false, "explanation": "Keyword to be searched", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.search.module  searches for given keyword in GRASS modules name,\n description, keywords and optionally manpages too.\n ", "notes": "\n There can be more keywords,  g.search.modules  will search for each of them\n  EXAMPLE \n Search all modules, where keywords  buffer  OR  clip  can be found\n g.search.modules keyword=buffer,clip\n r.circle\n     keywords: raster,buffer,geometry,circle\n     description: Creates a raster map containing concentric rings around a\n                  given point.\n r.buffer.lowmem\n     keywords: raster,buffer\n     description: Creates a raster map showing buffer zones surrounding cells\n                  that contain non-NULL category values. This is the low-\n                  memory alternative to the classic r.buffer module.\n r.buffer\n     keywords: raster,buffer\n     description: Creates a raster map showing buffer zones surrounding cells\n                  that contain non-NULL category values.\n Search all modules, where keywords  overlay  AND  clip  can be\n found with some fancy terminal output\n g.search.modules keyword=clip,overlay -a -c\n v.overlay\n     keywords: vector,geometry,spatial query,intersection,union,clip\n     description: Overlays two vector maps.;\n Search in manual pages too \n g.search.modules -m keyword=kapri\n db.execute\n     keywords: database,attribute table,SQL\n     description: Executes any SQL statement. For SELECT statements use\n                  'db.select'.\n db.select\n     keywords: database,attribute table,SQL\n     description: Selects data from attribute table. Performs SQL query\n                  statement(s).\n ", "see_also": ["g.manual"], "authors": ["Jachym Cepicky, OpenGeoLabs s.r.o., Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/g.search.modules"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.rename.html", "name": "g.rename", "definition": "- Renames data base element files in the user's current mapset.", "keywords": ["general", "map management", "rename"], "synopsis": "g.rename  [raster=from,to]   [raster_3d=from,to]   [vector=from,to]   [label=from,to]   [region=from,to]   [group=from,to]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "raster map(s) to be renamed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster_3d", "flag": "raster_3d", "dataType": "String", "optional": true, "explanation": "3D raster map(s) to be renamed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vector", "flag": "vector", "dataType": "String", "optional": true, "explanation": "vector map(s) to be renamed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label", "flag": "label", "dataType": "String", "optional": true, "explanation": "paint label file(s) to be renamed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "region", "flag": "region", "dataType": "String", "optional": true, "explanation": "region definition(s) to be renamed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": true, "explanation": "imagery group(s) to be renamed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.rename  allows the user to rename data base\n element files in the user's current mapset.  The user can\n specify all necessary information to  g.rename  on\n the command line, by specifying:  the type of data base\n element to be renamed (one or more of:   raster ,\n  raster_3d ,  vector ,  icon ,  labels ,\n  region , and  group ); the specific file element\n in the current mapset to be renamed ( old ); and the\n new name to be assigned to this file element ( new )\n in the current mapset.  The file element  old  is\n then renamed to  new .\n Users can also simply type  g.rename --help  without\n arguments on the command line, to receive a menu of\n existing data base element types and files from which to\n choose for possible renaming:\n        raster   raster map(s) to be renamed\n     raster_3d   3D raster map(s) to be renamed\n        vector   vector map(s) to be renamed\n        labels   paint label file(s) to be renamed\n        region   region definition(s) to be renamed\n         group   imagery group(s) to be renamed\n ", "notes": "\n If a data base element has support files (e.g., as is\n commonly the case with raster maps), these support files\n also are renamed.\n If the user attempts to rename a file to itself by setting\n the  new  file name equal to the  old  file\n name (e.g.,  g.rename raster=soils,soils ),\n  g.rename  will not execute the rename, but instead\n state that no rename is needed.  However,  g.rename \n will allow the user to overwrite other existing files in\n the current mapset by making the  new  file name\n that of an already existing file.\n  For portability reasons,  g.rename  is ignoring case of\n names. To change the case of a map name, first rename the map\n to a name which differs by more than case, then rename it to\n the intended name.\n  EXAMPLE \n # rename raster map\n g.rename raster=oldrast,newrast\n # rename vector map\n g.rename vector=oldvect,newvect\n # combined renaming\n g.rename raster=oldrast,newrast vector=oldvect,newvect\n ", "see_also": ["g.copy", "g.list", "g.remove"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.rename"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.remove.html", "name": "g.remove", "definition": "- Removes data base element files from the user's current mapset using the search pattern.", "keywords": ["general", "map management", "remove"], "synopsis": "g.remove [-irefb] type=datatype[,datatype,...]  [name=string[,string,...]]   [ignore=string[,string,...]]   [pattern=string]   [exclude=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Ignore case Use basic regular expressions instead of wildcards Use extended regular expressions instead of wildcards Force removal (required for actual deletion of files) Remove base raster maps Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Use basic regular expressions instead of wildcards Use extended regular expressions instead of wildcards Force removal (required for actual deletion of files) Remove base raster maps Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Use extended regular expressions instead of wildcards Force removal (required for actual deletion of files) Remove base raster maps Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Force removal (required for actual deletion of files) Remove base raster maps Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Remove base raster maps Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": false, "explanation": "Data type(s)", "defaultValue": null, "alternatives": ["raster", "raster_3d", "vector", "label", "region", "group", "all"], "isInputFile": false, "isOutputFile": false}, {"parameter": "name", "flag": "name", "dataType": "String", "optional": true, "explanation": "Name of file(s) to remove", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ignore", "flag": "ignore", "dataType": "String", "optional": true, "explanation": "Name of file(s) to ignore (default: none)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "pattern", "flag": "pattern", "dataType": "String", "optional": true, "explanation": "File name search pattern", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "exclude", "flag": "exclude", "dataType": "String", "optional": true, "explanation": "File name exclusion pattern (default: none)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "", "notes": "", "see_also": [], "authors": ["Huidae Cho"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.remove"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.region.html", "name": "g.region", "definition": "- Manages the boundary definitions for the geographic region.", "keywords": ["general", "settings", "computational region", "extent", "resolution", "level1"], "synopsis": "g.region [-dsplectwmn3bgfau]  [region=name]   [raster=name[,name,...]]   [raster_3d=name]   [vector=name[,name,...]]   [n=value]   [s=value]   [e=value]   [w=value]   [t=value]   [b=value]   [rows=value]   [cols=value]   [res=value]   [res3=value]   [nsres=value]   [ewres=value]   [tbres=value]   [zoom=name]   [align=name]   [grow=value]   [save=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Set from default region Save as default region Only possible from the PERMANENT mapset Print the current region Print the current region in lat/long using the current ellipsoid/datum Print the current region extent Print the current region map center coordinates Print the current region in GMT style Print the current region in WMS style Print region resolution in meters (geodesic) Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Save as default region Only possible from the PERMANENT mapset Print the current region Print the current region in lat/long using the current ellipsoid/datum Print the current region extent Print the current region map center coordinates Print the current region in GMT style Print the current region in WMS style Print region resolution in meters (geodesic) Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print the current region Print the current region in lat/long using the current ellipsoid/datum Print the current region extent Print the current region map center coordinates Print the current region in GMT style Print the current region in WMS style Print region resolution in meters (geodesic) Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Print the current region in lat/long using the current ellipsoid/datum Print the current region extent Print the current region map center coordinates Print the current region in GMT style Print the current region in WMS style Print region resolution in meters (geodesic) Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Print the current region extent Print the current region map center coordinates Print the current region in GMT style Print the current region in WMS style Print region resolution in meters (geodesic) Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Print the current region map center coordinates Print the current region in GMT style Print the current region in WMS style Print region resolution in meters (geodesic) Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Print the current region in GMT style Print the current region in WMS style Print region resolution in meters (geodesic) Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Print the current region in WMS style Print region resolution in meters (geodesic) Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Print region resolution in meters (geodesic) Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Print the convergence angle (degrees CCW) The difference between the projection's grid north and true north, measured at the center coordinates of the current region. Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "3", "flag": "-3", "explanation": "Print also 3D settings Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Print the maximum bounding box in lat/long on WGS84 Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print in shell script style Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Print in shell script style, but in one line (flat) Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Align region to resolution (default = align to bounds, works only for 2D resolution) Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "u", "flag": "-u", "explanation": "Do not update the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "region", "flag": "region", "dataType": "String", "optional": true, "explanation": "Set current region from named region", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Set region to match raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster_3d", "flag": "raster_3d", "dataType": "String", "optional": true, "explanation": "Set region to match 3D raster map(s) (both 2D and 3D values)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vector", "flag": "vector", "dataType": "String", "optional": true, "explanation": "Set region to match vector map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "n", "flag": "n", "dataType": "String", "optional": true, "explanation": "Value for the northern edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "s", "flag": "s", "dataType": "String", "optional": true, "explanation": "Value for the southern edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "e", "flag": "e", "dataType": "String", "optional": true, "explanation": "Value for the eastern edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "w", "flag": "w", "dataType": "String", "optional": true, "explanation": "Value for the western edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "t", "flag": "t", "dataType": "String", "optional": true, "explanation": "Value for the top edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "b", "flag": "b", "dataType": "String", "optional": true, "explanation": "Value for the bottom edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rows", "flag": "rows", "dataType": "String", "optional": true, "explanation": "Number of rows in the new region", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cols", "flag": "cols", "dataType": "String", "optional": true, "explanation": "Number of columns in the new region", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "res", "flag": "res", "dataType": "String", "optional": true, "explanation": "2D grid resolution (north-south and east-west)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "res3", "flag": "res3", "dataType": "String", "optional": true, "explanation": "3D grid resolution (north-south, east-west and top-bottom)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nsres", "flag": "nsres", "dataType": "String", "optional": true, "explanation": "North-south 2D grid resolution", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ewres", "flag": "ewres", "dataType": "String", "optional": true, "explanation": "East-west 2D grid resolution", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tbres", "flag": "tbres", "dataType": "String", "optional": true, "explanation": "Top-bottom 3D grid resolution", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zoom", "flag": "zoom", "dataType": "String", "optional": true, "explanation": "Shrink region until it meets non-NULL data from this raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "align", "flag": "align", "dataType": "String", "optional": true, "explanation": "Adjust region cells to cleanly align with this raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "grow", "flag": "grow", "dataType": "String", "optional": true, "explanation": "Number of cells to add to each side of the current region extent", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "save", "flag": "save", "dataType": "String", "optional": true, "explanation": "Save current region settings in named region file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  g.region  module allows the user to manage the\n settings of the current geographic region.  These regional\n boundaries can be set by the user directly and/or set from\n a region definition file (stored under the\n  windows  directory in the user's current\n mapset).  The user can create, modify, and store as many\n geographic region definitions as desired for any given\n mapset.  However, only one of these geographic region\n definitions will be current at any given moment, for a\n specified mapset;  i.e., GRASS programs that respect the\n geographic region settings will use the current geographic\n region settings.\n  DEFINITIONS \n  Region: \n  In GRASS, a  region  refers to a geographic area\n with some defined boundaries, based on a specific map\n coordinate system and map projection.  Each region also has\n associated with it the specific east-west and north-south\n resolutions of its smallest units (rectangular units called\n \"cells\").\n The region's boundaries are given as the northernmost,\n southernmost, easternmost, and westernmost points that\n define its extent (cell edges).  The north and south boundaries\n are commonly called  northings , while the east and west\n boundaries are called  eastings .\n The region's cell resolution defines the size of the\n smallest piece of data recognized (imported, analyzed,\n displayed, stored, etc.) by GRASS modules affected by the\n current region settings. The north-south and east-west cell\n resolutions need not be the same, thus allowing non-square\n data cells to exist.\n  Typically all raster and display modules are affected by the current\n region settings, but not vector modules.\n Some special modules diverge from this rule, for example raster import\n modules and  v.in.region .\n  Default Region: \n  Each GRASS LOCATION has a fixed\n geographic region, called the default geographic region\n (stored in the region file  DEFAULT_WIND  under\n the special mapset  PERMANENT ), that defines the\n extent of the data base.  While this provides a starting\n point for defining new geographic regions, user-defined\n geographic regions need not fall within this geographic\n region. The current region can be reset to the default region\n with the  -d  flag. The default region is initially set\n when the location is first created and can be reset using the\n  -s  flag.\n  Current Region: \n  Each mapset has a current geographic region.  This\n region defines the geographic area in which all GRASS\n displays and raster analyses will be done. Raster data will be\n resampled, if necessary, to meet the cell resolutions of\n the current geographic region setting.\n  Saved Regions: \n  Each GRASS MAPSET may contain any number of\n pre-defined, and named, geographic regions.  These region\n definitions are stored in the user's current mapset\n location under the  windows  directory (also\n referred to as the user's saved region definitions).\n Any of these pre-defined geographic regions\n may be selected, by name, to become the current geographic\n region.  Users may also access saved region definitions\n stored under other mapsets in the current location, if\n these mapsets are included in the user's mapset search\n path or the '@' operator is used ( region_name@mapset ).\n ", "notes": "\n After all updates have been applied, the current region's\n southern and western boundaries are (silently) adjusted so\n that the north/south distance is a multiple of the\n north/south resolution and that the east/west distance is a\n multiple of the east/west resolution.\n  With the  -a  flag all four boundaries are adjusted \n to be even multiples of the resolution, aligning the region to the\n resolution supplied by the user. The default is to\n align the region resolution to match the region boundaries.\n  The  -m  flag will report the region resolution in meters. The\n resolution is calculated by averaging the resolution at the region\n boundaries. This resolution is calculated by dividing the geodesic \n distance in meters at the boundary by the number of rows or columns.\n For example the east / west resolution (ewres) is determined from an \n average of the geodesic distances at the North and South boundaries \n divided by the number of columns.\n  The  -p  (or  -g ) option is recognized\n last.  This means that all changes are applied to the\n region settings before printing occurs.\n  The  -g  flag prints the current region settings in shell script style.\n This format can be given back to  g.region  on its command line.\n This may also be used to save region settings as shell environment variables\n with the UNIX eval command, \" eval `g.region -g` \".\n  Additional parameter information: \n  zoom= name \n  Shrink current region settings to the smallest region\n encompassing all non-NULL data in the named raster map\n layer that fall inside the user's current region. In this\n way you can tightly zoom in on isolated clumps within a\n bigger map.\n  If the user also includes the  raster= name \n option on the command line,  zoom= name  will\n set the current region settings to the smallest region\n encompassing all non-NULL data in the named  zoom  map\n that fall inside the region stated in the cell header for\n the named  raster  map.\n  align= name  \n  Set the current resolution equal to that of the named\n raster map, and align the current region to a row and\n column edge in the named map.  Alignment only moves the\n existing region edges outward to the edges of the next\n nearest cell in the named raster map - not to the named\n map's edges.  To perform the latter function, use the\n  raster= name  option.\n  EXAMPLES \n  Printing extent and raster resolution in 2D and 3D \n g.region -p\n   This will print the current region in the format:\n projection: 1 (UTM)\n zone:       13\n datum:      nad27\n ellipsoid:  clark66\n north:      4928000\n south:      4914000\n west:       590000\n east:       609000\n nsres:      20\n ewres:      20\n rows:       700\n cols:       950\n g.region -p3\n   This will print the current region and the 3D region (used for voxels)\n in the format:\n projection: 1 (UTM)\n zone:       13\n datum:      nad27\n ellipsoid:  clark66\n north:      4928000\n south:      4914000\n west:       590000\n east:       609000\n top:        1.00000000\n bottom:     0.00000000\n nsres:      20\n nsres3:     20\n ewres:      20\n ewres3:     20\n tbres:      1\n rows:       700\n rows3:      700\n cols:       950\n cols3:      950\n depths:     1\n g.region -g\n   The  -g  option prints the region in the\n following script style (key=value) format:\n n=4928000\n s=4914000\n w=590000\n e=609000\n nsres=20\n ewres=20\n rows=700\n cols=950\n g.region -bg\n   The  -bg  option prints the region in the\n following script style (key=value) format plus the\n boundary box in latitude-longitude/WGS84:\n n=4928000\n s=4914000\n w=590000\n e=609000\n nsres=20\n ewres=20\n rows=700\n cols=950\n LL_W=-103.87080682\n LL_E=-103.62942884\n LL_N=44.50164277\n LL_S=44.37302019\n g.region -l\n   The  -l  option prints the region in the\n following format:\n long: -103.86789484 lat: 44.50165890 (north/west corner)\n long: -103.62895703 lat: 44.49904013 (north/east corner)\n long: -103.63190061 lat: 44.37303558 (south/east corner)\n long: -103.87032572 lat: 44.37564292 (south/west corner)\n rows:       700\n cols:       950\n Center longitude: 103:44:59.170374W [-103.74977]\n Center latitude:  44:26:14.439781N [44.43734]\n g.region -pm\n   This will print the current region in the format\n  (latitude-longitude location):\n projection: 3 (Latitude-Longitude)\n zone:       0\n ellipsoid:  wgs84\n north:      90N\n south:      40N\n west:       20W\n east:       20E\n nsres:      928.73944902\n ewres:      352.74269109\n rows:       6000\n cols:       4800\n Note that the resolution is here reported in meters, not decimal degrees.\n  Changing extent and raster resolution using values \n g.region n=7360100 e=699000\n   will reset the northing and easting for the current\n region, but leave the south edge, west edge, and the region\n cell resolutions unchanged.\n g.region n=51:36:05N e=10:10:05E s=51:29:55N w=9:59:55E res=0:00:01\n   will reset the northing, easting, southing, westing and resolution\n for the current region, here in DMS latitude-longitude style\n (decimal degrees and degrees with decimal minutes can also be used).\n g.region -dp s=698000\n   will set the current region from the default region\n for the GRASS data base location, reset the south edge to\n 698000, and then print the result.\n g.region n=n+1000 w=w-500\n   The n= value  may also be specified as a\n function of its current value:  n=n+ value \n increases the current northing, while n=n- value \n decreases it.  This is also true for s= value ,\n e= value , and w= value .  In this example\n the current region's northern boundary is extended by 1000\n units and the current region's western boundary is\n decreased by 500 units.\n g.region n=s+1000 e=w+1000\n   This form allows the user to set the region boundary\n values relative to one another.  Here, the northern\n boundary coordinate is set equal to 1000 units larger than\n the southern boundary's coordinate value, and the eastern\n boundary's coordinate value is set equal to 1000 units\n larger than the western boundary's coordinate value.  The\n corresponding forms s=n- value  and\n w=e- value  may be used to set the values of the\n region's southern and western boundaries, relative to the\n northern and eastern boundary values.\n  Changing extent and raster resolution using maps \n g.region raster=soils\n   This form will make the current region settings\n exactly the same as those given in the cell header file for\n the raster map layer  soils .\n g.region raster=soils zoom=soils\n   This form will first look up the cell header file for\n the raster map layer  soils , use this as the\n current region setting, and then shrink the region down to\n the smallest region which still encompasses all non-NULL\n data in the map layer  soils .  Note that if the\n parameter  raster=soils  were not specified, the\n zoom would shrink to encompass all non-NULL data values in\n the soils map that were located within the  current region \n settings.\n g.region -up raster=soils\n   The  -u  option suppresses the re-setting of the\n current region definition.  This can be useful when it is\n desired to only extract region information.  In this case,\n the cell header file for the soils map layer is printed\n without changing the current region settings.\n g.region -up zoom=soils save=soils\n   This will zoom into the smallest region which\n encompasses all non-NULL soils data values, and save the\n new region settings in a file to be called  soils \n and stored under the  windows  directory in the\n user's current mapset.  The current region settings are not\n changed.\n  Changing extent and raster resolution in 3D \n g.region b=0 t=3000 tbres=200 res3=100\n g.region -p3\n   This will define the 3D region for voxel computations.\n In this example a volume with bottom (0m) to top (3000m)\n at horizontal resolution (100m) and vertical resolution (200m)\n is defined.\n  Using g.region in a shell in combination with OGR \n Extracting a spatial subset of the external vector map\n  soils.shp  into new external vector map  soils_cut.shp \n using the OGR  ogr2ogr  tool: \n eval `g.region -g`\n ogr2ogr -spat $w $s $e $n soils_cut.shp soils.shp\n This requires that the location/SHAPE file projection match.\n  Using g.region in a shell in combination with GDAL \n Extracting a spatial subset of the external raster map\n  p016r035_7t20020524_z17_nn30.tif  into new external raster\n map  p016r035_7t20020524_nc_spm_wake_nn30.tif  using the GDAL\n  gdalwarp  tool: \n eval `g.region -g`\n gdalwarp -t_srs \"`g.proj -wf`\" -te $w $s $e $n \n           p016r035_7t20020524_z17_nn30.tif \n           p016r035_7t20020524_nc_spm_wake_nn30.tif\n Here the input raster map does not have to match the location\n projection since it is reprojected on the fly.\n ", "see_also": ["g.access", "g.mapsets", "g.proj", "GRASS_REGION and WIND_OVERRIDE"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.region"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.proj.html", "name": "g.proj", "definition": "- Prints or modifies GRASS projection information files (in various co-ordinate system descriptions).", "keywords": ["general", "projection", "create location"], "synopsis": "g.proj [-pgdjfwetc]  [georef=file]   [wkt=file]   [proj4=params]   [epsg=code]   [datum=name]   [datum_trans=index]   [location=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print projection information in conventional GRASS format Print projection information in shell script style Verify datum information and print transformation parameters Print projection information in PROJ.4 format Print 'flat' output with no linebreaks (applies to WKT and PROJ.4 output) Print projection information in WKT format Use ESRI-style format (applies to WKT output only) Force override of datum transformation information in input co-ordinate system Modify current location projection files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print projection information in shell script style Verify datum information and print transformation parameters Print projection information in PROJ.4 format Print 'flat' output with no linebreaks (applies to WKT and PROJ.4 output) Print projection information in WKT format Use ESRI-style format (applies to WKT output only) Force override of datum transformation information in input co-ordinate system Modify current location projection files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Verify datum information and print transformation parameters Print projection information in PROJ.4 format Print 'flat' output with no linebreaks (applies to WKT and PROJ.4 output) Print projection information in WKT format Use ESRI-style format (applies to WKT output only) Force override of datum transformation information in input co-ordinate system Modify current location projection files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "j", "flag": "-j", "explanation": "Print projection information in PROJ.4 format Print 'flat' output with no linebreaks (applies to WKT and PROJ.4 output) Print projection information in WKT format Use ESRI-style format (applies to WKT output only) Force override of datum transformation information in input co-ordinate system Modify current location projection files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Print 'flat' output with no linebreaks (applies to WKT and PROJ.4 output) Print projection information in WKT format Use ESRI-style format (applies to WKT output only) Force override of datum transformation information in input co-ordinate system Modify current location projection files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Print projection information in WKT format Use ESRI-style format (applies to WKT output only) Force override of datum transformation information in input co-ordinate system Modify current location projection files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Use ESRI-style format (applies to WKT output only) Force override of datum transformation information in input co-ordinate system Modify current location projection files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Force override of datum transformation information in input co-ordinate system Modify current location projection files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Modify current location projection files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "georef", "flag": "georef", "dataType": "String", "optional": true, "explanation": "Name of georeferenced data file to read projection information from", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "wkt", "flag": "wkt", "dataType": "String", "optional": true, "explanation": "Name of ASCII file containing a WKT projection description", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "proj4", "flag": "proj4", "dataType": "String", "optional": true, "explanation": "PROJ.4 projection description", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "epsg", "flag": "epsg", "dataType": "String", "optional": true, "explanation": "EPSG projection code", "defaultValue": null, "alternatives": ["1-1000000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "datum", "flag": "datum", "dataType": "String", "optional": true, "explanation": "Datum (overrides any datum specified in input co-ordinate system)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "datum_trans", "flag": "datum_trans", "dataType": "String", "optional": true, "explanation": "Index number of datum transform parameters", "defaultValue": "0", "alternatives": ["-1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Name of new location to create", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.proj  provides a means of converting a co-ordinate system\n description (i.e. projection information) between various formats.\n If compiled without  OGR  present, the \n functionality is limited to:\n  Reporting the projection information for the current location, \n either in conventional GRASS (-p flag) or PROJ.4 (-j flag) format \n  Changing the datum, or reporting and modifying the datum transformation \n parameters, for the current location \n  When compiled with OGR, functionality is increased and allows output of \n the projection information in the Well-Known Text (WKT) format popularised \n by proprietary GIS. In addition, if one of the parameters  georef , \n  wkt ,  proj4  or  epsg  is specified, rather than the \n projection information being read from the current location it is imported \n from an external source as follows:\n  georef= filename \n  g.proj  attempts to invoke GDAL and OGR in turn to read a\n georeferenced file  filename . The projection information will be\n read from this file. If the file is not georeferenced or cannot be read,\n XY (unprojected) will be used. \n  wkt= filename  or  - \n  The file  filename  should contain a projection description in WKT\n format with or without line-breaks (e.g. a '.prj' file). If  -  is given\n for the filename, the WKT description will be read from stdin rather than a\n file. \n  proj4= description  or  - \n  description  should be a projection description in \n  PROJ.4  format, enclosed in\n quotation marks if there are any spaces. If  -  is given for\n  description , the PROJ.4 description will be read from stdin rather \n than as a directly-supplied command-line parameter. \n  epsg= number \n  number  should correspond to the index number of a valid\n co-ordinate system in the  EPSG \n database . EPSG code support is based upon a local copy of the GDAL CSV \n co-ordinate system and datum information files, stored in the directory \n  $GISBASE/etc/proj/ogr_csv . These can be updated if necessary\n to support future revisions of the EPSG database. \n  If datum information is incorrect or missing in the input\n co-ordinate system definition (e.g. PROJ.4 descriptions have very limited\n support for specifying datum names), a GRASS datum abbreviation can instead be\n supplied using the  datum  parameter. This will override any\n datum contained in the input co-ordinate system, and discard\n any datum transformation parameters. Enter datum= list  to return a\n list of all the datums supported by GRASS. Since any\n existing datum transformation parameters will have been discarded, the\n  datumtrans  parameter should in general always be used in\n conjunction with  datum .\n  The -p, -j, -w, etc. flags are all functional when importing projection\n information from an external source, meaning that  g.proj  can be\n used to convert between representations of the information. It is\n  not  required that either the input or output be in GRASS\n format.\n  In addition however, if the -c flag is specified,  g.proj  will \n create new GRASS projection files (PROJ_INFO, PROJ_UNITS, WIND and \n DEFAULT_WIND) based on the imported information. If the  location  \n parameter is specified in addition to -c, then a new location will be created. \n Otherwise the projection information files in the current location will be\n overwritten. The program will  not  warn before doing this.\n  The final mode of operation of g.proj is to report on the datum\n information and datum transformation parameters associated with the\n co-ordinate system. The -d flag will report a human-readable summary of\n this.\n ", "notes": "\n  If the input co-ordinate system contains a datum name but no\n transformation parameters, and there is more than one suitable parameter set\n available (according to the files datum.table and datumtransform.table in\n  $GISBASE/etc/proj ),  g.proj  will check the value of\n the  datumtrans  option and act according to the following: \n  -1:  List available parameter sets in a GUI-parsable (but also\n human-readable) format and exit. \n  0 (default):  Continue without specifying parameters - if \n used when creating a location, other GRASS modules will use the \"default\" \n (likely non-optimum) parameters for this datum if necessary in the future. \n  Any other number less than or equal to the number of parameter sets\n available for this datum:  Choose this parameter set and add it to the\n co-ordinate system description. \n If the  -t  flag is specified, the module will attempt to change the\n datum transformation parameters using one of the above two methods \n  even if  a valid parameter set is already specified in the \n input co-ordinate system. This can be useful to change the datum information\n for an existing location.\n  Output is simply based on the input projection information. g.proj does \n  not  attempt to verify that the co-ordinate system thus \n described matches an existing system in use in the world. In particular,\n this means there are no EPSG Authority codes in the WKT output.\n  WKT format shows the false eastings and northings in the projected unit\n (e.g. meters, feet) but in PROJ format it should always be given in meters.\n  The maximum size of input WKT or PROJ.4 projection descriptions is\n limited to 8000 bytes.\n  EXAMPLES \n  Print information \n Print the projection information for the current location: \n g.proj -p\n List the possible datum transformation parameters for the current location: \n g.proj -t datumtrans=-1\n  Create projection (PRJ) file \n Create a '.prj' file in ESRI format corresponding to the current location: \n g.proj -wef > irish_grid.prj\n  Read projection from file \n Read the projection information from a GeoTIFF file and print it in PROJ.4\n format: \n g.proj -jf georef=ASTER_DEM20020508161837.tif\n  Convert the PROJ.4 projection description contained in a text file to WKT\n format: \n cat proj4.description | g.proj -w proj4=-\n  Create new location \n  Create a new location with the co-ordinate system referred to by EPSG code\n 4326 (Latitude-Longitude/WGS84), without explicitly specifying datum\n transformation parameters: \n g.proj -c epsg=4326 location=latlong\n  Create a new location with the co-ordinate system referred to by ESRI-EPSG code\n 900913 ( Google Mercator Projection ) \n g.proj -c epsg=900913 location=google\n  Create a new location with the co-ordinate system referred to by EPSG code\n 29900 (Irish Grid), selecting datum transformation parameter set no. 2: \n # list available datums for EPSG code 29900\n g.proj -t datumtrans=-1 epsg=29900\n g.proj -c epsg=29900 datumtrans=2 location=irish_grid\n  Create a new location with the same co-ordinate system as the current\n location, but forcing a change to datum transformation parameter set no. 1: \n g.proj -c location=newloc -t datumtrans=1\n  Create a new location with the co-ordinate system from a WKT definition\n stored in a text file: \n g.proj -c wkt=irish_grid.prj location=irish_grid\n  Create a new location from a PROJ.4 description, explicitly\n specifying a datum and using the default datum transformation\n parameters: \n g.proj -c location=spain proj4=\"+proj=utm +zone=30 +ellps=intl\" datum=eur50 datumtrans=0\n  Using g.proj output for GDAL/OGR tools \n  Reproject external raster map to current GRASS projection (does not always make sense!)\n using the GDAL 'gdalwarp' tool. We recommend to use the ERDAS/Img format and not\n to use the ESRI style of WKT: \n # example for 30x30 pixel resolution (enforce with -tr to avoid odd values)\n gdalwarp -of HFA -tr 30 30 -t_srs \"`g.proj -wf`\" aster.img aster_tmerc.img\n  Reproject external vector map to current GRASS projection\n using the OGR 'ogr2ogr' tool: \n ogr2ogr -t_srs \"`g.proj -wf`\" polbnda_italy_GB_ovest.shp polbnda_italy_LL.shp\n  REFERENCES \n  PROJ 4 : Projection/datum support library \n  GDAL raster library and toolset \n  OGR vector library and toolset \n  Further reading \n    ASPRS Grids and Datum \n    MapRef - The Collection of Map Projections and Reference Systems for Europe \n    Projections Transform List  (PROJ4)\n ", "see_also": ["m.proj", "r.proj", "v.proj", "r.import", "r.in.gdal", "v.import", "v.in.ogr"], "authors": ["Paul Kelly"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.proj"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.ppmtopng.html", "name": "g.ppmtopng", "definition": "- Converts between PPM/PGM and PNG image formats.", "keywords": ["general", "display"], "synopsis": "g.ppmtopng input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "", "notes": "", "see_also": [], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.ppmtopng"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.pnmcomp.html", "name": "g.pnmcomp", "definition": "- Overlays multiple PPM image files.", "keywords": ["general", "display"], "synopsis": "g.pnmcomp input=name[,name,...]  [mask=name[,name,...]]   [opacity=float[,float,...]]  output=name  [output_mask=name]  width=integer height=integer  [bgcolor=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "mask", "flag": "mask", "dataType": "String", "optional": true, "explanation": "Name of input mask file(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "opacity", "flag": "opacity", "dataType": "String", "optional": true, "explanation": "Layer opacities", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "output_mask", "flag": "output_mask", "dataType": "String", "optional": true, "explanation": "Name for output mask file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": false, "explanation": "Image width", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "height", "flag": "height", "dataType": "String", "optional": false, "explanation": "Image height", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.pnmcomp  isn't meant for end users. It's an internal tool\n for use by  wxGUI .\n In essence,  g.pnmcomp  generates a PPM image by overlaying a\n series of PPM/PGM pairs (PPM = RGB image, PGM = alpha channel).\n ", "notes": "\n The intention is that  d.*  modules will emit PPM/PGM pairs (by\n way of the PNG-driver code being integrated into Display Library). The\n GUI will manage a set of layers; each layer consists of the data\n necessary to generate a PPM/PGM pair.\n Whenever the layer \"stack\" changes (by adding, removing,\n hiding, showing or re-ordering layers), the GUI will render any layers\n for which it doesn't already have the PPM/PGM pair, then re-run\n  g.pnmcomp  to generate the final image (just redoing the\n composition is a lot faster than redrawing everything).\n A C/C++ GUI would either have  g.pnmcomp's  functionality\n (image composition) built-in, or would use the system's graphics API\n to perform composition (for translucent layers, you would need OpenGL\n or the Render extension, or something else which supports translucent\n rendering).\n Tk doesn't support transparent (masked) true-colour images (it does\n support transparent GIFs, but that's limited to 256 colours), and an\n image composition routine in Tcl would be unacceptably slow, hence\n the existence of  g.pnmcomp .\n ", "see_also": [], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.pnmcomp"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.parser.html", "name": "g.parser", "definition": "- Provides full parser support for GRASS scripts.", "keywords": ["general", "support", "scripts"], "synopsis": "g.parser [-s] [-t] [-n] filename [argument,...] ", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Print strings for translation", "optional": true},{"parameter": "s", "flag": "-s", "explanation": "Write option values to standard output instead of reinvoking script", "optional": true},{"parameter": "n", "flag": "-n", "explanation": "Write option values to standard output separated by null character", "optional": true},{"parameter": "filename", "flag": "filename", "explanation": "input file", "optional": false}], "description": "\n The  g.parser  module provides full parser support for GRASS\n scripts, including an auto-generated GUI interface, help page template, and command line option checking. In this way a simple\n script can very quickly be made into a full-fledged GRASS module.\n  OPTIONS \n Unless the  -s  or  -n  switch is used, the arguments are stored in\n environment variables for use in your scripts. These variables are\n named \"GIS_FLAG_<NAME>\" for flags and \"GIS_OPT_<NAME>\" for\n options. The names of variables are converted to upper case. For\n example if an option with key  input  was defined in the script\n header, the value will be available in variable  GIS_OPT_INPUT \n and the value of flag with key  f  will be available in variable\n  GIS_FLAG_F .\n For flags, the value will be \"1\" if the flag was given, and \"0\" otherwise.\n If the  -s  or  -n  switch is used, the options and flags are written to\n standard output in the form  opt_<name>=<value>  and\n  flag_<name>=<value> , preceded by the string\n  @ARGS_PARSED@ . If this string doesn't appear as the first line\n of standard output, it indicates that the script was invoked with a switch such\n as  --html-description . In this case, the data written by\n  g.parser  to standard output should be copied to the script's standard output\n verbatim.\n If the  -s  switch is used, the options and flags are separated\n by newlines. If the  -n  switch is used, the options and flags\n are separated by null characters.\n Typical header definitions are as follows:\n #%module\n #% description: g.parser test script   \n #%end\n #%flag\n #% key: f\n #% description: A flag\n #%end\n #%option\n #% key: raster\n #% type: string\n #% gisprompt: old,cell,raster\n #% description: Raster input map\n #% required: yes\n #%end\n With  {NULL}  it is possible to suppress a predefined  description \n or  label .\n The parsers allows using predefined  standardized options and\n flags , see the list\n of  options  and  flags \n in the programmer manual. Eg. the option\n #%option\n #% key: raster\n #% type: string\n #% gisprompt: old,cell,raster\n #% description: Raster input map\n #% required: yes\n #%end\n can be easily defined as\n #%option G_OPT_R_MAP\n #% key: raster\n #%end\n The parser allows defining predefined  rules \n for used options.\n The syntax of the rules section is following:\n #%rules\n #% exclusive: capfile_output, capfile\n #%end\n The parser also allows defining \"OR\" conditions, e.g. requiring raster\n OR vector (for details, see below), e.g.for options:\n #%rules\n #% required: raster, vector\n #%end\n and e.g., for flags:\n #%rules\n #% required: -i,-d,-c\n #%end\n ", "notes": "\n An option can be instructed to allow multiple inputs by adding the\n following line:\n #% multiple: yes\n While this will only directly change the  Usage  section of the help\n screen, the option's environmental string may be easily parsed from within\n a script. For example, individual comma separated identities for an option \n named \"input\" can be parsed with the following Bash shell code:\n  IFS=,\n for opt in $GIS_OPT_INPUT ; do\n     ... \"$opt\"\n done\n A \" guisection \" field may be added to each option and flag to\n specify that the options should appear in multiple tabs in the\n auto-generated GUI.  Any options without a  guisection  field\n go into the \"Required\" or \"Options\" tab.  For example:\n #% guisection: tabname\n would put that option in a tab named  tabname .\n A \" key_desc \" field may be added to each option to specify the text that\n appears in the module's usage help section. For example:\n #% key_desc: filename\n added to an  input  option would create the usage summary\n  [input=filename] .\n If a script is run with  --o , the parser will\n set  GRASS_OVERWRITE=1 , which has the same effect as passing\n  --o  to every module which is run from the script. Similarly, passing\n  --q  or  --v  will set  GRASS_VERBOSE  to 0 or 3 respectively,\n which has the same effect as passing  --q  or  --v  to every module which\n is run from the script.  Rather than checking whether  --o ,  --q  or  --v \n were used, you should be checking  GRASS_OVERWRITE  and/or\n  GRASS_VERBOSE  instead. If those variables are set, the script\n should behave the same way regardless of whether they were set\n by  --o ,  --q  or  --v  being passed to the script or\n set by other means.\n  Conditional parameters \n Marking an option as \"required\" will result in the parser raising a\n fatal error if the option is not given, with one exception: if a flag\n has the  suppress_required  option, and that flag is given, all\n requirements are ignored. This feature is intended for flags which\n abandon \"normal operation\" for the module; e.g.  r.in.gdal 's\n  -f  flag (list supported formats) uses it.\n But in general, an option cannot be marked as required if it is\n optional except for the special case of a  suppress_required  flag.\n The parser has the ability to specify option relationships.\n For C, the relevant functions are those in\n  lib/gis/parser_dependencies.c .\n For scripts, relationships are specified using a \"rules\" section, e.g.\n #%rules\n #% required: altitude,elevation\n #%end\n specifies that at least one of those options must be given. Both\n options and flags can be specified (a leading \" - \" denotes a flag).\n The available rule types are:\n    exclusive : at most one of the options may be given \n    required : at least one of the options must be given \n    requires : if the first option is given, at least one of the\n       subsequent options must also be given \n    requires_all : if the first option is given, all of the\n       subsequent options must also be given \n    excludes : if the first option is given, none of the\n       subsequent options may be given \n    collective : all or nothing; if any option is given, all\n       must be given \n  AUTOMATED SCRIPT CREATION \n The flag  --script  added to a GRASS command, generates shell\n output. To write out a  g.parser  boilerplate for easy\n prototyping of Python scripts, the flag  --script  can be added\n to any GRASS command. Example:\n v.in.db --script\n  Help page template (HTML) \n The flag  --html-description  added to a GRASS command\n generates a related help page template in HTML. Example:\n v.in.db --html-description\n  GUI window parser (XML) \n The flag  --interface-description  added to a GRASS command\n generates a related help page template in XML. Example:\n v.in.db --interface-description\n  Web Processing Service (WPS) \n The flag  --wps-process-description  added to a GRASS command\n generates a Web Processing Service process description. Example:\n v.in.db --wps-process-description\n  reStructuredText \n The flag  --rst-description  added to a GRASS command\n generates module interface description in reStructuredText, a lightweight\n markup language. Example:\n v.in.db --rst-description\n reStructuredText is sometimes abbreviated as reST, ReST, or RST.\n The commonly used file extension is  .rst .\n Don't be confused with Representational State Transfer (REST) technology.\n  TRANSLATION \n  g.parser  provides some support for translating the options of\n scripts. If called with the -t switch before the script filename like\n this\n g.parser -t somescriptfile\n  g.parser  will print the text of the translatable options to\n standard output, one per line, and exit. This is for internal use within\n the build system to prepare GRASS scripts for translation.\n  EXAMPLES \n All examples below autogenerate the graphical user interface when invoked\n without parameters of flags:\n To run properly, the script needs to be copied into a directory listed\n in  $GRASS_ADDON_PATH  environmental variable with the\n executable flag being set. \n The script will provide a GUI (as above) and the following usage help\n text:\n test.py|sh|pl --help\n Description:\n  g.parser test script (python)\n Usage:\n  test.sh [-f] raster=string vector=string [option1=string]\n    [--verbose] [--quiet]\n Flags:\n   -f   A flag\n  --v   Verbose module output\n  --q   Quiet module output\n Parameters:\n    raster   Raster input map\n    vector   Vector input map\n   option1   An option\n  Example code for Python \n #!/usr/bin/env python\n # g.parser demo script for python programming\n #%module\n #% description: g.parser test script (python)\n #% keyword: keyword1\n #% keyword: keyword2\n #%end\n #%flag\n #% key: f\n #% description: A flag\n #%end\n #%option G_OPT_R_MAP\n #% key: raster\n #% required: yes\n #%end\n #%option G_OPT_V_MAP\n #% key: vector\n #%end\n #%option\n #% key: option1\n #% type: string\n #% description: An option\n #% required: no\n #%end\n import os\n import sys\n import grass.script as grass\n def main():\n     flag_f = flags['f']\n     option1 = options['option1']\n     raster = options['raster']\n     vector = options['vector']\n     #### add your code here ####\n     if flag_f:\n         print \"Flag -f set\"\n     else:\n         print \"Flag -f not set\"\n     # test if parameter present:\n     if option1:\n         print \"Value of option1 option: '%s'\" % option1\n     print \"Value of raster option: '%s'\" % raster\n     print \"Value of vector option: '%s'\" % vector\n     #### end of your code ####\n     return 0\n if __name__ == \"__main__\":\n     options, flags = grass.parser()\n     sys.exit(main())\n  Example code for SHELL \n #!/bin/sh\n # g.parser demo script for shell programming\n #%module\n #% description: g.parser test script (shell) \n #%end\n #%flag\n #% key: f\n #% description: A flag\n #%end\n #%option G_OPT_R_MAP\n #% key: raster\n #% required: yes\n #%end\n #%option G_OPT_V_MAP\n #% key: vector\n #%end\n #%option\n #% key: option1\n #% type: string\n #% description: An option\n #% required: no\n #%end\n if [ -z \"$GISBASE\" ] ; then\n     echo \"You must be in GRASS GIS to run this program.\" 1>&2\n     exit 1\n fi\n if [ \"$1\" != \"@ARGS_PARSED@\" ] ; then\n     exec g.parser \"$0\" \"$@\"\n fi\n #### add your code below ####\n echo \"\"\n if [ $GIS_FLAG_F -eq 1 ] ; then\n   g.message message=\"Flag -f set\"\n else\n   g.message message=\"Flag -f not set\"\n fi\n # test if parameter present:\n if [ -n \"$GIS_OPT_OPTION1\" ] ; then\n     echo \"Value of GIS_OPT_OPTION1: '$GIS_OPT_OPTION1'\"\n fi\n g.message message=\"Value of GIS_OPT_option1: '$GIS_OPT_option1'\"\n g.message message=\"Value of GIS_OPT_raster: '$GIS_OPT_raster'\"\n g.message message=\"Value of GIS_OPT_vect: '$GIS_OPT_vector'\"\n #### end of your code ####\n  Example code for Perl \n #!/usr/bin/perl -w\n use strict;\n # g.parser demo script\n #%module\n #%  description: g.parser test script (perl) \n #%  keyword: keyword1\n #%  keyword: keyword2\n #%end\n #%flag\n #%  key: f\n #%  description: A flag\n #%end\n #%option G_OPT_R_MAP\n #% key: raster\n #% required: yes\n #%end\n #%option G_OPT_V_MAP\n #% key: vector\n #%end\n #%option\n #% key: option1\n #% type: string\n #% description: An option\n #% required: no\n #%end\n if ( !$ENV{'GISBASE'} ) {\n     printf(STDERR  \"You must be in GRASS GIS to run this program.\\n \");\n     exit 1;\n }\n if( $ARGV[0] ne '@ARGS_PARSED@' ){\n     my $arg = \"\";\n     for (my $i=0; $i < @ARGV;$i++) {\n         $arg .= \" $ARGV[$i] \";\n     }\n     system(\"$ENV{GISBASE}/bin/g.parser $0 $arg\");\n     exit;\n }\n #### add your code here ####\n print  \"\\n \";\n if ( $ENV{'GIS_FLAG_F'} eq \"1\" ){\n    print \"Flag -f set\\n \"\n }\n else {\n    print \"Flag -f not set\\n \"\n }\n printf (\"Value of GIS_OPT_option1: '%s'\\n \", $ENV{'GIS_OPT_OPTION1'});\n printf (\"Value of GIS_OPT_raster: '%s'\\n \", $ENV{'GIS_OPT_RASTER'});\n printf (\"Value of GIS_OPT_vect: '%s'\\n \", $ENV{'GIS_OPT_VECTOR'});\n #### end of your code ####\n  Easy creation of a script \n By using the  --script  flag with any GRASS GIS module (must be run in\n a GRASS GIS session) header, description, keywords, parameters, flags and\n a template main Python script section will be printed in the terminal which\n can be saved to a file and used for further script programming.\n In this example, the module  v.what.rast  is used as an example.\n The output is shown below:\n v.what.rast --script\n #!/usr/bin/env python\n ############################################################################\n #\n # MODULE:       v.what.rast_wrapper\n # AUTHOR(S):    username\n # PURPOSE:      Wrapper for v.what.rast\n # COPYRIGHT:    (C) 2017 by username, and the GRASS Development Team\n #\n #  This program is free software; you can redistribute it and/or modify\n #  it under the terms of the GNU General Public License as published by\n #  the Free Software Foundation; either version 2 of the License, or\n #  (at your option) any later version.\n #\n #  This program is distributed in the hope that it will be useful,\n #  but WITHOUT ANY WARRANTY; without even the implied warranty of\n #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n #  GNU General Public License for more details.\n #\n ############################################################################\n #%module\n #% description: Uploads raster values at positions of vector points to the table.\n #% keyword: vector, sampling, raster, position, querying, attribute table, surface information\n #%end\n #%flag\n #% key: i\n #% description: Interpolate values from the nearest four cells\n #%end\n #%flag\n #% key: p\n #% description: Print categories and values instead of updating the database\n #%end\n #%option\n #% key: map\n #% type: string\n #% required: yes\n #% multiple: no\n #% key_desc: name\n #% label: Name of vector points map for which to edit attributes\n #% description: Or data source for direct OGR access\n #% gisprompt: old,vector,vector\n #%end\n #%option\n #% key: layer\n #% type: string\n #% required: no\n #% multiple: no\n #% label: Layer number or name\n #% description: Vector features can have category values in different layers. This number determines which layer to use. When used with direct OGR access this is the layer name.\n #% answer: 1\n #% gisprompt: old,layer,layer\n #%end\n #%option\n #% key: type\n #% type: string\n #% required: no\n #% multiple: yes\n #% options: point,centroid\n #% description: Input feature type\n #% answer: point\n #%end\n #%option\n #% key: raster\n #% type: string\n #% required: yes\n #% multiple: no\n #% key_desc: name\n #% description: Name of existing raster map to be queried\n #% gisprompt: old,cell,raster\n #%end\n #%option\n #% key: column\n #% type: string\n #% required: no\n #% multiple: no\n #% key_desc: name\n #% description: Name of attribute column to be updated with the query result\n #% gisprompt: old,dbcolumn,dbcolumn\n #%end\n #%option\n #% key: where\n #% type: string\n #% required: no\n #% multiple: no\n #% key_desc: sql_query\n #% label: WHERE conditions of SQL statement without 'where' keyword\n #% description: Example: income < 1000 and population >= 10000\n #%end\n import sys\n import grass.script as grass\n def main():\n     # put code here\n     return 0\n if __name__ == \"__main__\":\n     options, flags = grass.parser()\n     sys.exit(main())\n ", "see_also": ["g.filename", "g.findfile", "g.tempfile"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.parser"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.mkfontcap.html", "name": "g.mkfontcap", "definition": "- Generates the font configuration file by scanning various directories for fonts.", "keywords": ["general"], "synopsis": "g.mkfontcap [-os]  [extradirs=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "o", "flag": "-o", "explanation": "Overwrite font configuration file if already existing Write font configuration file to standard output instead of $GISBASE/etc Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Write font configuration file to standard output instead of $GISBASE/etc Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "extradirs", "flag": "extradirs", "dataType": "String", "optional": true, "explanation": "List of extra directories to scan", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  g.mkfontcap  is a utilty to generate a GRASS font configuration file\n (\"fontcap\") containing details of the fonts available on the current system.\n If  Freetype  is not installed,\n the font list will be limited to the set of Hershey stroke fonts supplied\n with GRASS. With Freetype enabled however, the module will recursively scan \n all files within a predefined hierarchy to find Freetype-compatible scalable\n fonts. The list of directories scanned is currently:\n     /usr/lib/X11/fonts\n     /usr/share/X11/fonts\n     /usr/share/fonts\n     /usr/local/share/fonts\n     ${HOME}/Library/Fonts\n     /Library/Fonts\n     /System/Library/Fonts\n     ${WINDIR}/Fonts\n  These correspond to directories where fonts can be found on some common\n operating systems. Extra directories to search can easily by added using the\n  extradirs  parameter, which accepts a comma-separated list. An extra\n directory may optionally contain an environment variable  at the start  \n of the string, if enclosed in ${xxx} syntax (see examples above).\n  The module will normally write to the standard fontcap file location,\n  $GISBASE/etc/fontcap . If the environment variable\n  GRASS_FONT_CAP  is set, the output will instead be written \n to the file specified by that variable. This is useful if you don't have\n permission to modify  $GISBASE/etc/fontcap : in this case you can\n use e.g.\n # use local file version instead of system copy\n GRASS_FONT_CAP=$HOME/.gfontcap\n export GRASS_FONT_CAP\n g.mkfontcap\n  to create a personal copy and then to make GRASS use that file\n instead of the system copy.\n  The output list of fonts is sorted first by type (Stroke fonts first,\n followed by Freetype) and within each type by the short name of the font.\n ", "notes": "", "see_also": ["d.font"], "authors": ["Paul Kelly"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.mkfontcap"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.message.html", "name": "g.message", "definition": "- Prints a message, warning, progress info, or fatal error in the GRASS way.", "keywords": ["general", "support", "scripts"], "synopsis": "g.message [-wedpiv] message=string  [debug=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "w", "flag": "-w", "explanation": "Print message as warning Print message as fatal error Print message as debug message Print message as progress info Print message in all modes except of quiet mode Message is printed on GRASS_VERBOSE>=1 Print message only in verbose mode Message is printed only on GRASS_VERBOSE>=3 Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Print message as fatal error Print message as debug message Print message as progress info Print message in all modes except of quiet mode Message is printed on GRASS_VERBOSE>=1 Print message only in verbose mode Message is printed only on GRASS_VERBOSE>=3 Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Print message as debug message Print message as progress info Print message in all modes except of quiet mode Message is printed on GRASS_VERBOSE>=1 Print message only in verbose mode Message is printed only on GRASS_VERBOSE>=3 Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print message as progress info Print message in all modes except of quiet mode Message is printed on GRASS_VERBOSE>=1 Print message only in verbose mode Message is printed only on GRASS_VERBOSE>=3 Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Print message in all modes except of quiet mode Message is printed on GRASS_VERBOSE>=1 Print message only in verbose mode Message is printed only on GRASS_VERBOSE>=3 Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Print message only in verbose mode Message is printed only on GRASS_VERBOSE>=3 Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "message", "flag": "message", "dataType": "String", "optional": false, "explanation": "Text of the message to be printed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "debug", "flag": "debug", "dataType": "String", "optional": true, "explanation": "Level to use for debug messages", "defaultValue": "1", "alternatives": ["0-5"], "isInputFile": false, "isOutputFile": false}], "description": "\n  This program is to be used in Shell/Perl/Python scripts, so the author does not\n need to use the  echo  program. The advantage of  g.message  is\n that it formats messages just like other GRASS modules do and that its\n functionality is influenced by the  GRASS_VERBOSE  and\n  GRASS_MESSAGE_FORMAT  environment variables.\n The program can be used for standard informative messages as well as warnings\n ( -w  flag) and fatal errors ( -e  flag). For debugging\n purposes, the  -d  flag will cause  g.message  to print a debugging\n message at the given level.\n ", "notes": "\n Messages containing \" = \" must use the full  message=  syntax so\n the parser doesn't get confused.\n If you want a long message (multi-line) to be dealt with as a single\n paragraph, use a single call to  g.message  with text split in the\n script using the backslash as the last character. (In shell scripts don't\n close the \"quote\")\n A blank line may be obtained with\n g.message message=\"\"\n Redundant whitespace will be stripped away.\n It's advisable to single quote the messages that are to be printed literally.\n It prevents a number of characters (most notably, space and the dollar sign\n ' $ ') from being treated specifically by the shell.\n When it is necessary to include, for example, a variable's value as part of\n the message, the double quotes may be used, which do not deprive the\n dollar sign of its special variable-expansion powers.\n While it is known that the interactive Bash instances may treat the\n exclamation mark ' ! ' character specifically (making single quoting\n of it necessary), it shouldn't be the case for the non-interactive\n instances of Bash. Nonetheless, to avoid context-based confusion later on\n you are enouraged to single-quote messages that do not require\n  $VARIABLE  expansion.\n  Usage in Python scripts \n  GRASS\n Python Scripting Library  defines special wrappers\n for  g.message .\n    debug()  for  g.message -d \n    error()  for  g.message -e \n    fatal()  for  g.message -e  +  exit() \n    info()  for  g.message -i \n    message()  for  g.message \n    verbose()  for  g.message -v \n    warning()  for  g.message -w \n Note: The Python tab in the  wxGUI  can be used for entering the\n following sample code:\n import grass.script as gcore\n gcore.warning(\"This is a warning\")\n is identical with\n g.message -w message=\"This is a warning\"\n  VERBOSITY LEVELS \n Controlled by the \" GRASS_VERBOSE \" environment variable. Typically this\n is set using the  --quiet  or  --verbose  command line options.\n  0 - only errors and warnings are printed\n  1 - progress messages are printed\n  2 - all module messages are printed\n  3 - additional verbose messages are printed\n  DEBUG LEVELS \n Controlled by the \" DEBUG \" GRASS  gisenv  variable (set with\n  g.gisenv ).\n Recommended levels:\n  1 - message is printed once or few times per module\n  3 - each row (raster) or line (vector)\n  5 - each cell (raster) or point (vector)\n  EXAMPLES \n This basic example prints the message \"hello\" in the console:\n g.message message=\"hello\"\n To print a message as an error message use the  -e  flag:\n g.message -e message=\"my error\"\n To print a message highlighted as a debug message (\"D0/0: debug\") in the\n console, use the  -d  flag. Optionally the debug level can be defined (see\n also  g.gisenv  for details):\n # Levels: (recommended levels)\n #   0 - silence\n #   1 - message is printed once or few times per module\n #   3 - each row (raster) or line (vector)\n #   5 - each cell (raster) or point (vector) \n g.message -d message=\"debug\" debug=0\n To print a message highlighted as a warning message (\"WARNING: my warning\")\n in the console, use the  -w  flag:\n g.message -w message=\"my warning\"\n ", "see_also": ["GRASS variables and environment variables", "g.gisenv", "g.parser"], "authors": ["Jachym Cepicky"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.message"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/g.mapsets.html", "name": "g.mapsets", "definition": "- Modifies/prints the user's current mapset search path.", "keywords": ["general", "settings", "search path"], "synopsis": "g.mapsets [-lps] mapset=name[,name,...] operation=string  [separator=character]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "List all available mapsets in alphabetical order Print mapsets in current search path Launch mapset selection GUI dialog Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print mapsets in current search path Launch mapset selection GUI dialog Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Launch mapset selection GUI dialog Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "mapset", "flag": "mapset", "dataType": "String", "optional": false, "explanation": "Name of mapset (default: current search path)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "operation", "flag": "operation", "dataType": "String", "optional": false, "explanation": "Operation to be performed", "defaultValue": "add", "alternatives": ["set", "add", "remove"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator for printing (-l and -p flags)", "defaultValue": "space", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n For basic information about GRASS  mapset ,  location \n and  data base  refer to  GRASS\n Quickstart .\n A  mapset  holds a distinct set of data layers, each relevant\n to the same (or a subset of the same) geographic region, and each\n drawn in the same map coordinate system.  At the outset of every GRASS\n session, the user identifies a GRASS data base, location, and mapset\n that are to be the user's  current data base ,  current\n location , and  current mapset  for the duration of the\n session; any maps created by the user during the session will be\n stored under the  current mapset  set at the session's outset\n (see  g.mapset  [without an \"s\"]\n and  g.gisenv  for changing the\n mapset with a session).\n The user can add, modify, and delete data layers that exist under\n their  current mapset . Although the user can\n also  access  (i.e., use) data that are stored under\n  other  mapsets in the same GRASS location using the\n  mapname@mapsetname  notation or mapset search path, the user\n can only make permanent changes (create or modify data)\n located in the  current mapset .  The user's\n  mapset search path  lists the order in which other mapsets in\n the same GRASS location can be searched and their data accessed by the\n user. The user can modify the listing and order in which these mapsets\n are accessed by modifying the mapset search path; this can be done\n using the  g.mapsets  command. This program allows the user to\n use other's relevant map data without altering the original data\n layer, and without taking up disk space with a copy of the original\n map. The  mapname@mapsetname  notation may be used irrespective\n of the mapset search path, i.e., any map found in another mapset with\n sufficient  g.access  privileges\n may be called in such a manner.\n  g.mapsets  shows the user available mapsets under the current\n GRASS location, lists mapsets to which the user currently has access,\n and lists the order in which accessible mapsets will be accessed by\n GRASS programs searching for data files.  The user is then given the\n opportunity to add or delete mapset names from the search path, or\n modify the order in which mapsets will be accessed.\n When the user specifies the name of a data base element file (e.g., a\n particular vector map, raster map,  imagery \n group file, etc.) to a GRASS program, the program searches for the\n named file under each of the mapsets listed in the user's mapset\n search path in the order listed there until the program finds a file\n of the given name. Users can also specify a file by its mapset, to\n make explicit the mapset from which the file is to be drawn; e.g., the\n command:\n g.copy raster=soils@PERMANENT,my_soils\n ensures that a new file named  my_soils  is to be a copy of\n the file  soils  from the mapset PERMANENT.\n In each location there is the special mapset  PERMANENT  included\n in the mapset search path, as this mapset typically contains base maps\n relevant to many applications. Often, other mapsets which contain sets\n of interpreted maps will be likewise included in the user's mapset search path.\n Suppose, for example, that the mapset  Soil_Maps  contains\n interpreted soils map layers to which the user wants access. The\n mapset  Soil_Maps  should then be included in the user's\n  search path  variable.\n The  mapset search path  is saved as part of the current\n mapset. When the user works with that mapset in subsequent GRASS\n sessions, the previously saved mapset search path will be used (and\n will continue to be used until it is modified by the user\n with  g.mapsets ).\n ", "notes": "\n By default  g.mapsets  adds to the current  mapset search\n path  mapsets named by  mapset  option. Alternatively mapsets\n can be removed ( operation=remove ) from the search path or\n defined by  operation=set .\n Users can restrict others' access to their mapset files through use\n of  g.access . Mapsets to which\n access is restricted can still be listed in another's mapset search\n path; however, access to these mapsets will remain restricted.\n  EXAMPLES \n  Selecting mapsets with the graphical mapset manager \n Using the  -s  flag, a convenient graphical mapset manager can\n be opened to select and deselect other mapsets (the actual mapset and\n the PERMANENT mapset are always selected):\n g.mapsets -s\n  \n  Print available mapsets \n All available mapsets in the current location can be printed out by\n g.mapsets -l\n Available mapsets:\n PERMANENT user1 user2\n  Add new mapset \n Add mapset 'user2' to the current mapset search path\n g.mapsets mapset=user2 operation=add\n The current mapset search path is changed accordingly\n g.mapsets -p\n Accessible mapsets:\n user1 user2\n  Overwrite current search path \n Overwrite current search path\n g.mapsets mapset=user1,PERMANENT operation=set\n  Using shortcuts for search path \n The current mapset can be defined by a shortcut \".\" (dot)\n g.mapsets mapset=.,PERMANENT operation=set\n  Note:  The current mapset will be always included in the search\n path on the first position even if you change its position or omit the\n current mapset from the  mapset  option.\n g.mapsets -p\n Accessible mapsets:\n user1 PERMANENT\n ", "see_also": ["g.access", "g.copy", "g.gisenv", "g.list", "g.mapset"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/general/g.mapsets"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.oif.html", "name": "i.oif", "definition": "- Calculates Optimum-Index-Factor table for spectral bands", "keywords": ["imagery", "multispectral", "statistics"], "synopsis": "i.oif [-gs] input=name[,name,...]  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print in shell script style Process bands serially (default: run in parallel) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Process bands serially (default: run in parallel) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.oif  calculates the Optimum Index Factor for \n multi-spectral satellite imagery.\n The Optimum Index Factor (OIF) determines the three-band combination \n that maximizes the variability (information) in a multi-spectral \n scene. The index is a ratio of the total variance (standard \n deviation) within and the correlation between all possible band \n combinations. The bands that comprise the highest scoring \n combination from  i.oif  are used as the three color channels \n required for  d.rgb  or  r.composite .\n  The analysis is saved to a file in the current directory called \"i.oif.result\".\n ", "notes": "\n Landsat 1-7 TM:\n Colour Composites in BGR order as important Landsat TM band combinations\n (example: 234 in BGR order means: B=2, G=3, R=4):\n   123: near natural (\"true\") colour; however, because of \n correlation of the 3 bands in visible spectrum, this combination \n contains not much more info than is contained in single band. \n   234: sensitive to green vegetation (portrayed as red), \n coniferous as distinctly darker red than deciduous forests. Roads \n and water bodies are clear. \n   243: green vegetation is green but coniferous forests aren't as \n clear as the 234 combination. \n   247: one of the best for info pertaining to forestry. Good for \n operation scale mapping of recent harvest areas and road \n construction. \n   345: contains one band from each of the main reflective units \n (vis, nir, shortwave infra). Green vegetation is green and the \n shortwave band shows vegetational stress and mortality. Roads are \n less evident as band 3 is blue. \n   347: similar to 345 but depicts burned areas better. \n   354: appears more like a colour infrared photo. \n   374: similar to 354. \n   457: shows soil texture classes (clay, loam, sandy). \n By default the module will calculate standard deviations for all bands in\n parallel. To run serially use the  -s  flag. If the  WORKERS \n environment variable is set, the number of concurrent processes will be\n limited to that number of jobs.\n  EXAMPLE \n North Carolina sample dataset:\n g.region raster=lsat7_2002_10 -p\n i.oif input=lsat7_2002_10,lsat7_2002_20,lsat7_2002_30,lsat7_2002_40,lsat7_2002_50,lsat7_2002_70\n  REFERENCES \n Jensen, 1996. Introductory digital image processing. Prentice Hall, \n p.98. ISBN 0-13-205840-5\n ", "see_also": ["d.rgb", "r.composite", "r.covar", "r.univar"], "authors": ["Markus Neteler, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/i.oif"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.modis.qc.html", "name": "i.modis.qc", "definition": "- Extracts quality control parameters from MODIS QC layers.", "keywords": ["imagery", "imagery quality assessment", "reflectance", "land surface temperature", "vegetation", "satellite", "MODIS"], "synopsis": "i.modis.qc input=name output=name productname=string qcname=string  [band=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input surface reflectance QC layer [bit array]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output QC type classification layer", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "productname", "flag": "productname", "dataType": "String", "optional": false, "explanation": "Name of MODIS product type", "defaultValue": null, "alternatives": ["mod09Q1", "mod09A1", "mod09A1s", "mod09GA", "mod09GAs", "mod09CMG", "mod09CMGs", "mod09CMGi", "mod11A1", "mod11A2", "mod13A2", "mcd43B2", "mcd43B2q", "mod13Q1"], "isInputFile": false, "isOutputFile": false}, {"parameter": "qcname", "flag": "qcname", "dataType": "String", "optional": false, "explanation": "Name of QC type to extract", "defaultValue": null, "alternatives": ["adjcorr", "atcorr", "cloud", "data_quality", "diff_orbit_from_500m", "modland_qa", "mandatory_qa_11A1", "data_quality_flag_11A1", "emis_error_11A1", "lst_error_11A1", "data_quality_flag_11A2", "emis_error_11A2", "mandatory_qa_11A2", "lst_error_11A2", "aerosol_quantity", "brdf_correction_performed", "cirrus_detected", "cloud_shadow", "cloud_state", "internal_cloud_algorithm", "internal_fire_algorithm", "internal_snow_mask", "land_water", "mod35_snow_ice", "pixel_adjacent_to_cloud", "salt_pan", "icm_cloudy", "icm_clear", "icm_high_clouds", "icm_low_clouds", "icm_snow", "icm_fire", "icm_sun_glint", "icm_dust", "icm_cloud_shadow", "icm_pixel_is_adjacent_to_cloud", "icm_cirrus", "icm_pan_flag", "icm_criteria_for_aerosol_retrieval", "icm_aot_has_clim_val", "modland_qa", "vi_usefulness", "aerosol_quantity", "pixel_adjacent_to_cloud", "brdf_correction_performed", "mixed_clouds", "land_water", "possible_snow_ice", "possible_shadow", "platform", "land_water", "sun_z_angle_at_local_noon", "brdf_correction_performed", "modland_qa", "vi_usefulness", "aerosol_quantity", "pixel_adjacent_to_cloud", "brdf_correction_performed", "mixed_clouds", "land_water", "possible_snow_ice", "possible_shadow"], "isInputFile": false, "isOutputFile": false}, {"parameter": "band", "flag": "band", "dataType": "String", "optional": true, "explanation": "Band number of MODIS product (mod09Q1=[1,2],mod09A1=[1-7],m[o/y]d09GA=[1-7],m[o/y]d09CMG=[1-7], mcd43B2q=[1-7])", "defaultValue": null, "alternatives": ["1", "2", "3", "4", "5", "6", "7"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.modis.qc  extracts Requested Quality Assessment flags from the\n following MODIS products: MOD09A1, MOD09Q1, MOD11A1, MOD11A2, MOD13A2, MOD13Q1,\n MCD43B2. This does include MOD09A1 QA_state_500m layer (see Notes).\n Added MOD09GA support in 2016, it follows MOD09A1 and its StateQA, but does not have BRDF State QA, instead has Salt Pan State QA.\n  MOD09A1 and MOD09Q1 \n  MOD09A1/Q1: MODLAND QA Bits. bits=[0-1] \n   [00]= class 0: Corrected product produced at ideal quality -- all bands \n   [01]= class 1: Corrected product produced at less than ideal quality -- some or all bands \n   [10]= class 2: Corrected product NOT produced due to cloud effect -- all bands \n   [11]= class 3: Corrected product NOT produced due to other reasons --\n  some or all bands maybe be fill value (Note that a value of [11] overrides a value of [01]) \n  MOD09Q1: Cloud State. bits=[2-3]  \n   [00]= class 0: Clear -- No clouds \n   [01]= class 1: Cloudy \n   [10]= class 2: Mixed \n   [11]= class 3: Not Set ; Assumed Clear \n  MOD09Q1: Band-wise Data Quality 250m bits=[4-7][8-11] \n  MOD09A1: Band-wise Data Quality 500m bits=[2-5][6-9][10-13][14-17][18-21][22-25][26-29] \n   [0000]= class 0: highest quality \n   [0111]= class 1: noisy detector \n   [1000]= class 2: dead detector; data interpolated in L1B \n   [1001]= class 3: solar zenith \u2265 86 degrees \n   [1010]= class 4: solar zenith \u2265 85 and < 86 degrees \n   [1011]= class 5: missing input \n   [1100]= class 6: internal constant used in place of climatological data for at least one atmospheric constant \n   [1101]= class 7: correction out of bounds, pixel constrained to extreme allowable value \n   [1110]= class 8: L1B data faulty \n   [1111]= class 9: not processed due to deep ocean or cloud \n   Class 10-15: Combination of bits unused \n  MOD09A1/Q1: Atmospheric correction bit=[12]/[30] \n   [0]= class 0: Not Corrected product \n   [1]= class 1: Corrected product \n  MOD09A1/Q1: Adjacency correction bit=[13]/[31] \n   [0]= class 0: Not Corrected product \n   [1]= class 1: Corrected product \n  MOD09Q1: Different orbit from 500m product, bit=[14] \n   [0]= class 0: same orbit as 500m \n   [1]= class 1: different orbit from 500m \n  MOD09A1s: Cloud State bits=[0-1] \n   [00]= class 0: clear \n   [01]= class 1: cloudy \n   [10]= class 2: mixed \n   [11]= class 3: not set, assumed clear \n  MOD09A1s: Cloud shadow bits=[2] \n   [0]= class 0: no \n   [1]= class 1: yes \n  MOD09A1s: Land/Water Flag bits=[3-5] \n   [000]= class 0: Shallow ocean \n   [001]= class 1: Land \n   [010]= class 2: Ocean coastlines and lake shorelines \n   [011]= class 3: Shallow inland water \n   [100]= class 4: Ephemeral water \n   [101]= class 5: Deep inland water \n   [110]= class 6: Continental/moderate ocean \n   [111]= class 7: Deep ocean \n  MOD09A1s: Aerosol Quantity bits=[6-7] \n   [00]= class 0: Climatology \n   [01]= class 1: Low \n   [10]= class 2: Average \n   [11]= class 3: High \n  MOD09A1s: Cirrus detected bits=[8-9] \n   [00]= class 0: None \n   [01]= class 1: Small \n   [10]= class 2: Average \n   [11]= class 3: High \n  MOD09A1s: Internal Cloud Algorithm Flag bits=[10] \n   [0]= class 0: No cloud \n   [1]= class 1: Cloud \n  MOD09A1s: Internal Fire Algorithm Flag bits=[11] \n   [0]= class 0: No fire \n   [1]= class 1: Fire \n  MOD09A1s: MOD35 snow/ice flag bits=[12] \n   [0]= class 0: No \n   [1]= class 1: Yes \n  MOD09A1s: Pixel adjacent to cloud bits=[13] \n   [0]= class 0: No \n   [1]= class 1: Yes \n  MOD09A1s: BRDF correction performed bits=[14] \n   [0]= class 0: No \n   [1]= class 1: Yes \n  MOD09A1s: Internal Snow Mask bits=[15] \n   [0]= class 0: No snow \n   [1]= class 1: Snow \n  MOD11A1 \n  MOD11A1: Mandatory QA Flags bits=[0-1] \n   [00]= class 0: LST produced, good quality, not necessary to examine more detailed QA \n   [01]= class 1: LST produced, other quality, recommend examination of more detailed QA \n   [10]= class 2: LST not produced due to cloud effects \n   [11]= class 3: LST not produced primarily due to reasons other than cloud \n  MOD11A1: Data Quality Flag bits=[2-3] \n   [00]= class 0: Good data quality of L1B in bands 31 and 32 \n   [01]= class 1: Other quality data \n   [10]= class 2: TBD \n   [11]= class 3: TBD \n  MOD11A1: Emis Error Flag bits=[4-5] \n   [00]= class 0: Average emissivity error \u2264 0.01 \n   [01]= class 1: Average emissivity error \u2264 0.02 \n   [10]= class 2: Average emissivity error \u2264 0.04 \n   [11]= class 3: Average emissivity error > 0.04 \n  MOD11A1: LST Error Flag bits=[6-7] \n   [00]= class 0: Average LST error \u2264 1 \n   [01]= class 1: Average LST error \u2264 2 \n   [10]= class 2: Average LST error \u2264 3  \n   [11]= class 3: Average LST error > 3 \n  MOD11A2 \n  MOD11A2: Mandatory QA Flags bits=[0-1] \n   [00]= class 0: LST produced, good quality, not necessary to examine more detailed QA \n   [01]= class 1: LST produced, other quality, recommend examination of more detailed QA \n   [10]= class 2: LST not produced due to cloud effects \n   [11]= class 3: LST not produced primarily due to reasons other than cloud \n  MOD11A2: Data Quality Flag bits=[2-3] \n   [00]= class 0: Good data quality of L1B in 7 TIR bands \n   [01]= class 1: Other quality data \n   [10]= class 2: TBD \n   [11]= class 3: TBD \n  MOD11A2: Emis Error Flag bits=[4-5] \n   [00]= class 0: Average emissivity error \u2264 0.01 \n   [01]= class 1: Average emissivity error \u2264 0.02 \n   [10]= class 2: Average emissivity error \u2264 0.04 \n   [11]= class 3: Average emissivity error > 0.04 \n  MOD11A2: LST Error Flag bits=[6-7] \n   [00]= class 0: Average LST error \u2264 1 \n   [01]= class 1: Average LST error \u2264 2 \n   [10]= class 2: Average LST error \u2264 3  \n   [11]= class 3: Average LST error > 3 \n  MOD13A2 \n  MOD13A2: Mandatory QA Flags 1km bits[0-1] \n   [00]= class 0: VI produced, good quality \n   [01]= class 1: VI produced, but check other QA \n   [10]= class 2: Pixel produced, but most probably cloud \n   [11]= class 3: Pixel not produced due to other reasons than clouds \n  MOD13A2: VI Usefulness Flag bits[2-5] \n   [0000]= class 0: Highest quality \n   [0001]= class 1: Lower quality \n   [0010]= class 2: Decreasing quality \n   [0100]= class 3: Decreasing quality \n   [1000]= class 4: Decreasing quality \n   [1001]= class 5: Decreasing quality \n   [1010]= class 6: Decreasing quality \n   [1100]= class 7: Lowest quality \n   [1101]= class 8: Quality so low that it is not useful \n   [1110]= class 9: L1B data faulty \n   [1111]= class 10: Not useful for any other reason/not processed \n  MOD13A2: Aerosol quantity Flags 1km bits[6-7] \n   [00]= class 0: Climatology \n   [01]= class 1: Low \n   [10]= class 2: Average \n   [11]= class 3: High \n  MOD13A2: Adjacent cloud detected 1km bit[8] \n   [00]= class 0: No \n   [01]= class 1: Yes \n  MOD13A2: Atmosphere BRDF correction performed 1km bit[9] \n   [00]= class 0: No \n   [01]= class 1: Yes \n  MOD13A2: Mixed clouds 1km bit[10] \n   [00]= class 0: No \n   [01]= class 1: Yes \n  MOD13A2: Land/Water Flags 1km bits[11-13] \n   [000]= class 0: Shallow Ocean \n   [001]= class 1: Land (Nothing else but land) \n   [010]= class 2: Ocean Coastlines and lake shorelines \n   [011]= class 3: Shallow inland water \n   [100]= class 4: Ephemeral water \n   [101]= class 5: Deep inland water \n   [110]= class 6: Moderate or continental ocean \n   [111]= class 7: Deep ocean \n  MOD13A2: Possible Snow/Ice 1km bits[14] \n   [0]= class 0: No \n   [1]= class 1: Yes \n  MOD13A2: Possible Shadow 1km bits[15] \n   [0]= class 0: No \n   [1]= class 1: Yes \n  MOD13Q1 \n  MOD13Q1: Mandatory QA Flags 250m bits[0-1] \n   [00]= class 0: VI produced, good quality \n   [01]= class 1: VI produced, but check other QA \n   [10]= class 2: Pixel produced, but most probably cloud \n   [11]= class 3: Pixel not produced due to other reasons than clouds \n  MOD13Q1: VI Usefulness Flag 250m bits[2-5] \n   [0000]= class 0: Highest quality \n   [0001]= class 1: Lower quality \n   [0010]= class 2: Decreasing quality \n   [0100]= class 3: Decreasing quality \n   [1000]= class 4: Decreasing quality \n   [1001]= class 5: Decreasing quality \n   [1010]= class 6: Decreasing quality \n   [1100]= class 7: Lowest quality \n   [1101]= class 8: Quality so low that it is not useful \n   [1110]= class 9: L1B data faulty \n   [1111]= class 10: Not useful for any other reason/not processed \n  MOD13Q1: Aerosol quantity Flags 250m bits[6-7] \n   [00]= class 0: Climatology \n   [01]= class 1: Low \n   [10]= class 2: Average \n   [11]= class 3: High \n  MOD13Q1: Adjacent cloud detected 250m bit[8] \n   [00]= class 0: No \n   [01]= class 1: Yes \n  MOD13Q1: Atmosphere BRDF correction performed 250m bit[9] \n   [00]= class 0: No \n   [01]= class 1: Yes \n  MOD13Q1: Mixed clouds 250m bit[10] \n   [00]= class 0: No \n   [01]= class 1: Yes \n  MOD13Q1: Land/Water Flags 250m bits[11-13] \n   [000]= class 0: Shallow Ocean \n   [001]= class 1: Land (Nothing else but land) \n   [010]= class 2: Ocean Coastlines and lake shorelines \n   [011]= class 3: Shallow inland water \n   [100]= class 4: Ephemeral water \n   [101]= class 5: Deep inland water \n   [110]= class 6: Moderate or continental ocean \n   [111]= class 7: Deep ocean \n  MOD13Q1: Possible Snow/Ice 250m bits[14] \n   [0]= class 0: No \n   [1]= class 1: Yes \n  MOD13Q1: Possible Shadow 250m bits[15] \n   [0]= class 0: No \n   [1]= class 1: Yes \n   \n  MCD43B2 \n  MCD43B2: Albedo Quality Ancillary Platform Data 1km bits[0-3] \n  SDS: BRDF_Albedo_Ancillary \n   [0000]= class 0: Satellite Platform: Terra \n   [0001]= class 1: Satellite Platform: Terrra/Aqua \n   [0010]= class 2: Satellite Platform: Aqua \n   [1111]= class 15: Fill Value \n   Classes 3-14: Not used \n  MCD43B2: Albedo Quality Ancillary Land/Water Data 1km bits[4-7] \n  SDS: BRDF_Albedo_Ancillary \n   [0000] class 0: Shallow Ocean \n   [0001] class 1: Land (Nothing else but land) \n   [0010] class 2: Ocean and lake shorelines \n   [0011] class 3: Shallow inland water \n   [0100] class 4: Ephemeral water \n   [0101] class 5: Deep inland water \n   [0110] class 6: Moderate or continental ocean \n   [0111] class 7: Deep ocean \n   [1111] class 15: Fill Value \n   Classes 8-14: Not used \n  MCD43B2: Albedo Quality Ancillary Sun Zenith Angle at Local Solar Noon Data 1km bits[8-14] \n  SDS: BRDF_Albedo_Ancillary \n    Returns integer value [0-90], 127 is Fill Value\n  MCD43B2: Band-wise Albedo Quality Data 1km \n  SDS: BRDF_Albedo_Band_Quality \n bits[0-3][4-7][8-11][12-15][16-19][20-23][24-27] \n   [0000]= class 0: best quality, 75% or more with best full inversions \n   [0001]= class 1: good quality, 75% or more with full inversions \n   [0010]= class 2: Mixed, 50% or less full inversions and 25% or less fill values  \n   [0011]= class 3: All magnitude inversions or 50% or less fill values  \n   [0100]= class 4: 75% or more fill values  \n   Classes 5-14: Not Used \n   [1111]= class 15: Fill Value \n ", "notes": "\n In MOD09A1: It seems that cloud related info is not filled properly in the\n standard QC (MOD09A1 in this module) since version 3, State-QA 500m images\n (MOD09A1s in this module) should be used (see Vermote et al., 2008).\n MOD11A2 quality control (QC) bands do not have a FillValue (No-data) according \n to  MODIS Land Products site . \n However, the metadata of the QC bands (i.e.:  gdalinfo QC_band ) shows  No-data=0 . \n This value is then transformed into GRASS NULLs when data is imported through \n  r.in.gdal . Applying  i.modis.qc  on those QC bands\n will not give the expected range of values in the different QC bits. Therefore, \n before using  i.modis.qc , the user needs to set the NULL value in QC bands \n back to zero (i.e.:  r.null map=QC_band null=0 ) or just edit the metadata with GDAL \n utilities before importing into GRASS GIS. This is a known issue for MOD11A2 \n (8-day LST product), but other MODIS products might be affected as well.\n  TODO \n Add more daily products.\n ", "see_also": ["i.vi"], "authors": ["Yann Chemin"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.modis.qc"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.maxlik.html", "name": "i.maxlik", "definition": "- Classifies the cell spectral reflectances in imagery data.", "keywords": ["imagery", "classification", "Maximum Likelihood Classification", "MLC"], "synopsis": "i.maxlik group=name subgroup=name signaturefile=name output=name  [reject=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "subgroup", "flag": "subgroup", "dataType": "String", "optional": false, "explanation": "Name of input imagery subgroup", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "signaturefile", "flag": "signaturefile", "dataType": "String", "optional": false, "explanation": "Name of input file containing signatures", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map holding classification results", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "reject", "flag": "reject", "dataType": "String", "optional": true, "explanation": "Name for output raster map holding reject threshold results", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.maxlik  is a maximum-likelihood discriminant\n analysis classifier.  It can be used to perform the second\n step in either an unsupervised or a supervised image\n classification.\n Either image classification methods are performed in two\n steps.  The first step in an unsupervised image\n classification is performed by\n  i.cluster ; the first step in a\n supervised classification is executed by the GRASS\n program  g.gui.iclass . In both\n cases, the second step in the image classification procedure is\n performed by  i.maxlik .\n In an unsupervised classification, the maximum-likelihood\n classifier uses the cluster means and covariance matrices\n from the  i.cluster \n signature file to determine to which category (spectral\n class) each cell in the image has the highest probability\n of belonging. In a supervised image classification, the\n maximum-likelihood classifier uses the region means and\n covariance matrices from the spectral signature file\n generated by  \n  g.gui.iclass , based on regions\n (groups of image pixels) chosen by the user, to determine\n to which category each cell in the image has the highest\n probability of belonging.\n In either case, the raster map output by\n  i.maxlik  is a classified image in which each cell\n has been assigned to a spectral class (i.e., a category).\n The spectral classes (categories) can be related to\n specific land cover types on the ground.\n ", "notes": "\n The maximum-likelihood classifier assumes that the spectral \n signatures for each class (category) in each band file\n are normally distributed (i.e., Gaussian in nature).\n Algorithms, such as\n  i.cluster ,\n  g.gui.iclass ,\n or  i.gensig ,\n however, can create signatures that are not valid \n distributed (more likely with \n  g.gui.iclass ). \n If this occurs, \n  i.maxlik \n will reject them and display a warning message.\n The signature file ( signaturefile ) contains the cluster and\n covariance matrices that were calculated by the GRASS\n program  i.cluster  (or the region\n means and covariance matrices generated by\n  g.gui.iclass , if the user\n runs a supervised classification). These spectral signatures are what\n determine the categories (classes) to which image pixels will be\n assigned during the classification process.\n The optional name of a  reject  raster map holds the reject\n threshold results. This is the result of a chi square test on each\n discriminant result at various threshold levels of confidence to\n determine at what confidence level each cell classified\n (categorized). It is the reject threshold map layer, and contains the\n index to one calculated confidence level for each classified cell in\n the classified image. 16 confidence intervals are predefined, and the\n reject map is to be interpreted as 1 = keep and 16 = reject. One of\n the possible uses for this map layer is as a mask, to identify cells\n in the classified image that have a low probability (high reject\n index) of being assigned to the correct class.\n  EXAMPLE \n Second part of the unsupervised classification of a LANDSAT subscene\n (VIZ, NIR, MIR channels) in North Carolina (see\n  i.cluster  manual page for the first\n part of the example):\n # using here the signaturefile created by i.cluster\n i.maxlik group=lsat7_2002 subgroup=lsat7_2002 \n    signaturefile=sig_cluster_lsat2002 \n    output=lsat7_2002_cluster_classes reject=lsat7_2002_cluster_reject\n # visually check result\n d.mon wx0\n d.rast.leg lsat7_2002_cluster_classes\n d.rast.leg lsat7_2002_cluster_reject\n # see how many pixels were rejected at given levels\n r.report lsat7_2002_cluster_reject units=k,p\n # optionally, filter out pixels with high level of rejection\n # here we remove pixels of at least 90% of rejection probability, i.e. categories 12-16\n r.mapcalc \"lsat7_2002_cluster_classes_filtered = \n             if(lsat7_2002_cluster_reject <= 12, lsat7_2002_cluster_classes, null())\"\n RGB composite of input data\n Output raster map with pixels classified (10 classes)\n Output raster map with rejection probability values (pixel classification confidence levels)\n ", "see_also": ["Image Processing manual"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.maxlik"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.landsat.toar.html", "name": "i.landsat.toar", "definition": "- Calculates top-of-atmosphere radiance or reflectance and temperature for Landsat MSS/TM/ETM+/OLI", "keywords": ["imagery", "radiometric conversion", "radiance", "reflectance", "brightness temperature", "atmospheric correction", "satellite", "Landsat"], "synopsis": "i.landsat.toar [-rnp] input=basename output=basename  [metfile=name]   [sensor=string]   [method=string]   [date=yyyy-mm-dd]   [sun_elevation=float]   [product_date=yyyy-mm-dd]   [gain=string]   [percent=float]   [pixel=integer]   [rayleigh=float]   [lsatmet=string[,string,...]]   [scale=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Output at-sensor radiance instead of reflectance for all bands Input raster maps use as extension the number of the band instead the code Print output metadata info Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Input raster maps use as extension the number of the band instead the code Print output metadata info Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print output metadata info Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Base name of input raster bands", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Prefix for output raster maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "metfile", "flag": "metfile", "dataType": "String", "optional": true, "explanation": "Name of Landsat metadata file (.met or MTL.txt)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sensor", "flag": "sensor", "dataType": "String", "optional": true, "explanation": "Spacecraft sensor", "defaultValue": null, "alternatives": ["mss1", "mss2", "mss3", "mss4", "mss5", "tm4", "tm5", "tm7", "oli8"], "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Atmospheric correction method", "defaultValue": "uncorrected", "alternatives": ["uncorrected", "dos1", "dos2", "dos2b", "dos3", "dos4"], "isInputFile": false, "isOutputFile": false}, {"parameter": "date", "flag": "date", "dataType": "String", "optional": true, "explanation": "Image acquisition date (yyyy-mm-dd)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sun_elevation", "flag": "sun_elevation", "dataType": "String", "optional": true, "explanation": "Sun elevation in degrees", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "product_date", "flag": "product_date", "dataType": "String", "optional": true, "explanation": "Image creation date (yyyy-mm-dd)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "gain", "flag": "gain", "dataType": "String", "optional": true, "explanation": "Gain (H/L) of all Landsat ETM+ bands (1-5,61,62,7,8)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "percent", "flag": "percent", "dataType": "String", "optional": true, "explanation": "Percent of solar radiance in path radiance", "defaultValue": "0.01", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "pixel", "flag": "pixel", "dataType": "String", "optional": true, "explanation": "Minimum pixels to consider digital number as dark object", "defaultValue": "1000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rayleigh", "flag": "rayleigh", "dataType": "String", "optional": true, "explanation": "Rayleigh atmosphere (diffuse sky irradiance)", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lsatmet", "flag": "lsatmet", "dataType": "String", "optional": true, "explanation": "return value stored for a given metadata", "defaultValue": null, "alternatives": ["number", "creation", "date", "sun_elev", "sensor", "bands", "sunaz", "time"], "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Scale factor for output", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  i.landsat.toar  is used to transform the calibrated digital\n number of Landsat imagery products to top-of-atmosphere radiance or\n top-of-atmosphere reflectance and temperature (band 6 of the sensors\n TM and ETM+). Optionally, it can be used to calculate the at-surface\n radiance or reflectance with atmospheric correction (DOS method).\n Usually, to do so the production date, the acquisition date, and the\n solar elevation are needed. Moreover, for Landsat-7 ETM+ it is also\n needed the gain (high or low) of the nine respective bands.\n Optionally (recommended), the data can be read from metadata file\n (.met or MTL.txt) for all Landsat MSS, TM, ETM+ and OLI/TIRS. However,\n if the solar elevation is given the value of the metadata file is\n overwritten. This is necessary when the data in the .met file is\n incorrect or not accurate. Also, if acquisition or production dates are\n not found in the metadata file then the command line values are used.\n  Attention : Any null value or smaller than QCALmin in the input\n raster is set to null in the output raster and it is not included in\n the equations.\n  Uncorrected at-sensor values (method=uncorrected, default) \n The standard geometric and radiometric corrections result in a\n calibrated digital number (QCAL = DN) images. To further standardize\n the impact of illumination geometry, the QCAL images are first\n converted first to at-sensor radiance and then to at-sensor\n reflectance. The thermal band is first converted from QCAL to\n at-sensor radiance, and then to effective at-sensor temperature in\n Kelvin degrees.\n Radiometric calibration converts QCAL to  at-sensor radiance , a\n radiometric quantity measured in W/(m\u00b2 * sr * \u00b5m) using the\n equations:\n     gain = (Lmax - Lmin) / (QCALmax - QCALmin) \n     bias = Lmin - gain * QCALmin  \n     radiance = gain * QCAL + bias  \n where,  Lmax  and  Lmin  are the calibration constants,\n and  QCALmax  and  QCALmin  are the highest and the\n lowest points of the range of rescaled radiance in QCAL.\n Then, to calculate  at-sensor reflectance  the equations are:\n     sun_radiance = [Esun * sin(e)] / (PI * d^2) \n     reflectance = radiance / sun_radiance  \n where,  d  is the earth-sun distance in astronomical\n units,  e  is the solar elevation angle, and  Esun  is\n the mean solar exoatmospheric irradiance in W/(m\u00b2 * \u00b5m).\n  Simplified at-surface values (method=dos[1-4]) \n Atmospheric correction and reflectance calibration remove the path\n radiance, i.e. the stray light from the atmosphere, and the spectral\n effect of solar illumination. To output these simple  at-surface\n radiance  and  at-surface reflectance , the equations are (not\n for thermal bands):\n     sun_radiance = TAUv * [Esun * sin(e) * TAUz + Esky] / (PI * d^2)  \n     radiance_path = radiance_dark - percent * sun_radiance  \n     radiance = (at-sensor_radiance - radiance_path)  \n     reflectance = radiance / sun_radiance  \n where,  percent  is a value between 0.0 and 1.0 (usually\n 0.01),  Esky  is the diffuse sky irradiance,  TAUz  is\n the atmospheric transmittance along the path from the sun to the\n ground surface, and  TAUv  is the atmospheric transmittance\n along the path from the ground surface to the\n sensor.  radiance_dark  is the at-sensor radiance calculated\n from the darkest object, i.e. DN with a least 'dark_parameter'\n (usually 1000) pixels for the entire image.\n The values are,\n    DOS1: TAUv = 1.0, TAUz = 1.0 and Esky = 0.0 \n    DOS2: TAUv = 1.0, Esky = 0.0, and TAUz = sin(e) for all bands\n     with maximum wave length less than 1. (i.e. bands 4-6 MSS, 1-4 TM,\n     and 1-4 ETM+) other bands TAUz = 1.0 \n    DOS3: TAUv = exp[-t/cos(sat_zenith)],\n     TAUz = exp[-t/sin(e)], Esky = rayleigh \n    DOS4: TAUv = exp[-t/cos(sat_zenith)],\n     TAUz = exp[-t/sin(e)], Esky = PI * radiance_dark  \n  Attention : Output radiance remain untouched (i.e. no set to 0.0\n when it is negative) then they are possible negative values. However,\n output reflectance is set to 0.0 when is obtained a negative value.\n ", "notes": "\n The output raster cell values can be rescaled with the  scale \n parameter (e.g., with 100 in case of using reflectance output\n in  i.gensigset ).\n  On Landsat-8 metadata file  \n NASA reports a structure of the L1G Metadata file \n ( LDCM-DFCB-004.pdf ) \n for Landsat Data Continuity Mission (i.e. Landsat-8).\n NASA retains in MIN_MAX_RADIANCE group the necessary information \n to transform Digital Numbers (DN) in radiance values. Then, \n  i.landsat.toar  replaces the possible standard values with the \n metadata values. The results match with the values reported by the \n metada file in RADIOMETRIC_RESCALING group.\n Also, NASA reports the same values of reflectance for all bands \n in max-min values and in gain-bias values. This is strange that all \n bands have the same range of reflectance. Also, they wrote in the \n web page as to calculate reflectance directly from DN, first with \n RADIOMETRIC_RESCALING values and second divided by sin(sun_elevation).\n This is a simple rescaling \n     reflectance = radiance / sun_radiance = (DN * RADIANCE_MULT + RADIANCE_ADD) / sun_radiance \n     now reflectance = DN * REFLECTANCE_MULT + REFLECTANCE_ADD  \n     then REFLECTANCE_MULT = RADIANCE_MULT / sun_radiance  \n     and REFLECTANCE_ADD = RADIANCE_ADD / sun_radiance  \n The problem arises when we need ESUN values (not provided) to \n compute sun_radiance and DOS. We assume that REFLECTANCE_MAXIMUM \n corresponds to the RADIANCE_MAXIMUM, then\n     REFLECTANCE_MAXIMUM / sin(e) = RADIANCE_MAXIMUM / sun_radiance \n     Esun = (PI * d^2) * RADIANCE_MAXIMUM / REFLECTANCE_MAXIMUM  \n where  d  is the earth-sun distance provided by metadata file \n or computed inside the program.\n The  i.landsat.toar  reverts back the NASA rescaling to continue \n using Lmax, Lmin, and Esun values to compute the constant to convert \n DN to radiance and radiance to reflectance with the \"traditional\" \n equations and simple atmospheric corrections.\n  Attention : When MAXIMUM values are not provided,\n  i.landsat.toar  tries to calculate Lmax, Lmin, and Esun from \n RADIOMETRIC_RESCALING (in tests the results were the same).\n  Calibration constants \n In verbose mode (flag  --verbose ), the program write basic\n satellite data and the parameters used in the transformations.\n Production date is not an exact value but it is necessary to apply\n correct calibration constants, which were changed in the dates:\n    Landsat-1 MSS: never  \n    Landsat-2 MSS: July 16, 1975 \n    Landsat-3 MSS: June 1, 1978 \n    Landsat-4 MSS: August 26, 1982 and April 1, 1983 \n    Landsat-4 TM:  August 1, 1983 and January 15, 1984 \n    Landsat-5 MSS: April 6, 1984 and November 9, 1984 \n    Landsat-5 TM:  May 4, 2003 and April, 2 2007 \n    Landsat-7 ETM+: July 1, 2000 \n    Landsat-8 OLI/TIRS: launched in 2013 \n  EXAMPLES \n  Metadata file examples \n Transform digital numbers of Landsat-7 ETM+ in band rasters 203_30.1,\n 203_30.2 [...] to uncorrected at-sensor reflectance in output files\n 203_30.1_toar, 203_30.2_toar [...] and at-sensor temperature in output\n files 293_39.61_toar and 293_39.62_toar:\n i.landsat.toar input=203_30. output=_toar \n    metfile=p203r030_7x20010620.met\n or\n i.landsat.toar input=L5121060_06020060714. \n    output=L5121060_06020060714_toar \n    metfile=L5121060_06020060714_MTL.txt\n or\n i.landsat.toar input=LC80160352013134LGN03_B output=toar \n    metfile=LC80160352013134LGN03_MTL.txt sensor=oli8 date=2013-05-14\n  DOS1 example \n DN to reflectance using DOS1:\n # rename channels or make a copy to match i.landsat.toar's input scheme:\n g.copy raster=lsat7_2002_10,lsat7_2002.1\n g.copy raster=lsat7_2002_20,lsat7_2002.2\n g.copy raster=lsat7_2002_30,lsat7_2002.3\n g.copy raster=lsat7_2002_40,lsat7_2002.4\n g.copy raster=lsat7_2002_50,lsat7_2002.5\n g.copy raster=lsat7_2002_61,lsat7_2002.61\n g.copy raster=lsat7_2002_62,lsat7_2002.62\n g.copy raster=lsat7_2002_70,lsat7_2002.7\n g.copy raster=lsat7_2002_80,lsat7_2002.8\n Calculation of reflectance values from DN using DOS1 (metadata obtained\n from  p016r035_7x20020524.met.gz ):\n i.landsat.toar input=lsat7_2002. output=lsat7_2002_toar. sensor=tm7 \n    method=dos1 date=2002-05-24 sun_elevation=64.7730999 \n    product_date=2004-02-12 gain=HHHLHLHHL\n The resulting Landsat channels are named  lsat7_2002_toar.1 .. lsat7_2002_toar.8 .\n  REFERENCES \n    Chander G., B.L. Markham and D.L. Helder, 2009: Remote Sensing of\n     Environment, vol. 113 \n    Chander G.H. and B. Markham, 2003.: IEEE Transactions On Geoscience And\n     Remote Sensing, vol. 41, no. 11. \n    Chavez P.S., jr. 1996. Image-based atmospheric corrections -\n     Revisited and Improved. Photogrammetric Engineering and Remote\n     Sensing 62(9): 1025-1036. \n    Huang et al: At-Satellite Reflectance, 2002: A First Order Normalization\n     Of Landsat 7 ETM+ Images. \n    R. Irish:  Landsat\n       7. Science Data Users Handbook . February 17, 2007; 15 May 2011. \n    Markham B.L. and J.L. Barker, 1986: Landsat MSS and TM Post-Calibration\n     Dynamic Ranges, Exoatmospheric Reflectances and At-Satellite\n     Temperatures. EOSAT Landsat Technical Notes, No. 1. \n    Moran M.S., R.D. Jackson, P.N. Slater and P.M. Teillet, 1992: Remote\n     Sensing of Environment, vol. 41. \n    Song et al, 2001: Classification and Change Detection Using Landsat TM\n     Data, When and How to Correct Atmospheric Effects? Remote Sensing\n     of Environment, vol. 75. \n ", "see_also": ["i.atcorr", "r.mapcalc", "r.in.gdal"], "authors": ["E. Jorge Tizado (ej.tizado unileon es), Dept. Biodiversity and Environmental Management, University of Le\u00f3n, Spain"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.landsat.toar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.landsat.acca.html", "name": "i.landsat.acca", "definition": "- Performs Landsat TM/ETM+ Automatic Cloud Cover Assessment (ACCA).", "keywords": ["imagery", "ACCA", "cloud detection", "satellite", "Landsat"], "synopsis": "i.landsat.acca [-5fx2s] input=basename output=name  [b56composite=float]   [b45ratio=float]   [histogram=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "5", "flag": "-5", "explanation": "Data is Landsat-5 TM I.e. Thermal band is '.6' not '.61') Apply post-processing filter to remove small holes Always use cloud signature (step 14) Bypass second-pass processing, and merge warm (not ambiguous) and cold clouds Include a category for cloud shadows Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Apply post-processing filter to remove small holes Always use cloud signature (step 14) Bypass second-pass processing, and merge warm (not ambiguous) and cold clouds Include a category for cloud shadows Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "x", "flag": "-x", "explanation": "Always use cloud signature (step 14) Bypass second-pass processing, and merge warm (not ambiguous) and cold clouds Include a category for cloud shadows Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "2", "flag": "-2", "explanation": "Bypass second-pass processing, and merge warm (not ambiguous) and cold clouds Include a category for cloud shadows Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Include a category for cloud shadows Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Base name of input raster bands", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "b56composite", "flag": "b56composite", "dataType": "String", "optional": true, "explanation": "B56composite (step 6)", "defaultValue": "225.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "b45ratio", "flag": "b45ratio", "dataType": "String", "optional": true, "explanation": "B45ratio: Desert detection (step 10)", "defaultValue": "1.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "histogram", "flag": "histogram", "dataType": "String", "optional": true, "explanation": "Number of classes in the cloud temperature histogram", "defaultValue": "100", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  i.landsat.acca  implements the  Automated Cloud-Cover\n Assessment  (ACCA) Algorithm from Irish (2000) with the constant\n values for pass filter one from Irish et al. (2006). To do this, it\n needs Landsat band numbers 2, 3, 4, 5, and 6 (or band 61 for Landsat-7\n ETM+) which have already been processed from DN into reflectance and\n band-6 temperature\n with  i.landsat.toar ).\n  The ACCA algorithm gives good results over most of the planet with the\n exception of ice sheets because ACCA operates on the premise that\n clouds are colder than the land surface they cover. The algorithm was\n designed for Landsat-7 ETM+ but because reflectance is used it is also\n useful for Landsat-4/5 TM.\n ", "notes": "\n  i.landsat.acca  works in the current region settings.\n  EXAMPLES \n Run the standard ACCA algorithm with filling of small cloud holes\n (the  -f  flag): With per-band reflectance raster maps\n named  226_62.toar.1, 226_62.toar.2,   [...] and LANDSAT-7\n thermal band  226_62.toar.61 , outputting to a new raster map\n named  226_62.acca :\n i.landsat.toar sensor=7 gain=HHHLHLHHL date=2003-04-07 \n    product_date=2008-11-27 band_prefix=226_62 solar_elevation=49.51654\n i.landsat.acca -f band_prefix=226_62.toar output=226_62.acca\n  REFERENCES \n    Irish R.R., Barker J.L., Goward S.N., and Arvidson T., 2006.\n     Characterization of the Landsat-7 ETM+ Automated Cloud-Cover\n     Assessment (ACCA) Algorithm. Photogrammetric Engineering and Remote\n     Sensing vol. 72(10): 1179-1188. \n   \n    Irish, R.R., 2000. Landsat 7 Automatic Cloud Cover Assessment. In\n     S.S. Shen and M.R. Descour (Eds.): Algorithms for Multispectral,\n     Hyperspectral, and Ultraspectral Imagery VI. Proceedings of SPIE,\n     4049: 348-355. \n ", "see_also": ["i.atcorr", "i.landsat.toar"], "authors": ["E. Jorge Tizado (ej.tizado unileon es), Dept. Biodiversity and Environmental Management, University of Le\u00f3n, Spain"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.landsat.acca"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.in.spotvgt.html", "name": "i.in.spotvgt", "definition": "- Imports SPOT VGT NDVI data into a raster map.", "keywords": ["imagery", "import", "NDVI", "SPOT"], "synopsis": "i.in.spotvgt [-a] input=name  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Also import quality map (SM status map layer) and filter NDVI map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input SPOT VGT NDVI HDF file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.in.spotvgt  imports SPOT Vegetation (1km, global) NDVI data sets.\n After import the digital numbers (DN) are remapped to VEGETATION NDVI\n values and the NDVI color table is applied. The imported DN map is \n removed after remapping.\n  Apparently missing raster cells due to bad pixel quality are reconstructed\n by the SPOT operating team in the NDVI file. The differences between the\n filtered (-a flag) and raw NDVI map should be compared.\n ", "notes": "\n The SPOT VGT files are delivered in HDF4 (Hierarchical Data Format Release 4)\n format. It is required to have the GDAL libraries installed with HDF4 support.\n  Export of entire world SPOT VGT maps \n When working with SPOT VGT with entire world extent, it is recommended\n to zoom to  w=180W  and  e=180E  instead of using the map\n extent for map export. These entire world SPOT VGT data are exceeding\n -180.0 degree which can lead to unhelpful large East-West coordinates in\n the exported file. It is also recommended to then use an export command\n which respects the user settings. Example:\n # import:\n i.in.spotvgt 0001_NDV.HDF\n # export:\n g.region w=180W e=180E n=75:00:16.071429N s=56:00:16.069919S res=0:00:32.142857 -p\n r.out.gdal 0001_NDV format=GTiff out=spotndvi.tif\n ", "see_also": ["r.in.gdal", "r.out.gdal"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/i.in.spotvgt"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.image.mosaic.html", "name": "i.image.mosaic", "definition": "- Mosaics several images and extends colormap.", "keywords": ["imagery", "geometry", "mosaicking"], "synopsis": "i.image.mosaic input=name[,name,...] output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.image.mosaic  mosaics several images or raster maps using the\n GRASS GIS map calculator, and extends the colormap to the range of all images.\n ", "notes": "", "see_also": ["r.patch", "r.mapcalc"], "authors": ["Markus Neteler, ITC-Irst, Trento, Italy Updated to GRASS 5.7 by Michael Barton, Arizona State University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/i.image.mosaic"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.ifft.html", "name": "i.ifft", "definition": "- Inverse Fast Fourier Transform (IFFT) for image processing.", "keywords": ["imagery", "transformation", "Fast Fourier Transform"], "synopsis": "i.ifft real=name imaginary=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "real", "flag": "real", "dataType": "String", "optional": false, "explanation": "Name of input raster map (image fft, real part)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "imaginary", "flag": "imaginary", "dataType": "String", "optional": false, "explanation": "Name of input raster map (image fft, imaginary part", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.ifft  is an image processing program based on the algorithm given\n by Frigo et al. (1998), that converts real and imaginary frequency space\n images (produced by\n  i.fft ) into a normal image.\n ", "notes": "\n The current mask is respected when reading the real and imaginary \n component files;  thus, creating a mask is a primary step for selecting \n the portion of the frequency space data to be included in the inverse \n transform.  The module  wxGUI vector digitizer \n can be used to create masks while viewing the real \n or imaginary component image. Alternatively  r.circle  can be \n used to generate high-, low- and donut filters specifying the DC point \n as circle/ring center. When  i.ifft  is executed, it \n (automatically) uses the same GRASS region definition setting that was \n used during the original transformation done with\n  i.fft .\n ", "see_also": ["i.cca", "g.gui.iclass", "i.fft", "i.pca", "r.circle", "wxGUI vector digitizer"], "authors": ["David Satnik, GIS Laboratory, Central Washington University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.ifft"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.his.rgb.html", "name": "i.his.rgb", "definition": "- Transforms raster maps from HIS (Hue-Intensity-Saturation) color space to RGB (Red-Green-Blue) color space.", "keywords": ["imagery", "color transformation", "RGB", "HIS", "IHS"], "synopsis": "i.his.rgb hue=name intensity=name saturation=name red=name green=name blue=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "hue", "flag": "hue", "dataType": "String", "optional": false, "explanation": "Name of input raster map (hue)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "intensity", "flag": "intensity", "dataType": "String", "optional": false, "explanation": "Name of input raster map (intensity)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "saturation", "flag": "saturation", "dataType": "String", "optional": false, "explanation": "Name of input raster map (saturation)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": false, "explanation": "Name for output raster map (red)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": false, "explanation": "Name for output raster map (green)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": false, "explanation": "Name for output raster map (blue)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.his.rgb  is an image processing program that\n processes three input raster map layers as hue, intensity\n and saturation components and produces three output raster\n map layers representing the red, green and blue components\n of this data.  The output raster map layers are created by\n a standard hue-intensity-saturation (HIS) to red-green-blue\n (RGB) color transformation.  Each output raster map layer\n is given a linear gray scale color table.  The current\n geographic region and mask settings are respected.\n ", "notes": "\n It is not possible to process three bands with\n  i.his.rgb  and then exactly recover the original\n bands with  i.rgb.his .  \n This is due to loss of precision because of integer\n computations and rounding.  Tests have shown that more than\n 70% of the original cell values will be reproduced exactly\n after transformation in both directions and that 99% will\n be within plus or minus 1.  A few cell values may differ\n significantly from their original values.\n ", "see_also": ["i.rgb.his", "r.colors"], "authors": ["David Satnik, GIS Laboratory, Central Washington University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.his.rgb"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.group.html", "name": "i.group", "definition": "- Creates, edits, and lists groups of imagery data.", "keywords": ["imagery", "map management"], "synopsis": "i.group [-rlsg] group=name  [subgroup=name]   [input=name[,name,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Remove selected files from specified group or subgroup List files from specified (sub)group List subgroups from specified group Print in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List files from specified (sub)group List subgroups from specified group Print in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "List subgroups from specified group Print in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of imagery group", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "subgroup", "flag": "subgroup", "dataType": "String", "optional": true, "explanation": "Name of imagery subgroup", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of raster map(s) to include in group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}], "description": "\n  i.group  allows the user to collect raster map layers in an imagery\n group by assigning them to user-named subgroups or other groups. This\n enables the user to run analyses on any combination of the raster map layers\n in a group.  The user creates the groups and subgroups and selects the\n raster map layers that are to reside in them. Imagery analysis programs like\n  g.gui.gcp , \n  i.rectify ,\n  i.ortho.photo  and\n others ask the user for the name of an imagery group whose data are to be\n analyzed. Imagery analysis programs like\n  i.cluster  and \n  i.maxlik  ask the user for the imagery group\n and imagery subgroup whose data are to be analyzed.\n ", "notes": "\n The  i.group  options are only available for \n imagery map layers in the current LOCATION_NAME.\n  Subgroup names may not contain more than 12 characters.\n  EXAMPLE \n This example runs in the \"landsat\" mapset of the North Carolina sample\n dataset. The following command creates a group and subgroup containing\n only the visible light bands of Landsat-7:\n i.group group=vis_bands subgroup=vis_bands input=lsat7_2000_10,lsat7_2000_20,lsat7_2000_30\n ", "see_also": ["Image Processing manual"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.group"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.gensigset.html", "name": "i.gensigset", "definition": "- Generates statistics for i.smap from raster map.", "keywords": ["imagery", "classification", "supervised classification", "SMAP", "signatures"], "synopsis": "i.gensigset trainingmap=name group=name subgroup=name signaturefile=name  [maxsig=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "trainingmap", "flag": "trainingmap", "dataType": "String", "optional": false, "explanation": "Ground truth training map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "subgroup", "flag": "subgroup", "dataType": "String", "optional": false, "explanation": "Name of input imagery subgroup", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "signaturefile", "flag": "signaturefile", "dataType": "String", "optional": false, "explanation": "Name for output file containing result signatures", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "maxsig", "flag": "maxsig", "dataType": "String", "optional": true, "explanation": "Maximum number of sub-signatures in any class", "defaultValue": "5", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  i.gensigset \n is a non-interactive method for generating input into\n  i.smap . \n It is used as the first pass in the a two-pass\n classification process.  It reads a raster map layer,\n called the training map, which has some of the pixels or\n regions already classified.   i.gensigset  will then\n extract spectral signatures from an image based on the\n classification of the pixels in the training map and make\n these signatures available to\n  i.smap . \n The user would then execute the GRASS program  \n  i.smap  to create the\n final classified map.\n  OPTIONS \n  Parameters \n  trainingmap= name  \n  ground truth training map\n This raster layer, supplied as input by the user, has some\n of its pixels already classified, and the rest (probably\n most) of the pixels unclassified.  Classified means that\n the pixel has a non-zero value and unclassified means that\n the pixel has a zero value.\n This map must be prepared by the user in advance by using\n a combination of\n  wxGUI vector digitizer \n and \n  v.to.rast ,\n or some other import/developement process (e.g.,\n  v.transects ) \n to define the areas representative of the classes in the image.\n At present, there is no fully-interactive tool specifically\n designed for producing this layer.\n  group= name  \n  imagery group\n This is the name of the group that contains the band files\n which comprise the image to be analyzed. The\n  i.group \n command is used to construct groups of raster layers which\n comprise an image.\n  subgroup= name  \n  subgroup containing image files\n This names the subgroup within the group that selects a\n subset of the bands to be analyzed. The\n  i.group \n command is also used to prepare this subgroup.  The\n subgroup mechanism allows the user to select a subset of\n all the band files that form an image.\n  signaturefile= name \n  resultant signature file\n This is the resultant signature file (containing the means\n and covariance matrices) for each class in the training map\n that is associated with the band files in the subgroup\n selected.\n  maxsig= value  \n  maximum number of sub-signatures in any class\n default: 5\n The spectral signatures which are produced by this program\n are \"mixed\" signatures (see  NOTES ).\n Each signature contains one or more subsignatures\n (represeting subclasses).  The algorithm in this program\n starts with a maximum number of subclasses and reduces this\n number to a minimal number of subclasses which are\n spectrally distinct.  The user has the option to set this\n starting value with this option.\n  INTERACTIVE MODE \n If none of the arguments are specified on the command line,\n  i.gensigset  will interactively prompt for the\n names of these maps and files.\n It should be noted that interactive mode here only means\n interactive prompting for maps and files.  It does not mean\n visualization of the signatures that result from the\n process.\n ", "notes": "\n The algorithm in  i.gensigset  determines the\n parameters of a spectral class model known as a Gaussian\n mixture distribution.  The parameters are estimated using\n multispectral image data and a training map which labels\n the class of a subset of the image pixels.  The mixture\n class parameters are stored as a class signature which can\n be used for subsequent segmentation (i.e., classification)\n of the multispectral image.\n The Gaussian mixture class is a useful model because it can\n be used to describe the behavior of an information class\n which contains pixels with a variety of distinct spectral\n characteristics.  For example, forest, grasslands or urban\n areas are examples of information classes that a user may\n wish to separate in an image.  However, each of these\n information classes may contain subclasses each with its\n own distinctive spectral characteristic.  For example, a\n forest may contain a variety of different tree species each\n with its own spectral behavior.\n The objective of mixture classes is to improve segmentation\n performance by modeling each information class as a\n probabilistic mixture with a variety of subclasses.  The\n mixture class model also removes the need to perform an\n initial unsupervised segmentation for the purposes of\n identifying these subclasses.  However, if misclassified\n samples are used in the training process, these erroneous\n samples may be grouped as a separate undesired subclass.\n Therefore, care should be taken to provided accurate\n training data.\n This clustering algorithm estimates both the number of\n distinct subclasses in each class, and the spectral mean\n and covariance for each subclass.  The number of subclasses\n is estimated using Rissanen's minimum description length\n (MDL) criteria \n [ 1 ].  \n This criteria attempts to determine\n the number of subclasses which \"best\" describe the data.\n The approximate maximum likelihood estimates of the mean\n and covariance of the subclasses are computed using the\n expectation maximization (EM) algorithm \n [ 2 , 3 ].  \n  WARNINGS \n If warnings like this occur, reducing the remaining classes to 0:\n ...\n WARNING: Removed a singular subsignature number 1 (4 remain)\n WARNING: Removed a singular subsignature number 1 (3 remain)\n WARNING: Removed a singular subsignature number 1 (2 remain)\n WARNING: Removed a singular subsignature number 1 (1 remain)\n WARNING: Unreliable clustering. Try a smaller initial number of clusters\n WARNING: Removed a singular subsignature number 1 (-1 remain)\n WARNING: Unreliable clustering. Try a smaller initial number of clusters\n Number of subclasses is 0\n then the user should check for:\n  the range of the input data should be between 0 and 100 or 255 but not\n   between 0.0 and 1.0 ( r.info  and  r.univar  show the range) \n  the training areas need to contain a sufficient amount of pixels \n  REFERENCES \n  J. Rissanen, \n \"A Universal Prior for Integers and Estimation by Minimum Description Length,\"\n  Annals of Statistics,  vol. 11, no. 2, pp. 417-431, 1983. \n  A. Dempster, N. Laird and D. Rubin, \n \"Maximum Likelihood from Incomplete Data via the EM Algorithm,\"\n  J. Roy. Statist. Soc. B,  vol. 39, no. 1, pp. 1-38, 1977. \n  E. Redner and H. Walker, \n \"Mixture Densities, Maximum Likelihood and the EM Algorithm,\"\n  SIAM Review,  vol. 26, no. 2, April 1984. \n ", "see_also": ["i.group", "i.smap", "r.info", "r.univar", "wxGUI vector digitizer"], "authors": ["Charles Bouman, School of Electrical Engineering, Purdue University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.gensigset"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.gensig.html", "name": "i.gensig", "definition": "- Generates statistics for i.maxlik from raster map.", "keywords": ["imagery", "classification", "supervised classification", "Maximum Likelihood Classification", "MLC", "signatures"], "synopsis": "i.gensig trainingmap=name group=name subgroup=name signaturefile=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "trainingmap", "flag": "trainingmap", "dataType": "String", "optional": false, "explanation": "Ground truth training map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "subgroup", "flag": "subgroup", "dataType": "String", "optional": false, "explanation": "Name of input imagery subgroup", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "signaturefile", "flag": "signaturefile", "dataType": "String", "optional": false, "explanation": "Name for output file containing result signatures", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.gensig \n is a non-interactive method for generating input into \n  i.maxlik .\n It can be used as the first pass in the GRASS two-pass \n classification process (instead of \n  i.cluster \n  or \n  g.gui.iclass ) .\n It reads a raster map layer, called the training map, which\n has some of the pixels or regions already classified.\n  i.gensig  will then extract spectral signatures\n from an image based on the classification of the pixels in\n the training map and make these signatures available to\n  i.maxlik .\n The user would then execute the GRASS program \n  i.maxlik \n to actually create the final classified map.\n  OPTIONS \n  Parameters \n  trainingmap= name \n  ground truth training map\n This map must be prepared by the user in advance using vector or\n raster digitizer. Of course other methods could be devised by the user\n for creating this training map -  i.gensig  makes no assumption\n about the origin of this map layer. It simply creates signatures for\n the classes defined in the training map for the image to be classified\n (the image is specified in other options - see below). The\n  wxGUI vector digitizer  can be\n used for interactively creating the training map.\n  group= name  \n  imagery group\n This is the name of the group that contains the band files\n which comprise the image to be analyzed. The  \n  i.group    command is\n used to construct groups of raster layers which comprise an\n image.\n  subgroup= name \n  subgroup containing image files\n This names the subgroup within the group that selects a\n subset of the bands to be analyzed. The  \n  i.group    command is\n also used to prepare this subgroup.  The subgroup mechanism\n allows the user to select a subset of all the band files\n that form an image.\n  signaturefile= name  \n  resultant signature file\n This is the resultant signature file (containing the means\n and covariance matrices) for each class in the training map\n that is associated with the band files in the subgroup\n select (see  above ).\n  INTERACTIVE MODE \n If none of the arguments are specified on the command line, \n  i.gensig \n will interactively prompt for the names of these maps and files.\n It should be noted that interactive mode here only means\n interactive prompting for maps and files.\n It does not mean visualization of the signatures that\n result from the process.\n ", "notes": "\n The structure of the SIG files generated by  i.gensig  is\n as follows (ASCII file, used internally by  i.maxlik ):\n  Note: the line numbers are not present in the file but have been\n added here for explanation only :\n SIG file \"lsat7_2000_gensig\":\n  1 #\n  2 #water\n  3 4186\n  4 67.9508 48.7346 37.8915 15.3129 13.8473 12.0855 \n  5 1.74334 \n  6 0.439504 2.07267 \n  7 0.662523 1.63501 4.21189 \n  8 0.530339 2.40757 5.52857 22.433 \n  9 0.561184 2.30762 5.18846 20.5364 20.4926 \n 10 0.393218 1.2184 2.63628 9.61528 9.36025 5.85314 \n   Line 2: text label\n   Line 3: number of points in class\n   Line 4: mean values per band of the class\n   Line 5-10: (semi)-matrix of band-band covariance\n ", "see_also": ["g.gui.iclass", "i.group", "i.smap", "r.info", "r.univar", "wxGUI vector digitizer"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.gensig"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.fft.html", "name": "i.fft", "definition": "- Fast Fourier Transform (FFT) for image processing.", "keywords": ["imagery", "transformation", "Fast Fourier Transform"], "synopsis": "i.fft input=name real=name imaginary=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "real", "flag": "real", "dataType": "String", "optional": false, "explanation": "Name for output real part arrays stored as raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "imaginary", "flag": "imaginary", "dataType": "String", "optional": false, "explanation": "Name for output imaginary part arrays stored as raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.fft  is an image processing program based on the FFT algorithm\n given by Frigo et al. (1998), that processes a single input raster map layer\n ( input ) and constructs the real and imaginary Fourier\n components in frequency space.\n ", "notes": "\n The real and imaginary components are stored into the\n  real  and  imaginary  raster map\n layers.  In these raster map\n layers the low frequency components are in the center and\n the high frequency components are toward the edges.  The\n  input  need not be square. A\n color table is assigned to the resultant map layer.\n The current geographic region and mask settings are respected when\n reading the input file. The presence of nulls or a mask will make the\n resulting fast Fourier transform invalid.\n  EXAMPLE \n North Carolina example:\n g.region raster=lsat7_2002_70\n i.fft input=lsat7_2002_70 real=lsat7_2002_70.real imaginary=lsat7_2002_70.imag\n # set region to resulting FFT output map (due to new FFT coordinate space):\n g.region raster=lsat7_2002_70.real -p\n d.mon x0\n d.rast lsat7_2002_70.real\n d.rast lsat7_2002_70.imag\n  REFERENCES \n   M. Frigo and S. G. Johnson (1998): \"FFTW: An Adaptive Software Architecture\n for the FFT\". See  www.FFTW.org : FFTW is a C subroutine library\n for computing the Discrete Fourier Transform (DFT) in one or more\n dimensions, of both real and complex data, and of arbitrary input size.\n   John A. Richards, 1986. Remote Sensing Digital Image Analysis, Springer-Verlag.\n  Personal communication, between progam author and Ali R. Vali,\n Space Research Center,  University of Texas , Austin, 1990.\n ", "see_also": ["i.cca", "g.gui.iclass", "i.ifft", "i.pca"], "authors": ["David Satnik, GIS Laboratory, Central Washington University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.fft"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.evapo.time.html", "name": "i.evapo.time", "definition": "- Computes temporal integration of satellite ET actual (ETa) following the daily ET reference (ETo) from meteorological station(s).", "keywords": ["imagery", "evapotranspiration"], "synopsis": "i.evapo.time eta=name[,name,...] eta_doy=name[,name,...] eto=name[,name,...] eto_doy_min=float start_period=float end_period=float output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "eta", "flag": "eta", "dataType": "String", "optional": false, "explanation": "Names of satellite ETa raster maps [mm/d or cm/d]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "eta_doy", "flag": "eta_doy", "dataType": "String", "optional": false, "explanation": "Names of satellite ETa Day of Year (DOY) raster maps [0-400] [-]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "eto", "flag": "eto", "dataType": "String", "optional": false, "explanation": "Names of meteorological station ETo raster maps [0-400] [mm/d or cm/d]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "eto_doy_min", "flag": "eto_doy_min", "dataType": "String", "optional": false, "explanation": "Value of DOY for ETo first day", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_period", "flag": "start_period", "dataType": "String", "optional": false, "explanation": "Value of DOY for the first day of the period studied", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "end_period", "flag": "end_period", "dataType": "String", "optional": false, "explanation": "Value of DOY for the last day of the period studied", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.evapo.time  (i.evapo.time_integration) integrates ETa in time following a\n reference ET (typically) from a set of meteorological stations dataset.\n Inputs:\n   ETa images\n   ETa images DOY (Day of Year)\n   ETo images\n   ETo DOYmin as a single value \n Method:\n   each ETa pixel is divided by the same day ETo and become ETrF\n   each ETrF pixel is multiplied by the ETo sum for the representative days\n   Sum all n temporal [ETrF*ETo_sum] pixels to make a summed(ET) in [DOYmin;DOYmax]\n representative days calculation:\n let assume i belongs to range [DOYmin;DOYmax]\n DOYbeforeETa[i] = ( DOYofETa[i] - DOYofETa[i-1] ) / 2\n DOYafterETa[i] = ( DOYofETa[i+1] - DOYofETa[i] ) / 2\n ", "notes": "\n ETo images preparation:\n If you only have one meteorological station data set, the easiest way is:\n n=0\n for ETo_val in Eto[1] Eto[2] ...\n do\n \tr.mapcalc \"eto$n = $ETo_val\" \n \t`expr n = n + 1`\n done\n with Eto[1], Eto[2], etc being a simple copy and paste from your data file\n of all ETo values separated by an empty space from each other.\n If you have several meteorological stations data, then you need to grid\n them by generating Thiessen polygons or using different interpolation methods\n for each day.\n For multi-year calculations, just continue incrementing DOY values above\n 366, it will continue working, up to maximum input of 400 satellite images.\n ", "see_also": ["i.eb.eta", "i.evapo.mh", "i.evapo.pt", "i.evapo.pm", "r.sun"], "authors": ["Yann Chemin, International Rice Research Institute, The Philippines"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.evapo.time"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.evapo.pt.html", "name": "i.evapo.pt", "definition": "- Computes evapotranspiration calculation Priestley and Taylor formulation, 1972.", "keywords": ["imagery", "evapotranspiration"], "synopsis": "i.evapo.pt [-z] net_radiation=name soil_heatflux=name air_temperature=name atmospheric_pressure=name priestley_taylor_coeff=float output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Set negative ETa to zero Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "net_radiation", "flag": "net_radiation", "dataType": "String", "optional": false, "explanation": "Name of input net radiation raster map [W/m2]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "soil_heatflux", "flag": "soil_heatflux", "dataType": "String", "optional": false, "explanation": "Name of input soil heat flux raster map [W/m2]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "air_temperature", "flag": "air_temperature", "dataType": "String", "optional": false, "explanation": "Name of input air temperature raster map [K]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "atmospheric_pressure", "flag": "atmospheric_pressure", "dataType": "String", "optional": false, "explanation": "Name of input atmospheric pressure raster map [millibars]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "priestley_taylor_coeff", "flag": "priestley_taylor_coeff", "dataType": "String", "optional": false, "explanation": "Priestley-Taylor coefficient", "defaultValue": "1.26", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of output evapotranspiration raster map [mm/d]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.evapo.pt  Calculates the diurnal evapotranspiration after Prestley\n and Taylor (1972). The Priestley-Taylor model (Priestley and Taylor, 1972)\n is a modification of Penman\u00e2\u20ac\u2122s more theoretical equation.\n ", "notes": "\n RNETD optional output from i.evapo.potrad is giving good results as input\n for net radiation in this module.\n  Alpha values:\n   1.32 for estimates from vegetated areas as a result of the increase in\n surface roughness (Morton, 1983; Brutsaert and Stricker, 1979)\n   1.26 is applicable in humid climates (De Bruin and Keijman, 1979;\n Stewart and Rouse, 1976; Shuttleworth and Calder, 1979), and temperate\n hardwood swamps (Munro, 1979)\n   1.74 has been recommended for estimating potential evapotranspiration\n in more arid regions (ASCE, 1990). This worked well in Greece with University\n of Thessaloniki.\n Alpha values extracted from:\n  Watflood manual .\n ", "see_also": ["i.evapo.mh", "i.evapo.pm", "i.evapo.time", "i.eb.netrad", "r.sun"], "authors": ["Yann Chemin, GRASS Development team, 2007-08"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.evapo.pt"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.evapo.pm.html", "name": "i.evapo.pm", "definition": "- Computes potential evapotranspiration calculation with hourly Penman-Monteith.", "keywords": ["imagery", "evapotranspiration"], "synopsis": "i.evapo.pm [-zn] elevation=name temperature=name relativehumidity=name windspeed=name netradiation=name cropheight=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Set negative evapotranspiration to zero Use Night-time Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Use Night-time Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map [m a.s.l.]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "temperature", "flag": "temperature", "dataType": "String", "optional": false, "explanation": "Name of input temperature raster map [C]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "relativehumidity", "flag": "relativehumidity", "dataType": "String", "optional": false, "explanation": "Name of input relative humidity raster map [%]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "windspeed", "flag": "windspeed", "dataType": "String", "optional": false, "explanation": "Name of input wind speed raster map [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "netradiation", "flag": "netradiation", "dataType": "String", "optional": false, "explanation": "Name of input net solar radiation raster map [MJ/m2/h]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "cropheight", "flag": "cropheight", "dataType": "String", "optional": false, "explanation": "Name of input crop height raster map [m]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.evapo.pm , given the vegetation height (hc), humidity (RU), \n wind speed at two meters height (WS), temperature (T), digital terrain model (DEM), \n and net radiation (NSR) raster input maps, \n calculates the potential evapotranspiration map (EPo).\n  Optionally the user can activate a flag (-z) \n that allows him setting to zero all of the negative evapotranspiration cells; \n in fact these negative values motivated by the condensation of the air water \n vapour content, are sometime undesired because they can produce  computational \n problems. The usage of the flag -n detect that the module is run in night hours \n and the appropriate soil heat flux is calculated.\n  The algorithm implements well known approaches: the hourly \n Penman-Monteith method as presented in Allen et al. (1998) for land \n surfaces and the Penman method (Penman, 1948) for water surfaces.\n  Land and water surfaces are idenfyied by Vh:\n   where Vh gt 0 vegetation is present and evapotranspiration is calculated;\n   where Vh = 0 bare ground is present and evapotranspiration is calculated;\n   where Vh lt 0 water surface is present and evaporation is calculated.\n  For more details on the algorithms see [1,2,3].\n ", "notes": "\n  Net solar radiation map in MJ/(m2*h) can be computed from the combination of the r.sun , \n run in mode 1, and the  r.mapcalc  commands.\n  The sum of the three radiation components outputted by r.sun (beam, diffuse, and reflected) \n multiplied by the Wh to Mj conversion factor (0.0036) and optionally by a \n clear sky factor [0-1] allows the generation of a map to be used as \n an NSR input for the  i.evapo.PM  command.\n Example:\n r.sun -s elevin=dem aspin=aspect slopein=slope lin=2 albedo=alb_Mar \n        incidout=out beam_rad=beam diff_rad=diffuse refl_rad=reflected \n        day=73 time=13:00 dist=100;\n r.mapcalc \"NSR = 0.0036 * (beam + diffuse + reflected)\"\n ", "see_also": ["i.evapo.mh", "i.evapo.pm", "i.evapo.time", "r.sun", "r.mapcalc"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.evapo.pm"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.evapo.mh.html", "name": "i.evapo.mh", "definition": "- Computes evapotranspiration calculation modified or original Hargreaves formulation, 2001.", "keywords": ["imagery", "evapotranspiration"], "synopsis": "i.evapo.mh [-zhs] netradiation_diurnal=name average_temperature=name minimum_temperature=name maximum_temperature=name  [precipitation=name]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Set negative ETa to zero Use original Hargreaves (1985) Use Hargreaves-Samani (1985) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Use original Hargreaves (1985) Use Hargreaves-Samani (1985) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Use Hargreaves-Samani (1985) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "netradiation_diurnal", "flag": "netradiation_diurnal", "dataType": "String", "optional": false, "explanation": "Name of input diurnal net radiation raster map [W/m2/d]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "average_temperature", "flag": "average_temperature", "dataType": "String", "optional": false, "explanation": "Name of input average air temperature raster map [C]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "minimum_temperature", "flag": "minimum_temperature", "dataType": "String", "optional": false, "explanation": "Name of input minimum air temperature raster map [C]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "maximum_temperature", "flag": "maximum_temperature", "dataType": "String", "optional": false, "explanation": "Name of input maximum air temperature raster map [C]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "precipitation", "flag": "precipitation", "dataType": "String", "optional": true, "explanation": "Name of precipitation raster map [mm/month]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map [mm/d]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.evapo.mh  calculates the reference evapotranspiration (ET) after\n Hargreaves et al. (1985), Hargreaves and Samani (1985) and the Modified Hargreaves version found in Droogers and Allen (2002). \n ", "notes": "", "see_also": ["i.evapo.pt", "i.evapo.pm", "i.evapo.time", "r.sun"], "authors": ["Yann Chemin, GRASS Development team, 2007-2016"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.evapo.mh"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.emissivity.html", "name": "i.emissivity", "definition": "- Computes emissivity from NDVI, generic method for sparse land.", "keywords": ["imagery", "emissivity", "land flux", "energy balance"], "synopsis": "i.emissivity input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the NDVI map [-]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output emissivity layer", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.emissivity  calculates the emissivity in the longwave radiation\n spectrum, according to the semi-empirical equation related to NDVI by\n Caselles et al. (1997), valid in the NDVI range of 0.16 to 0.74 (Bastiaanssen, 1995).\n Caselles et al. (1997) give reference (in Table 3 and Figure 2) to both\n the NDVI range used (0.15 - 0.71) and the corresponding emissivity range\n used (0.97 - 0.99). \n The emissivity is the efficiency of longwave energy returning to the\n atmosphere from the skin surface. The skin surface receives heat from\n the thermal infrared radiation of the Sun, through atmospheric interaction.\n A part is returned to the atmosphere fastly, and another part is kept in\n the surface skin to be returned later. In more scientific terms, the\n grey body radiation is equal to the black body radiation times the emissivity.\n ", "notes": "", "see_also": ["i.eb.netrad"], "authors": ["Yann Chemin, GRASS Development Team"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.emissivity"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.eb.soilheatflux.html", "name": "i.eb.soilheatflux", "definition": "- Soil heat flux approximation (Bastiaanssen, 1995).", "keywords": ["imagery", "energy balance", "soil heat flux", "SEBAL"], "synopsis": "i.eb.soilheatflux [-r] albedo=name ndvi=name temperature=name netradiation=name localutctime=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "HAPEX-Sahel empirical correction (Roerink, 1995) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "albedo", "flag": "albedo", "dataType": "String", "optional": false, "explanation": "Name of albedo raster map [0.0;1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ndvi", "flag": "ndvi", "dataType": "String", "optional": false, "explanation": "Name of NDVI raster map [-1.0;+1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "temperature", "flag": "temperature", "dataType": "String", "optional": false, "explanation": "Name of Surface temperature raster map [K]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "netradiation", "flag": "netradiation", "dataType": "String", "optional": false, "explanation": "Name of Net Radiation raster map [W/m2]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "localutctime", "flag": "localutctime", "dataType": "String", "optional": false, "explanation": "Name of time of satellite overpass raster map [local time in UTC]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.eb.soilheatflux  calculates the soil heat flux approximation (g0)\n after Bastiaanssen (1995). The main reference for implementation is Alexandridis, 2009.\n It takes input of Albedo, NDVI, Surface Skin temperature, Net Radiation (see \n  r.sun ), time of satellite overpass, and a flag for the Roerink empirical modification from the HAPEX-Sahel experiment.\n The \"time of satellite overpass\" map can be obtained as follows:\n  MODIS: a related sub dataset is included in each HDF file, and simply \n     to be imported as a raster map; \n  Landsat: to be generated as map from the overpass time stored in\n     the metadata file (given in Greenwich Mean Time - GMT), see below. \n   \n For Landsat, the overpass map can be computed by using a two-step method:\n # 1) extract the overpass time in GMT from metadata file\n i.landsat.toar -p input=dummy output=dummy2 \n     metfile=LC81250452013338LGN00_MTL.txt lsatmet=time\n # ... in this example approx. 03:12am GMT\n # 2) create map for computational region of Landsat scene\n g.region rast=LC81250452013338LGN00_B4 -p\n r.mapcalc \"overpasstime = 3.211328\"\n ", "notes": "", "see_also": ["r.sun", "i.albedo", "i.emissivity", "i.eb.hsebal01", "i.eb.evapfr", "i.landsat.toar"], "authors": ["Yann Chemin, Asian Institute of Technology, Thailand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.eb.soilheatflux"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.eb.netrad.html", "name": "i.eb.netrad", "definition": "- Net radiation approximation (Bastiaanssen, 1995).", "keywords": ["imagery", "energy balance", "net radiation", "SEBAL"], "synopsis": "i.eb.netrad albedo=name ndvi=name temperature=name localutctime=name temperaturedifference2m=name emissivity=name transmissivity_singleway=name dayofyear=name sunzenithangle=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "albedo", "flag": "albedo", "dataType": "String", "optional": false, "explanation": "Name of albedo raster map [0.0;1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ndvi", "flag": "ndvi", "dataType": "String", "optional": false, "explanation": "Name of NDVI raster map [-1.0;+1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "temperature", "flag": "temperature", "dataType": "String", "optional": false, "explanation": "Name of surface temperature raster map [K]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "localutctime", "flag": "localutctime", "dataType": "String", "optional": false, "explanation": "Name of time of satellite overpass raster map [local time in UTC]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "temperaturedifference2m", "flag": "temperaturedifference2m", "dataType": "String", "optional": false, "explanation": "Name of the difference map of temperature from surface skin to about 2 m height [K]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "emissivity", "flag": "emissivity", "dataType": "String", "optional": false, "explanation": "Name of the emissivity map [-]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "transmissivity_singleway", "flag": "transmissivity_singleway", "dataType": "String", "optional": false, "explanation": "Name of the single-way atmospheric transmissivitymap [-]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dayofyear", "flag": "dayofyear", "dataType": "String", "optional": false, "explanation": "Name of the Day Of Year (DOY) map [-]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sunzenithangle", "flag": "sunzenithangle", "dataType": "String", "optional": false, "explanation": "Name of the sun zenith angle map [degrees]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output net radiation layer", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.eb.netrad  calculates the net radiation at the time of satellite\n overpass, the way it is in the SEBAL model of Bastiaanssen (1995).\n It takes input of Albedo, NDVI, Surface Skin temperature, time of satellite\n overpass, surface emissivity, difference of temperature from surface skin and\n about 2 m height (dT), instantaneous satellite overpass single-way atmospheric\n transmissivity (tsw), Day of Year (DOY), and sun zenith angle.\n ", "notes": "\n In the old methods, dT was taken as flat images (dT=5.0), if you don't have a dT\n map from ground data, you would want to try something in this line, this is to\n calculate atmospherical energy balance. In the same way, a standard tsw is used\n in those equations. Refer to  r_net.c  for that and for other non-used equations,\n but stored in there for further research convenience.\n  TODO \n Add more explanations.\n ", "see_also": ["i.eb.soilheatflux", "i.eb.hsebal01", "i.albedo"], "authors": ["Yann Chemin, International Rice Research Institute, The Philippines"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.eb.netrad"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.eb.hsebal01.html", "name": "i.eb.hsebal01", "definition": "- Computes sensible heat flux iteration SEBAL 01.", "keywords": ["imagery", "energy balance", "soil moisture", "evaporative fraction", "SEBAL"], "synopsis": "i.eb.hsebal01 [-ac] netradiation=name soilheatflux=name aerodynresistance=name temperaturemeansealevel=name frictionvelocitystar=float vapourpressureactual=float  [row_wet_pixel=float]   [column_wet_pixel=float]   [row_dry_pixel=float]   [column_dry_pixel=float]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Automatic wet/dry pixel (careful!) Dry/Wet pixels coordinates are in image projection, not row/col Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Dry/Wet pixels coordinates are in image projection, not row/col Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "netradiation", "flag": "netradiation", "dataType": "String", "optional": false, "explanation": "Name of instantaneous net radiation raster map [W/m2]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "soilheatflux", "flag": "soilheatflux", "dataType": "String", "optional": false, "explanation": "Name of instantaneous soil heat flux raster map [W/m2]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "aerodynresistance", "flag": "aerodynresistance", "dataType": "String", "optional": false, "explanation": "Name of aerodynamic resistance to heat momentum raster map [s/m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "temperaturemeansealevel", "flag": "temperaturemeansealevel", "dataType": "String", "optional": false, "explanation": "Name of altitude corrected surface temperature raster map [K]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "frictionvelocitystar", "flag": "frictionvelocitystar", "dataType": "String", "optional": false, "explanation": "Value of the height independent friction velocity (u*) [m/s]", "defaultValue": "0.32407", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vapourpressureactual", "flag": "vapourpressureactual", "dataType": "String", "optional": false, "explanation": "Value of the actual vapour pressure (e_act) [KPa]", "defaultValue": "1.511", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "row_wet_pixel", "flag": "row_wet_pixel", "dataType": "String", "optional": true, "explanation": "Row value of the wet pixel", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column_wet_pixel", "flag": "column_wet_pixel", "dataType": "String", "optional": true, "explanation": "Column value of the wet pixel", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "row_dry_pixel", "flag": "row_dry_pixel", "dataType": "String", "optional": true, "explanation": "Row value of the dry pixel", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column_dry_pixel", "flag": "column_dry_pixel", "dataType": "String", "optional": true, "explanation": "Column value of the dry pixel", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output sensible heat flux raster map [W/m2]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.eb.hsebal01  will calculate the sensible heat flux map (h0), given\n both maps of Net Radiation and soil Heat flux (Rn, g0) at instantaneous time,\n the surface roughness (z0m), a map of the altitude corrected temperature\n (t0dem), a point data of the frictional velocity (u*), a value of actual vapour\n pressure (ea[KPa]) and the (x,y) pairs for wet and dry pixels.\n Full process will need those:\n    i.vi ,  i.albedo ,  r.latlong ,  i.emissivity \n    i.evapo.potrad  (GRASS Addon)\n    i.eb.netrad ,  i.eb.soilheatflux ,  i.eb.hsebal01 \n    i.eb.evapfr ,  i.eb.eta \n (for time integration:  i.evapo.time_integration )  \n  i.eb.hsebal01  performs the computation of  sensible heat flux \n [W/m2] after Bastiaanssen, 1995 in [1], used in this form in 2001 by [2]. Implemented\n in this code in [3].\n ", "notes": "\n   z0m can be alculated by  i.eb.z0m  or  i.eb.z0m0  (GRASS Addons).\n   ea can be calculated with standard meteorological data. \n \teoTmin=0.6108*EXP(17.27*Tmin/(Tmin+237.3)) \n \teoTmax=0.6108*EXP(17.27*Tmax/(Tmax+237.3)) \n \tea=(RH/100)/((eoTmin+eoTmax)/2)\n   t0dem = surface temperature + (altitude * 0.627 / 100)\n ", "see_also": ["i.eb.soilheatflux", "i.eb.hsebal01", "i.eb.evapfr"], "authors": ["Yann Chemin, International Rice Research Institute, Los Banos, The Philippines."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.eb.hsebal01"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.eb.evapfr.html", "name": "i.eb.evapfr", "definition": "- Computes evaporative fraction and root zone soil moisture.", "keywords": ["imagery", "energy balance", "soil moisture", "evaporative fraction", "SEBAL"], "synopsis": "i.eb.evapfr [-m] netradiation=name soilheatflux=name sensibleheatflux=name evaporativefraction=name  [soilmoisture=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Root zone soil moisture output (Makin, Molden and Bastiaanssen, 2001) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "netradiation", "flag": "netradiation", "dataType": "String", "optional": false, "explanation": "Name of Net Radiation raster map [W/m2]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "soilheatflux", "flag": "soilheatflux", "dataType": "String", "optional": false, "explanation": "Name of soil heat flux raster map [W/m2]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sensibleheatflux", "flag": "sensibleheatflux", "dataType": "String", "optional": false, "explanation": "Name of sensible heat flux raster map [W/m2]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "evaporativefraction", "flag": "evaporativefraction", "dataType": "String", "optional": false, "explanation": "Name for output evaporative fraction raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "soilmoisture", "flag": "soilmoisture", "dataType": "String", "optional": true, "explanation": "Name for output root zone soil moisture raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.eb.evapfr  calculates the evaporative fraction after\n Bastiaanssen 1995. The main implementation follows Alexandridis et al.\n (2009). The module takes as input the net radiation (see  r.sun ,\n  i.eb.netrad ), soil heat flux (see  i.eb.soilheatflux )\n and sensible heat flux (see  i.eb.hsebal01 ). A flag adds a\n root zone empirical soil moisture output from the article of\n Bastiaanssen, et al. (2000).\n ", "notes": "", "see_also": ["i.eb.hsebal01", "i.eb.netrad", "i.eb.soilheatflux", "r.sun"], "authors": ["Yann Chemin, Asian Institute of Technology, Thailand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.eb.evapfr"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.eb.eta.html", "name": "i.eb.eta", "definition": "- Actual evapotranspiration for diurnal period (Bastiaanssen, 1995).", "keywords": ["imagery", "energy balance", "actual evapotranspiration", "SEBAL"], "synopsis": "i.eb.eta netradiationdiurnal=name evaporativefraction=name temperature=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "netradiationdiurnal", "flag": "netradiationdiurnal", "dataType": "String", "optional": false, "explanation": "Name of the diurnal net radiation map [W/m2]", "defaultValue": "rnetday", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "evaporativefraction", "flag": "evaporativefraction", "dataType": "String", "optional": false, "explanation": "Name of the evaporative fraction map [-]", "defaultValue": "evapfr", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "temperature", "flag": "temperature", "dataType": "String", "optional": false, "explanation": "Name of the surface skin temperature [K]", "defaultValue": "tempk", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output actual evapotranspiration layer [mm/d]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.eb.eta  calculates the actual evapotranspiration (ETa ; mm/d) for\n diurnal period after [1], implemented in [3].\n It takes input of Diurnal Net Radiation (see  r.sun ), evaporative fraction (see\n  i.eb.evapfr ) and surface skin temperature. \n ", "notes": "\n Full ETa processing will need those:\n    i.vi ,  i.albedo ,  r.latlong ,  i.emissivity \n    i.evapo.potrad  (GRASS Addon)\n    i.eb.netrad ,  i.eb.soilheatflux ,  i.eb.hsebal01 \n    i.eb.evapfr ,  i.eb.eta \n (for time integration:  i.evapo.time_integration )  \n  For more details on the algorithms see [1][2][3][4].\n ", "see_also": ["r.sun", "i.eb.evapfr", "i.eb.netrad"], "authors": ["Yann Chemin, Asian Institute of Technology, Thailand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.eb.eta"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/m.cogo.html", "name": "m.cogo", "definition": "- A simple utility for converting bearing and distance measurements to coordinates and vice versa.", "keywords": ["miscellaneous", "distance", "polar"], "synopsis": "m.cogo [-lrc]  [input=name]   [output=name]   [coordinates=east,north]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "Lines are labelled Convert from coordinates to bearing and distance Repeat the starting coordinate at the end to close a loop Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Convert from coordinates to bearing and distance Repeat the starting coordinate at the end to close a loop Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Repeat the starting coordinate at the end to close a loop Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input file", "defaultValue": "-", "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file", "defaultValue": "-", "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Starting coordinate pair", "defaultValue": "0.0,0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  m.cogo  converts data points between bearing and distance\n and X,Y coordinates.  Only simple bearing/distance or coordinate\n pairs are handled. It assumes a cartesian coordinate system.\n Input can be entered via standard input (default) or from the file\n  input= name . Specifying the input as \"-\" also\n specifies standard input, and is useful for using the program in\n a pipeline.  Output will be to standard output unless a file\n name other than \"-\" is specified.  The input file must\n closely adhere to the following format, where up to a 10 character\n label is allowed but not required (see  -l  flag).\n  Example COGO input: \n    P23 N 23:14:12 W 340\n    P24 S 04:18:56 E 230\n    ...\n The first column may contain a label and you must use the  -l \n flag so the program knows.  This is followed by a space, and then\n either the character 'N' or 'S' to indicate whether the bearing is\n relative to the north or south directions.  After another space,\n the angle begins in degrees, minutes, and seconds in\n \"DDD:MM:SS.SSSS\" format. Generally, the angle can be of the form\n  digits + separator + digits + separator + digits [+ '.' + digits] .\n A space follows the angle, and is then followed by either the 'E' or 'W'\n characters. A space separates the bearing from the distance (which should\n be in appropriate linear units).\n  Output of the above input: \n    -134.140211 312.420236 P23\n    -116.832837 83.072345 P24\n    ...\n Unless specified with the  coord  option, calculations begin from (0,0).\n ", "notes": "\n For those unfamiliar with the notation for bearings: Picture yourself in the\n center of a circle.  The first hemispere notation tell you whether you should\n face north or south.  Then you read the angle and either turn that many\n degrees to the east or west, depending on the second hemisphere notation.  \n Finally, you move <distance> units in that direction to get to the \n next station.\n  m.cogo  can be run either non-interactively or\n interactively.  The program will be run non-interactively\n if the user specifies any parameter or flag. Use \"m.cogo -\",\n to run the program in a pipeline.  Without any flags or\n parameters,  m.cogo  will prompt for each value\n using the familiar GRASS parser interface.\n This program is very simplistic, and will not handle deviations\n from the input format explained above.  Currently, the\n program doesn't do anything particularly useful with\n the output.  However, it is envisioned that this program\n will be extended to provide the capability to generate\n vector and/or sites layers.\n Lines may be closed by using the  -c  flag or snapped with\n  v.clean , lines may be converted to boundaries with  v.type ,\n and closed boundaries may be converted to areas with  v.centroids .\n  EXAMPLES \n    m.cogo -l in=cogo.dat\n Where the  cogo.dat  input file looks like:\n # Sample COGO input file -- This defines an area.\n # <label> <bearing> <distance>\n P001 S 88:44:56 W 6.7195\n P002 N 33:34:15 W 2.25\n P003 N 23:23:50 W 31.4024\n P004 N 05:04:45 W 25.6981\n P005 N 18:07:25 E 22.2439\n P006 N 27:49:50 E 75.7317\n P007 N 22:56:50 E 87.4482\n P008 N 37:45:15 E 37.7835\n P009 N 46:04:30 E 11.5854\n P010 N 90:00:00 E 8.8201\n P011 N 90:00:00 E 164.1128\n P012 S 48:41:12 E 10.1311\n P013 S 00:25:50 W 255.7652\n P014 N 88:03:13 W 98.8567\n P015 S 88:44:56 W 146.2713\n P016 S 88:44:56 W 18.7164\n Round trip:\n    m.cogo -l input=cogo.dat | m.cogo -rl in=\"-\"\n Import as a vector points map:\n    m.cogo -l input=cogo.dat | v.in.ascii output=cogo_points x=1 y=2 separator=space\n Shell script to import as a vector line map:\n    m.cogo -l input=cogo.dat | tac | awk '\n        BEGIN { FS=\" \" ; R=0 }\n        $1~/\\d*\\.\\d*/ { printf(\" %.8f %.8f\\n \", $1, $2) ; ++R }\n        END { printf(\"L %d\\n \", R) }' | tac | \n         v.in.ascii -n format=standard out=cogo_line\n Convert that lines map into an area:\n    # Add the -c flag to the above example to close the loop:\n    m.cogo -l -c input=cogo.dat | ...\n        ...\n    v.type input=cogo_line output=cogo_boundary from_type=line to_type=boundary\n    v.centroids input=cogo_boundary output=cogo_area\n If necessary, snap the boundary closed with the  v.clean  module.\n Use  tool=snap  and  thresh=0.0001 , or some small value.\n ", "see_also": ["v.centroids", "v.clean", "wxGUI vector digitizer", "v.in.ascii", "v.type"], "authors": ["Eric G. Miller"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/misc/m.cogo"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.zc.html", "name": "i.zc", "definition": "- Zero-crossing \"edge detection\" raster function for image processing.", "keywords": ["imagery", "edges"], "synopsis": "i.zc input=string output=string  [width=integer]   [threshold=float]   [orientations=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Zero crossing raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "x-y extent of the Gaussian filter", "defaultValue": "9", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Sensitivity of Gaussian filter", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "orientations", "flag": "orientations", "dataType": "String", "optional": true, "explanation": "Number of azimuth directions categorized", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  i.zc  is an image processing module used for edge\n detection.  The raster map produced shows the location of\n \"boundaries\" on the input map.  Boundaries tend to be found\n in regions of changing cell values and tend to run\n perpendicular to the direction of the slope.  The algorithm\n used for edge detection is one of the \"zero-crossing\"\n algorithms and is discussed briefly below.", "notes": "\n The procedure to find the \"edges\" in the image is as follows:\n   The Fourier transform of the image is taken, \n   The Fourier transform of the Laplacian of a two-dimensional \n Gaussian function is used to filter the transformed image, \n   The result is run through an inverse Fourier transform,\n   The resulting image is traversed in search of places where the image\n changes from positive to negative or from negative to positive, \n   Each cell in the map where the value crosses zero\n (with a change in value greater than the threshold value)\n is marked as an edge and an orientation is assigned to it.\n The resulting raster map layer is output.\n The  width=  parameter determines the x-y extent of the\n Gaussian filter.  The default value is  9 ; higher and lower\n values can be tested by the user.  Increasing the width\n will result in finding \"edges\" representing more gradual\n changes in cell values.\n The  threshold=  parameter determines the \"sensitivity\" of the\n Gaussian filter.  The default value is  1 ;  higher and\n lower values can be tested by the user.  Increasing the\n threshold value will result in fewer edges being found.\n The  orientations=  value is the number of azimuth directions the\n cells on the output raster map layer are categorized into\n (similar to the aspect raster map layer produced by\n  r.slope.aspect .\n For example, a value of  16  would result in\n detected edges being categorized into one of 16 bins\n depending on the direction of the edge at that point.\n The current region definition and mask settings are respected\n when reading the input map.\n ", "see_also": ["i.fft", "i.ifft", "r.mapcalc", "r.mfilter", "r.slope.aspect"], "authors": ["David Satnik, GIS Laboratory, Central Washington University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.zc"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.vi.html", "name": "i.vi", "definition": "- Calculates different types of vegetation indices.", "keywords": ["imagery", "vegetation index", "biophysical parameters"], "synopsis": "i.vi red=name output=name viname=type  [nir=name]   [green=name]   [blue=name]   [band5=name]   [band7=name]   [soil_line_slope=float]   [soil_line_intercept=float]   [soil_noise_reduction=float]   [storage_bit=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": false, "explanation": "Name of input red channel surface reflectance map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "viname", "flag": "viname", "dataType": "String", "optional": false, "explanation": "Type of vegetation index", "defaultValue": "ndvi", "alternatives": ["arvi", "dvi", "evi", "evi2", "gvi", "gari", "gemi", "ipvi", "msavi", "msavi2", "ndvi", "pvi", "savi", "sr", "vari", "wdvi"], "isInputFile": false, "isOutputFile": false}, {"parameter": "nir", "flag": "nir", "dataType": "String", "optional": true, "explanation": "Name of input nir channel surface reflectance map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": true, "explanation": "Name of input green channel surface reflectance map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": true, "explanation": "Name of input blue channel surface reflectance map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "band5", "flag": "band5", "dataType": "String", "optional": true, "explanation": "Name of input 5th channel surface reflectance map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "band7", "flag": "band7", "dataType": "String", "optional": true, "explanation": "Name of input 7th channel surface reflectance map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "soil_line_slope", "flag": "soil_line_slope", "dataType": "String", "optional": true, "explanation": "Value of the slope of the soil line (MSAVI only)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "soil_line_intercept", "flag": "soil_line_intercept", "dataType": "String", "optional": true, "explanation": "Value of the intercept of the soil line (MSAVI only)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "soil_noise_reduction", "flag": "soil_noise_reduction", "dataType": "String", "optional": true, "explanation": "Value of the factor of reduction of soil noise (MSAVI only)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "storage_bit", "flag": "storage_bit", "dataType": "String", "optional": true, "explanation": "Maximum bits for digital numbers", "defaultValue": "8", "alternatives": ["7", "8", "10", "16"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.vi  calculates vegetation indices based on biophysical\n parameters.\n    ARVI: atmospherically resistant vegetation indices \n    DVI: Difference Vegetation Index \n    EVI: Enhanced Vegetation Index \n    EVI2: Enhanced Vegetation Index 2 \n    GARI: Green atmospherically resistant vegetation index \n    GEMI: Global Environmental Monitoring Index \n    GVI: Green Vegetation Index \n    IPVI: Infrared Percentage Vegetation Index \n    MSAVI2: second Modified Soil Adjusted Vegetation Index \n    MSAVI: Modified Soil Adjusted Vegetation Index \n    NDVI: Normalized Difference Vegetation Index \n    PVI: Perpendicular Vegetation Index \n    RVI: ratio vegetation index \n    SAVI: Soil Adjusted Vegetation Index \n    SR: Simple Vegetation ratio \n    WDVI: Weighted Difference Vegetation Index \n  Background for users new to remote sensing \n Vegetation Indices are often considered the entry point of remote \n sensing for Earth land monitoring. They are suffering from their \n success, in terms that often people tend to harvest satellite images \n from online sources and use them directly in this module.\n From Digital number to Radiance: \n Satellite imagery is commonly stored in Digital Number (DN) for \n storage purposes; e.g., Landsat5 data is stored in 8bit values \n (ranging from 0 to 255), other satellites maybe stored in 10 or 16 \n bits. If the data is provided in DN, this implies that this imagery \n is \"uncorrected\". What this means is that the image is what the \n satellite sees at its position and altitude in space (stored in DN). \n This is not the signal at ground yet. We call this data at-satellite \n or at-sensor. Encoded in the 8bits (or more) is the amount of energy \n sensed by the sensor inside the satellite platform. This energy is \n called radiance-at-sensor. Generally, satellites image providers \n encode the radiance-at-sensor into 8bit (or more) through an affine \n transform equation (y=ax+b). In case of using Landsat imagery, look \n at the  i.landsat.toar  for an easy way to transform DN to \n radiance-at-sensor. If using Aster data, try the  i.aster.toar  \n module.\n From Radiance to Reflectance: \n Finally, once having obtained the radiance at sensor values, still \n the atmosphere is between sensor and Earth's surface. This fact \n needs to be corrected to account for the atmospheric interaction \n with the sun energy that the vegetation reflects back into space. \n This can be done in two ways for Landsat. The simple way is through \n  i.landsat.toar , use e.g. the DOS correction. The more \n accurate way is by using  i.atcorr  (which works for many \n satellite sensors). Once the atmospheric correction has been applied \n to the satellite data, data vales are called surface reflectance. \n Surface reflectance is ranging from 0.0 to 1.0 theoretically (and \n absolutely). This level of data correction is the proper level of \n correction to use with  i.vi .\n  Vegetation Indices \n  ARVI: Atmospheric Resistant Vegetation Index  \n ARVI is resistant to atmospheric effects (in comparison to \n the NDVI) and is accomplished by a self correcting process \n for the atmospheric effect in the red channel, using the \n difference in the radiance between the blue and the red \n channels (Kaufman and Tanre 1996).\n arvi( redchan, nirchan, bluechan )\n ARVI = (nirchan - (2.0*redchan - bluechan)) / \n        ( nirchan + (2.0*redchan - bluechan))\n  DVI: Difference Vegetation Index \n dvi( redchan, nirchan )\n DVI = ( nirchan - redchan )\n  EVI: Enhanced Vegetation Index \n The enhanced vegetation index (EVI) is an optimized index designed \n to enhance the vegetation signal with improved sensitivity in high \n biomass regions and improved vegetation monitoring through a \n de-coupling of the canopy background signal and a reduction in \n atmosphere influences (Huete A.R., Liu H.Q., Batchily K., van Leeuwen \n W. (1997). A comparison of vegetation indices global set of TM \n images for EOS-MODIS. Remote Sensing of Environment, 59:440-451).\n evi( bluechan, redchan, nirchan )\n EVI = 2.5 * ( nirchan - redchan ) / \n       ( nirchan + 6.0 * redchan - 7.5 * bluechan + 1.0 )\n  EVI2: Enhanced Vegetation Index 2 \n A 2-band EVI (EVI2), without a blue band, which has the best \n similarity with the 3-band EVI, particularly when atmospheric \n effects are insignificant and data quality is good (Zhangyan Jiang ; \n Alfredo R. Huete ; Youngwook Kim and Kamel Didan 2-band enhanced \n vegetation index without a blue band and its application to AVHRR \n data. Proc. SPIE 6679, Remote Sensing and Modeling of Ecosystems for \n Sustainability IV, 667905 (october 09, 2007)\n  doi:10.1117/12.734933 ).\n evi2( redchan, nirchan )\n EVI2 = 2.5 * ( nirchan - redchan ) / \n        ( nirchan + 2.4 * redchan + 1.0 )\n  GARI: green atmospherically resistant vegetation index \n The formula was actually defined:\n Gitelson, Anatoly A.; Kaufman, Yoram J.; Merzlyak, Mark N. (1996)\n Use of a green channel in remote sensing of global vegetation from EOS-\n MODIS, Remote Sensing of Environment 58 (3), 289-298.\n  doi:10.1016/s0034-4257(96)00072-7 \n gari( redchan, nirchan, bluechan, greenchan )\n GARI = ( nirchan - (greenchan - (bluechan - redchan))) / \n        ( nirchan + (greenchan - (bluechan - redchan)))\n  GEMI: Global Environmental Monitoring Index \n gemi( redchan, nirchan )\n GEMI = (( (2*((nirchan * nirchan)-(redchan * redchan)) +\n        1.5*nirchan+0.5*redchan) / (nirchan + redchan + 0.5)) * \n        (1 - 0.25 * (2*((nirchan * nirchan)-(redchan * redchan)) +\n        1.5*nirchan+0.5*redchan) / (nirchan + redchan + 0.5))) -\n        ( (redchan - 0.125) / (1 - redchan))\n  GVI: Green Vegetation Index \n gvi( bluechan, greenchan, redchan, nirchan, chan5chan, chan7chan)\n GVI = ( -0.2848 * bluechan - 0.2435 * greenchan - \n       0.5436 * redchan + 0.7243 * nirchan + 0.0840 * chan5chan-\n       0.1800 * chan7chan)\n  IPVI: Infrared Percentage Vegetation Index \n ipvi( redchan, nirchan )\n IPVI = nirchan/(nirchan+redchan)\n  MSAVI2: second Modified Soil Adjusted Vegetation Index \n msavi2( redchan, nirchan )\n MSAVI2 = (1/2)*(2*NIR+1-sqrt((2*NIR+1)^2-8*(NIR-red)))\n  MSAVI: Modified Soil Adjusted Vegetation Index \n msavi( redchan, nirchan )\n MSAVI = s(NIR-s*red-a) / (a*NIR+red-a*s+X*(1+s*s))\t\n where a is the soil line intercept, s is the\n soil line slope, and X \tis an adjustment factor\n which is set to minimize soil noise (0.08 in \n original papers).\n  NDVI: Normalized Difference Vegetation Index \n ndvi( redchan, nirchan )\n Satellite specific band numbers ([NIR, Red]):\n   MSS Bands        = [ 7,  5]\n   TM1-5,7 Bands    = [ 4,  3]\n   TM8 Bands        = [ 5,  4]\n   Sentinel-2 Bands = [ 8,  4]\n   AVHRR Bands      = [ 2,  1]\n   SPOT XS Bands    = [ 3,  2]\n   AVIRIS Bands     = [51, 29]\n NDVI = (NIR - Red) / (NIR + Red)\n  PVI: Perpendicular Vegetation Index \n pvi( redchan, nirchan )\n PVI = sin(a)NIR-cos(a)red \n for a isovegetation lines (lines of equal vegetation)\n would all be parallel to the soil line therefore  a=1 .\n  SAVI: Soil Adjusted Vegetation Index \n savi( redchan, nirchan )\n SAVI = ((1.0+0.5)*(nirchan - redchan)) / (nirchan + redchan +0.5)\n  SR: Simple Vegetation ratio \n sr( redchan, nirchan )\n SR = (nirchan/redchan)\n  VARI: Visible Atmospherically Resistant Index \n VARI was designed to introduce an atmospheric self-correction \n (Gitelson A.A., Kaufman Y.J., Stark R., Rundquist D., 2002. Novel \n algorithms for estimation of vegetation fraction Remote Sensing of \n Environment (80), pp76-87.)\n vari = ( bluechan, greenchan, redchan )\n VARI = (green - red ) / (green + red - blue)\n  WDVI: Weighted Difference Vegetation Index \n wdvi( redchan, nirchan, soil_line_weight )\n WDVI = nirchan - a * redchan\n if(soil_weight_line == None):\n    a = 1.0   #slope of soil line\n  EXAMPLES \n  Calculation of DVI \n The calculation of DVI from the reflectance values is done as follows:\n g.region raster=band.1 -p\n i.vi blue=band.1 red=band.3 nir=band.4 viname=dvi output=dvi\n r.univar -e dvi\n  Calculation of EVI \n The calculation of EVI from the reflectance values is done as follows:\n g.region raster=band.1 -p\n i.vi blue=band.1 red=band.3 nir=band.4 viname=evi output=evi\n r.univar -e evi\n  Calculation of EVI2 \n The calculation of EVI2 from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi red=band.3 nir=band.4 viname=evi2 output=evi2\n r.univar -e evi2\n  Calculation of GARI \n The calculation of GARI from the reflectance values is done as follows:\n g.region raster=band.1 -p\n i.vi blue=band.1 green=band.2 red=band.3 nir=band.4 viname=gari output=gari\n r.univar -e gari\n  Calculation of GEMI \n The calculation of GEMI from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi red=band.3 nir=band.4 viname=gemi output=gemi\n r.univar -e gemi\n  Calculation of GVI \n The calculation of GVI from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi blue=band.1 green=band.2 red=band.3 nir=band.4 band5=band.5 band7=band.7 viname=gvi output=gvi\n r.univar -e gvi\n  Calculation of IPVI \n The calculation of IPVI from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi red=band.3 nir=band.4 viname=ipvi output=ipvi\n r.univar -e ipvi\n  Calculation of MSAVI \n The calculation of MSAVI from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi red=band.3 nir=band.4 viname=msavi output=msavi\n r.univar -e msavi\n  Calculation of NDVI \n The calculation of NDVI from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi red=band.3 nir=band.4 viname=ndvi output=ndvi\n r.univar -e ndvi\n  Calculation of PVI \n The calculation of PVI from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi red=band.3 nir=band.4 viname=pvi output=pvi\n r.univar -e pvi\n  Calculation of SAVI \n The calculation of SAVI from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi red=band.3 nir=band.4 viname=savi output=savi\n r.univar -e savi\n  Calculation of SR \n The calculation of SR from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi red=band.3 nir=band.4 viname=sr output=sr\n r.univar -e sr\n  Calculation of VARI \n The calculation of VARI from the reflectance values is done as follows:\n g.region raster=band.3 -p\n i.vi blue=band.2 green=band.3 red=band.4 viname=vari output=vari\n r.univar -e vari\n  Landsat TM7 example \n The following examples are based on a LANDSAT TM7 scene included in the North Carolina\n sample dataset. \n  Preparation: DN to reflectance \n As a first step, the original DN (digital number) pixel values must be\n converted to reflectance using  i.landsat.toar . To do so, we \n make a copy (or rename the channels) to match  i.landsat.toar 's\n input scheme:\n g.copy raster=lsat7_2002_10,lsat7_2002.1\n g.copy raster=lsat7_2002_20,lsat7_2002.2\n g.copy raster=lsat7_2002_30,lsat7_2002.3\n g.copy raster=lsat7_2002_40,lsat7_2002.4\n g.copy raster=lsat7_2002_50,lsat7_2002.5\n g.copy raster=lsat7_2002_61,lsat7_2002.61\n g.copy raster=lsat7_2002_62,lsat7_2002.62\n g.copy raster=lsat7_2002_70,lsat7_2002.7\n g.copy raster=lsat7_2002_80,lsat7_2002.8\n Calculation of reflectance values from DN using DOS1 (metadata obtained\n from  p016r035_7x20020524.met.gz ):\n i.landsat.toar input=lsat7_2002. output=lsat7_2002_toar. sensor=tm7 \n    method=dos1 date=2002-05-24 sun_elevation=64.7730999 \n    product_date=2004-02-12 gain=HHHLHLHHL\n The resulting Landsat channels are names  lsat7_2002_toar.1 .. lsat7_2002_toar.8 .\n  Calculation of NDVI \n The calculation of NDVI from the reflectance values is done as follows:\n g.region raster=lsat7_2002_toar.3 -p\n i.vi red=lsat7_2002_toar.3 nir=lsat7_2002_toar.4 viname=ndvi \n       output=lsat7_2002.ndvi\n r.colors lsat7_2002.ndvi color=ndvi\n d.mon wx0\n d.rast.leg lsat7_2002.ndvi\n North Carolina dataset: NDVI\n  Calculation of ARVI \n The calculation of ARVI from the reflectance values is done as follows:\n g.region raster=lsat7_2002_toar.3 -p\n i.vi blue=lsat7_2002_toar.1 red=lsat7_2002_toar.3 nir=lsat7_2002_toar.4 \n       viname=arvi output=lsat7_2002.arvi\n d.mon wx0\n d.rast.leg lsat7_2002.arvi\n North Carolina dataset: ARVI\n  Calculation of GARI \n The calculation of GARI from the reflectance values is done as follows:\n g.region raster=lsat7_2002_toar.3 -p\n i.vi blue=lsat7_2002_toar.1 green=lsat7_2002_toar.2 red=lsat7_2002_toar.3 \n       nir=lsat7_2002_toar.4 viname=gari output=lsat7_2002.gari\n d.mon wx0\n d.rast.leg lsat7_2002.gari\n North Carolina dataset: GARI\n ", "notes": "\n Originally from kepler.gps.caltech.edu ( FAQ ):\n A FAQ on Vegetation in Remote Sensing \n Written by Terrill W. Ray, Div. of Geological and Planetary Sciences,\n California Institute of Technology, email: terrill@mars1.gps.caltech.edu\n  Snail Mail:  Terrill Ray \n \t     Division of Geological and Planetary Sciences \n \t     Caltech, Mail Code 170-25 \n \t     Pasadena, CA  91125\n ", "see_also": ["i.albedo", "i.aster.toar", "i.landsat.toar", "i.atcorr", "i.tasscap"], "authors": ["Baburao Kamble, Asian Institute of Technology, Thailand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.vi"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.topo.corr.html", "name": "i.topo.corr", "definition": "- Computes topographic correction of reflectance.", "keywords": ["imagery", "terrain", "topographic correction"], "synopsis": "i.topo.corr [-is]  [input=name[,name,...]]  output=name basemap=name zenith=float  [azimuth=float]   [method=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Output sun illumination terrain model Scale output to input and copy color rules Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Scale output to input and copy color rules Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of reflectance raster maps to be corrected topographically", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name (flag -i) or prefix for output raster maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basemap", "flag": "basemap", "dataType": "String", "optional": false, "explanation": "Name of input base raster map (elevation or illumination)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "zenith", "flag": "zenith", "dataType": "String", "optional": false, "explanation": "Solar zenith in degrees", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "azimuth", "flag": "azimuth", "dataType": "String", "optional": true, "explanation": "Solar azimuth in degrees (only if flag -i)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Topographic correction method", "defaultValue": "c-factor", "alternatives": ["cosine", "minnaert", "c-factor", "percent"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.topo.corr  is used to topographically correct reflectance\n from imagery files, e.g. obtained with  i.landsat.toar , using a\n sun illumination terrain model. This illumination model represents the\n cosine of the incident angle  i , i.e. the  angle between the normal to the\n ground and the sun rays.\n Note: If needed, the sun position can be calculated for a given date with\n  r.sunmask .\n Figure showing terrain and solar angles\n Using the  -i  flag and given an elevation basemap (metric),\n  i.topo.corr  creates a simple illumination model using the formula:\n     cos_i = cos(s) * cos(z) + sin(s) * sin(z) * cos(a - o)  \n where,\n  i  is the incident angle to be calculated,\n  s  is the terrain slope angle,\n  z  is the solar zenith angle,\n  a  the solar azimuth angle,\n  o  the terrain aspect angle.\n For each band file, the corrected reflectance (ref_c) is calculate from\n the original reflectance (ref_o) using one of the four offered methods\n (one lambertian and two non-lambertian). \n  Method: cosine \n     ref_c = ref_o * cos_z / cos_i  \n  Method: minnaert \n    ref_c = ref_o * (cos_z / cos_i) ^k \n where,\n  k  is obtained by linear regression of \n ln(ref_o) = ln(ref_c) - k ln(cos_i/cos_z)\n  Method: c-factor \n    ref_c = ref_o * (cos_z + c)/ (cos_i + c) \n where,\n  c  is a/m from ref_o = a + m * cos_i\n  Method: percent \n We can use cos_i to estimate the percent of solar incidence on the surface,\n then the transformation (cos_i + 1)/2 varied from 0\n (surface in the side in opposition to the sun: infinite correction) to 1\n (direct exhibition to the sun: no correction) and the corrected reflectance can\n be calculated as\n    ref_c = ref_o * 2 / (cos_i + 1) \n ", "notes": "\n  The illumination model (cos_i) with flag -i uses the actual region\n     as limits and the resolution of the elevation map. \n  The topographic correction use the full reflectance file (null remain\n     null) and its resolution. \n  The elevation map to calculate the illumination model should be metric. \n  EXAMPLES \n First, make a illumination model from the elevation map (here, SRTM). Then\n make perform the topographic correction of e.g. the bands toar.5, toar.4 and toar.3\n with output as tcor.toar.5, tcor.toar.4, and tcor.toar.3 using c-factor (= c-correction)\n method:\n # first pass: create illumination model\n i.topo.corr -i base=SRTM zenith=33.3631 azimuth=59.8897 output=SRTM.illumination\n # second pass: apply illumination model\n i.topo.corr base=SRTM.illumination input=toar.5,toar.4,toar.3 output=tcor \\ \n   zenith=33.3631 method=c-factor\n  REFERENCES \n  Law K.H. and Nichol J, 2004. Topographic Correction For Differential\n     Illumination Effects On Ikonos Satellite Imagery. International Archives of\n     Photogrammetry Remote Sensing and Spatial Information, pp. 641-646. \n  Meyer, P. and Itten, K.I. and Kellenberger, KJ and Sandmeier, S. and\n     Sandmeier, R., 1993. Radiometric corrections of topographically induced\n     effects on Landsat TM data in alpine terrain. Photogrammetric Engineering\n     and Remote Sensing 48(17). \n  Ria\u00f1o, D. and Chuvieco, E. and Salas, J. and Aguado, I., 2003.\n     Assessment of Different Topographic Corrections in Landsat-TM\n     Data for Mapping Vegetation Types. IEEE Transactions On Geoscience\n     And Remote Sensing, Vol. 41, No. 5 \n  Twele A. and Erasmi S, 2005. Evaluating topographic correction algorithms\n     for improved land cover discrimination in mountainous areas of\n     Central Sulawesi. G\u00f6ttinger Geographische Abhandlungen, vol. 113. \n ", "see_also": ["i.landsat.toar", "r.mapcalc", "r.sun", "r.sunmask"], "authors": ["E. Jorge Tizado (ej.tizado unileon es)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.topo.corr"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.tasscap.html", "name": "i.tasscap", "definition": "- Performs Tasseled Cap (Kauth Thomas) transformation.", "keywords": ["imagery", "transformation", "Landsat", "MODIS", "Tasseled Cap transformation"], "synopsis": "i.tasscap input=name[,name,...] output=basename sensor=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "For Landsat4-7: bands 1, 2, 3, 4, 5, 7; for Landsat8: bands 2, 3, 4, 5, 6, 7; for MODIS: bands 1, 2, 3, 4, 5, 6, 7", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output basename raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "sensor", "flag": "sensor", "dataType": "String", "optional": false, "explanation": "Satellite sensor", "defaultValue": null, "alternatives": ["landsat4_tm", "landsat5_tm", "landsat7_etm", "landsat8_oli", "modis"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.tasscap  calculates Tasseled Cap (Kauth Thomas, TC) transformation\n for Landsat TM data (TM4, TM5, ETM7) and MODIS data.\n The tasseled cap transformation is effectively a compression method to\n reduce multiple spectral data into a few bands. The method was originally\n developed for understanding important phenomena of crop development in\n spectral space (Kauth and Thomas, 1976).\n Tasseled cap coefficients for Landsat 7 ETM+ are at-satellite reflectance\n values (C. Huang et al., 2001), the conversion can be achieved with\n  i.landsat.toar .\n The following tasseled cap components are generated:\n   tasscap.1: corresponds to brightness,\n   tasscap.2: corresponds to greenness,\n   tasscap.3: corresponds to wetness,\n   tasscap.4: corresponds to atmospheric haze (only selected sensors: Landsat 5,7,8).\n  EXAMPLE \n Calculation of TC maps from North Carolina Landsat 7 ETM scene:\n # See manual page of i.landsat.toar for preprocessing\n g.region raster=lsat7_2002_toar.1 -p\n i.tasscap sensor=landsat7_etm \n    input=lsat7_2002_toar.1,lsat7_2002_toar.2,lsat7_2002_toar.3,lsat7_2002_toar.4,lsat7_2002_toar.5,lsat7_2002_toar.7 \n    output=lsat7_2002_tasscap\n Results:\n    \n    \n      \n       \u00a0 \n        \n        \n        'Brightness' Tasseled Cap component 1 \n        \n      \n      \n       \u00a0 \n        \n        \n        'Greenness' Tasseled Cap component 2 \n        \n      \n    \n    \n      \n       \u00a0 \n        \n        \n        'Wetness' Tasseled Cap component 3 \n        \n      \n      \n       \u00a0 \n        \n        \n        'Atmospheric haze' Tasseled Cap component 4 \n        \n      \n    \n    \n  REFERENCES \n  LANDSAT-4/LANDSAT-5: TC-factor changed to CRIST et al. 1986,\n                       Proc. IGARSS 1986, p.1467\n  Crist, E. P., 1985, A TM tasseled cap equivalent transformation for reflectance\n     factor data, Remote Sensing of Environment, 17: 301-306.\n  LANDSAT-7: TASSCAP factors cited from:\n   DERIVATION OF A TASSELED CAP TRANSFORMATION BASED ON LANDSAT 7 AT-SATELLITE REFLECTANCE.\n   Chengquan Huang, Bruce Wylie, Limin Yang, Collin Homer and Gregory Zylstra Raytheon ITSS, \n   USGS EROS Data Center Sioux Falls, SD 57198, USA\n   http://landcover.usgs.gov/pdf/tasseled.pdf\n  This is published as well in INT. J. OF RS, 2002, VOL 23, NO. 8, 1741-1748.\n   MODIS Tasselled Cap coefficients - Ref: Lobser & Cohen (2007). MODIS tasselled cap:\n  land cover characteristics expressed through transformed MODIS data.\n  International Journal of Remote Sensing, Volume 28(22), Table 3\n ", "notes": "", "see_also": ["i.albedo", "i.atcorr", "i.landsat.toar", "i.vi"], "authors": ["Dr. Agustin Lobo, original script, 1997"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/i.tasscap"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.target.html", "name": "i.target", "definition": "- Targets an imagery group to a GRASS location and mapset.", "keywords": ["imagery", "map management"], "synopsis": "i.target [-c] group=name  [location=string]   [mapset=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Set current location and mapset as target for imagery group Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Name of imagery target location", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapset", "flag": "mapset", "dataType": "String", "optional": true, "explanation": "Name of target mapset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  i.target  targets an  imagery\n group  to a GRASS data base location name and mapset.\n A location name and mapset are required for the\n  i.rectify  imagery module, into which\n to write the rectified map just prior to completion of the program;\n  i.target  enables the user to specify this location.\n  i.target  must be run before \n  g.gui.gcp  and \n  i.rectify .\n ", "notes": "\n  The module's first option asks for the name of the\n  imagery group  that needs a target.\n The imagery group must be present in the user's current mapset.\n An  imagery group  may be targeted to any GRASS\n location.\n  If a group name is given without setting options, the currently targeted\n group will be displayed.\n ", "see_also": ["Image Processing manual"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.target"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.spectral.html", "name": "i.spectral", "definition": "- Displays spectral response at user specified locations in group or images.", "keywords": ["imagery", "querying", "raster", "multispectral"], "synopsis": "i.spectral [-cgt]  [group=name]   [raster=name[,name,...]]  coordinates=east,north[,east,north,...]  [output=name]   [format=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Show sampling coordinates instead of numbering in the legend Use gnuplot for display output to text file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Use gnuplot for display output to text file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "output to text file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": true, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "Coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output image (or text file for -t)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Graphics format for output file", "defaultValue": "png", "alternatives": ["png", "eps", "svg"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.spectral  displays spectral response at user specified \n locations in images.\n ", "notes": "\n This script needs gnuplot to be installed.\n  EXAMPLE \n Analysis of LANDSAT TM7 channels (North Carolina dataset):\n g.region raster=lsat7_2002_10 -p\n i.spectral -g input=lsat7_2002_10,lsat7_2002_20,lsat7_2002_30,lsat7_2002_40,lsat7_2002_50,lsat7_2002_70 \n             coordinates=636069,215440,637958,223393,633277,223605\n Spectral plot of 3 different land cover types: (1) water, (2) green vegetation, and (3) highway\n North Carolina sample dataset:\n g.region raster=lsat7_2002_10 -p\n LIST=`g.list type=raster pattern=\"lsat7_2002_[1-5,7]0\" separator=\",\"`\n i.spectral input=$LIST coordinates=637502.25,221744.25\n This will search all LANDSAT map for 2002 but select only the B, G, R, \n NIR, and MIR channels.\n ", "see_also": ["d.where", "r.what"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/i.spectral"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.smap.html", "name": "i.smap", "definition": "- Performs contextual image classification using sequential maximum a posteriori (SMAP) estimation.", "keywords": ["imagery", "classification", "supervised classification", "segmentation", "SMAP"], "synopsis": "i.smap [-m] group=name subgroup=name signaturefile=name output=name  [goodness=name]   [blocksize=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Use maximum likelihood estimation (instead of smap) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "subgroup", "flag": "subgroup", "dataType": "String", "optional": false, "explanation": "Name of input imagery subgroup", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "signaturefile", "flag": "signaturefile", "dataType": "String", "optional": false, "explanation": "Name of input file containing signatures", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map holding classification results", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "goodness", "flag": "goodness", "dataType": "String", "optional": true, "explanation": "Name for output raster map holding goodness of fit (lower is better)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "blocksize", "flag": "blocksize", "dataType": "String", "optional": true, "explanation": "Size of submatrix to process at one time", "defaultValue": "1024", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  i.smap  program is used to segment\n multispectral images using a spectral class model known as\n a Gaussian mixture distribution.  Since Gaussian mixture\n distributions include conventional multivariate Gaussian\n distributions, this program may also be used to segment\n multispectral images based on simple spectral mean and\n covariance parameters.\n  i.smap  has two modes of operation. The first mode\n is the sequential maximum a posteriori (SMAP) mode\n [ 1 , 2 ].  The SMAP\n segmentation algorithm attempts to improve segmentation\n accuracy by segmenting the image into regions rather than\n segmenting each pixel separately \n (see  NOTES ).\n The second mode is the more conventional maximum likelihood (ML)\n classification which classifies each pixel separately,\n but requires somewhat less computation. This mode is selected with\n the  -m  flag (see  below ).\n  OPTIONS \n  Flags: \n  -m \n  Use maximum likelihood estimation (instead of smap).\n Normal operation is to use SMAP estimation (see\n  NOTES ).\n  Parameters: \n  group= name  \n  imagery group \n The imagery group that defines the image to be classified.\n  subgroup= name  \n  imagery subgroup \n The subgroup within the group specified that specifies the\n subset of the band files that are to be used as image data\n to be classified.\n  signaturefile= name  \n  imagery signaturefile \n The signature file that contains the spectral signatures (i.e., the\n statistics) for the classes to be identified in the image.\n This signature file is produced by the program\n  i.gensigset \n (see  NOTES ).\n  blocksize= value  \n  size of submatrix to process at one time \n default: 1024 \n This option specifies the size of the \"window\" to be used when\n reading the image data. \n This program was written to be nice about memory usage\n without influencing the resultant classification. This\n option allows the user to control how much memory is used.\n More memory may mean faster (or slower) operation depending\n on how much real memory your machine has and how much\n virtual memory the program uses.\n The size of the submatrix used in segmenting the image has\n a principle function of controlling memory usage; however,\n it also can have a subtle effect on the quality of the\n segmentation in the smap mode.  The smoothing parameters\n for the smap segmentation are estimated separately for each\n submatrix.  Therefore, if the image has regions with\n qualitatively different behavior, (e.g., natural woodlands\n and man-made agricultural fields) it may be useful to use a\n submatrix small enough so that different smoothing\n parameters may be used for each distinctive region of the\n image.\n The submatrix size has no effect on the performance of the\n ML segmentation method.\n  output= name \n  output raster map. \n The name of a raster map that will contain the\n classification results.  This new raster map layer will\n contain categories that can be related to landcover\n categories on the ground.\n  INTERACTIVE MODE \n If none of the arguments are specified on the command line,\n  i.smap  will interactively prompt for the names of\n the maps and files.\n ", "notes": "\n The SMAP algorithm exploits the fact that nearby pixels in\n an image are likely to have the same class.  It works by\n segmenting the image at various scales or resolutions and\n using the coarse scale segmentations to guide the finer\n scale segmentations.  In addition to reducing the number of\n misclassifications, the SMAP algorithm generally produces\n segmentations with larger connected regions of a fixed\n class which may be useful in some applications.\n The amount of smoothing that is performed in the\n segmentation is dependent of the behavior of the data in\n the image.  If the data suggests that the nearby pixels\n often change class, then the algorithm will adaptively\n reduce the amount of smoothing.  This ensures that\n excessively large regions are not formed.\n The degree of misclassifications can be investigated with the goodness \n of fit output map. Lower values indicate a better fit. The largest 5 to \n 15% of the goodness values may need some closer inspection.\n The module  i.smap  does not support MASKed or NULL cells. Therefore \n it might be necessary to create a copy of the classification results \n using e.g. r.mapcalc:\n r.mapcalc \"MASKed_map = classification_results\"\n  EXAMPLE \n Supervised classification of LANDSAT\n g.region raster=lsat7_2002_10 -p\n # store VIZ, NIR, MIR into group/subgroup\n i.group group=my_lsat7_2002 subgroup=my_lsat7_2002 \n    input=lsat7_2002_10,lsat7_2002_20,lsat7_2002_30,lsat7_2002_40,lsat7_2002_50,lsat7_2002_70\n # Now digitize training areas \"training\" with the digitizer\n # and convert to raster model with v.to.rast\n v.to.rast input=training output=training use=cat label_column=label\n # calculate statistics\n i.gensigset trainingmap=training group=my_lsat7_2002 subgroup=my_lsat7_2002 \n              signaturefile=my_smap_lsat7_2002 maxsig=5\n i.smap group=my_lsat7_2002 subgroup=my_lsat7_2002 signaturefile=my_smap_lsat7_2002 \n         output=lsat7_2002_smap_classes\n # Visually check result\n d.mon wx0\n d.rast.leg lsat7_2002_smap_classes\n # Statistically check result\n r.kappa -w classification=lsat7_2002_smap_classes reference=training\n  REFERENCES \n  C. Bouman and M. Shapiro,\n \"Multispectral Image Segmentation using a Multiscale Image Model\", \n  Proc. of IEEE Int'l Conf. on Acoust., Speech and Sig. Proc., \n pp. III-565 - III-568, San Francisco, California, March 23-26, 1992.\n  C. Bouman and M. Shapiro 1994,\n \"A Multiscale Random Field Model for Bayesian Image Segmentation\",\n  IEEE Trans. on Image Processing., 3(2), 162-177\" \n ( PDF ) \n  McCauley, J.D. and B.A. Engel 1995,\n \"Comparison of Scene Segmentations: SMAP, ECHO and Maximum Likelyhood\",\n  IEEE Trans. on Geoscience and Remote Sensing, 33(6): 1313-1316. \n ", "see_also": ["i.group", "r.mapcalc", "i.gensigset"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.smap"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.segment.html", "name": "i.segment", "definition": "- Identifies segments (objects) from imagery data.", "keywords": ["imagery", "segmentation", "classification", "object recognition"], "synopsis": "i.segment [-dwap] group=name[,name,...] output=name  [band_suffix=name]  threshold=float  [radius=float]   [hr=float]   [method=string]   [similarity=string]   [minsize=integer]   [memory=integer]   [iterations=integer]   [seeds=name]   [bounds=name]   [goodness=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Use 8 neighbors (3x3 neighborhood) instead of the default 4 neighbors for each pixel Weighted input, do not perform the default scaling of input raster maps Use adaptive bandwidth for mean shift Range (spectral) bandwidth is adapted for each moving window Use progressive bandwidth for mean shift Spatial bandwidth is increased, range (spectral) bandwidth is decreased in each iteration Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Weighted input, do not perform the default scaling of input raster maps Use adaptive bandwidth for mean shift Range (spectral) bandwidth is adapted for each moving window Use progressive bandwidth for mean shift Spatial bandwidth is increased, range (spectral) bandwidth is decreased in each iteration Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Use adaptive bandwidth for mean shift Range (spectral) bandwidth is adapted for each moving window Use progressive bandwidth for mean shift Spatial bandwidth is increased, range (spectral) bandwidth is decreased in each iteration Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Use progressive bandwidth for mean shift Spatial bandwidth is increased, range (spectral) bandwidth is decreased in each iteration Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group or raster maps", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "band_suffix", "flag": "band_suffix", "dataType": "String", "optional": true, "explanation": "Suffix for output bands with modified band values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": false, "explanation": "Difference threshold between 0 and 1", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "radius", "flag": "radius", "dataType": "String", "optional": true, "explanation": "Spatial radius in number of cells", "defaultValue": "1.5", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "hr", "flag": "hr", "dataType": "String", "optional": true, "explanation": "Range (spectral) bandwidth [0, 1]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Segmentation method", "defaultValue": "region_growing", "alternatives": ["region_growing", "mean_shift"], "isInputFile": false, "isOutputFile": false}, {"parameter": "similarity", "flag": "similarity", "dataType": "String", "optional": true, "explanation": "Similarity calculation method", "defaultValue": "euclidean", "alternatives": ["euclidean", "manhattan"], "isInputFile": false, "isOutputFile": false}, {"parameter": "minsize", "flag": "minsize", "dataType": "String", "optional": true, "explanation": "Minimum number of cells in a segment", "defaultValue": "1", "alternatives": ["1-100000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Memory in MB", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "iterations", "flag": "iterations", "dataType": "String", "optional": true, "explanation": "Maximum number of iterations", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "seeds", "flag": "seeds", "dataType": "String", "optional": true, "explanation": "Name for input raster map with starting seeds", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bounds", "flag": "bounds", "dataType": "String", "optional": true, "explanation": "Name of input bounding/constraining raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "goodness", "flag": "goodness", "dataType": "String", "optional": true, "explanation": "Name for output goodness of fit estimate map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n Image segmentation or object recognition is the process of grouping \n similar pixels into unique segments, also referred to as objects. \n Boundary and region based algorithms are described in the literature, \n currently a region growing and merging algorithm is implemented. Each \n object found during the segmentation process is given a unique ID and \n is a collection of contiguous pixels meeting some criteria. Note the \n contrast with image classification where all pixels similar to each \n other are assigned to the same class and do not need to be contiguous. \n The image segmentation results can be useful on their own, or used as a \n preprocessing step for image classification. The segmentation \n preprocessing step can reduce noise and speed up the classification.\n ", "notes": "\n  Region Growing and Merging \n This segmentation algorithm sequentially examines all current segments\n in the raster map. The similarity between the current segment and each\n of its neighbors is calculated according to the given distance\n formula. Segments will be merged if they meet a number of criteria,\n including:\n    The pair is mutually most similar to each other (the similarity\n distance will be smaller than to any other neighbor), and \n    The similarity must be lower than the input threshold. The\n process is repeated until no merges are made during a complete pass. \n  Similarity and Threshold \n The similarity between segments and unmerged objects is used to \n determine which objects are merged. Smaller distance values indicate a \n closer match, with a similarity score of zero for identical pixels.\n During normal processing, merges are only allowed when the \n similarity between two segments is lower than the given \n threshold value. During the final pass, however, if a minimum \n segment size of 2 or larger is given with the  minsize  \n parameter, segments with a smaller pixel count will be merged with \n their most similar neighbor even if the similarity is greater than \n the threshold.\n The  threshold  must be larger than 0.0 and smaller than 1.0. A threshold \n of 0 would allow only identical valued pixels to be merged, while a \n threshold of 1 would allow everything to be merged. The threshold is scaled to\n the data range of the entire input data, not the current computational region.\n This allows the application of the same threshold to different computational\n regions when working on the same dataset, ensuring that this threshold has the\n same meaning in all subregions.\n   \n Initial empirical \n tests indicate threshold values of 0.01 to 0.05 are reasonable values \n to start. It is recommended to start with a low value, e.g. 0.01, and \n then perform hierarchical segmentation by using the output of the last \n run as  seeds  for the next run.\n  Calculation Formulas \n Both Euclidean and Manhattan distances use the normal definition, \n considering each raster in the image group as a dimension.\n In future, the distance calculation will also take into account the\n shape characteristics of the segments. The normal distances are then\n multiplied by the input radiometric weight. Next an additional\n contribution is added:  (1-radioweight) * {smoothness * smoothness\n weight + compactness * (1-smoothness weight)} ,\n where  compactness = Perimeter Length / sqrt( Area ) \n and  smoothness = Perimeter Length / Bounding Box . The\n perimeter length is estimated as the number of pixel sides the segment\n has.\n  Seeds \n The seeds map can be used to provide either seed pixels (random or \n selected points from which to start the segmentation process) or \n seed segments. If the seeds are the results of a previous segmentation \n with lower threshold, hierarchical segmentation can be performed. The \n different approaches are automatically detected by the program: any \n pixels that have identical seed values and are contiguous will be \n assigned a unique segment ID.\n  Maximum number of segments \n The current limit with CELL storage used for segment IDs is 2\n billion starting segment IDs. Segment IDs are assigned whenever a yet \n unprocessed pixel is merged with another segment. Integer overflow can \n happen for computational regions with more than 2 billion cells and \n very low threshold values, resulting in many segments. If integer \n overflow occurs durin region growing, starting segments can be used \n (created by initial classification or other methods).\n  Goodness of Fit \n The  goodness  of fit for each pixel is calculated as 1 - distance \n of the pixel to the object it belongs to. The distance is calculated \n with the selected  similarity  method. A value of 1 means \n identical values, perfect fit, and a value of 0 means maximum possible \n distance, worst possible fit.\n  Mean shift \n Mean shift image segmentation consists of 2 steps: anisotrophic \n filtering and 2. clustering. For anisotrophic filtering new cell values \n are calculated from all pixels not farther than  hs  pixels away \n from the current pixel and with a spectral difference not larger than \n  hr . That means that pixels that are too different from the current \n pixel are not considered in the calculation of new pixel values. \n  hs  and  hr  are the spatial and spectral (range) bandwidths \n for anisotrophic filtering. Cell values are iteratively recalculated \n (shifted to the segment's mean) until the maximum number of iterations \n is reached or until the largest shift is smaller than  threshold .\n If input bands have been reprojected, they should not be reprojected \n with bilinear resampling because that method causes smooth transitions \n between objects. More appropriate methods are bicubic or lanczos \n resampling.\n  Boundary Constraints \n Boundary constraints limit the adjacency of pixels and segments. \n Each unique value present in the  bounds  raster are \n considered as a MASK. Thus no segments in the final segmentated map \n will cross a boundary, even if their spectral data is very similar.\n  Minimum Segment Size \n To reduce the salt and pepper effect, a  minsize  greater \n than 1 will add one additional pass to the processing. During the \n final pass, the threshold is ignored for any segments smaller then \n the set size, thus forcing very small segments to merge with their \n most similar neighbor. A minimum segment size larger than 1 is \n recommended when using adaptive bandwidth selected with the  -a  \n flag.\n  EXAMPLES \n  Segmentation of RGB orthophoto \n This example uses the ortho photograph included in the NC Sample \n Dataset. Set up an imagery group:\n i.group group=ortho_group input=ortho_2001_t792_1m@PERMANENT\n  Set the region to a smaller test region (resolution taken from\n input ortho photograph).\n g.region -p raster=ortho_2001_t792_1m n=220446 s=220075 e=639151 w=638592\n Try out a low threshold and check the results.\n i.segment group=ortho_group output=ortho_segs_l1 threshold=0.02\n From a visual inspection, it seems this results in too many segments. \n Increasing the threshold, using the previous results as seeds, \n and setting a minimum size of 2:\n i.segment group=ortho_group output=ortho_segs_l2 threshold=0.05 seeds=ortho_segs_l1 min=2\n i.segment group=ortho_group output=ortho_segs_l3 threshold=0.1 seeds=ortho_segs_l2\n i.segment group=ortho_group output=ortho_segs_l4 threshold=0.2 seeds=ortho_segs_l3\n i.segment group=ortho_group output=ortho_segs_l5 threshold=0.3 seeds=ortho_segs_l4\n The output  ortho_segs_l4  with  threshold =0.2 still has\n too many segments, but the output with  threshold =0.3 has too few\n segments. A threshold value of 0.25 seems to be a good choice. There\n is also some noise in the image, lets next force all segments smaller\n than 10 pixels to be merged into their most similar neighbor (even if\n they are less similar than required by our threshold):\n  Set the region to match the entire map(s) in the group.\n g.region -p raster=ortho_2001_t792_1m@PERMANENT\n Run  i.segment  on the full map:\n i.segment group=ortho_group output=ortho_segs_final threshold=0.25 min=10\n Processing the entire ortho image with nearly 10 million pixels took\n about 450 times more then for the final run.\n  Segmentation of panchromatic channel \n This example uses the panchromatic channel of the Landsat7 scene included\n in the North Carolina sample dataset:\n # create group with single channel\n i.group group=singleband input=lsat7_2002_80\n # set computational region to Landsat7 PAN band\n g.region raster=lsat7_2002_80 -p\n # perform segmentation with minsize=5\n i.segment group=singleband threshold=0.05 minsize=5 \n    output=lsat7_2002_80_segmented_min5 goodness=lsat7_2002_80_goodness_min5\n # perform segmentation with minsize=100\n i.segment group=singleband threshold=0.05 minsize=100\n   output=lsat7_2002_80_segmented_min100 goodness=lsat7_2002_80_goodness_min100\n  \n Original panchromatic channel of the Landsat7 scene\n  \n Segmented panchromatic channel, minsize=5\n  \n Segmented panchromatic channel, minsize=100\n  TODO \n  Functionality \n  Further testing of the shape characteristics (smoothness, \n compactness), if it looks good it should be added.\n ( in progress ) \n  Malahanobis distance for the similarity calculation. \n  Use of Segmentation Results \n  Improve the optional output from this module, or better yet, add a \n module for  i.segment.metrics . \n  Providing updates to  i.maxlik \n to ensure the segmentation output can be used as input for the\n existing classification functionality. \n  Integration/workflow for  r.fuzzy  (Addon). \n  Speed \n  See create_isegs.c \n  REFERENCES \n This project was first developed during GSoC 2012. Project documentation, \n Image Segmentation references, and other information is at the \n  project wiki .\n Information about \n  classification in GRASS  \n is at available on the wiki.\n ", "see_also": ["g.gui.iclass", "i.group", "i.maxlik", "i.smap", "r.kappa"], "authors": ["Eric Momsen - North Dakota State University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.segment"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.rgb.his.html", "name": "i.rgb.his", "definition": "- Transforms raster maps from RGB (Red-Green-Blue) color space to HIS (Hue-Intensity-Saturation) color space.", "keywords": ["imagery", "color transformation", "RGB", "HIS", "IHS"], "synopsis": "i.rgb.his red=name green=name blue=name hue=name intensity=name saturation=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": false, "explanation": "Name of input raster map (red)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": false, "explanation": "Name of input raster map (green)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": false, "explanation": "Name of input raster map (blue)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "hue", "flag": "hue", "dataType": "String", "optional": false, "explanation": "Name for output raster map (hue)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "intensity", "flag": "intensity", "dataType": "String", "optional": false, "explanation": "Name for output raster map (intensity)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "saturation", "flag": "saturation", "dataType": "String", "optional": false, "explanation": "Name for output raster map (saturation)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  i.rgb.his  is an image processing program that\n processes three input raster map layers as red, green, and\n blue components and produces three output raster map layers\n representing the hue, intensity, and saturation of the\n data.  The output raster map layers are created by a\n standard red-green-blue (RGB) to hue-intensity-saturation\n (HIS) color transformation.  Each output raster map layer\n is given a linear gray scale color table.  The current\n geographic region definition and mask settings are\n respected.\n ", "notes": "", "see_also": ["i.his.rgb"], "authors": ["David Satnik, GIS Laboratory, Central Washington University,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.rgb.his"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.rectify.html", "name": "i.rectify", "definition": "- Rectifies an image by computing a coordinate transformation for each pixel in the image based on the control points.", "keywords": ["imagery", "rectify"], "synopsis": "i.rectify [-cat] group=name  [input=name[,name,...]]  extension=string order=integer  [resolution=float]   [memory=memory in MB]   [method=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Use current region settings in target location (def.=calculate smallest area) Rectify all raster maps in group Use thin plate spline Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Rectify all raster maps in group Use thin plate spline Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Use thin plate spline Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "extension", "flag": "extension", "dataType": "String", "optional": false, "explanation": "Output raster map(s) suffix", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": false, "explanation": "Rectification polynomial order (1-3)", "defaultValue": "1", "alternatives": ["1-3"], "isInputFile": false, "isOutputFile": false}, {"parameter": "resolution", "flag": "resolution", "dataType": "String", "optional": true, "explanation": "Target resolution (ignored if -c flag used)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Amount of memory to use in MB", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Interpolation method to use", "defaultValue": "nearest", "alternatives": ["nearest", "linear", "cubic", "lanczos", "linear_f", "cubic_f", "lanczos_f"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.rectify  uses the control points included in the source data \n or identified with the\n  Ground Control Points Manager \n to calculate a transformation matrix and then converts x,y\n cell coordinates to standard map coordinates for each pixel\n in the image. The result is a planimetric image with a\n transformed coordinate system (i.e., a different coordinate\n system than before it was rectified). Supported transformation methods \n are first, second, and third order polynomial and thin plate spline. \n Thin plate spline is recommended for ungeoreferenced satellite imagery \n where ground control points (GCPs) are included. Examples are \n  NOAA/AVHRR \n and  ENVISAT  \n imagery which include throusands of GCPs.\n If no ground control points are available, the \n  Ground Control Points Manager \n must be run before  i.rectify . An image must be\n georeferences before it can reside in a standard coordinate\n LOCATION, and therefore be analyzed with the other map\n layers in the standard coordinate LOCATION. Upon\n completion of  i.rectify , the rectified image is\n deposited in the target standard coordinate LOCATION. This\n LOCATION is selected using\n  i.target .\n  More than one raster map may be rectified at a time. Each cell file\n should be given a unique output file name. The rectified image or\n rectified raster maps will be located in the target LOCATION when the\n program is completed. The original unrectified files are not modified\n or removed.\n  If the  -c  flag is used,  i.rectify  will only rectify that\n portion of the image or raster map that occurs within the chosen window\n region in the target location, and only that portion of the cell\n file will be relocated in the target database. It is\n important therefore, to check the current mapset window in\n the target LOCATION if the  -c  flag is used.\n If you are rectifying a file with plans to patch it to\n another file using the GRASS program  r.patch ,\n choose option number one, the current window in the target\n location. This window, however, must be the default window\n for the target LOCATION. When a file being rectified is\n smaller than the default window in which it is being\n rectified, NULLs are added to the rectified file. Patching\n files of the same size that contain NULL data,\n eliminates the possibility of a no-data line in the patched\n result. This is because, when the images are patched, the\n NULLs in the image are \"covered\" with non-NULL pixel\n values. When rectifying files that are going to be\n patched, rectify all of the files using the same default\n window.\n  Coordinate transformation \n  The desired order of transformation (1, 2, or 3) is selected with the\n  order  option.\n The program will calculate the RMSE and check the required number of points.\n  Linear affine transformation (1st order transformation) \n \t  x' = ax + by + c\n \t  y' = Ax + By + C\n The a,b,c,A,B,C are determined by least squares regression\n based on the control points entered.  This transformation\n applies scaling, translation and rotation. It is NOT a\n general purpose rubber-sheeting like TPS, nor is it ortho-photo\n rectification using a DEM, not second order polynomial,\n etc. It can be used if (1) you have geometrically correct\n images, and (2) the terrain or camera distortion effect can\n be ignored.\n  Polynomial Transformation Matrix (2nd, 3d order transformation) \n  i.rectify  uses a first, second, or third order transformation\n matrix to calculate the registration coefficients. The number\n of control points required for a selected order of transformation\n (represented by n) is\n  ((n + 1) * (n + 2) / 2) \n or 3, 6, and 10 respectively. It is strongly recommended\n that one or more additional points be identified to allow\n for an overly-determined transformation calculation which\n will generate the Root Mean Square (RMS) error values for\n each included point. The RMS error values for all the\n included control points are immediately recalculated when\n the user selects a different transformation order from the\n menu bar. The polynomial equations are performed using a \n modified Gaussian elimination method.\n  Thin plate spline (TPS) transformation \n TPS transformation is selected with the  -t  flag. This method of\n coordinate transformation is recommended for satellite imagery where \n hundreds or thousands of GCPs are included, and for historical printed \n or scanned maps with unknown georeferencing and/or known localized \n distortions. \n TPS combines a linear affine transformation with individual \n transformation coefficients for each GCP, using the radial basis kernel \n function with the distance  dist  between any two points:\n  dist 2  * log(dist)\n As a consequence, localized distortions can be removed with TPS \n transformation. For example, scan line sensors will have due to the \n changing viewing angle larger distortions towards the end points of the \n scan line than at the center of the scan line. Even higher order \n polynomial transformations are not able to remove these locally \n different distortions, but TPS transformation can. For best results, \n TPS requires an even and, for localized distortions, dense spacing of \n GCPs.\n  Resampling method \n  The rectified data is resampled with one of seven different methods: \n  nearest ,  bilinear ,  cubic ,  lanczos ,\n  bilinear_f ,  cubic_f , or  lanczos_f .\n  The  method=nearest  method, which performs a nearest neighbor assignment,\n is the fastest of the resampling methods. It is primarily used for\n categorical data such as a land use classification, since it will not change\n the values of the data cells. The  method=bilinear  method determines the new\n value of the cell based on a weighted distance average of the 4 surrounding\n cells in the input map. The  method=cubic  method determines the new value of\n the cell based on a weighted distance average of the 16 surrounding cells in\n the input map.  The  method=lanczos  method determines the new value of\n the cell based on a weighted distance average of the 25 surrounding cells in\n the input map.\n  The bilinear, cubic and lanczos interpolation methods are most appropriate for\n continuous data and cause some smoothing. These options should not be used\n with categorical data, since the cell values will be altered.\n  In the bilinear, cubic and lanczos methods, if any of the surrounding cells used to\n interpolate the new cell value are NULL, the resulting cell will be NULL, even if\n the nearest cell is not NULL. This will cause some thinning along NULL borders,\n such as the coasts of land areas in a DEM. The bilinear_f, cubic_f and lanczos_f\n interpolation methods can be used if thinning along NULL edges is not desired.\n These methods \"fall back\" to simpler interpolation methods along NULL borders.\n That is, from lanczos to cubic to bilinear to nearest.\n  If nearest neighbor assignment is used, the output map has the same raster\n format as the input map. If any of the other interpolations is used, the\n output map is written as floating point.\n ", "notes": "\n If  i.rectify  starts normally but after some time the following text is seen:\n ERROR: Error writing segment file\n the user may try the  -c  flag or the module needs more free space\n on the hard drive.\n ", "see_also": ["Image Processing manual"], "authors": ["William R. Enslin, Michigan State University, Center for Remote Sensing"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.rectify"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.pca.html", "name": "i.pca", "definition": "- Principal components analysis (PCA) for image processing.", "keywords": ["imagery", "transformation", "PCA", "principal components analysis"], "synopsis": "i.pca [-nf] input=name[,name,...] output=basename  [rescale=min,max]   [percent=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Normalize (center and scale) input maps Default: center only Output will be filtered input bands Apply inverse PCA after PCA Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Output will be filtered input bands Apply inverse PCA after PCA Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of two or more input raster maps or imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output basename raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "rescale", "flag": "rescale", "dataType": "String", "optional": true, "explanation": "Rescaling range for output maps", "defaultValue": "0,255", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "percent", "flag": "percent", "dataType": "String", "optional": true, "explanation": "Cumulative percent importance for filtering", "defaultValue": "99", "alternatives": ["50-99"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.pca  is an image processing program based on the\n algorithm provided by Vali (1990), that processes n\n (n\u00a0>=\u00a02) input raster map layers and produces n output\n raster map layers containing the principal components of\n the input data in decreasing order of variance\n (\"contrast\").  The output raster map layers are assigned\n names with .1, .2, ... .n suffixes. The numbers used as suffix \n correspond to percent importance with .1 being the scores of the \n principal component with the highest importance.\n The current geographic region definition and MASK settings are \n respected when reading the input raster map layers. When the rescale\n option is used, the output files are rescaled to fit the min,max range.\n The order of the input bands does not matter for the output maps \n (PC scores), but does matter for the vectors (loadings), since each \n loading refers to a specific input band.\n If the output is not rescaled ( rescale=0,0 , the output raster \n maps will be of type DCELL, otherwise the output raster maps will be of \n type CELL.\n  By default, the values of the input raster maps are centered for each \n map separately with  x - mean . With  -n , the input raster \n maps are normalized for each map separately with  (x - mean) / stddev . \n Normalizing is highly recommended when the input raster maps have different\n units, e.g. represent different environmental parameters. \n  The  -f  flag, together with the  percent  option, can \n be used to remove noise from input bands. Input bands will be \n recalculated from a subset of the principal components (inverse PCA). \n The subset is selected by using only the most important (highest \n eigenvalue) principal components which explain together  percent  \n percent variance observed in the input bands.\n ", "notes": "\n Richards (1986) gives a good example of the application of principal\n components analysis (PCA) to a time series of LANDSAT images of a burned\n region in Australia.\n Eigenvalue and eigenvector information is stored in the output maps'\n history files. View with  r.info .\n  EXAMPLE \n PCA calculation using Landsat7 imagery in the North Carolina sample dataset:\n g.region raster=lsat7_2002_10 -p\n i.pca in=lsat7_2002_10,lsat7_2002_20,lsat7_2002_30,lsat7_2002_40,lsat7_2002_50,lsat7_2002_70 \n      out=lsat7_2002_pca\n r.info -h lsat7_2002_pca.1\n    Eigen values, (vectors), and [percent importance]:\n    PC1   4334.35 ( 0.2824, 0.3342, 0.5092,-0.0087, 0.5264, 0.5217) [83.04%]\n    PC2    588.31 ( 0.2541, 0.1885, 0.2923,-0.7428,-0.5110,-0.0403) [11.27%]\n    PC3    239.22 ( 0.3801, 0.3819, 0.2681, 0.6238,-0.4000,-0.2980) [ 4.58%]\n    PC4     32.85 ( 0.1752,-0.0191,-0.4053, 0.1593,-0.4435, 0.7632) [ 0.63%]\n    PC5     20.73 (-0.6170,-0.2514, 0.6059, 0.1734,-0.3235, 0.2330) [ 0.40%]\n    PC6      4.08 (-0.5475, 0.8021,-0.2282,-0.0607,-0.0208, 0.0252) [ 0.08%]\n d.mon wx0\n d.rast lsat7_2002_pca.1\n # ...\n d.rast lsat7_2002_pca.6\n In this example, the first two PCAs (PCA1 and PCA2) already explain 94.31% of\n the variance in the six input channels.\n Resulting PCA maps calculated from the Landsat7 imagery (NC, USA)\n ", "see_also": [], "authors": ["David Satnik, GIS Laboratory"], "source_code": null},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.pansharpen.html", "name": "i.pansharpen", "definition": "- Image fusion algorithms to sharpen multispectral with high-res panchromatic channels", "keywords": ["imagery", "fusion", "sharpen", "Brovey", "IHS", "HIS", "PCA"], "synopsis": "i.pansharpen [-sl] red=name green=name blue=name pan=name output=basename method=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Serial processing rather than parallel processing Rebalance blue channel for LANDSAT Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Rebalance blue channel for LANDSAT Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <red>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <green>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <blue>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "pan", "flag": "pan", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for high resolution panchromatic channel", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output basename raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Method for pan sharpening", "defaultValue": "ihs", "alternatives": ["brovey", "ihs", "pca"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.pansharpen  uses a high resolution panchromatic band from a\n multispectral image to sharpen 3 lower resolution bands. The 3\n lower resolution bands can then be combined into an RGB color image at a\n higher (more detailed) resolution than is possible using the original 3\n bands. For example, Landsat ETM has low resolution spectral bands 1 (blue),\n 2 (green), 3 (red), 4 (near IR), 5 (mid-IR), and 7 (mid-IR) at 30m resolution, \n and a high resolution panchromatic band 8 at 15m resolution. Pan sharpening\n allows bands 3-2-1 (or other combinations of 30m resolution bands like 4-3-2 \n or 5-4-2) to be combined into a 15m resolution color image.\n i.pansharpen offers a choice of three different 'pan sharpening' \n algorithms: IHS, Brovey, and PCA.\n For  IHS pan sharpening , the original 3 lower resolution bands, selected \n as red, green and blue channels for creating an RGB composite image, are \n transformed into IHS (intensity, hue, and saturation) color space. The \n panchromatic band is then substituted for the intensity channel (I), combined \n with the original hue (H) and saturation (S) channels, and transformed back to \n RGB color space at the higher resolution of the panchromatic band. The \n algorithm for this can be represented as: RGB -> IHS -> [pan]HS -> RGB.\n With a  Brovey pan sharpening , each of the 3 lower resolution bands and \n panchromatic band are combined using the following algorithm to calculate \n 3 new bands at the higher resolution (example for band 1):\n                          band1 \n     new band1 = ----------------------- * panband\n                  band1 + band2 + band3\n In  PCA pan sharpening , a principal component analysis is performed on the \n original 3 lower resolution bands to create 3 principal component images\n (PC1, PC2, and PC3) and their associated eigenvectors (EV), such that:\n     \n      band1  band2  band3\n PC1: EV1-1  EV1-2  EV1-3\n PC2: EV2-1  EV2-2  EV2-3\n PC3: EV3-1  EV3-2  EV3-3  \n and\n PC1 = EV1-1 * band1 + EV1-2 * band2 + EV1-3 * band3 - mean(bands 1,2,3)\n An inverse PCA is then performed, substituting the panchromatic band for PC1. \n To do this, the eigenvectors matrix is inverted (in this case transposed), the \n PC images are multiplied by the eigenvectors with the panchromatic band \n substituted for PC1, and mean of each band is added to each transformed image \n band using the following algorithm (example for band 1):\n band1' = pan * EV1-1 + PC2 * EV2-1 + PC3 * EV3-1 + mean(band1)\n    \n The assignment of the channels depends on the satellite. Examples of satellite \n imagery with high resolution panchromatic bands, and lower resolution spectral \n bands include Landsat 7 ETM, QuickBird, and SPOT.\n ", "notes": "\n The module currently only works for 8-bit images.\n The command temporarily changes the computational region to the high \n resolution of the panchromatic band during sharpening calculations, then \n restores the previous region settings. The current region coordinates (and \n null values) are respected. The high resolution panchromatic image is \n histogram matched to the band it is replaces prior to substitution (i.e., the \n intensity channel for IHS sharpening, the low res band selected for each color \n channel with Brovey sharpening, and the PC1 image for PCA sharpening).\n By default, the command will attempt to employ parallel processing, using \n up to 3 cores simultaneously. The -s flag will disable parallel processing, \n but does use an optimized r.mapcalc expression to reduce disk I/O.\n The three pan-sharpened output channels may be combined with  d.rgb  or \n  r.composite . Colors may be optionally optimized with  i.colors.enhance .\n While the resulting color image will be at the higher resolution in all cases, \n the 3 pan sharpening algorithms differ in terms of spectral response.  \n  EXAMPLES \n  Pan sharpening comparison example \n Pan sharpening of a Landsat image from Boulder, Colorado, USA:\n # R, G, B composite at 30m \n g.region raster=p034r032_7dt20010924_z13_10 -p\n d.rgb b=p034r032_7dt20010924_z13_10 g=lp034r032_7dt20010924_z13_20 \n     r=p034r032_7dt20010924_z13_30\n # i.pansharpen with IHS algorithm\n i.pansharpen red=p034r032_7dt20010924_z13_30 green=p034r032_7dt20010924_z13_20 \n     blue=p034r032_7dt20010924_z13_10 pan=p034r032_7dp20010924_z13_80 \n     output=ihs321 method=ihs\n # ... likewise with method=brovey and method=pca\n # display at 15m\n g.region raster=ihs321_blue -p\n d.rgb b=ihs321_blue g=ihs321_green r=ihs321_red\n  Results: \n    \n    \n      \n       \u00a0 \n        \n        \n        R, G, B composite of Landsat at 30m \n        \n      \n      \n       \u00a0 \n        \n        \n        R, G, B composite of Brovey sharpened image at 15m \n        \n      \n    \n    \n      \n       \u00a0 \n        \n        \n        R, G, B composite of IHS sharpened image at 15m \n        \n      \n      \n       \u00a0 \n        \n        \n        R, G, B composite of PCA sharpened image at 15m\" \n        \n      \n    \n    \n  Pan sharpening of LANDSAT ETM+ (Landsat 7) \n LANDSAT ETM+ (Landsat 7), North Carolina sample dataset:\n # original at 28m\n g.region raster=lsat7_2002_10 -p\n d.mon wx0\n d.rgb b=lsat7_2002_10 g=lsat7_2002_20 r=lsat7_2002_30\n # i.pansharpen with IHS algorithm\n i.pansharpen red=lsat7_2002_30@PERMANENT \n    green=lsat7_2002_20 blue=lsat7_2002_10 \n    pan=lsat7_2002_80 method=ihs \n    output=lsat7_2002_ihs\n # display at 14.25m\n g.region raster=lsat7_2002_ihs_red -p\n d.erase\n d.rgb r=lsat7_2002_ihs_red g=lsat7_2002_ihs_green b=lsat7_2002_ihs_blue\n # compare before/after (RGB support in \"Advanced\"):\n g.gui.mapswipe\n # optionally color balancing:\n i.colors.enhance r=lsat7_2002_ihs_red g=lsat7_2002_ihs_green b=lsat7_2002_ihs_blue\n ", "see_also": ["i.his.rgb", "i.rgb.his", "i.pca", "d.rgb", "r.composite"], "authors": ["Michael Barton (Arizona State University, USA)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/i.pansharpen"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.ortho.transform.html", "name": "i.ortho.transform", "definition": "- Computes a coordinate transformation based on the control points.", "keywords": ["imagery", "orthorectify", "transformation", "GCP"], "synopsis": "i.ortho.transform [-srx] group=name  [format=string[,string,...]]   [coords=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Display summary information Reverse transform of coords file or coeff. dump Target east,north,height coordinates to local x,y,z Display transform matrix coefficients Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Reverse transform of coords file or coeff. dump Target east,north,height coordinates to local x,y,z Display transform matrix coefficients Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "x", "flag": "-x", "explanation": "Display transform matrix coefficients Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Output format", "defaultValue": "fd,rd", "alternatives": ["idx", "src", "dst", "fwd", "rev", "fxy", "rxy", "fd", "rd"], "isInputFile": false, "isOutputFile": false}, {"parameter": "coords", "flag": "coords", "dataType": "String", "optional": true, "explanation": "File containing coordinates to transform (\"-\" to read from stdin)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  i.ortho.transform  is an utility to compute transformation\n based upon GCPs and output error measurements.\n If coordinates are given with the  input  file option or fed from \n  stdin , both the input and the output format is \"x y z\" with one \n coordinate pair per line. Reverse transform is performed with the \n  -r  flag.\n The  format  option determines how control points are printed out. \n A summary on the control points can be printed with the  -s  flag. \n The summary includes maximum deviation observed when transforming GCPs \n and overall RMS. The  format  option is ignored when coordinates \n are given with the  input  file option.\n ", "notes": "\n Ortho-transformation is a 2-step transformation. First, source \n coordinates are transformed to sensor coordinates, then sensor \n coordinates are transformed to target coordinates. \n ", "see_also": ["i.rectify"], "authors": ["Brian J. Buckley"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.ortho.photo/i.ortho.transform"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.ortho.target.html", "name": "i.ortho.target", "definition": "- Select or modify the imagery group target.", "keywords": ["imagery", "orthorectify"], "synopsis": "i.ortho.target group=name target_location=name mapset_location=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of imagery group for ortho-rectification", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "target_location", "flag": "target_location", "dataType": "String", "optional": false, "explanation": "Location name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapset_location", "flag": "mapset_location", "dataType": "String", "optional": false, "explanation": "Name of mapset (default: current search path)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "", "notes": "", "see_also": [], "authors": [], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.ortho.photo/i.ortho.target"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.ortho.rectify.html", "name": "i.ortho.rectify", "definition": "- Orthorectifies an image by using the image to photo coordinate transformation matrix.", "keywords": ["imagery", "orthorectify"], "synopsis": "i.ortho.rectify [-ca] group=name  [input=name[,name,...]]  extension=string  [resolution=float]   [memory=memory in MB]   [method=string]   [angle=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Use current region settings in target location (def.=calculate smallest area) Rectify all raster maps in group Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Rectify all raster maps in group Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "extension", "flag": "extension", "dataType": "String", "optional": false, "explanation": "Output raster map(s) suffix", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "resolution", "flag": "resolution", "dataType": "String", "optional": true, "explanation": "Target resolution (ignored if -c flag used)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Amount of memory to use in MB", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Interpolation method to use", "defaultValue": "nearest", "alternatives": ["nearest", "linear", "cubic", "lanczos", "linear_f", "cubic_f", "lanczos_f"], "isInputFile": false, "isOutputFile": false}, {"parameter": "angle", "flag": "angle", "dataType": "String", "optional": true, "explanation": "Raster map with camera angle relative to ground surface", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "", "notes": "", "see_also": [], "authors": [], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.ortho.photo/i.ortho.rectify"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.ortho.photo.html", "name": "i.ortho.photo", "definition": "- Menu driver for the photo imagery programs.", "keywords": ["imagery", "orthorectify"], "synopsis": "i.ortho.photo group=name productname=string  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of imagery group for ortho-rectification", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "productname", "flag": "productname", "dataType": "String", "optional": false, "explanation": "Name of Modules", "defaultValue": null, "alternatives": ["i.group", "i.ortho.target", "i.ortho.elev", "i.ortho.camera", "g.gui.photo2image", "i.ortho.init", "g.gui.image2target", "i.ortho.rectify"], "isInputFile": false, "isOutputFile": false}], "description": "\n  i.ortho.photo  is a menu to launch the different parts of the \n ortho rectification process of aerial imagery.  i.ortho.photo \n allows the user to ortho-rectify imagery group files consisting of\n several scanned aerial photographs (raster maps) of a common area.\n  i.ortho.photo  guides the user through 8 steps required to\n ortho-rectify the raster maps in a single imagery group. Alternatively,\n all the steps can be performed separately by running the appropriate modules.\n  Initialization Options \n  Create/Modify imagery group to be orthorectified:\n  i.group \n  Select/Modify target location and mapset for orthorectification:\n  i.ortho.target \n  Select/Modify target elevation model used for orthorectification:\n  i.ortho.elev \n  Create/Modify camera file of imagery group:\n  i.ortho.camera \n  Transformation Parameters Computation \n   Compute image-to-photo transformation:\n  g.gui.photo2image \n   Initialize parameters of camera:\n  i.ortho.init \n   Compute ortho-rectification parameters from ground control points:\n  g.gui.image2target \n  Ortho-rectification \n   Ortho-rectify imagery group:\n  i.ortho.rectify \n  \n The ortho-rectification procedure in GRASS GIS places the image pixels on \n the surface of the earth by matching the coordinate system of the aerial\n image in pixels ( image coordinate system ) and the coordinate \n system of the camera sensor in millimetres ( photo coordinate system )\n for the interior orientation of the image, and further to the georeferenced\n coordinate system defined by projection parametres \n ( target coordinate system ) for exterior orientation.\n         \n  EXAMPLE \n Five groups of input parameters are required for ortho-rectification:\n   \n  Aerial image (images), \n  Exposure and characteristics of the camera, i.e. its coordinates in\n target coordinate system and height above sea level, focal length, yaw, \n pitch and roll, dimensions of the camera sensor and resolution of aerial\n images, \n  Reference surface, i.e. digital elevation model in the target coordinate\n system used to normalize the terrain undulation, \n  Topographic reference map used to find corresponding ground control\n points and/or, \n  Coordinates of ground control points in the target coordinate system. \n  Example of an input oblique image in a source location \n \t\t\n To ortho-rectify aerial images the user has to follow the menu options\n step by step. Alternatively, all the steps can be performed separately\n by running the corresponding modules.\n The aerial photos shall be stored in a  source location  - a general \n Cartesian coordinate system (XY). Digital elevation model and a map reference \n (topo sheet or other map used for ground control point matching) shall \n be stored in a  target location  in a real-world coordinate system\n (e.g. ETRS33).\n The steps to follow are described below:\n  Create/Modify imagery group to be orthorectified:\n  i.group \n This step is to be run in the  source location . \n In this first step an imagery group of aerial images for ortho-rectification \n is created or modified. The current imagery group is displayed at the top\n of the menu. You may select a new or existing imagery\n group for the ortho-rectification. After choosing this option you will\n be prompted for the name of a new or existing imagery group. As a result,\n a new file  mapset/group/name_of_group/ REF \n is created that contatins the names of all images in a group.\n IMG_0020 source_mapset\n IMG_0021 source_mapset\n IMG_0022 source_mapset\n  Select/Modify target location and mapset for orthorectification:\n  i.ortho.target \n This step is to be run in the  source location .\n The target location and mapset may be selected or modified in Step 2.\n You will be prompted for the names of the projected target location and\n mapset where the ortho-rectified raster maps will reside. The target\n location is also the location from which the elevation model (raster\n map) will be selected (see Step 3). In Step 2, a new file\n  mapset/group/name_of_group/ TARGET \n is created contatining the names of target location and mapset.\n ETRS_33N\n target_mapset\n  Select/Modify target elevation model used for orthorectification:\n  i.ortho.elev \n This step is to be run in the  source location .\n Step 3 allows you to select the raster map from the target location to be \n used as the elevation model. The elevation model is required for both the \n computation of photo-to-target parameters (Step 6) and for the \n ortho-rectification of the imagery group files (Step 8). \n The raster map selected for the elevation model should cover the entire\n area of the image group to be ortho-rectified. DTED and DEM files are\n suitable for use as elevation model in the ortho-rectification program.\n In Step 3 you will be prompted for the name of the raster map in the\n target location that you want to use as the elevation model. As a result\n of this step, a new file  mapset/group/name_of_group/ ELEVATION \n is created contatining the name and mapset of the chosen DEM.\n elevation layer :ELEVATION\n mapset elevation:target_mapset\n location        :ETRS_33N\n math expression :(null)\n units           :(null)\n no data values  :(null)\n   Create/Modify camera file of imagery group:\n  i.ortho.camera \n This step is to be run in the  source location .\n In Step 4 you may select or create a camera reference file that will be\n used with the current imagery group. A camera reference file contains\n information on the internal characteristics of the aerial camera, as well\n as the geometry of the fiducial or reseau marks. The most important\n characteristic of the camera is its focal length. Fiducial or reseau marks\n locations are required to compute the scanned image to photo coordinate\n transformation parameter (Step 5). Two new files are created in this step:\n a file  mapset/group/name_of_group/ CAMERA , contatining\n the name of the reference camera and a file\n  mapset/camera/ name_of_reference , contatining the\n camera parameters.\n CAMERA NAME   sony \n CAMERA ID     123 \n CAMERA XP     0 \n CAMERA YP     0 \n CAMERA CFL    16 \n NUM FID       4 \n       0 -11.6 0 \n       1 0 7.7 \n       2 11.6 0 \n       3 0 -7.7 \n   Compute image-to-photo transformation:\n  g.gui.photo2image \n This step is to be run in the  source location .\n The scanned image to photo coordinate transformation parameters, i.e. the \n \"interior orientation\", is computed in Step 5. In this interactive step you \n associate the scanned reference points (fiducials, reseau marks, etc.)\n with their known photo coordinates from the camera reference file. A new\n file  mapset/group/name_of_group/ REF_POINTS \n is created, contatining a list of pairs of coordinates in image and photo \n coordinate systems.\n # Ground Control Points File\n # \n # target location: XY\n # target mapset: source_mapset\n # source  target  status\n # east north east north (1=ok, 0=ignore)\n #-------------------------------------------------------------\n 0 1816     -11.6 0.0     1\n 2728 3632     0.0 7.7     1\n 5456 1816     11.6 0.0     1\n 2728 0.0     0.0 -7.7     1\n  Step 5: Image-to-photo transformation of an oblique image \n   Initialize parameters of camera:\n  i.ortho.init \n This step is to be run in the  source location . \n In Step 6, initial camera exposure station parameters and initial variances \n may be selected or modified. \n   \n      X : East aircraft position; \n      Y : North aircraft position; \n      Z : Flight heigh above surface; \n \t Omega (roll) : Raising or lowering of the wings (turning \n \taround the aircraft's axis); \n      Phi (pitch) : Raising or lowering of the aircraft's front \n \t(turning around the wings' axis); \n \t Kappa (yaw) : Rotation needed to align the aerial photo to \n \ttrue north: needs to be denoted as +90\u00b0 for clockwise turn and\n \t-90\u00b0 for a counter-clockwise turn. \n  Principle of pitch and yaw \n  In Step 6, a new file  mapset/group/name_of_group/ INIT_EXP \n is created, contatining camera parameters.\n INITIAL XC    215258.345387 \n INITIAL YC    6911444.022270 \n INITIAL ZC    1101.991120 \n INITIAL OMEGA 0.000000 \n INITIAL PHI   -0.168721 \n INITIAL KAPPA 3.403392 \n VARIANCE XC    5.000000 \n VARIANCE YC    5.000000 \n VARIANCE ZC    5.000000 \n VARIANCE OMEGA 0.000000 \n VARIANCE PHI   0.020153 \n VARIANCE KAPPA 0.017453 \n STATUS (1=OK, 0=NOT OK) 0 \n   Compute ortho-rectification parameters from ground control points:\n  g.gui.image2target \n This step is to be run in the  target location .\n The photo to target transformation parameters, i.e. the \"exterior \n orientation\", is computed in Step 7. In this interactive step, control\n points are marked on one or more imagery group files and associated with\n the known standard (e.g. UTM) and elevation coordinates.\n Reasonable rectification results can be obtained with around twelve\n control points well distributed over the image.\n In this step, a new file  mapset/group/name_of_group/ CONTROL_POINTS \n is created, contatining a list of pairs of coordinates of ground control\n points in photo and target coordinate systems.\n # Ground Control Points File\n # \n # target location: ETRS_33N\n # target mapset: target_mapset\n #\tsource                          target                     status\n #\teast\tnorth\theight          east\tnorth\theight    (1=ok, 0=ignore)\n #------------------------------     ----------------------    ---------------\n 98.3679932698 906.327649515 0.0 \t1.0 5.0  100.0             1\n 733.293023813 1329.61100321 0.0 \t2.0 6.0  100.0             1\n 1292.6317412  1703.76325335 0.0 \t3.0 7.0  100.0             1\n 1625.54617472 1368.11694482 0.0 \t4.0 6.0  100.3             1\n 3239.82849913 1390.97403968 0.0 \t7.4 6.0  100.3             1\n 1570.09788497 2790.06537829 0.0 \t3.0 11.0 100.0             1\n  Step 7: Detail of ground control points matching in an oblique image and terrain model \n   Ortho-rectify imagery group:\n  i.ortho.rectify \n This step is to be run in the  source location .\n Step 8 is used to perform the actual image ortho-rectification after all\n of the transformation parameters have been computed. Ortho-rectified raster\n files will be created in the target location for each selected imagery\n group file. You may select either the current window in the target\n location or the minimal bounding window for the ortho-rectified image.\n  \n  Step 8: Ortho-rectified oblique image \n As a result, the ortho-rectified raster map is available for visualization\n and further image analysis.\n ", "notes": "", "see_also": ["g.gui.image2target", "g.gui.photo2image", "i.group", "i.ortho.camera", "i.ortho.elev", "i.ortho.init", "i.ortho.rectify", "i.ortho.target"], "authors": ["Mike Baba, DBA Systems, Inc."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.ortho.photo/i.ortho.photo"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.ortho.init.html", "name": "i.ortho.init", "definition": "- Interactively creates or modifies entries in a camera initial exposure station file for imagery group referenced by a sub-block.", "keywords": ["imagery", "orthorectify"], "synopsis": "i.ortho.init [-rp] group=name  [xc=float]   [yc=float]   [zc=float]   [xc_sd=float]   [yc_sd=float]   [zc_sd=float]   [omega=float]   [phi=float]   [kappa=float]   [omega_sd=float]   [phi_sd=float]   [kappa_sd=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Use initial values at run time Print initial values Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print initial values Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of imagery group for ortho-rectification", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "xc", "flag": "xc", "dataType": "String", "optional": true, "explanation": "Initial Camera Exposure X-coordinate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "yc", "flag": "yc", "dataType": "String", "optional": true, "explanation": "Initial Camera Exposure Y-coordinate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zc", "flag": "zc", "dataType": "String", "optional": true, "explanation": "Initial Camera Exposure Z-coordinate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "xc_sd", "flag": "xc_sd", "dataType": "String", "optional": true, "explanation": "Apriori X-coordinate standard deviation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "yc_sd", "flag": "yc_sd", "dataType": "String", "optional": true, "explanation": "Apriori Y-coordinate standard deviation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zc_sd", "flag": "zc_sd", "dataType": "String", "optional": true, "explanation": "Apriori Z-coordinate standard deviation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "omega", "flag": "omega", "dataType": "String", "optional": true, "explanation": "Initial Camera Omega (roll) degrees", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "phi", "flag": "phi", "dataType": "String", "optional": true, "explanation": "Initial Camera Phi (pitch) degrees", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "kappa", "flag": "kappa", "dataType": "String", "optional": true, "explanation": "Initial Camera Kappa (yaw) degrees", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "omega_sd", "flag": "omega_sd", "dataType": "String", "optional": true, "explanation": "Apriori Omega (roll) standard deviation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "phi_sd", "flag": "phi_sd", "dataType": "String", "optional": true, "explanation": "Apriori Phi (pitch) standard deviation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "kappa_sd", "flag": "kappa_sd", "dataType": "String", "optional": true, "explanation": "Apriori Kappa (yaw) standard deviation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n Aerial photographs may be either vertical or oblique. Vertical photographs\n can be truly vertical (nadir), or slightly tilted (less than 3 degree\n from the vertical). Usually aerial photos are tilted to some degree. We\n refer to the term  vertical photograph  up to a tilt of 3 degree.\n Oblique aerial photographs are purposely taken with an\n angle between 3 and 90 degree from the nadir direction.\n  The use of  i.ortho.init  (menu 6) is only required when rectifying a\n tilted or oblique aerial photo. \n  i.ortho.init  creates or modifies entries in a camera initial exposure\n station file for imagery group referenced by a sub-block.  These entries\n include: the (XC,YC,ZC) standard (e.g. UTM) approximate coordinates of the camera exposure\n station; initial roll, pitch, and yaw angles (in degrees) of the cameras\n attitude; and the  a priori  standard deviations for these\n parameters. During the imagery program,  i.photo.rectify , the initial camera\n exposure station file is used for computation of the ortho-rectification\n parameters.  If no initial camera exposure station file exist, the default\n values are computed from the control points file created in  i.photo.2target .\n The following menu is displayed:\n         Please provide the following information\n \tINITIAL XC: Meters                __________\n \tINITIAL YC: Meters                __________\n \tINITIAL ZC: Meters                __________\n \tINITIAL omega (roll) degrees:     __________\n \tINITIAL phi  (pitch) degrees:     __________\n \tINITIAL kappa  (yaw) degrees:     __________\n \tStandard Deviation XC: Meters     __________\n \tStandard Deviation YC: Meters     __________\n \tStandard Deviation ZC: Meters     __________\n \tStd. Dev. omega (roll) degrees:   __________\n \tStd. Dev. phi  (pitch) degrees:   __________\n \tStd. Dev. kappa  (yaw) degrees:   __________\n         Use these values at run time? (1=yes, 0=no)\n      AFTER COMPLETING ALL ANSWERS, HIT <ESC> TO CONTINUE\n                   (OR <Ctrl-C> TO CANCEL)\n The INITIAL values for (XC,YC,ZC) are expressed in standard (e.g. UTM) coordinates, and\n represent an approximation for the location of the camera at the time of \n exposure.\n   X: East aircraft position;\n   Y: North aircraft position;\n   Z: Flight altitude above sea level\n The INITIAL values for (omega,phi,kappa) are expressed in degrees, and\n represent an approximation for the cameras attitude  at the time of \n exposure. \n   Omega (roll): Raising or lowering of the wings (turning around the\n   aircraft's axis);\n   Phi (pitch): Raising or lowering of the aircraft's front (turning\n   around the wings' axis);\n   Kappa (yaw): Rotation needed to align the aerial photo to true north:\n   needs to be denoted as +90 degree for clockwise turn and -90 degree for\n   a counterclockwise turn.\n The standard deviations for (XC,YC,ZC) are expressed in meters, and\n are used as  a priori  values for the standard deviations used in \n computation of the ortho rectification parameters.\n The standard deviations for (omega,phi,kappa) are expressed in degrees, and\n are used as  a priori  values for the standard deviations used in \n computation of the ortho rectification parameters.\n If  Use these values at run time? (1=yes, 0=no)  is set to 0, the\n values in this menu are not used.\n ", "notes": "", "see_also": ["i.ortho.photo", "i.photo.2image", "i.photo.2target", "i.ortho.elev", "i.ortho.camera", "i.ortho.transform", "i.photo.rectify"], "authors": ["Mike Baba, DBA Systems, Inc."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.ortho.photo/i.ortho.init"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.ortho.elev.html", "name": "i.ortho.elev", "definition": "- Select or modify the target elevation model.", "keywords": ["imagery", "orthorectify"], "synopsis": "i.ortho.elev [-p] group=name  [location=name]   [mapset=name]   [elevation=name]   [math_expression=string]   [units=string]   [null_value=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print currently selected elevation map and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of imagery group for ortho-rectification", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Location name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapset", "flag": "mapset", "dataType": "String", "optional": true, "explanation": "Name of mapset (default: current search path)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Name of elevation map to use for ortho-rectification", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "math_expression", "flag": "math_expression", "dataType": "String", "optional": true, "explanation": "Math expression to convert to real elevation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Unit of the elevation map", "defaultValue": null, "alternatives": ["miles", "feet", "meters", "kilometers", "acres", "hectares"], "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "No data value", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  i.ortho.elev  is used to select or modify the target elevation model.\n ", "notes": "", "see_also": ["i.ortho.photo", "i.ortho.camera", "i.photo.2image", "i.photo.2target", "i.ortho.init", "i.rectify"], "authors": ["Mike Baba, DBA Systems, Inc."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.ortho.photo/i.ortho.elev"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/i.ortho.camera.html", "name": "i.ortho.camera", "definition": "- Select and modify the imagery group camera reference file.", "keywords": ["imagery", "orthorectify"], "synopsis": "i.ortho.camera  [group=name]  camera=name  [name=string]   [id=string]   [clf=float]   [pp=east,north]   [fid=east,north[,east,north,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": true, "explanation": "Name of imagery group for ortho-rectification", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "camera", "flag": "camera", "dataType": "String", "optional": false, "explanation": "Name of camera reference file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "name", "flag": "name", "dataType": "String", "optional": true, "explanation": "Camera name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "id", "flag": "id", "dataType": "String", "optional": true, "explanation": "Camera id", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "clf", "flag": "clf", "dataType": "String", "optional": true, "explanation": "Calibrated focal length", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "pp", "flag": "pp", "dataType": "String", "optional": true, "explanation": "Principal point coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fid", "flag": "fid", "dataType": "String", "optional": true, "explanation": "Fiducial coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  i.ortho.camera  creates or modifies entries in a camera reference\n file. For ortho-photo rectification, a camera reference file is required for\n computation of scanned image to photo-coordinate transformation parameters.\n There are two coordinate systems: The image coordinate system (in pixels)\n and the photo coordinate system (in milli-meters). The inner orientation\n establishes a relation between the pixels and the image coordinates with\n help of fiducial marks.\n The first prompt in the program will ask you for the name of \n the camera reference file to be created or modified.  You may\n create a new camera reference file by entering a new name, or modify an\n existing camera reference file by entering the name of an existing camera file.\n After entering the camera file name, following menu is displayed:\n Please provide the following information\n \tCAMERA NAME:                camera name ______\n \tCAMERA IDENTIFICATION:      identification ___\n \tCALIBRATED FOCAL LENGTH mm.:_________________\n \tPOINT OF SYMMETRY (X)   mm.:_________________\n \tPOINT OF SYMMETRY (Y)   mm.:_________________\n \tMAXIMUM NUMBER OF FIDUCIALS:_________________\n    AFTER COMPLETING ALL ANSWERS, HIT <ESC> TO CONTINUE\n                (OR <Ctrl-C> TO CANCEL)\n The camera name and identification describe the camera reference file.\n The calibrated focal length and the point of symmetry are used in computing \n the photo-to-target transformation parameters.  These values should be entered\n from the camera calibration report (usually available from the photograph \n supplier).\n  This example is the camera Zeiss LMK9 265-002A belonging to the Hellenic\n Military Geographical Survey (HMGS) and calibrated in December 1985 \n The photo coordinate system origin is the so-called calibrated principal\n point (PP, Principal Point of Symmetry) which is in the center of the image. \n The origin of the axes is at the intersection of the radii traced from the\n fiducial marks. In the ideal case of no deviations in the camera (see camera\n calibration certificate) the center is the origin and the values are 0 for\n both X and Y of Point of Symmetry. But usually the principal point does not\n fall on the intersection of the radii at the center of the picture. This\n excentricity is usually of the order of a few micrometers.  \n You are then asked to enter the X and Y photo coordinates of each fiducial\n as follows.\n These fiducials (or reseau) marks are index marks imaged on film which serve\n as reference photo coordinate system. The maximum number of fiducials will\n determine the number of fiducial or reseau coordinate pairs to be entered\n below. The origin is the center of the image (or the point of symmetry) and\n X and Y are left-right and up-down. The order is up to the user, but must be\n kept consistent throughout the rectification process.\n On this screen you should enter the fiducial or\n reseau photo-coordinates as given in the camera calibration report. The X,\n and Y coordinates are in milli-meters from the principle point.\n Please provide the following information\n \tFid#\tFID ID\t\t  X          Y\n \t1__\t_____\t\t0.0___\t0.0___\n \t2__\t_____\t\t0.0___\t0.0___\n \t3__\t_____\t\t0.0___\t0.0___\t\t\t\t\n \t4__\t_____\t\t0.0___\t0.0___\n \t5__\t_____\t\t0.0___\t0.0___\t\t\t\t\n \t6__\t_____\t\t0.0___\t0.0___\n \t7__\t_____\t\t0.0___\t0.0___\n \t8__\t_____\t\t0.0___\t0.0___\t\t\t\t\n \t9__\t_____\t\t0.0___\t0.0___\n \t10_\t_____\t\t0.0___\t0.0___\t\t\t\t\n \t\t     next:  end__\n      AFTER COMPLETING ALL ANSWERS, HIT <ESC> TO CONTINUE\n                     (OR <Ctrl-C> TO CANCEL)\n The input display is repeated until the number of MAXIMUM FIDUCIALS \n is reached.  \n ", "notes": "", "see_also": ["i.ortho.photo", "i.photo.2image", "i.photo.2target", "i.ortho.init"], "authors": ["Mike Baba, DBA Systems, Inc."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/imagery/i.ortho.photo/i.ortho.camera"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.import.html", "name": "r.import", "definition": "- Imports raster data into a GRASS raster map using GDAL library and reprojects on the fly.", "keywords": ["raster", "import", "projection"], "synopsis": "r.import [-enlo] input=name  [band=integer[,integer,...]]   [memory=integer]   [output=name]   [resample=string]   [extent=string]   [resolution=string]   [resolution_value=float]   [title=phrase]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Estimate resolution only Do not perform region cropping optimization Force Lat/Lon maps to fit into geographic coordinates (90N,S; 180E,W) Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Do not perform region cropping optimization Force Lat/Lon maps to fit into geographic coordinates (90N,S; 180E,W) Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Force Lat/Lon maps to fit into geographic coordinates (90N,S; 180E,W) Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of GDAL dataset to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "band", "flag": "band", "dataType": "String", "optional": true, "explanation": "Input band(s) to select (default is all bands)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used (in MB)", "defaultValue": "300", "alternatives": ["0-2047"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "resample", "flag": "resample", "dataType": "String", "optional": true, "explanation": "Resampling method to use for reprojection", "defaultValue": "nearest", "alternatives": ["nearest", "bilinear", "bicubic", "lanczos", "bilinear_f", "bicubic_f", "lanczos_f"], "isInputFile": false, "isOutputFile": false}, {"parameter": "extent", "flag": "extent", "dataType": "String", "optional": true, "explanation": "Output raster map extent", "defaultValue": "input", "alternatives": ["input", "region"], "isInputFile": false, "isOutputFile": false}, {"parameter": "resolution", "flag": "resolution", "dataType": "String", "optional": true, "explanation": "Resolution of output raster map (default: estimated)", "defaultValue": "estimated", "alternatives": ["estimated", "value", "region"], "isInputFile": false, "isOutputFile": false}, {"parameter": "resolution_value", "flag": "resolution_value", "dataType": "String", "optional": true, "explanation": "Resolution of output raster map (use with option resolution=value)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.import  imports a map or selected bands from a GDAL raster datasource\n into the current location and mapset. If the projection of the input\n does not match the projection of the location, the input is reprojected\n into the current location. If the projection of the input does match\n the projection of the location, the input is imported directly with\n  r.in.gdal .\n ", "notes": "\n  r.import  checks the projection metadata of the dataset to be\n imported against the current location's projection. If not identical a\n related error message is shown.\n To override this projection check (i.e. to use current location's projection)\n by assuming that the dataset has the same projection as the current location\n the  -o  flag can be used. This is also useful when geodata to be\n imported do not contain any projection metadata at all. The user must be\n sure that the projection is identical in order to avoid to introduce data\n errors.\n  Resolution \n  r.import  reports the estimated target resolution for each \n input band. The estimated resolution will usually be some floating \n point number, e.g. 271.301. In case option  resolution  is set to\n  estimated  (default), this floating point number will be used\n as target resolution. Since the target resolution should be typically the rounded \n estimated resolution, e.g. 250 or 300 instead of 271.301, flag  -e \n can be used first to obtain the estimate without importing the raster bands.\n Then the desired resolution is set with option  resolution_value  \n and option  resolution = value .\n For latlong locations, the resolution might be set to arc seconds, e.g. 1, 3, 7.5, \n 15, and 30 arc seconds are commonly used resolutions.\n  Resampling methods \n When reprojecting a map to a new spatial reference system, the projected\n data is resampled with one of four different methods: nearest neighbor,\n bilinear, bicubic iterpolation or lanczos.\n In the following common use cases:\n  nearest  is the simplest method and the only possible method for \n categorical data.\n  bilinear  does linear interpolation and provides smoother output \n than  nearest .  bilinear  is recommended when reprojecting a \n DEM for hydrological analysis or for surfaces where overshoots must be \n avoided, e.g. precipitation should not become negative. \n   \n  bicubic  produces smoother output than  bilinear , at \n the cost of overshoots. \n  lanczos  produces the smoothest output of all methods and \n preserves contrast best.  lanczos  is recommended for imagery. \n Both  bicubic  and  lanczos  preserve linear features. With \n  nearest  or  bilinear , linear features can become zigzag \n features after reprojection.\n For explanation of the  -l  flag, please refer to the\n  r.in.gdal  manual.\n When importing whole-world maps the user should disable map-trimming with\n the  -n  flag. For further explanations of  -n  flag, please refer\n the to  r.proj  manual.\n  EXAMPLES \n  Import of SRTM V3 global data at 1 arc-seconds resolution \n The SRTM V3 1 arc-second global data (~30 meters resolution) are available\n from EarthExplorer ( http://earthexplorer.usgs.gov/ ).\n The SRTM collections are located under the \"Digital Elevation\" category.\n Example for North Carolina sample dataset (the tile name is \"n35_w079_1arc_v3.tif\"):\n # set computational region to e.g. 10m elevation model:\n g.region raster=elevation -p\n # Import with reprojection on the fly. Recommended parameters:\n # resample   Resampling method to use for reprojection - bilinear\n # extent     Output raster map extent - region: extent of current region\n # resolution Resolution of output raster map\n #  - region: current region resolution - limit to g.region setting from above\n r.import input=n35_w079_1arc_v3.tif output=srtmv3_resamp10m resample=bilinear \n    extent=region resolution=region title=\"SRTM V3 resampled to 10m resolution\"\n # beautify colors:\n r.colors srtmv3_resamp10m color=elevation\n  Import of WorldClim data \n Import of a subset from WorldClim  Bioclim data set ,\n to be reprojected to current location projection (North Carolina sample dataset).\n Different resolutions are available, in this example we use the 2.5 arc-minutes\n resolution data. During import, we spatially subset the world data to the \n North Carolina region using the  extent  parameter:\n # download selected Bioclim data (2.5 arc-minutes resolution)\n # optionally tiles are available for the 30 arc-sec resolution\n wget http://biogeo.ucdavis.edu/data/climate/worldclim/1_4/grid/cur/bio_2-5m_bil.zip\n # extract BIO1 from package (BIO1 = Annual Mean Temperature):\n unzip bio_2-5m_bil.zip bio1.bil bio1.hdr\n # prior to import, fix broken WorldClim extent using GDAL tool\n gdal_translate -a_ullr -180 90 180 -60 bio1.bil bio1_fixed.tif\n # set computational region to North Carolina, 4000 m target pixel resolution\n g.region -d res=4000 -ap\n # subset to current region and reproject on the fly to current location projection,\n # using -n since whole-world map is imported:\n r.import input=bio1_fixed.tif output=bioclim01 resample=bilinear \n           extent=region resolution=region -n\n # temperature data are in \u00b0C * 10\n r.info bioclim01\n r.univar -e bioclim01\n ", "see_also": ["r.in.gdal", "r.proj"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.import"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.horizon.html", "name": "r.horizon", "definition": "- Computes horizon angle height from a digital elevation model.", "keywords": ["raster", "solar", "sun position"], "synopsis": "r.horizon [-dc] elevation=name  [direction=float]   [step=float]   [start=float]   [end=float]   [bufferzone=float]   [e_buff=float]   [w_buff=float]   [n_buff=float]   [s_buff=float]   [maxdistance=float]   [output=basename]   [coordinates=east,north]   [distance=float]   [file=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Write output in degrees (default is radians) Write output in compass orientation (default is CCW, East=0) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Write output in compass orientation (default is CCW, East=0) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "direction", "flag": "direction", "dataType": "String", "optional": true, "explanation": "Direction in which you want to know the horizon height", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "step", "flag": "step", "dataType": "String", "optional": true, "explanation": "Angle step size for multidirectional horizon [degrees]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start", "flag": "start", "dataType": "String", "optional": true, "explanation": "Start angle for multidirectional horizon [degrees]", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "end", "flag": "end", "dataType": "String", "optional": true, "explanation": "End angle for multidirectional horizon [degrees]", "defaultValue": "360.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bufferzone", "flag": "bufferzone", "dataType": "String", "optional": true, "explanation": "For horizon rasters, read from the DEM an extra buffer around the present region", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "e_buff", "flag": "e_buff", "dataType": "String", "optional": true, "explanation": "For horizon rasters, read from the DEM an extra buffer eastward the present region", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "w_buff", "flag": "w_buff", "dataType": "String", "optional": true, "explanation": "For horizon rasters, read from the DEM an extra buffer westward the present region", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "n_buff", "flag": "n_buff", "dataType": "String", "optional": true, "explanation": "For horizon rasters, read from the DEM an extra buffer northward the present region", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "s_buff", "flag": "s_buff", "dataType": "String", "optional": true, "explanation": "For horizon rasters, read from the DEM an extra buffer southward the present region", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxdistance", "flag": "maxdistance", "dataType": "String", "optional": true, "explanation": "The maximum distance to consider when finding the horizon height", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output basename raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Coordinate for which you want to calculate the horizon", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": true, "explanation": "Sampling distance step coefficient (0.5-1.5)", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Name of file for output (use output=- for stdout)", "defaultValue": "-", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.horizon  computes the angular height of terrain horizon in\n radians. It reads a raster of elevation data and outputs the horizon\n outline in one of two modes:\n   single point: as a series of horizon \n heights in the specified directions from the given point. The results are\n written to the stdout.\n   raster: in this case the output is\n one or more raster maps, with each point in a raster giving the horizon\n height in a specific direction. One raster is created for each direction.\n The directions are given as azimuthal angles (in degrees), with\n the angle starting with 0 towards East and moving counterclockwise\n (North is 90, etc.). The calculation takes into account the actual\n projection, so the angles are corrected for direction distortions\n imposed by it. The directions are thus aligned to those of the\n geographic projection and not the coordinate system given by the rows\n and columns of the raster map. This correction implies that the\n resulting cardinal directions represent true orientation towards the\n East, North, West and South. The only exception of this feature is\n LOCATION with x,y coordinate system, where this correction is\n not applied.\n Using the  -c  flag, the azimuthal angles will be printed in compass\n orientation (North=0, clockwise).\n  Input parameters: \n  The  elevation  parameter is an input elevation raster map. If\n the buffer options are used (see below), this raster should extend\n over the area that accommodate the presently defined region plus\n defined buffer zones. \n  The  step  parameter gives the angle step (in degrees)\n between successive azimuthal directions for the calculation of the\n horizon. Thus, a value of 5 for the  step  will give a total of\n 360/5=72 directions (72 raster maps if used in the raster map mode). \n  The  start  parameter gives the angle start (in degrees)\n for the calculation of the horizon. The default value is 0 (East with\n North being 90 etc.).\n  The  end  parameter gives the angle end (in degrees)\n for the calculation of the horizon. The end point is omitted!\n So for example if we run r.horizon with step=10, start=30 and end=70\n the raster maps generated by r.horizon will be only for angles:\n 30, 40, 50, 60. The default value is 360.\n  The  direction  parameter gives the initial direction of the\n first output. This parameter acts as an direction angle offset. For\n example, if you want to get horizon angles for directions 45 and 225\n degrees, the  direction  should be set to 45 and  step  to\n 180. If you only want one single direction, use this parameter to\n specify desired direction of horizon angle, and set the  step \n size to 0 degrees. Otherwise all angles for a given starting  direction \n with step of  step  are calculated.\n  The  distance  controls the sampling distance step size for the\n search for horizon along the line of sight. The default value is 1.0\n meaning that the step size will be taken from the raster resolution.\n Setting the value below 1.0 might slightly improve results for\n directions apart from the cardinal ones, but increasing the\n processing load of the search algorithm. \n  The  maxdistance  value gives a maximum distance to move away\n from the origin along the line of sight in order to search for the\n horizon height.\n The default  maxdistance  is the full map extent.\n The smaller this value the faster the calculation but\n the higher the risk that you may miss a terrain feature that can\n contribute significantly to the horizon outline. Note that a viewshed\n can be calculated with  r.viewshed .\n  The  coordinate  parameter takes a pair of easting-northing values\n in the current coordinate system and calculates the values of angular\n height of the horizon around this point. To achieve the\n consistency of the results, the point coordinate is\n aligned to the midpoint of the closest elevation raster cell. \n  If an analyzed point (or raster cell) lies close to the edge of\n the defined region, the horizon calculation may not be realistic,\n since it may not see some significant terrain features which could\n have contributed to the horizon, because these features are outside\n the region. There are to options how to set the size of the buffer\n that is used to increase the area of the horizon analysis. The\n  bufferzone  parameter allows you to specify the same size of\n buffer for all cardinal directions and the parameters  e_buff ,\n  n_buff ,  s_buff , and  w_buff  allow you to specify\n a buffer size individually for each of the four directions. The\n buffer parameters influence only size of the read elevation map,\n while the analysis in the raster mode will be done only for the\n area specified by the current region definition.\n  The  output  parameter defines the basename of the output\n horizon raster maps. The raster name of each horizon direction\n raster will be constructed as  basename_ ANGLE, where ANGLE\n is the angle in degrees with the direction. If you use  r.horizon \n in the single point mode this option will be ignored. \n  The  file  parameter allows saving the resulting horizon\n angles in a comma separated ASCII file (single point mode only). If\n you use  r.horizon  in the raster map mode this option will be ignored.\n  At the moment the elevation and maximum distance must be measured in meters, \n even if you use geographical coordinates (longitude/latitude). If your \n projection is based on distance (easting and northing), these too must \n be in meters. The buffer parameters must be in the same units as the \n raster coordinates (e.g., for latitude-longitude locations buffers are\n measured in degree unit).\n  METHOD \n  The calculation method is based on the method used in  r.sun \n to calculate shadows. It starts at a very shallow angle and walks\n along the line of sight and asks at each step whether the line of\n sight \"hits\" the terrain. If so, the angle is increased to\n allow the line of sight to pass just above the terrain at that point.\n This is continued until the line of sight reaches a height that is\n higher than any point in the region or until it reaches the border of\n the region (see also the  bufferzone,e_buff ,  n_buff ,\n  s_buff , and  w_buff ). The the number of lines of sight (azimuth \n directions) is determined from the  direction  and\n  step  parameters. The method takes into account the curvature\n of the Earth whereby remote features will seem to be lower than they\n actually are. It also accounts for the changes of angles towards\n cardinal directions caused by the projection (see above). \n  EXAMPLES \n The examples are intended for the North Carolina sample dataset.\n  Single point mode \n  Example 1 : determine horizon angle in 225 degree direction (output\n of horizon angles CCW from East):\n g.region raster=elevation -p\n r.horizon elevation=elevation direction=215 step=0 bufferzone=200 \n      coordinates=638871.6,223384.4 maxdistance=5000\n  Example 2 : determine horizon values starting at 90 deg (North), \n step size of 5 deg, saving result as CSV file:\n r.horizon elevation=elevation direction=90 step=5 bufferzone=200 \n      coordinates=638871.6,223384.4 maxdistance=5000 file=horizon.csv\n  Example 3 : test point near highway intersection, saving result\n as CSV file for plotting the horizon around the highway intersection:\n g.region n=223540 s=220820 w=634650 e=638780 res=10 -p\n r.horizon elevation=elevation direction=0 step=5 bufferzone=200 \n      coordinates=636483.54,222176.25 maxdistance=5000 -d file=horizon.csv\n Test point near high way intersection (North Carolina sample dataset)\n Horizon angles for test point (CCW from East)\n  We can plot horizon in polar coordinates using Matplotlib in Python:\n import numpy as np\n import matplotlib.pyplot as plt\n horizon = np.genfromtxt('horizon.csv', delimiter=',')\n horizon = horizon[1:, :]\n ax = plt.subplot(111, polar=True)\n bars = ax.plot(horizon[:, 0] / 180 * np.pi,\n                (90 - horizon[:, 1]) / 180 * np.pi)\n # uncomment the 2 following lines when using -c flag\n # ax.set_theta_direction(-1)\n # ax.set_theta_zero_location('N')\n plt.show()\n Horizon plot in polar coordinates.\n  Raster map mode \n Raster map mode (output maps \"horangle*\" become input for  r.sun ):\n g.region raster=elevation -p\n # we put a bufferzone of 10% of maxdistance around the study area\n # compute only direction between 90 and 270 degrees\n r.horizon elevation=elevation step=30 start=90 end=300 \n      bufferzone=200 output=horangle maxdistance=5000\n  REFERENCES \n  Hofierka J., 1997. Direct solar radiation modelling within an\n open GIS environment. Proceedings of JEC-GI'97 conference in Vienna,\n Austria, IOS Press Amsterdam, 575-584 \n  Hofierka J., Huld T., Cebecauer T., Suri M., 2007. Open Source Solar \n Radiation Tools for Environmental and Renewable Energy Applications,\n  International Symposium on \n Environmental Software Systems , Prague, 2007\n  Neteler M., Mitasova H., 2004. Open Source GIS: A GRASS GIS\n Approach,  Springer , New York.\n ISBN: 1-4020-8064-6, 2nd Edition 2004 (reprinted 2005), 424 pages \n  Project  PVGIS , European \n Commission, DG Joint Research Centre 2001-2007\n  Suri M., Hofierka J., 2004.\n A New GIS-based Solar Radiation Model and Its Application for\n Photovoltaic Assessments.  Transactions\n in GIS , 8(2), 175-190\n ", "notes": "", "see_also": ["r.sun", "r.sunmask", "r.viewshed"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.horizon"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.his.html", "name": "r.his", "definition": "- Generates red, green and blue (RGB) raster map layers combining hue, intensity and saturation (HIS) values from user-specified input raster map layers.", "keywords": ["raster", "color transformation", "RGB", "HIS", "IHS"], "synopsis": "r.his [-c] hue=string  [intensity=string]   [saturation=string]  red=string green=string blue=string  [bgcolor=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Use colors from color tables for NULL values Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "hue", "flag": "hue", "dataType": "String", "optional": false, "explanation": "Name of layer to be used for hue", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "intensity", "flag": "intensity", "dataType": "String", "optional": true, "explanation": "Name of layer to be used for intensity", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "saturation", "flag": "saturation", "dataType": "String", "optional": true, "explanation": "Name of layer to be used for saturation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": false, "explanation": "Name of output layer to be used for red", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": false, "explanation": "Name of output layer to be used for green", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": false, "explanation": "Name of output layer to be used for blue", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Color to use instead of NULL values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  HIS  stands for hue, intensity, and saturation. \n This program produces red, green and blue raster map layers\n providing a visually pleasing combination of hue,\n intensity, and saturation values from two or three\n user-specified raster map layers.\n The human brain automatically interprets the vast amount of\n visual information available according to basic rules. \n Color, or  hue , is used to categorize objects. \n Shading, or  intensity , is interpreted as\n three-dimensional texturing. Finally, the degree of\n haziness, or  saturation , is associated with\n distance or depth. This program allows data from up to\n three raster map layers to be combined into a color image\n (in the form of separate red, green and blue raster map\n layers) which retains the original information in terms of\n  hue ,  intensity , and  saturation .\n While any raster map layer can be used to represent the hue\n information, map layers with a few very distinct colors\n work best.  Only raster map layers representing\n continuously varying data like elevation, aspect, weights,\n intensities, or amounts can suitably be used to provide\n intensity and saturation information.\n For example, a visually pleasing image can be made by using\n a watershed map for the  hue  factor, an aspect map\n for the  intensity  factor, and an elevation map for\n  saturation . (The user may wish to leave out the\n elevation information for a first try.) Ideally, the\n resulting image should resemble the view from an aircraft\n looking at a terrain on a sunny day with a bit of haze in\n the valleys.\n  The Process \n Each map cell is processed individually. First, the working\n color is set to the color of the corresponding cell in the\n map layer chosen to represent  hue .  Second, this\n color is multiplied by the  red  intensity of that\n cell in the  intensity  map layer.  This map layer\n should have an appropriate gray-scale color table\n associated with it. You can ensure this by using the color\n manipulation capabilities of\n  r.colors .\n Finally, the color is made somewhat gray-based on the\n  red  intensity of that cell in the\n  saturation  map layer.  Again, this map layer\n should have a gray-scale color table associated with it.\n ", "notes": "\n The name is misleading. The actual conversion used is\n    H .i.s +  G .(1-s)\n where\n    H    is the R,G,B color from the hue map\n   i   is the red value from the intensity map\n   s   is the red value from the saturation map\n    G    is 50% gray (R = G = B = 0.5)\n Either (but not both) of the intensity or the saturation\n map layers may be omitted. This means that it is possible\n to produce output images that represent combinations of\n  his, hi,  or  hs .\n The separate  red ,  green  and  blue \n maps can be displayed on the graphics monitor using\n  d.rgb , or combined into\n a composite RGB layer using\n  r.composite .\n Users wishing to simply display an  his  composite\n image without actually generating any layers should use the\n program  d.his .\n  EXAMPLES \n Recreate the following example for  d.his  using  r.his .\n First, create shaded relief and show it.\n g.region raster=elevation\n r.relief input=elevation output=elevation_shaded_relief\n d.mon wx0\n d.his hue=elevation intensity=elevation_shaded_relief brighten=50\n Second, compute lighter version of color of shaded relief.\n Then convert from HIS model to RGB and show the result.\n r.mapcalc \"elevation_shaded_relief_bright_50 = #elevation_shaded_relief * 1.5\"\n r.colors elevation_shaded_relief_bright_50 color=grey255\n r.his hue=elevation intensity=elevation_shaded_relief_bright_50 \n        red=shadedmap_r green=shadedmap_g blue=shadedmap_b\n d.mon wx1\n d.rgb red=shadedmap_r green=shadedmap_g blue=shadedmap_b\n ", "see_also": ["d.his", "d.colortable", "d.rgb", "r.blend", "r.colors", "r.composite", "r.mapcalc", "r.shade", "i.his.rgb", "i.rgb.his", "d.his"], "authors": ["Glynn Clements (based upon"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.his"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.gwflow.html", "name": "r.gwflow", "definition": "- Numerical calculation program for transient, confined and unconfined groundwater flow in two dimensions.", "keywords": ["raster", "groundwater flow", "hydrology"], "synopsis": "r.gwflow [-f] phead=name status=name hc_x=name hc_y=name  [q=name]  s=name  [recharge=name]  top=name bottom=name output=name  [vx=name]   [vy=name]   [budget=name]  type=string  [river_bed=name]   [river_head=name]   [river_leak=name]   [drain_bed=name]   [drain_leak=name]  dtime=float  [maxit=integer]   [maxit=integer]   [error=float]   [solver=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Allocate a full quadratic linear equation system, default is a sparse linear equation system. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "phead", "flag": "phead", "dataType": "String", "optional": false, "explanation": "Name of input raster map with initial piezometric head in [m]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "status", "flag": "status", "dataType": "String", "optional": false, "explanation": "Name of input raster map providing boundary condition status: 0-inactive, 1-active, 2-dirichlet", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "hc_x", "flag": "hc_x", "dataType": "String", "optional": false, "explanation": "Name of input raster map with x-part of the hydraulic conductivity tensor in [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "hc_y", "flag": "hc_y", "dataType": "String", "optional": false, "explanation": "Name of input raster map with y-part of the hydraulic conductivity tensor in [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "q", "flag": "q", "dataType": "String", "optional": true, "explanation": "Name of input raster map with water sources and sinks in [m^3/s]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "s", "flag": "s", "dataType": "String", "optional": false, "explanation": "Name of input raster map with storativity for confined or effective porosity for unconfined groundwater flow booth in [-]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "recharge", "flag": "recharge", "dataType": "String", "optional": true, "explanation": "Recharge input raster map e.g: 6*10^-9 per cell in [m^3/s*m^2]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "top", "flag": "top", "dataType": "String", "optional": false, "explanation": "Name of input raster map describing the top surface of the aquifer in [m]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "bottom", "flag": "bottom", "dataType": "String", "optional": false, "explanation": "Name of input raster map describing the bottom surface of the aquifer in [m]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output raster map storing the numerical result [m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "vx", "flag": "vx", "dataType": "String", "optional": true, "explanation": "Output raster map to store the groundwater filter velocity vector part in x direction [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vy", "flag": "vy", "dataType": "String", "optional": true, "explanation": "Output raster map to store the groundwater filter velocity vector part in y direction [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "budget", "flag": "budget", "dataType": "String", "optional": true, "explanation": "Output raster map to store the groundwater budget for each cell [m^3/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": false, "explanation": "The type of groundwater flow", "defaultValue": "confined", "alternatives": ["confined", "unconfined"], "isInputFile": false, "isOutputFile": false}, {"parameter": "river_bed", "flag": "river_bed", "dataType": "String", "optional": true, "explanation": "Name of input raster map providing the height of the river bed in [m]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "river_head", "flag": "river_head", "dataType": "String", "optional": true, "explanation": "Name of input raster map providing the water level (head) of the river with leakage connection in [m]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "river_leak", "flag": "river_leak", "dataType": "String", "optional": true, "explanation": "Name of input raster map providing the leakage coefficient of the river bed in [1/s].", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "drain_bed", "flag": "drain_bed", "dataType": "String", "optional": true, "explanation": "Name of input raster map providing the height of the drainage bed in [m]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "drain_leak", "flag": "drain_leak", "dataType": "String", "optional": true, "explanation": "Name of input raster map providing the leakage coefficient of the drainage bed in [1/s]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "dtime", "flag": "dtime", "dataType": "String", "optional": false, "explanation": "The calculation time in seconds", "defaultValue": "86400", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxit", "flag": "maxit", "dataType": "String", "optional": true, "explanation": "Maximum number of iteration used to solve the linear equation system", "defaultValue": "10000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxit", "flag": "maxit", "dataType": "String", "optional": true, "explanation": "The maximum number of iterations in the linearization approach", "defaultValue": "25", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "error", "flag": "error", "dataType": "String", "optional": true, "explanation": "Error break criteria for iterative solver", "defaultValue": "0.000001", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "solver", "flag": "solver", "dataType": "String", "optional": true, "explanation": "The type of solver which should solve the symmetric linear equation system", "defaultValue": "cg", "alternatives": ["cg", "pcg", "cholesky"], "isInputFile": false, "isOutputFile": false}], "description": "\n This numerical program calculates implicit transient, confined and\n unconfined groundwater flow in two dimensions based on  \n raster maps and the current region settings.\n All initial and boundary conditions must be provided as \n raster maps. The unit in the location must be meters.\n  This module is sensitive to mask settings. All cells which are outside the mask\n are ignored and handled as no flow boundaries.\n  \n  Workflow of r.gwflow \n  \n  r.gwflow  calculates the piezometric head and optionally \n the water budget and the filter velocity field,\n based on the hydraulic conductivity and the piezometric head. \n The vector components can be visualized with paraview if they are exported\n with  r.out.vtk .\n The groundwater flow will always be calculated transient. \n For stady state computation set the timestep\n to a large number (billions of seconds) or set the \n storativity/ effective porosity raster map to zero.\n The water budget is calculated for each non inactive cell. The\n sum of the budget for each non inactive cell must be near zero.\n This is an indicator of the quality of the numerical result.\n ", "notes": "\n The groundwater flow calculation is based on Darcy's law and a numerical implicit\n finite volume discretization. The discretization results in a symmetric and positive definit\n linear equation system in form of  Ax = b , which must be solved. The groundwater flow partial\n differential equation is of the following form:\n  (dh/dt)*S = div (K grad h) + q\n  In detail for 2 dimensions:\n  (dh/dt)*S = Kxx * (d^2h/dx^2) + Kyy * (d^2h/dy^2) + q\n  h -- the piezometric head im [m] \n  dt -- the time step for transient calculation in [s] \n  S -- the specific storage [1/m] \n  Kxx -- the hydraulic conductivity tensor part in x direction in [m/s] \n  Kyy -- the hydraulic conductivity tensor part in y direction in [m/s] \n  q - inner source/sink in meter per second [1/s] \n  Confined and unconfined groundwater flow is supported. Be aware that the storativity input parameter\n is handled differently in case of unconfined flow. Instead of the storativity, the effective porosity is expected.\n  To compute unconfined groundwater flow, a simple Picard based linearization scheme is used to\n solve the resulting non-linear equation system.\n  Two different boundary conditions are implemented, \n the Dirichlet and Neumann conditions. By default the calculation area is surrounded by homogeneous Neumann boundary conditions.\n The calculation and boundary status of single cells must be set with a status map, \n the following states are supportet:\n  0 == inactive - the cell with status 0 will not be calculated, active cells will have a no flow boundary to this cell \n  1 == active - this cell is used for groundwater floaw calculation, inner sources and recharge can be defined for those cells \n  2 == Dirichlet - cells of this type will have a fixed piezometric head value which do not change over the time  \n Note that all required raster maps are read into main memory. Additionally the\n linear equation system will be allocated, so the memory consumption of this\n module rapidely grow with the size of the input maps.\n The resulting linear equation system  Ax = b  can be solved with several solvers.\n An iterative solvers with sparse and quadratic matrices support is implemented.\n The conjugate gradients method with (pcg) and without (cg) precondition.\n Additionally a direct Cholesky solver is available. This direct solver\n only work with normal quadratic matrices, so be careful using them with large maps \n (maps of size 10.000 cells will need more than one gigabyte of RAM).\n Always prefer a sparse matrix solver.\n  EXAMPLE \n Use this small script to create a working\n groundwater flow area and data. Make sure you are not in a lat/lon projection.\n It includes drainage and river input as well.\n # set the region accordingly\n g.region res=25 res3=25 t=100 b=0 n=1000 s=0 w=0 e=1000 -p3\n #now create the input raster maps for confined and unconfined aquifers\n r.mapcalc expression=\"phead = if(row() == 1 , 50, 40)\"\n r.mapcalc expression=\"status = if(row() == 1 , 2, 1)\"\n r.mapcalc expression=\"well = if(row() == 20 && col() == 20 , -0.01, 0)\"\n r.mapcalc expression=\"hydcond = 0.00025\"\n r.mapcalc expression=\"recharge = 0\"\n r.mapcalc expression=\"top_conf = 20.0\"\n r.mapcalc expression=\"top_unconf = 70.0\"\n r.mapcalc expression=\"bottom = 0.0\"\n r.mapcalc expression=\"null = 0.0\"\n r.mapcalc expression=\"poros = 0.15\"\n r.mapcalc expression=\"s = 0.0001\"\n # The maps of the river\n r.mapcalc expression=\"river_bed = if(col() == 35 , 48, null())\"\n r.mapcalc expression=\"river_head = if(col() == 35 , 49, null())\"\n r.mapcalc expression=\"river_leak = if(col() == 35 , 0.0001, null())\"\n # The maps of the drainage\n r.mapcalc expression=\"drain_bed = if(col() == 5 , 48, null())\"\n r.mapcalc expression=\"drain_leak = if(col() == 5 , 0.01, null())\"\n #confined groundwater flow with cg solver and sparse matrix, river and drain\n #do not work with this confined aquifer (top == 20m)\n r.gwflow solver=cg top=top_conf bottom=bottom phead=phead status=status \n    hc_x=hydcond hc_y=hydcond q=well s=s recharge=recharge output=gwresult_conf \n    dt=8640000 type=confined vx=gwresult_conf_velocity_x vy=gwresult_conf_velocity_y budget=budget_conf\n #unconfined groundwater flow with cg solver and sparse matrix, river and drain are enabled\n # We use the effective porosity as storativity parameter\n r.gwflow solver=cg top=top_unconf bottom=bottom phead=phead \n    status=status hc_x=hydcond hc_y=hydcond q=well s=poros recharge=recharge \n    river_bed=river_bed river_head=river_head river_leak=river_leak \n    drain_bed=drain_bed drain_leak=drain_leak \n    output=gwresult_unconf dt=8640000 type=unconfined vx=gwresult_unconf_velocity_x \n    budget=budget_unconf vy=gwresult_unconf_velocity_y\n # The data can be visulaized with paraview when exported with r.out.vtk\n r.out.vtk -p in=gwresult_conf,status vector=gwresult_conf_velocity_x,gwresult_conf_velocity_y,null \n    out=/tmp/gwdata_conf2d.vtk\n r.out.vtk -p elevation=gwresult_unconf in=gwresult_unconf,status vector=gwresult_unconf_velocity_x,gwresult_unconf_velocity_y,null \n    out=/tmp/gwdata_unconf2d.vtk\n #now load the data into paraview\n paraview --data=/tmp/gwdata_conf2d.vtk &\n paraview --data=/tmp/gwdata_unconf2d.vtk &\n ", "see_also": ["r.solute.transport", "r3.gwflow", "r.out.vtk"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.gwflow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.grow.html", "name": "r.grow", "definition": "- Generates a raster map layer with contiguous areas grown by one cell.", "keywords": ["raster", "distance", "proximity"], "synopsis": "r.grow [-m] input=name output=name  [radius=float]   [metric=string]   [old=integer]   [new=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Radius is in map units rather than cells Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "radius", "flag": "radius", "dataType": "String", "optional": true, "explanation": "Radius of buffer in raster cells", "defaultValue": "1.01", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "metric", "flag": "metric", "dataType": "String", "optional": true, "explanation": "Metric", "defaultValue": "euclidean", "alternatives": ["euclidean", "maximum", "manhattan"], "isInputFile": false, "isOutputFile": false}, {"parameter": "old", "flag": "old", "dataType": "String", "optional": true, "explanation": "Value to write for input cells which are non-NULL (-1 => NULL)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "new", "flag": "new", "dataType": "String", "optional": true, "explanation": "Value to write for \"grown\" cells", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.grow  adds cells around the perimeters of all areas\n in a user-specified raster map layer and stores the output in\n a new raster map layer. The user can use it to grow by one or\n more than one cell (by varying the size of the  radius \n parameter), or like  r.buffer , but with the\n option of preserving the original cells (similar to combining\n  r.buffer  and  r.patch ).\n If  radius  is negative, r.grow  shrinks areas by removing \n cells around the perimeters of all areas.\n ", "notes": "\n The user has the option of specifying three different metrics which\n control the geometry in which grown cells are created, (controlled by\n the  metric  parameter):  Euclidean ,  Manhattan , and \n  Maximum . \n  The  Euclidean distance  or  Euclidean metric  is the \"ordinary\" distance \n between two points that one would measure with a ruler, which can be \n proven by repeated application of the Pythagorean theorem. \n The formula is given by: \n  d(dx,dy) = sqrt(dx^2 + dy^2) \n Cells grown using this metric would form isolines of distance that are\n circular from a given point, with the distance given by the  radius .\n  The  Manhattan metric , or  Taxicab geometry , is a form of geometry in \n which the usual metric of Euclidean geometry is replaced by a new \n metric in which the distance between two points is the sum of the (absolute) \n differences of their coordinates. The name alludes to the grid layout of \n most streets on the island of Manhattan, which causes the shortest path a \n car could take between two points in the city to have length equal to the\n points' distance in taxicab geometry.\n The formula is given by:\n  d(dx,dy) = abs(dx) + abs(dy) \n where cells grown using this metric would form isolines of distance that are\n rhombus-shaped from a given point. \n  The  Maximum metric  is given by the formula\n  d(dx,dy) = max(abs(dx),abs(dy)) \n where the isolines of distance from a point are squares.\n  If there are two cells which are equal candidates to grow into an empty space, \n  r.grow  will choose the northernmost candidate; if there are multiple \n candidates with the same northing, the westernmost is chosen. \n  EXAMPLE \n In this example, the lakes map in the\n North Carolina sample dataset location is buffered:\n g.region raster=lakes -p\n r.grow input=lakes output=lakes_grown_100m radius=10\n Shrinking instead of growing:\n r.grow input=lakes output=lakes_shrunk_100m radius=-10\n ", "see_also": ["r.buffer", "r.grow.distance", "r.patch"], "authors": ["Marjorie Larson, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.grow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.grow.distance.html", "name": "r.grow.distance", "definition": "- Generates a raster map containing distances to nearest raster features.", "keywords": ["raster", "distance", "proximity"], "synopsis": "r.grow.distance [-mn] input=name  [distance=name]   [value=name]   [metric=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Output distances in meters instead of map units Calculate distance to nearest NULL cell Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Calculate distance to nearest NULL cell Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": true, "explanation": "Name for distance output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "value", "flag": "value", "dataType": "String", "optional": true, "explanation": "Name for value output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "metric", "flag": "metric", "dataType": "String", "optional": true, "explanation": "Metric", "defaultValue": "euclidean", "alternatives": ["euclidean", "squared", "maximum", "manhattan", "geodesic"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.grow.distance  generates raster maps representing the\n distance to the nearest non-null cell in the input map and/or the\n value of the nearest non-null cell.\n ", "notes": "\n The flag  -n  calculates the respective pixel distances to the\n nearest NULL cell.\n The user has the option of specifying five different metrics which\n control the geometry in which grown cells are created, (controlled by\n the  metric  parameter):  Euclidean ,  Squared ,\n  Manhattan ,  Maximum , and  Geodesic .\n The  Euclidean distance  or  Euclidean metric  is the \"ordinary\" distance \n between two points that one would measure with a ruler, which can be \n proven by repeated application of the Pythagorean theorem. \n The formula is given by: \n d(dx,dy) = sqrt(dx^2 + dy^2)\n Cells grown using this metric would form isolines of distance that are\n circular from a given point, with the distance given by the  radius .\n The  Squared  metric is the  Euclidean  distance squared,\n i.e. it simply omits the square-root calculation. This may be faster,\n and is sufficient if only relative values are required.\n The  Manhattan metric , or  Taxicab geometry , is a form of geometry in \n which the usual metric of Euclidean geometry is replaced by a new \n metric in which the distance between two points is the sum of the (absolute) \n differences of their coordinates. The name alludes to the grid layout of \n most streets on the island of Manhattan, which causes the shortest path a \n car could take between two points in the city to have length equal to the\n points' distance in taxicab geometry.\n The formula is given by:\n d(dx,dy) = abs(dx) + abs(dy)\n where cells grown using this metric would form isolines of distance that are\n rhombus-shaped from a given point. \n The  Maximum metric  is given by the formula\n d(dx,dy) = max(abs(dx),abs(dy))\n where the isolines of distance from a point are squares.\n The  Geodesic metric  is calculated as geodesic distance, to \n be used only in latitude-longitude locations. It is recommended \n to use it along with the  -m  flag in order to output \n distances in meters instead of map units.\n  EXAMPLES \n  Distance from the streams network \n North Carolina sample dataset:\n g.region raster=streams_derived -p\n r.grow.distance input=streams_derived distance=dist_from_streams\n  Euclidean distance from the streams network in meters (map subset) \n  Euclidean distance from the streams network in meters (detail, numbers shown\n    with d.rast.num) \n  Distance from sea in meters in latitude-longitude location \n g.region raster=sea -p\n r.grow.distance -m input=sea distance=dist_from_sea_geodetic metric=geodesic\n  \n  Geodesic distances to sea in meters \n ", "see_also": ["r.grow", "r.distance", "r.buffer", "r.cost", "r.patch"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.grow.distance"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.geomorphon.html", "name": "r.geomorphon", "definition": "- Calculates geomorphons (terrain forms) and associated geometry using machine vision approach.", "keywords": ["raster", "geomorphons", "terrain patterns", "machine vision geomorphometry"], "synopsis": "r.geomorphon [-me] elevation=name  [forms=name]   [ternary=name]   [positive=name]   [negative=name]   [intensity=name]   [exposition=name]   [range=name]   [variance=name]   [elongation=name]   [azimuth=name]   [extend=name]   [width=name]  search=integer skip=integer flat=float dist=float  [prefix=string]   [step=float]   [start=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Use meters to define search units (default is cells) Use extended form correction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Use extended form correction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "forms", "flag": "forms", "dataType": "String", "optional": true, "explanation": "Most common geomorphic forms", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ternary", "flag": "ternary", "dataType": "String", "optional": true, "explanation": "Code of ternary patterns", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "positive", "flag": "positive", "dataType": "String", "optional": true, "explanation": "Code of binary positive patterns", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "negative", "flag": "negative", "dataType": "String", "optional": true, "explanation": "Code of binary negative patterns", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "intensity", "flag": "intensity", "dataType": "String", "optional": true, "explanation": "Rasters containing mean relative elevation of the form", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "exposition", "flag": "exposition", "dataType": "String", "optional": true, "explanation": "Rasters containing maximum difference between extend and central cell", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "range", "flag": "range", "dataType": "String", "optional": true, "explanation": "Rasters containing difference between max and min elevation of the form extend", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "variance", "flag": "variance", "dataType": "String", "optional": true, "explanation": "Rasters containing variance of form boundary", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elongation", "flag": "elongation", "dataType": "String", "optional": true, "explanation": "Rasters containing local elongation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "azimuth", "flag": "azimuth", "dataType": "String", "optional": true, "explanation": "Rasters containing local azimuth of the elongation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "extend", "flag": "extend", "dataType": "String", "optional": true, "explanation": "Rasters containing local extend (area) of the form", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Rasters containing local width of the form", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "search", "flag": "search", "dataType": "String", "optional": false, "explanation": "Outer search radius", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "skip", "flag": "skip", "dataType": "String", "optional": false, "explanation": "Inner search radius", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "flat", "flag": "flat", "dataType": "String", "optional": false, "explanation": "Flatenss threshold (degrees)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dist", "flag": "dist", "dataType": "String", "optional": false, "explanation": "Flatenss distance, zero for none", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "prefix", "flag": "prefix", "dataType": "String", "optional": true, "explanation": "Prefix for maps resulting from multiresolution approach", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "step", "flag": "step", "dataType": "String", "optional": true, "explanation": "Distance step for every iteration (zero to omit)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start", "flag": "start", "dataType": "String", "optional": true, "explanation": "Distance where serch will start in multiple mode (zero to omit)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  What is geomorphon: \n  \n Geomorphon is a new concept of presentation and analysis of terrain\n forms. This concept utilises 8-tuple pattern of the visibility\n neighbourhood  and breaks well known limitation of standard calculus\n approach where all terrain forms cannot be detected in a single window\n size. The pattern arises from a comparison of a focus pixel with its eight\n neighbors starting from the one located to the east and continuing\n counterclockwise  producing ternary operator. For example, a tuple\n {+,-,-,-,0,+,+,+} describes one possible pattern of relative measures\n {higher, lower, lower, lower, equal, higher, higher, higher} for pixels\n surrounding the focus pixel. It is important to stress that the visibility\n neighbors are  not necessarily an immediate neighbors  of the focus\n pixel in the grid, but the pixels determined from  the line-of-sight \n principle along the eight principal directions. This principle relates\n surface relief and horizontal distance by means of so-called zenith and\n nadir angles along the eight principal compass directions. The ternary\n operator converts the information contained in all the pairs of zenith and\n nadir angles into the ternary pattern (8-tuple). The result depends on the\n values of two parameters: search radius (L) and relief threshold (d). The\n search radius is the maximum allowable distance for calculation of zenith\n and nadir angles. The relief threshold is a minimum value of difference\n between  LOSs angle (zenith and nadir) that is considered significantly\n different from the horizon. Two lines-of-sight are necessary due to zenith\n LOS only, does not detect positive forms correctly.\n   There are 38 = 6561 possible ternary patterns (8-tuplets). However by\n eliminating all patterns that are results of either rotation or reflection\n of other patterns wa set of 498 patterns remain referred as geomorphons.\n This is a comprehensive and exhaustive set of idealized landforms that are\n independent of the size, relief, and orientation of the actual landform.\n   Form recognition depends on two free parameters:  Search radius \n and  flatness threshold . Using larger values of L and is tantamount\n to terrain classification from a higher and wider perspective, whereas\n using smaller values of L and is tantamount to terrain classification from\n a local point of view. A character of the map depends on the value of L.\n Using small value of L results in the map that correctly identifies\n landforms if their size is smaller than L; landforms having larger sizes\n are broken down into components. Using larger values of L allows\n simultaneous identification of landforms on variety of sizes in expense of\n recognition smaller, second-order forms. There are two addational\n parameters:  skip radius  used to eliminate impact of small\n irregularities. On the contrary  flatness distance  eliminates the\n impact of very high distance (in meters) of search radius which may not\n detect elevation difference if this is at very far distance. Important\n especially with low resolution DEMS.\n  OPTIONS \n  -m \n  All distance parameters (search, skip, flat distances) are supplied as meters instead of cells (default). To avoid situation when supplied distances is smaller than one cell program first check if supplied distance is longer than one cell in both NS and WE directions. For LatLong projection only NS distance checked, because in latitude angular unit comprise always bigger or equal distance than longitude one. If distance is supplied in cells, For all projections is recalculated into meters according formula:  number_of_cells*resolution_along_NS_direction . It is important if geomorphons are calculate for large areas in LatLong projecton. \n  elevation \n  Digital elevation model. Data can be of any type and any projection. During calculation DEM is stored as floating point raster. \n  search \n  Determines length on the geodesic distances in all eight directions where line-of-sight is calculated. To speed up calculation is determines only these cells which centers falls into the distance \n  skip \n  Determines length on the geodesic distances at the beginning of calculation all eight directions where line-of-sight is yet calculated. To speed up calculation this distance is always recalculated into number of cell which are skipped at the beginning of every line-of-sight and is equal in all direction.  This parameter eliminates forms of very small extend, smaller than skip parameter. \n  flat \n  The difference (in degrees) between zenith and nadir line-of-sight which indicate flat direction. If higher threshold produce more flat maps. If resolution of the map is low (more than 1 km per cell) threshold should be very small (much smaller than 1 degree) because on such distance 1 degree of difference means several meters of high difference. \n  dist \n  >Flat distance. This is additional parameter defining the distance above which the threshold starts to decrease to avoid problems with pseudo-flat line-of-sights if real elevation difference appears on the distance where its value is higher DO POPRAWKI  \n  form \n  Returns geomorphic map with 10 most popular terrestial forms. Legend for forms, its definition by the number of  +  and  -  and its idealized  visualisation are presented at the image.\n \t\n  Forms represented by geomorphons: \n  pattern \n  returns code of one of 498 unique ternary patterns for every cell. The code is a decimal representation o 8-tuple minimalised patterns written in ternary system. Full list of patterns is available in source code directory as patterns.txt. This map can be used to create alternative form classification using supervised approach \n  positive and negative \n  returns codes binary patterns for zenith (positive) and nadir (negative) line of sights. The code is a decimal representation o 8-tuple minimalised patterns written in binary system. Full list of patterns is available in source code directory as patterns.txt \n  NOTE: parameters below are very experimental. The usefulness of these parameters are currently under investigation \n  intensity \n  returns avarage difference between central cell of geomorphon and eight cells in visibility neighbourhood. This parameter shows local (as is visible) exposition/abasment of the form in the terrain \n  range \n  returns difference between minimum and maximum values of visibility neighbourhood. \n  variance \n  returns variance (difference between particular values and mean value) ofvisibility neighbourhood. \n  extend \n  returns area of the polygon created by the 8 points where line-of-sight cuts the terrain (see image in description section). \n  azimuth \n  returns orientation of the poligon constituting geomorphon. This orientation is currentlyb calculated as a orientation of least square fit line to the eight verticles of this polygon. \n  elongation \n  returns proportion between sides of the bounding box rectangle calculated for geomorphon rotated to fit lest square line. \n  width \n  returns length of the shorter side of the bounding box rectangle calculated for geomorphon rotated to fit lest square line. \n ", "notes": "\n From computational point of view there are no limitations of input DEM and\n free parameters used in calculation. However, in practice there are some\n issues on DEM resolution and search radius. Low resolution DEM especially\n above 1 km per cell requires smaller than default flatness threshold. On\n the other hand, only forms with high local elevation difference will be\n detected correctly. It results form fact that on very high distance (of\n order of kilometers or higher) even relatively high elevation difference\n will be recognized as flat. For example at the distance of 8 km (8 cells\n with 1 km resolution DEM) an relative elevation difference of at least 136\n m is required to be noticed as non-flat. Flatness distance threshold may\n be helpful to avoid this problem.\n  EXAMPLES \n  Geomorphon calculation: extraction of terrestial landforms \n Geomorphon calculation example using the EU DEM 25m:\n g.region raster=eu_dem_25m -p\n r.geomorphon elevation=eu_dem_25m forms=eu_dem_25m_geomorph\n # verify terrestial landforms found in DEM\n r.category eu_dem_25m_geomorph\n  1  flat\n  2  summit\n  3  ridge\n  4  shoulder\n  5  spur\n  6  slope\n  7  hollow\n  8  footslope\n  9  valley\n  10 depression\n  \n  Extraction of summits \n Using the resulting terrestial landforms map, single landforms can\n be extracted, e.g. the summits, and converted into a vector point map:\n r.mapcalc expression=\"eu_dem_25m_summits = if(eu_dem_25m_geomorph == 2, 1, null())\"\n r.thin input=eu_dem_25m_summits output=eu_dem_25m_summits_thinned\n r.to.vect input=eu_dem_25m_summits_thinned output=eu_dem_25m_summits type=point\n v.info input=eu_dem_25m_summits\n  \n ", "see_also": ["r.param.scale"], "authors": ["Jarek Jasiewicz, Tomek Stepinski (merit contribution)"], "source_code": null},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.flow.html", "name": "r.flow", "definition": "- Constructs flowlines.", "keywords": ["raster", "hydrology"], "synopsis": "r.flow [-u3m] elevation=name  [aspect=name]   [barrier=name]   [skip=integer]   [bound=integer]   [flowline=name]   [flowlength=name]   [flowaccumulation=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "u", "flag": "-u", "explanation": "Compute upslope flowlines instead of default downhill flowlines 3D lengths instead of 2D Use less memory, at a performance penalty Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "3", "flag": "-3", "explanation": "3D lengths instead of 2D Use less memory, at a performance penalty Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Use less memory, at a performance penalty Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "aspect", "flag": "aspect", "dataType": "String", "optional": true, "explanation": "Name of input aspect raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "barrier", "flag": "barrier", "dataType": "String", "optional": true, "explanation": "Name of input barrier raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "skip", "flag": "skip", "dataType": "String", "optional": true, "explanation": "Number of cells between flowlines", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bound", "flag": "bound", "dataType": "String", "optional": true, "explanation": "Maximum number of segments per flowline", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "flowline", "flag": "flowline", "dataType": "String", "optional": true, "explanation": "Name for output flow line vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "flowlength", "flag": "flowlength", "dataType": "String", "optional": true, "explanation": "Name for output flow path length raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "flowaccumulation", "flag": "flowaccumulation", "dataType": "String", "optional": true, "explanation": "Name for output flow accumulation raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.flow  generates flowlines using a combined raster-vector\n approach\n (see  Mitasova\n and Hofierka 1993 \n and  Mitasova\n et al. 1995 ) from an input  elevation  raster map (integer or\n floating point), and optionally an input  aspect  raster map\n and/or an input  barrier  raster map.\n There are three possible output raster maps which can be produced in any\n combination simultaneously: a vector map  flowline  of flowlines,\n a raster map\n  flowlength  of flowpath lengths, and a raster map\n  flowaccumulation  of flowline densities (which are equal upslope\n contributed areas per unit width, when multiplied by resolution).\n ", "notes": "\n Aspect used for input must follow the same rules as aspect computed in\n other modules (see  v.surf.rst \n or  r.slope.aspect ).\n Output  flowline  is generated downhill. The line segments of\n flowline vectors have endpoints on edges of a grid formed by drawing\n imaginary lines through the centers of the cells in the elevation\n map. Flowlines are generated from each cell downhill by default; they\n can be generated uphill using the flag  -u . A flowline stops if\n its next segment would reverse the direction of flow (from up to down\n or vice-versa), cross a barrier, or arrive at a cell with undefined\n elevation or aspect. Another option,  skip , indicates that\n only the flowlines from every val-th cell are to be included\n in  flowline .  The default  skip  is  max(1,\u00a0<rows\n in elevation>/50,\u00a0<cols in elevation>/50) .  A high  skip  usually speeds up processing time and often improves\n the readability of a visualization of  flowline .\n Flowpath length output is given in a raster map  flowlength . The value\n in each grid cell is the sum of the planar lengths of all segments of the\n flowline generated from that cell. If the flag  -3  is given, elevation\n is taken into account in calculating the length of each segment.\n  Flowline density downhill or uphill output is given in a raster map\n  flowaccumulation.  The value in each grid cell is the number of\n flowlines which pass through that grid cell, that means the number of\n flowlines from thec entire map which have segment endpoints within that cell.\n With the  -m  flag less memory is used as aspect at each cell is\n computed on the fly. This option incurs a severe performance penalty. If\n this flag is given, the  aspect  input map (if any) will be ignored.\n The  barrier  parameter is a raster map name with non-zero\n values representing barriers as input.\n For best results, use input elevation maps with high precision units (e.g.,\n centimeters) so that flowlines do not terminate prematurely in flat areas.\n To prevent the creation of tiny flowline segments with imperceivable changes\n in elevation, an endpoint which would land very close to the center of\n a grid cell is quantized to the exact center of that cell. The maximum\n distance between the intercepts along each axis of a single diagonal segment\n and another segment of 1/2 degree different aspect is taken to be \"very\n close\" for that axis. Note that this distance (the so-called \"quantization\n error\") is about 1-2% of the resolution on maps with square cells.\n  The values in length maps computed using the  -u  flag represent\n the distances from each cell to an upland flat or singular point. Such\n distances are useful in water erosion modeling for computation of the LS\n factor in the standard form of USLE. Uphill flowlines merge on ridge lines;\n by redirecting the order of the flowline points in the output vector map,\n dispersed waterflow can be simulated. The density map can be used for the\n extraction of ridge lines.\n  Computing the flowlines downhill simulates the actual flow (also known\n as the raindrop method). These flowlines tend to merge in valleys; they\n can be used for localization of areas with waterflow accumulation and for\n the extraction of channels. The downslope flowline density multiplied by\n the resolution can be used as an approximation of the upslope contributing\n area per unit contour width. This area is a measure of potential water\n flux for the steady state conditions and can be used in the modeling of\n water erosion for the computation of the unit stream power based LS factor\n or sediment transport capacity.\n  r.flow  has been designed for modeling erosion on\n hillslopes and has rather strict conditions for ending flowlines. It\n is therefore not very suitable for the extraction of stream networks\n or delineation of watersheds unless a DEM without pits or flat areas\n is available ( r.fill.dir  can be\n used to fill pits).\n   To label the vector flowlines automatically, the user can use\n  v.category  (add categories).\n  Algorithm background \n  r.flow  uses an original vector-grid algorithm which uses an\n infinite number of directions between 0.0000... and 360.0000...  and\n traces the flow as a line (vector) in the direction of gradient\n (rather than from cell to cell in one of the 8 directions = D-infinity\n algorithm). They are traced in any direction using aspect (so there is\n no limitation to 8 directions here). The D8 algorithm produces zig-zag\n lines. The value in the outlet is very similar for  r.flow \n algorithm (because it is essentially the watershed area), however the\n spatial distribution of flow, especially on hillslopes is quite\n different. It is still a 1D flow routing so the dispersal flow is not\n accurately described, but still better than D8.\n  r.flow  uses a single flow algorithm, i.e. all flow is\n transported to a single cell downslope.\n  Diagnostics \n Elevation raster map resolution differs from current region resolution\n The resolutions of all input raster maps and the current region must\n match (see  g.region ).\n Resolution too unbalanced\n The difference in length between the two axes of a grid cell is so\n great that quantization error is larger than one of the\n dimensions. Resample the map and try again.\n  EXAMPLE \n In this example a flow line vector map, a flow path length raster map and\n a flow accumulation raster map are computed from an elevation raster map\n (North Carolina sample dataset):\n g.region raster=elevation -p\n r.flow elevation=elevation skip=3 flowline=flowline flowlength=flowlength \n         flowaccumulation=flowaccumulation\n Figure: Flow lines with underlying elevation map;\n flow lines with underlying flow path lengths (in map units: meters);\n flow accumulation map (zoomed view)\n  REFERENCES \n  Mitasova, H., L. Mitas, 1993, Interpolation by regularized spline with\n tension : I. Theory and implementation. Mathematical Geology 25, p. 641-655.\n ( online )\n  Mitasova and Hofierka 1993 : Interpolation by Regularized Spline with\n Tension: II. Application to Terrain Modeling and Surface Geometry Analysis.\n Mathematical Geology 25(6), 657-669\n ( online ).\n  Mitasova, H., Mitas, L., Brown, W.M., Gerdes, D.P., Kosinovsky, I.,\n Baker, T., 1995: Modeling spatially and temporally distributed phenomena:\n New methods and tools for GRASS GIS. International Journal of Geographical\n Information Systems 9(4), 433-446. \n  Mitasova, H., J. Hofierka, M. Zlocha, L.R. Iverson, 1996, Modeling\n topographic potential for erosion and deposition using GIS. Int. Journal of\n Geographical Information Science, 10(5), 629-641. (reply to a comment to\n this paper appears in 1997 in Int. Journal of Geographical Information\n Science, Vol. 11, No. 6)\n  Mitasova, H.(1993): Surfaces and modeling. Grassclippings (winter and\n spring) p.18-19.\n ", "see_also": ["r.basins.fill", "r.drain", "r.fill.dir", "r.water.outlet", "r.watershed", "v.category", "v.to.rast"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.flow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.fillnulls.html", "name": "r.fillnulls", "definition": "- Fills no-data areas in raster maps using spline interpolation.", "keywords": ["raster", "surface", "elevation", "interpolation"], "synopsis": "r.fillnulls input=name output=name method=string  [tension=float]   [smooth=float]   [edge=integer]   [npmin=integer]   [segmax=integer]   [lambda=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Interpolation method to use", "defaultValue": "rst", "alternatives": ["bilinear", "bicubic", "rst"], "isInputFile": false, "isOutputFile": false}, {"parameter": "tension", "flag": "tension", "dataType": "String", "optional": true, "explanation": "Spline tension parameter", "defaultValue": "40.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "smooth", "flag": "smooth", "dataType": "String", "optional": true, "explanation": "Spline smoothing parameter", "defaultValue": "0.1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "edge", "flag": "edge", "dataType": "String", "optional": true, "explanation": "Width of hole edge used for interpolation (in cells)", "defaultValue": "3", "alternatives": ["2-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "npmin", "flag": "npmin", "dataType": "String", "optional": true, "explanation": "Minimum number of points for approximation in a segment (>segmax)", "defaultValue": "600", "alternatives": ["2-10000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "segmax", "flag": "segmax", "dataType": "String", "optional": true, "explanation": "Maximum number of points in a segment", "defaultValue": "300", "alternatives": ["2-10000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "lambda", "flag": "lambda", "dataType": "String", "optional": true, "explanation": "Tykhonov regularization parameter (affects smoothing)", "defaultValue": "0.01", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.fillnulls  fills NULL pixels (no data areas) in input raster\n map and stores filled data to a new output raster map. The fill areas\n are interpolated from the no data area boundaries buffer\n using  v.surf.rst  regularized\n spline interpolation with tension ( method=rst ) or\n  r.resamp.bspline  cubic or\n linear spline interpolation with Tykhonov regularization.\n ", "notes": "\n Each area boundary buffer is set to three times the map resolution to get nominally\n three points around the edge. This way the algorithm interpolates into the hole with\n a trained slope and curvature at the edges, in order to avoid that such a flat plane\n is generated in a hole. The width of edge area can be adjusted by \n changing the edge parameter.\n  During the interpolation following warning may occur when using the RST method: \n Warning: strip exists with insufficient data \n Warning: taking too long to find points for interpolation--please change\n the region to area where your points are \n This warning is generated if large data holes exist within the surface.\n As the idea of  r.fillnulls  is to fill such holes, the user may\n ignore the warning. The interpolation will be continued. However, the user\n may pay attention to below notes.\n If interpolation fails, temporary raster and vector maps are left in place to allow\n unfilled map hole (NULL area) identification and manual repair.\n When using the default RST method, the algorithm is based\n on  v.surf.rst  regularized\n splines with tension interpolation module which interpolates the\n raster cell values for NULL data areas from the boundary values of the\n NULL data area. An eventual raster MASK is respected during the NULL\n data area(s) filling. The interpolated values are patched into the\n NULL data area(s) of the input map and saved into a new raster map.\n Otherwise, either the linear or cubic spline interpolation with\n Tykhonov regularization can be selected (based on  r.resamp.bspline ). \n  WARNING \n Depending on the shape of the NULL data area(s) problems may occur due to an\n insufficient number of input cell values for the interpolation process. Most\n problems will occur if a NULL data area reaches a large amount of the map\n boundary. The user will have to carefully check the result using\n  r.mapcalc  (generating a\n difference map to the input map and applying the\n \"differences\" color table\n with  r.colors ) and/or to query\n individual cell values.\n RST method stores temporary maps on hard disk. It will require at least as much\n free space as one extra input raster map takes.\n  EXAMPLE \n In this example, the SRTM elevation map in the\n North Carolina sample dataset location is filtered for outlier\n elevation values; missing pixels are then re-interpolated to obtain\n a complete elevation map:\n g.region raster=elev_srtm_30m -p\n d.mon wx0\n d.histogram elev_srtm_30m\n # remove too low elevations (esp. lakes)\n r.mapcalc \"elev_srtm_30m_filt = if(elev_srtm_30m < 50.0, null(), elev_srtm_30m)\"\n d.histogram elev_srtm_30m_filt\n d.rast elev_srtm_30m_filt\n r.fillnulls input=elev_srtm_30m_filt output=elev_srtm_30m_complete tension=20\n d.histogram elev_srtm_30m_complete\n d.rast elev_srtm_30m_complete\n  REFERENCES \n   Mitas, L., Mitasova, H., 1999, Spatial Interpolation. In: P.Longley,\n M.F. Goodchild, D.J. Maguire, D.W.Rhind (Eds.), Geographical Information\n Systems: Principles, Techniques, Management and Applications, Wiley,\n pp.481-492\n  Mitasova H., Mitas L.,\u00a0 Brown W.M.,\u00a0 D.P. Gerdes, I.\n Kosinovsky, Baker, T.1995, Modeling spatially and temporally distributed\n phenomena: New methods and tools for GRASS GIS.  International Journal of\n GIS , 9 (4), special issue on Integrating GIS and Environmental modeling,\n 433-446.\n  Mitasova H.\n and Mitas L. 1993 : Interpolation by Regularized Spline with Tension: I.\n Theory and Implementation,  Mathematical Geology  25, 641-655.\n  Mitasova H.\n and Hofierka L. 1993 : Interpolation by Regularized Spline with Tension:\n II. Application to Terrain Modeling and Surface Geometry Analysis,\n  Mathematical Geology  25, 657-667.\n ", "see_also": ["r.fill.dir", "r.mapcalc", "r.resamp.bspline", "v.surf.rst"], "authors": ["Markus Neteler, University of Hannover and Fondazione Edmund Mach"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.fillnulls"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.fill.stats.html", "name": "r.fill.stats", "definition": "- Rapidly fills 'no data' cells (NULLs) of a raster map with interpolated values (IDW).", "keywords": ["raster", "surface", "interpolation", "IDW", "null data"], "synopsis": "r.fill.stats [-mkwus] input=name output=name  [uncertainty=name]  distance=value mode=name  [minimum=value]   [maximum=value]  power=value cells=value  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Interpret distance as map units, not number of cells Keep (preserve) original cell values By default original values are smoothed Just print the spatial weights matrix Just print estimated memory usage Single precision floating point output Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "k", "flag": "-k", "explanation": "Keep (preserve) original cell values By default original values are smoothed Just print the spatial weights matrix Just print estimated memory usage Single precision floating point output Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Just print the spatial weights matrix Just print estimated memory usage Single precision floating point output Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "u", "flag": "-u", "explanation": "Just print estimated memory usage Single precision floating point output Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Single precision floating point output Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Raster map with data gaps to fill", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of result output map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "uncertainty", "flag": "uncertainty", "dataType": "String", "optional": true, "explanation": "Name of uncertainty output map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": false, "explanation": "Distance threshold (default: in cells) for interpolation", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mode", "flag": "mode", "dataType": "String", "optional": false, "explanation": "Statistic for interpolated cell values", "defaultValue": "wmean", "alternatives": ["wmean", "mean", "median", "mode"], "isInputFile": false, "isOutputFile": false}, {"parameter": "minimum", "flag": "minimum", "dataType": "String", "optional": true, "explanation": "Minimum input data value to include in interpolation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maximum", "flag": "maximum", "dataType": "String", "optional": true, "explanation": "Maximum input data value to include in interpolation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "power", "flag": "power", "dataType": "String", "optional": false, "explanation": "Power coefficient for IDW interpolation", "defaultValue": "2.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cells", "flag": "cells", "dataType": "String", "optional": false, "explanation": "Minimum number of data cells within search radius", "defaultValue": "8", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.fill.stats  is a module for fast gap filling and\n interpolation (with smoothing) of dense raster data.\n The  r.fill.stats  module is capable of quickly filling small\n data gaps in large and high-resolution raster maps. It's primary purpose\n is to improve high-resolution, rasterized sensor data (such as Lidar\n data). As a rule of thumb, there should be at least as many data cells as there are \"no data\" (NULL) cells in\n the input raster map. Several interpolation modes are available. By\n default, all values of the input raster map will be replaced with\n locally interpolated values in the output raster map. This is the\n equivalent of running a low-pass smoothing filter on the interpolated\n data and is often desirable, owing to noisy nature of high-resolution\n sensor data. With dense data and small gaps, this should result in only slight\n deviations from the original data and produce smooth output. Alternatively,\n setting the  -k  flag will disable the low-pass filter and preserve\n the original cell values.\n Available gap filling modes:\n  spatially weighted mean (default) \n  simple mean \n  simple median \n  simple mode \n The spatially weighted mean is equivalent to an Inverse Distance\n Weighting (IDW;\n see also  r.surf.idw )\n interpolation. The simple mean is equivalent to a simple low-pass filter.\n Median and mode replacements can also be achieved using\n  r.neighbors .\n Note that  r.fill.stats  is highly optimized for fast processing\n of large raster datasets with a small interpolation distance threshold\n (i.e. closing small gaps). As a trade-off for speed and a small memory\n foot print, some spatial accuracy is lost due to the rounding of the\n distance threshold to the closest approximation in input raster cells\n and the use of a matrix of precomputed weights at cell resolution (see\n further down for details). Note also that processing time will increase\n exponentially with higher distance settings. Cells outside the distance\n threshold will not be interpolated, preserving the edges of the original data\n extent.\n This module is not well suited for interpolating sparse input data and\n closing large gaps. For such purposes more appropriate\n methods are available, such as\n  v.surf.idw  or\n  v.surf.rst .\n Applications where the properties of  r.fill.stats  are\n advantageous include the processing of high resolution, close range\n scanning and remote sensing datasets. Such datasets commonly feature\n densely spaced measurements that have some gaps after rasterization,\n due to blind spots, instrument failures, and misalignments between the\n GIS' raster cell grids and the original measurement locations. In these\n cases,  r.fill.stats  should typically be run using the \"weighted\n mean\" (default) method and with a small distance setting (the default\n is to use a search radius of just three cells).\n The images below show a gradiometer dataset with gaps and its\n interpolated equivalent, produced using the spatially weighted mean\n operator ( mode=\"wmean\" ).\n     \n In addition,  r.fill.stats  can be useful for raster map\n generalization. Often, this involves removing small clumps of\n categorized cells and then filling the resulting data gaps without\n \"inventing\" any new values. In such cases, the \"mode\" or \"median\"\n interpolators should be used.\n  Usage \n The most critical user-provided settings are the interpolation/gap\n filling method ( mode ) and the maximum distance, up to which\n  r.fill.stats  will scan for cells with values ( distance ).\n The distance can be expressed as a number of cells (default) or in the\n current GRASS location's units (if the  -m  flag is given). The latter\n are typically meters, but can be any other units of a  planar \n coordinate system.\n Note that proper handling of geodetic coordinates (lat/lon) and\n distances is currently not implemented. For lat/lon data, the distance\n should therefore be specified in cells and usage of\n  r.fill.stats  should be restricted to small areas to avoid large\n inaccuracies that may arise from the different extents of cells along\n the latitudinal and longitudinal axes.\n Distances specified in map units ( -m  flag) will be approximated\n as accurately as the current region's cell resolution settings allow.\n The program will warn if the distance cannot be expressed as whole\n cells at the current region's resolution. In such case, the number of\n cells in the search window will be rounded up. Due to the rounding\n effect introduced by using cells as spatial units, the actual maximum\n distance considered by the interpolation may be up to half a cell\n diagonal larger than the one specified by the user.\n The interpolator type \"wmean\" uses a precomputed matrix of spatial\n weights to speed up computation. This matrix can be examined (printed\n to the screen) before running the interpolation, by setting the\n  -w  flag. In mode \"wmean\", the  power  option has the usual\n meaning in IDW: higher values mean that cell values in the neighborhood\n lose their influence on the cell to be interpolated more rapidly with\n increasing distance from the latter. Another way of explaining this\n effect is to state that larger \"power\" settings result in more\n localized interpolation, smaller ones in more globalized interpolation.\n The default setting is  power=2.0 .\n The interpolators \"mean\", \"median\" and \"mode\" are calculated from all\n cell values within the search radius. No spatial weighting is applied\n for these methods. The \"mode\" of the input data may not always be\n unique. In such case, the mode will be the smallest value with the\n highest frequency.\n Often, input data will contain spurious extreme measurements (spikes,\n outliers, noise) caused by the limits of device sensitivity, hardware\n defects, environmental influences, etc. If the normal, valid range of\n input data is known beforehand, then the  minimum  and\n  maximum  options can be used to exclude those input cells that\n have values below or above that range, respectively. This will prevent\n the influence of spikes and outliers from spreading through the\n interpolation.\n Unless the  -k  (keep) flag is given, data cells of the input\n map will be replaced with interpolated values instead of preserving\n them in the output. In modes \"wmean\" and \"mean\", this results in a\n smoothing effect that includes the original data (see below)!\n Besides the result of the interpolation/gap filling, a second output\n map can be specified via the  uncertainty  option. The cell values\n in this map represent a simple measure of how much uncertainty was\n involved in interpolating each cell value of the primary output map,\n with \"0\" being the lowest and \"1\" being the theoretic highest\n uncertainty. Uncertainty is measured by summing up all cells in the\n neighborhood (defined by the search radius  distance ) that\n contain a value in the  input  map, multiplied by their weights,\n and dividing the result by the sum of all weights in the neighborhood.\n For  mode=wmean , this means that interpolated output cells that\n were computed from many nearby input cells have very low uncertainty\n and vice versa. For all other modes, all weights in the neighborhood\n are constant \"1\" and the uncertainty measure is a simple measure of how\n many input data cells were present in the search window.\n  Smoothing \n The  r.fill.stats  module uses the interpolated values to adjust\n the original values and create a smooth surface, which is akin to running\n a low-pass filter on the data. Since most high-resolution sensor data\n is noisy, this is normally a desired effect and results in output that\n is more suitable for deriving secondary products, such as slope, aspect\n and curvature maps. Larger settings for the search radius ( distance )\n will result in a stronger smoothing. In practice, some experimentation\n with different settings for  distance  and  power  might be required\n to achieve good results. In some cases (e.g. when dealing with low-noise or\n classified data), it might be desirable to turn off data smoothing by\n setting the  -k  (keep) flag. This will ensure that the original\n cell data is copied through to the result map without alteration. \n      \n Effect of smoothing the original data: The top row shows a gap-filled surface computed from a rasterized Lidar point  \n cloud (using  mode=wmean  and  power=2 ), and the derived slope, aspect,\n and profile curvature maps. The smoothing effect is clearly visible.\n The bottom row shows the effect of setting the  -k  flag: Preserving the original\n cell values in the interpolated output produces and unsmoothed, noisy surface, and likewise\n noisy derivative maps.\n The effect can be seen in the illustration above:\n Slope, aspect, and profile curvature are computed using the\n  r.slope.aspect  module, which\n uses a window (kernel) for computations that considers only the\n immediate neighborhood of each cell. When performed on noisy data,\n such local operations result in equally noisy derivatives if the\n original data is preserved (by setting the  -k  flag) and no smoothing\n is performed.  \n (Note that the effects of noisy data can also be avoided by using modules\n that are not restricted to minimal kernel sizes. For example, aspect and other morphometric parameters can be computed\n using the  r.param.scale  module\n which operates with variable-size cell neighborhoods.)\n  Spatial weighting scheme \n The key to getting good gap filling results is to understand the\n spatial weighting scheme used in mode \"wmean\". The weights are\n precomputed and assigned per cell within the search window centered on\n the location at which to interpolate/gap fill all cells within the\n user-specified distance.\n The illustration below shows the precomputed weights matrix for a\n search distance of four cells from the center cell:\n 000.00 000.01 000.04 000.07 000.09 000.07 000.04 000.01 000.00\n 000.01 000.06 000.13 000.19 000.22 000.19 000.13 000.06 000.01\n 000.04 000.13 000.25 000.37 000.42 000.37 000.25 000.13 000.04\n 000.07 000.19 000.37 000.56 000.68 000.56 000.37 000.19 000.07\n 000.09 000.22 000.42 000.68 001.00 000.68 000.42 000.22 000.09\n 000.07 000.19 000.37 000.56 000.68 000.56 000.37 000.19 000.07\n 000.04 000.13 000.25 000.37 000.42 000.37 000.25 000.13 000.04\n 000.01 000.06 000.13 000.19 000.22 000.19 000.13 000.06 000.01\n 000.00 000.01 000.04 000.07 000.09 000.07 000.04 000.01 000.00\n Note that the weights in such a small window drop rapidly for the\n default setting of  power=2 .\n If the distance is given in map units (flag  -m ), then the\n search window can be modeled more accurately as a circle. The\n illustration below shows the precomputed weights for a distance in map\n units that is approximately equivalent to four cells from the center\n cell:\n ...... ...... ...... 000.00 000.00 000.00 ...... ...... ......\n ...... 000.00 000.02 000.06 000.09 000.06 000.02 000.00 ......\n ...... 000.02 000.11 000.22 000.28 000.22 000.11 000.02 ......\n 000.00 000.07 000.22 000.44 000.58 000.44 000.22 000.07 000.00\n 000.00 000.09 000.28 000.58 001.00 000.58 000.28 000.09 000.00\n 000.00 000.07 000.22 000.44 000.58 000.44 000.22 000.07 000.00\n ...... 000.02 000.11 000.22 000.28 000.22 000.11 000.02 ......\n ...... 000.00 000.02 000.06 000.09 000.06 000.02 000.00 ......\n ...... ...... ...... 000.00 000.00 000.00 ...... ...... ......\n When using a small search radius,  cells  must also be set to a\n small value. Otherwise, there may not be enough cells with data within\n the search radius to support interpolation.\n ", "notes": "\n The straight-line metric used for converting distances in map units to\n cell numbers is only adequate for planar coordinate systems. Using this\n module with lat/lon input data will likely give inaccurate results,\n especially when interpolating over large geographical areas.\n If the distance is set to a relatively large value, processing time\n will quickly approach and eventually exceed that of point-based\n interpolation modules such as\n  v.surf.rst .\n This module can handle cells with different X and Y resolutions.\n However, note that the weight matrix will be skewed in such cases, with\n higher weights occurring close to the center and along the axis with\n the higher resolution. This is because weights on the lower resolution\n axis are less accurately calculated. The skewing effect will be\n stronger if the difference between the X and Y axis resolution is\n greater and a larger \"power\" setting is chosen. This property of the\n weights matrix directly reflects the higher information density along\n the higher resolution axis.\n Note on printing the weights matrix (using the  -w  flag): the\n matrix cannot be printed if it is too large.\n The memory estimate provided by the  -u  flag is a lower limit on\n the amount of RAM that will be needed.\n If the  -s  flag is set, floating point type output will be\n saved as a \"single precision\" raster map, saving ~50% disk space\n compared to the default \"double precision\" output.\n  EXAMPLES \n Gap-fill a dataset using spatially weighted mean (IDW) and a maximum\n search radius of 3.0 map units; also produce uncertainty estimation\n map:\n r.fill.stats input=measurements output=result dist=3.0 -m mode=wmean uncertainty=uncert_map\n Run a fast low-pass filter (replacement all cells with mean value of\n neighboring cells) on the input map:\n r.fill.stats input=measurements output=result dist=10 mode=mean\n Fill data gaps in a categorized raster map; preserve existing data:\n r.fill.stats input=categories output=result dist=100 -m mode=mode -k\n  Lidar point cloud example \n Inspect the point density and determine the extent of the point cloud\n using the  r.in.lidar  module:\n r.in.lidar -e input=points.las output=density method=n resolution=5 class_filter=2\n Based on the result, set computational region extent and desired\n resolution:\n g.region -pa raster=density res=1\n Import the point cloud as raster using binning:\n r.in.lidar input=points.las output=ground_raw method=mean class_filter=2\n Check that there are more non-NULL cells than NULL (\"no data\") cells:\n r.univar map=ground_raw\n total null and non-null cells: 2340900\n total null cells: 639184\n ...\n Fill in the NULL cells using the default 3-cell search radius:\n r.fill.stats input=ground output=ground_filled uncertainty=uncertainty distance=3 mode=wmean power=2.0 cells=8\n  \n Binning of Lidar and resulting ground surface with filled gaps.\n Note the remaining NULL cells (white) in the resulting ground surface.\n These are areas with a lack of cells with values in close proximity.\n ", "see_also": ["r.fillnulls", "r.neighbors", "r.surf.idw", "v.surf.idw", "v.surf.rst"], "authors": ["Benjamin Ducke"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.fill.stats"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.fill.dir.html", "name": "r.fill.dir", "definition": "- Filters and generates a depressionless elevation map and a flow direction map from a given elevation raster map.", "keywords": ["raster", "hydrology", "sink", "fill sinks", "depressions"], "synopsis": "r.fill.dir [-f] input=name output=name direction=name  [areas=name]   [format=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Find unresolved areas only Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output depressionless elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "direction", "flag": "direction", "dataType": "String", "optional": false, "explanation": "Name for output flow direction map for depressionless elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "areas", "flag": "areas", "dataType": "String", "optional": true, "explanation": "Name for output raster map of problem areas", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Aspect direction format", "defaultValue": "grass", "alternatives": ["agnps", "answers", "grass"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.fill.dir  filters and generates a depressionless\n elevation map and a flow direction map from a given raster elevation map.\n The method adopted to filter the elevation map and rectify it is\n based on the paper titled \"Extracting topographic structure from\n digital elevation model data for geographic information system analysis\"\n by S.K. Jenson and J.O. Domingue (1988).\n The procedure takes an elevation layer as input and initially fills all the\n depressions with one pass across the layer. Next, the flow direction\n algorithm tries to find a unique direction for each cell. If the watershed\n program detects areas with pothholes, it delineates this area from the rest\n of the area and once again the depressions are filled using the neighborhood\n technique used by the flow direction routine. The final output will be a\n depressionless elevation layer and a unique flow direction layer.\n This (D8) flow algorithm performs as follows: At each raster cell the code\n determines the slope to each of the 8 surrounding cells and assigns the flow\n direction to the highest slope out of the cell.  If there is more than one\n equal, non-zero slope then the code picks one direction based on preferences\n that are hard-coded into the program.  If the highest slope is flat and in\n more than one direction then the code first tries to select an alternative\n based on flow directions in the adjacent cells.  r.fill.dir  iterates that process,\n effectively propagating flow directions from areas where the directions are\n known into the area where the flow direction cannot otherwise be resolved.\n The  format  parameter is the type of format at which the user wishes to create\n the flow  direction  map.\n The flow direction map can be encoded in GRASS GIS aspect format,\n ANSWERS (Beasley et.al, 1982), or AGNPS (Young et.al, 1985) format,\n so that it can be readily used as input to other GRASS GIS modules\n or the aforementioned hydrological models.\n The  grass  format gives the same category\n values as  r.slope.aspect \n gives for aspect, i.e. angles in degrees counter-clockwise from east\n in 45 degree increments.\n The  agnps  format gives category values from\n 1-8, with 1 facing north and increasing values in the clockwise direction.\n The  answers  format gives category values from 0-360 degrees,\n with 0 (represented as 360) facing east and values increasing in the\n counter-clockwise direction at 45 degree increments.\n In all cases, NULL (no data) values are used for cells where direction\n cannot be determined.\n In case of local problems, those unfilled areas can be stored optionally.\n Each unfilled area in this maps is numbered. The  -f  flag\n instructs the program to fill single-cell pits but otherwise to just find\n the undrained areas and exit. With the  -f  flag set the program\n writes an elevation map with just single-cell pits filled, a direction map\n with unresolved problems and a map of the undrained areas that were found\n but not filled. This option was included because filling DEMs was often not\n the best way to solve a drainage problem. These options let the user get a\n partially-fixed elevation map, identify the remaining problems and fix the\n problems appropriately.\n In some cases it may be necessary to run  r.fill.dir  repeatedly (using output\n from one run as input to the next run) before all of problem areas are\n filled.\n The resulting depressionless elevation\n raster map can further be processed to derive slopes and other\n attributes required by other hydrological models.\n As any GRASS GIS module,  r.fill.dir  is sensitive to the\n computational region settings. Thus\n the module can be used to generate a flow direction map for any \n sub-area within the full map layer. Also,  r.fill.dir  is\n sensitive to any raster  MASK  in effect.\n ", "notes": "\n The  r.fill.dir  module can be used not only to fill depression,\n but also to detect water bodies or potential water bodies based on\n the nature of the terrain and the digital elevation model used.\n Not all depressions are errors in digital elevation models. In fact,\n many are wetlands and as Jenkins and McCauley (2006) note careless use\n of depression filling may lead to unintended consequences such\n as loss of wetlands.\n Although many hydrological algorithms require depression filling,\n advanced algorithms such as those implemented in\n  r.watershed  and\n  r.sim.water  do not require\n depressionless digital elevation model to work.\n The flow direction map can be visualized with\n  d.rast.arrow .\n  EXAMPLES \n Generic example: create a depressionless (sinkless) elevation\n map  ansi.fill.elev  and a flow direction map  ansi.asp  for the\n type \"grass\":\n r.fill.dir input=ansi.elev output=ansi.fill.elev direction=ansi.asp\n North Carolina sample dataset example: The LiDAR derived 1m elevation map is\n sink-filled. The outcome are a depressionless elevation map, the flow direction\n map and an error map.\n # set computational region to elevation map\n g.region raster=elev_lid792_1m -p\n # generate depressionless DEM and related maps\n r.fill.dir input=elev_lid792_1m output=elev_lid792_1m_filled \n             direction=elev_lid792_1m_dir areas=elev_lid792_1m_error\n # generate elevation map of pixelwise differences to see obtained terrain alterations\n r.mapcalc \"elev_lid792_1m_diff = elev_lid792_1m_filled - elev_lid792_1m\"\n r.colors elev_lid792_1m_diff color=differences\n # assess univariate statistics of differences\n r.univar -e elev_lid792_1m_diff\n # vectorize filled areas (here all fills are of positive value, see r.univar output)\n r.mapcalc \"elev_lid792_1m_fill_area = if(elev_lid792_1m_diff > 0.0, 1, null() )\"\n r.to.vect input=elev_lid792_1m_fill_area output=elev_lid792_1m_fill_area type=area\n # generate shaded terrain for better visibility of results\n r.relief input=elev_lid792_1m_filled output=elev_lid792_1m_filled_shade\n d.mon wx0\n d.shade shade=elev_lid792_1m_filled_shade color=elev_lid792_1m_filled\n d.vect elev_lid792_1m_fill_area type=boundary color=red\n  \n  Figure: Sink-filled DEM (shown as shaded terrain) with areas of filling shown as vector polygons \n  REFERENCES \n  Beasley, D.B. and L.F. Huggins. 1982. ANSWERS (areal nonpoint source watershed environmental \n response simulation): User's manual. U.S. EPA-905/9-82-001, Chicago, IL, 54 p.\n  Jenkins, D. G., and McCauley, L. A. 2006.\n     GIS, SINKS, FILL, and disappearing wetlands:\n     unintended consequences in algorithm development and use.\n     In Proceedings of the 2006 ACM symposium on applied computing\n     (pp. 277-282).\n  Jenson, S.K., and J.O. Domingue. 1988. Extracting topographic structure from\n digital elevation model data for geographic information system analysis. Photogram.\n Engr. and Remote Sens. 54: 1593-1600.\n  Young, R.A., C.A. Onstad, D.D. Bosch and W.P. Anderson. 1985. Agricultural nonpoint\n surface pollution models (AGNPS) I and II model documentation. St. Paul: Minn. Pollution\n control Agency and Washington D.C., USDA-Agricultural Research Service.\n ", "see_also": ["d.rast.arrow", "d.shade", "g.region", "r.fillnulls", "r.relief", "r.slope.aspect"], "authors": ["Fortran version: Raghavan Srinivasan, Agricultural Engineering Department, Purdue University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.fill.dir"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.external.out.html", "name": "r.external.out", "definition": "- Redirects raster output to file utilizing GDAL library rather than storing in GRASS raster format.", "keywords": ["raster", "export", "output", "external"], "synopsis": "r.external.out [-frp] directory=path  [extension=string]  format=string  [options=string[,string,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "List supported formats and exit Cease using GDAL and revert to native output Print current status Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Cease using GDAL and revert to native output Print current status Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print current status Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "directory", "flag": "directory", "dataType": "String", "optional": false, "explanation": "Name of output directory", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "extension", "flag": "extension", "dataType": "String", "optional": true, "explanation": "Extension for output files", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": false, "explanation": "Format of output files", "defaultValue": null, "alternatives": ["VRT", "GTiff", "NITF", "HFA", "ELAS", "AAIGrid", "DTED", "PNG", "JPEG", "MEM", "GIF", "XPM", "BMP", "PCIDSK", "PCRaster", "ILWIS", "SGI", "SRTMHGT", "Leveller", "Terragen", "GMT", "netCDF", "HDF4Image", "ISIS2", "ERS", "JPEG2000", "FIT", "RMF", "WMS", "RST", "INGR", "GSAG", "GSBG", "GS7BG", "R", "PNM", "ENVI", "EHdr", "PAux", "MFF", "MFF2", "BT", "LAN", "IDA", "GTX", "NTv2", "CTable2", "ARG", "USGSDEM", "ADRG", "BLX", "Rasterlite", "EPSILON", "PostGISRaster", "SAGA", "KMLSUPEROVERLAY", "XYZ", "HF2", "PDF", "WEBP", "ZMap"], "isInputFile": false, "isOutputFile": false}, {"parameter": "options", "flag": "options", "dataType": "String", "optional": true, "explanation": "Creation options", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.external.out  instructs GRASS GIS to write subsequently generated\n raster maps as data files (e.g. GeoTIFF) using GDAL instead of storing them\n in GRASS raster format in the current mapset.\n Any new raster map is immediately written out through GDAL as a file.\n ", "notes": "\n A relative directory path (parameter  directory ) is interpreted\n relative to the current mapset directory, not the current directory where\n the command was launched. An unspecified or empty directory (which will\n occur if the user passes a simple filename for  output ) results\n in the output file being placed in the \"gdal/\" subdirectory of the \n current mapset directory.\n  EXAMPLES \n  Storing results from raster data analysis directly as GeoTIFF \n The module  r.external.out  is used to write out processing results\n directly in GeoTIFF format (any GDAL supported format can be used here):\n # define output directory for files resulting from GRASS calculation(s)\n # and target format:\n mkdir $HOME/gisoutput/\n r.external.out directory=$HOME/gisoutput/ format=\"GTiff\"\n # prepare sample analysis\n g.region raster=elevation -p\n # perform GRASS calculation (here: filter by height, write > 120m, NULL otherwise)\n # this will store the output map directly as GeoTIFF, so we use .tif extension:\n r.mapcalc \"elev_filt.tif = if(elevation > 120.0, elevation, null() )\"\n # ...the \"elev_filt.tif\" is immediately written.\n # cease GDAL output connection and turn back to write out GRASS raster files:\n r.external.out -r\n # verify resulting file\n gdalinfo $HOME/gisoutput/elev_filt.tif\n  Complete workflow using only external geodata while processing in GRASS GIS \n The module  r.external.out  can be used along with\n  r.external  to process external geodata in GRASS\n while writing out the results directly in GeoTIFF:\n # register GeoTIFF file to be used in current mapset:\n r.external input=terra_lst1km20030314.LST_Day.tif output=modis_celsius\n # define output directory for files resulting from GRASS calculation:\n r.external.out directory=$HOME/gisoutput/ format=\"GTiff\"\n # perform GRASS calculation (here: extract pixels > 20 deg C)\n # this stores the output map directly as GeoTIFF:\n r.mapcalc \"warm.tif = if(modis_celsius > 20.0, modis_celsius, null() )\"\n # cease GDAL output connection and turn back to write GRASS raster files:\n r.external.out -r\n # now use the resulting file elsewhere\n gdalinfo $HOME/gisoutput/warm.tif\n  REFERENCES \n GDAL Pages:  http://www.gdal.org/ \n ", "see_also": ["r.in.gdal", "r.out.gdal", "r.external"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.external.out"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.external.html", "name": "r.external", "definition": "- Links GDAL supported raster data as a pseudo GRASS raster map.", "keywords": ["raster", "import", "external"], "synopsis": "r.external [-fojeahvt]  [input=name]   [source=name]  output=name  [band=integer]   [title=phrase]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "List supported formats and exit Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Perform projection check only and exit Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Flip horizontally Flip vertically List available bands including band type in dataset and exit Format: band number,type,projection check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Perform projection check only and exit Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Flip horizontally Flip vertically List available bands including band type in dataset and exit Format: band number,type,projection check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "j", "flag": "-j", "explanation": "Perform projection check only and exit Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Flip horizontally Flip vertically List available bands including band type in dataset and exit Format: band number,type,projection check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Flip horizontally Flip vertically List available bands including band type in dataset and exit Format: band number,type,projection check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Flip horizontally Flip vertically List available bands including band type in dataset and exit Format: band number,type,projection check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Flip horizontally Flip vertically List available bands including band type in dataset and exit Format: band number,type,projection check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Flip vertically List available bands including band type in dataset and exit Format: band number,type,projection check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "List available bands including band type in dataset and exit Format: band number,type,projection check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of raster file to be linked", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "source", "flag": "source", "dataType": "String", "optional": true, "explanation": "Name of non-file GDAL data source", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "band", "flag": "band", "dataType": "String", "optional": true, "explanation": "Band to select (default is all bands)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.external  allows a user to link a GDAL supported raster file to a binary\n raster map layer, from any GDAL supported raster map format, with an optional \n title. The file is not imported but just registered as GRASS raster map.\n ", "notes": "\n In essence,  r.external  creates a read-only link to the \n original dataset which is only valid if the original dataset remains \n at the originally indicated directory and filename.\n  NULL data handling \n GDAL-linked ( r.external ) maps do not have or use a NULL \n bitmap, hence  r.null  cannot manipulate them directly. Here \n NULL cells are those whose value matches the value reported by the \n GDALGetRasterNoDataValue() function.\n To apply the GDAL-linked the user need to either create a MASK (e.g. \n with  r.mask ) and then \"apply\" it using e.g.  r.resample ,\n or use  r.mapcalc  to create a copy with the appropriate categories\n changed to NULL (if() condition).\n  EXAMPLES \n  RGB Orthophoto from GeoTIFF \n # import of all channels (each channel will become a GRASS raster map):\n r.external input=/home/user/data/maps/059100.tif output=ortho\n g.region raster=ortho.3 -p\n d.rgb r=ortho.1 g=ortho.2 b=ortho.3\n r.composite r=ortho.1 g=ortho.2 b=ortho.3 output=ortho.rgb\n  Processing workflow without data import and export \n External raster maps to be processed can be directly linked using  r.external ;\n likewise, results can be written out to standard raster formats with\n  r.external.out  (GDAL supported formats):\n # register GeoTIFF file to be used in current mapset:\n r.external input=terra_lst1km20030314.LST_Day.tif output=modis_celsius\n # define output directory for files resulting from GRASS calculation:\n r.external.out directory=$HOME/gisoutput/ format=\"GTiff\"\n # perform GRASS calculation (here: extract pixels > 20 deg C)\n # this stores the output map directly as GeoTIFF:\n r.mapcalc \"warm.tif = if(modis_celsius > 20.0, modis_celsius, null() )\"\n # cease GDAL output connection and turn back to write GRASS raster files:\n r.external.out -r\n # now use the resulting file elsewhere\n gdalinfo $HOME/gisoutput/warm.tif\n  REFERENCES \n GDAL Pages:  http://www.gdal.org/ \n ", "see_also": ["r.import", "r.in.gdal", "r.external.out"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.external"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.drain.html", "name": "r.drain", "definition": "- Traces a flow through an elevation model or cost surface on a raster map.", "keywords": ["raster", "hydrology", "cost surface"], "synopsis": "r.drain [-cand] input=name  [direction=name]  output=name  [drain=name]   [start_coordinates=east,north[,east,north,...]]   [start_points=name[,name,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Copy input cell values on output Accumulate input values along the path Count cell numbers along the path The input raster map is a cost surface (direction surface must also be specified) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Accumulate input values along the path Count cell numbers along the path The input raster map is a cost surface (direction surface must also be specified) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Count cell numbers along the path The input raster map is a cost surface (direction surface must also be specified) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "The input raster map is a cost surface (direction surface must also be specified) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input elevation or cost surface raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "direction", "flag": "direction", "dataType": "String", "optional": true, "explanation": "Name of input movement direction map associated with the cost surface", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "drain", "flag": "drain", "dataType": "String", "optional": true, "explanation": "Name for output drain vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "start_coordinates", "flag": "start_coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates of starting point(s) (E,N)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_points", "flag": "start_points", "dataType": "String", "optional": true, "explanation": "Name of starting vector points map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.drain  traces a flow through a least-cost path in an\n elevation model or cost surface. For cost surfaces, a movement\n direction map must be specified with the\n  direction  option and the  -d  flag to trace a flow path following \n the given directions. Such a movement direction map can be generated with \n  r.walk , \n  r.cost , \n  r.slope.aspect  or \n  r.watershed \n provided that the direction is in degrees, measured counterclockwise\n from east.\n The  output  raster map will show one or more least-cost paths\n between each user-provided location(s) and the minima (low category\n values) in the raster  input  map. If the  -d  flag is used\n the output least-cost paths will be found using the direction raster\n map.  By default, the  output  will be an integer CELL map with\n category 1 along the least cost path, and null cells elsewhere.\n  With the  -c  ( copy ) flag, the input raster map cell values are\n copied verbatim along the path. With the  -a  ( accumulate )\n flag, the accumulated cell value from the starting point up to the current\n cell is written on output. With either the  -c  or the  -a  flags, the\n  output  map is created with the same cell type as\n the  input  raster map (integer, float or double).  With\n the  -n  ( number ) flag, the cells are numbered\n consecutively from the starting point to the final point.\n The  -c ,  -a , and  -n  flags are mutually incompatible.\n  For an elevation surface, the path is calculated by choosing the\n steeper \"slope\" between adjacent cells. The slope calculation\n accurately acounts for the variable scale in lat-lon projections. For\n a cost surface, the path is calculated by following the movement\n direction surface back to the start point given\n in  r.walk  or\n  r.cost . The path search stops \n as soon as a region border or a neighboring NULL cell is encountered, \n because in these cases the direction can not be determined (the path \n could continue outside the current region).\n  The  start_coordinates  parameter consists of map E and N grid coordinates of\n a starting point. Each x,y pair is the easting and northing (respectively) of\n a starting point from which a least-cost corridor will be developed.\n The  start_points  parameter can take multiple vector maps containing \n additional starting points.\n Up to 1024 starting points can be input from a combination of the\n  start_coordinates  and  start_points  parameters.\n  Explanation of output values \n Consider the following example: \n Input:                          Output:\n   ELEVATION SURFACE               LEAST COST PATH\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 19. 20. 18. 19. 16. 15. 15.    .   .   .   .   .   .   .   .\n . .  ---  . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 20| 19| 17. 16. 17. 16. 16.    .   . 1 . 1 . 1 .   .   .   .\n . .  ---  . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 18. 18. 24. 18. 15. 12. 11.    .   .   .   .   . 1 .   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 22. 16. 16. 18. 10. 10. 10.    .   .   .   .   . 1 .   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 17. 15. 15. 15. 10. 8 . 8 .    .   .   .   .   .   . 1 .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 24. 16. 8 . 7 . 8 . 0 . 12.    .   .   .   .   .   . 1 .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 17. 9 . 8 . 7 . 8 . 6 . 12.    .   .   .   .   .   .   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n The user-provided starting location in the above example is \n the boxed  19  in the left-hand map. The path in the output \n shows the least-cost corridor for moving from the starting \n box to the lowest (smallest) possible point. This is the path a raindrop \n would take in this landscape.\n With the  -c   (copy)  flag, you get the following result:\n Input:                          Output:\n   ELEVATION SURFACE               LEAST COST PATH\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 19. 20. 18. 19. 16. 15. 15.    .   .   .   .   .   .   .   .\n . .  ---  . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 20| 19| 17. 16. 17. 16. 16.    .   . 19. 17. 16.   .   .   .\n . .  ---  . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 18. 18. 24. 18. 15. 12. 11.    .   .   .   .   . 15.   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 22. 16. 16. 18. 10. 10. 10.    .   .   .   .   . 10.   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 17. 15. 15. 15. 10. 8 . 8 .    .   .   .   .   .   . 8 .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 24. 16. 8 . 7 . 8 . 0 .12 .    .   .   .   .   .   . 0 .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 17. 9 . 8 . 7 . 8 . 6 .12 .    .   .   .   .   .   .   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n Note that the last  0  will not be put in the null values map.\n With the  -a   (accumulate)  flag, you get the following result:\n Input:                          Output:\n   ELEVATION SURFACE               LEAST COST PATH\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 19. 20. 18. 19. 16. 15. 15.    .   .   .   .   .   .   .   .\n . .  ---  . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 20| 19| 17. 16. 17. 16. 16.    .   . 19. 36. 52.   .   .   .\n . .  ---  . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 18. 18. 24. 18. 15. 12. 11.    .   .   .   .   . 67.   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 22. 16. 16. 18. 10. 10. 10.    .   .   .   .   . 77.   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 17. 15. 15. 15. 10. 8 . 8 .    .   .   .   .   .   . 85.   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 24. 16. 8 . 7 . 8 . 0 .12 .    .   .   .   .   .   . 85.   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 17. 9 . 8 . 7 . 8 . 6 .12 .    .   .   .   .   .   .   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n With the  -n   (number)  flag, you get the following result:\n Input:                          Output:\n   ELEVATION SURFACE               LEAST COST PATH\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 19. 20. 18. 19. 16. 15. 15.    .   .   .   .   .   .   .   .\n . .  ---  . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 20| 19| 17. 16. 17. 16. 16.    .   . 1 . 2 . 3 .   .   .   .\n . .  ---  . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 18. 18. 24. 18. 15. 12. 11.    .   .   .   .   . 4 .   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 22. 16. 16. 18. 10. 10. 10.    .   .   .   .   . 5 .   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 17. 15. 15. 15. 10. 8 . 8 .    .   .   .   .   .   . 6 .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 24. 16. 8 . 7 . 8 . 0 .12 .    .   .   .   .   .   . 7 .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n . 17. 9 . 8 . 7 . 8 . 6 .12 .    .   .   .   .   .   .   .   .\n . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .\n With the  -d   (direction)  flag, the direction raster is used \n for the input, rather than the elevation surface. The output is then created \n according to one of the  -can  flags.\n The directions are recorded as degrees CCW from East:\n        112.5     67.5         i.e. a cell with the value 135 \n 157.5  135   90  45   22.5    means the next cell is to the North-West \n        180   x   0            \n 202.5  225  270  315  337.5\n        247.5     292.5\n ", "notes": "\n If no direction input map is given,  r.drain  currently finds\n only the lowest point (the cell having the smallest category value) in\n the input file that can be reached through directly adjacent cells\n that are less than or equal in value to the cell reached immediately\n prior to it; therefore, it will not necessarily reach the lowest point\n in the input file. It currently finds  pits  in the data,\n rather than the lowest point in the entire input\n map. The  r.fill.dir ,\n  r.terraflow ,\n and  r.basins.fill  modules\n can be used to fill in subbasins prior to processing\n with  r.drain .\n  r.drain  will not give sane results at the region boundary. On outer rows\n and columns bordering the edge of the region, the flow direction is always directly out \n of the map. In this case, the user could try adjusting the region extents slightly with \n  g.region  to allow additional outlet paths for  r.drain .\n  EXAMPLES \n  Path to the lowest point \n In this example we compute drainage paths from two given points\n following decreasing elevation values to the lowest point.\n We are using the full North Carolina sample dataset.\n First we create the two points from a text file using\n  v.in.ascii  module\n (here the text file is CSV and we are using unix here-file syntax\n with EOF, in GUI just enter the values directly for the parameter input):\n v.in.ascii input=- output=start format=point separator=comma <<EOF\n 638667.15686275,220610.29411765\n 638610.78431373,220223.03921569\n EOF\n Now we compute the drainage path:\n r.drain input=elev_lid792_1m output=drain_path drain=drain start_points=start\n Before we visualize the result, we set a color table for the elevation\n we are using and we create a shaded relief map:\n r.colors map=elev_lid792_1m color=elevation\n r.relief input=elev_lid792_1m output=relief\n Finally we visualize all the input and output data:\n d.shade shade=relief color=elev_lid792_1m\n d.vect map=drain_path color=0:0:61 width=4 legend_label=\"drainage paths\"\n d.vect map=start color=none fill_color=224:0:0 icon=basic/circle size=15 legend_label=origins\n d.legend.vect -b\n  \n  Figure: Drainage paths from two points flowing into the points with\n lowest values \n  Path following directions \n To continue flow even after it hits a depression, we need to supply a\n direction raster map which will tell the  r.drain  module how to\n continue from the depression. To get these directions, we use the\n  r.watershed  module:\n r.watershed elevation=elev_lid792_1m accumulation=accum drainage=drain_dir\n The directions are categorical and we convert them to degrees using\n raster algebra:\n r.mapcalc \"drain_deg = if(drain_dir != 0, 45. * abs(drain_dir), null())\"\n Together with directions, we need to provide the  r.drain  module\n with cost values. We don't have any cost to assign to specific cells,\n so we create a constant surface:\n r.mapcalc \"const1 = 1\"\n Now we are ready to compute the drainage paths.\n We are using the two points from the previous example.\n r.drain -d input=const1 direction=drain_deg output=drain_path_2 drain=drain_2 start_points=start\n We visualize the result in the same way as in the previous example.\n  Figure: Drainage paths from two points where directions from\n r.watershed were used \n  KNOWN ISSUES \n  Sometimes, when the differences among integer cell category values in the\n  r.cost  cumulative cost surface output are \n small, this cumulative cost output cannot accurately be used as input to\n  r.drain  ( r.drain  will output bad results).\n This problem can be circumvented by making the differences\n between cell category values in the cumulative cost output bigger. It\n is recommended that if the output from  r.cost  is to be used\n as input to  r.drain , the user multiply the  r.cost \n input cost surface map by the value of the map's cell resolution,\n before running  r.cost . This can be done using\n  r.mapcalc . The map resolution can be\n found using  g.region .\n This problem doesn't arise with floating point maps.\n ", "see_also": ["g.region", "r.cost", "r.fill.dir", "r.basins.fill", "r.watershed", "r.terraflow", "r.mapcalc", "r.walk"], "authors": ["Completely rewritten by Roger S. Miller, 2001"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.drain"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.distance.html", "name": "r.distance", "definition": "- Locates the closest points between objects in two raster maps.", "keywords": ["raster", "distance"], "synopsis": "r.distance [-lon] map=name1,name2[,name1,name2,...]  [separator=character]   [sort=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "Include category labels in the output Report zero distance if rasters are overlapping Report null objects as * Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Report zero distance if rasters are overlapping Report null objects as * Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Report null objects as * Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of two input raster maps for computing inter-class distances", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": ":", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "sort", "flag": "sort", "dataType": "String", "optional": true, "explanation": "Sort output by distance", "defaultValue": null, "alternatives": ["asc", "desc"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.distance  locates the closest points between \"objects\" in two raster maps.  An\n \"object\" is defined as all the grid cells that have the same category\n number, and closest means having the shortest \"straight-line\" distance.\n The cell centers are considered for the distance calculation (two\n adjacent grid cells have the distance between their cell centers).\n The output is an ascii list, one line per pair of objects, in the following form:\n cat1:cat2:distance:east1:north1:east2:north2\n  cat1 \n  Category number from map1\n  cat2 \n  Category number from map2\n  distance \n  The distance in meters between \"cat1\" and \"cat2\"\n  east1,north1 \n  The coordinates of the grid cell \"cat1\" which is closest to \"cat2\"\n  east2,north2 \n  The coordinates of the grid cell \"cat2\" which is closest to \"cat1\"\n  Flags \n  -l  \n The -l flag outputs the category labels of the matched raster objects at the \n beginning of the line, if they exist.\n  -o \n The -o flag reports zero distance if the input rasters are overlapping.\n ", "notes": "\n The output format lends itself to filtering.  For example, to \"see\" lines\n connecting each of the category pairs in two maps, filter the output using\n awk and then into  d.graph :\n r.distance map=map1,map2 | \n    awk -F: '{print \"move\",$4,$5,\"\\n draw\",$6,$7}' | d.graph -m\n To create a vector map of all the \"map1\" coordinates, filter the output into\n awk and then into  v.in.ascii :\n r.distance map=map1,map2 | \n    awk -F: '{print $4,$5}' | v.in.ascii format=point output=name separator=space\n ", "see_also": ["r.buffer", "r.cost", "r.drain", "r.grow", "r.grow.distance", "v.distance"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.distance"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.describe.html", "name": "r.describe", "definition": "- Prints terse list of category values found in a raster map layer.", "keywords": ["raster", "metadata"], "synopsis": "r.describe [-1rndi] map=name  [null_value=string]   [nsteps=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "1", "flag": "-1", "explanation": "Print the output one value per line Only print the range of the data Suppress reporting of any NULLs Use the current region Read floating-point map as integer Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Only print the range of the data Suppress reporting of any NULLs Use the current region Read floating-point map as integer Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Suppress reporting of any NULLs Use the current region Read floating-point map as integer Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Use the current region Read floating-point map as integer Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Read floating-point map as integer Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nsteps", "flag": "nsteps", "dataType": "String", "optional": true, "explanation": "Number of quantization steps", "defaultValue": "255", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.describe  prints a terse listing of category values found in\n a user-specified raster map layer.\n  r.describe  ignores the current geographic region and mask, and\n reads the full extent of the input raster map.  This functionality is useful if the\n user intends to  reclassify  or  rescale  the data, \n since these functions ( r.reclass  and\n  r.rescale ) \n also ignore the current  geographic region \n and  mask .\n  The  nv  parameter sets the string to be used to represent  NULL  \n values in the module output; the default is '*'.\n  The  nsteps  parameter sets the number of quantisation steps to divide into \n the input raster map.\n ", "notes": "\n  FLAGS \n If the user selects the  -r  flag, a range of category values found in \n the raster map layer will be printed. The range is divided into three groups: \n negative, positive, and zero. If negative values occur, the minimum and maximum \n negative values will be printed. If positive values occur, the minimum and maximum \n positive values will be printed. If zero occurs, this will be indicated. The range \n report will generally run faster than the full list (the default output).\n The  -d  flag can be used to force  r.describe  to respect the current region\n extents when repoting raster map categories. The default behavior is to read the full \n extent of the input raster map.\n  If the  -1  flag is specified, the output appears with one category value/range per line.\n  The  -n  flag suppresses the reporting of  NULL  values.\n  EXAMPLES \n The following examples are from the Spearfish60 sample Location:\n # Print the full list of raster map categories:\n r.describe landcover.30m \n * 11 21-23 31 32 41-43 51 71 81-83 85 91 92\n # Print the raster range only:\n r.describe -r landcover.30m\n 11 thru 92\n *\n # Print raster map category range, suppressing nulls:\n r.describe -n landcover.30m \n 11 21-23 31 32 41-43 51 71 81-83 85 91 92\n # Print raster map categories, one category per line:\n r.describe -1 geology \n *\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n ", "see_also": ["g.region", "r.mask", "r.reclass", "r.report", "r.rescale", "r.stats", "r.univar"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.describe"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.cross.html", "name": "r.cross", "definition": "- Creates a cross product of the category values from multiple raster map layers.", "keywords": ["raster", "statistics"], "synopsis": "r.cross [-z] input=string[,string,...] output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Non-NULL data only Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Names of 2-30 input raster maps", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.cross  creates an  output  raster map layer representing\n all unique combinations of category values in the raster input layers\n ( input= name,name,name , ...).  At least two, but not more than\n ten,  input  map layers must be specified.  The user must also\n specify a name to be assigned to the  output  raster map layer\n created by  r.cross .\n  OPTIONS \n The program will be run non-interactively if the user specifies \n the names of between 2-10 raster map layers be used as  input ,\n and the name of a raster map layer to hold program  output .\n With the  -z  flag NULL values are not crossed. \n This means that if a NULL value occurs in any input data layer, \n this combination is ignored, \n even if other data layers contain non-NULL data. \n In the example given below, use of the  -z  option \n would cause 3 categories to be generated instead of 5. \n If the  -z  flag is not specified, then map layer combinations \n in which some values are NULL will be assigned \n a unique category value in the resulting output map. \n Category values in the new  output  map layer will be the\n cross-product of the category values from these existing  input  map\n layers.\n  EXAMPLE \n For example, suppose that, using two raster map layers, \n the following combinations occur: \n           map1   map2\n           ___________\n           NULL    1\n           NULL    2\n            1      1\n            1      2\n            2      4\n  r.cross  would produce a new raster map layer with 5 categories: \n           map1   map2   output\n           ____________________\n           NULL    1       0\n           NULL    2       1\n            1      1       2\n            1      2       3\n            2      4       4\n Note: The actual category value assigned to a particular combination \n in the  result  map layer is \n dependent on the order in which the combinations occur in the input map \n layer data and can be considered essentially random. \n The example given here is illustrative only. \n  SUPPORT FILES \n The category file created for the  output  raster map \n layer describes the \n combinations of input map layer category values which generated \n each category. \n In the above example, the category labels would be: \n           category   category\n           value      label\n           ______________________________\n              0       layer1(0) layer2(1)\n              1       layer1(0) layer2(2)\n              2       layer1(1) layer2(1)\n              3       layer1(1) layer2(2)\n              4       layer1(2) layer2(4)\n A random color table is also generated for the  output  map layer. \n ", "notes": "", "see_also": ["r.covar", "r.stats"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.cross"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.covar.html", "name": "r.covar", "definition": "- Outputs a covariance/correlation matrix for user-specified raster map layer(s).", "keywords": ["raster", "statistics"], "synopsis": "r.covar [-r] map=name[,name,...]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Print correlation matrix Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.covar  outputs a covariance/correlation matrix for user-specified\n raster map layer(s).  The output can be printed, or saved by redirecting\n output into a file.\n The output is an N x N symmetric covariance (correlation) matrix, \n where N is the number of raster map layers specified on the command line. \n ", "notes": "\n This module can be used as the first step of a principle components \n transformation. \n The covariance matrix would be input into a system which determines \n eigen values and eigen vectors. An NxN covariance matrix would result in \n N real eigen values and N eigen vectors (each composed of N real numbers). \n The module  m.eigensystem \n in  GRASS GIS Addons \n can be compiled and used to generate the eigen values and vectors.\n  EXAMPLE \n For example, \n g.region raster=layer.1 -p\n r.covar -r map=layer.1,layer.2,layer.3\n would produce a 3x3 matrix (values are example only): \n      1.000000  0.914922  0.889581\n      0.914922  1.000000  0.939452\n      0.889581  0.939452  1.000000\n In the above example, the eigen values and corresponding eigen vectors \n for the covariance matrix are: \n component   eigen value               eigen vector\n     1       1159.745202   <0.691002  0.720528  0.480511>\n     2          5.970541   <0.711939 -0.635820 -0.070394>\n     3        146.503197   <0.226584  0.347470 -0.846873>\n The component corresponding to each vector can be produced using \n  r.mapcalc \n as follows: \n r.mapcalc \"pc.1 = 0.691002*layer.1 + 0.720528*layer.2 + 0.480511*layer.3\" \n r.mapcalc \"pc.2 = 0.711939*layer.1 - 0.635820*layer.2 - 0.070394*layer.3\" \n r.mapcalc \"pc.3 = 0.226584*layer.1 + 0.347470*layer.2 - 0.846873*layer.3\"\n Note that based on the relative sizes of the eigen values, \n  pc.1 \n will contain about 88% of the variance in the data set, \n  pc.2 \n will contain about 1% of the variance in the data set, and \n  pc.3 \n will contain about 11% of the variance in the data set. \n Also, note that the range of values produced in \n  pc.1 ,  pc.2 , and  pc.3  will \n not (in general) be the same as those for \n  layer.1 ,  layer.2 , and  layer.3 .\n It may be necessary to rescale \n  pc.1 ,  pc.2  and  pc.3  to \n the desired range (e.g. 0-255). \n This can be done with  r.rescale .\n ", "see_also": ["i.pca", "r.mapcalc", "r.rescale"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.covar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.cost.html", "name": "r.cost", "definition": "- Creates a raster map showing the cumulative cost of moving between different geographic locations on an input raster map whose cell category values represent cost.", "keywords": ["raster", "cost surface", "cumulative costs", "cost allocation"], "synopsis": "r.cost [-knrib] input=name output=name  [nearest=name]   [outdir=name]   [start_points=name]   [stop_points=name]   [start_raster=name]   [start_coordinates=east,north[,east,north,...]]   [stop_coordinates=east,north[,east,north,...]]   [max_cost=value]   [null_cost=value]   [memory=value]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "k", "flag": "-k", "explanation": "Use the 'Knight's move'; slower, but more accurate Keep null values in output raster map Start with values in raster map Print info about disk space and memory requirements and exit Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Keep null values in output raster map Start with values in raster map Print info about disk space and memory requirements and exit Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Start with values in raster map Print info about disk space and memory requirements and exit Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Print info about disk space and memory requirements and exit Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map containing grid cell cost information", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "nearest", "flag": "nearest", "dataType": "String", "optional": true, "explanation": "Name for output raster map with nearest start point", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "outdir", "flag": "outdir", "dataType": "String", "optional": true, "explanation": "Name for output raster map to contain movement directions", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "start_points", "flag": "start_points", "dataType": "String", "optional": true, "explanation": "Name of starting vector points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stop_points", "flag": "stop_points", "dataType": "String", "optional": true, "explanation": "Name of stopping vector points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_raster", "flag": "start_raster", "dataType": "String", "optional": true, "explanation": "Name of starting raster points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_coordinates", "flag": "start_coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates of starting point(s) (E,N)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stop_coordinates", "flag": "stop_coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates of stopping point(s) (E,N)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max_cost", "flag": "max_cost", "dataType": "String", "optional": true, "explanation": "Maximum cumulative cost", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_cost", "flag": "null_cost", "dataType": "String", "optional": true, "explanation": "Cost assigned to null cells. By default, null cells are excluded", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used in MB", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.cost  determines the cumulative cost of moving to each\n cell on a  cost surface  (the  input  raster map) from\n other user-specified cell(s) whose locations are specified by their\n geographic coordinate(s). Each cell in the original cost surface map\n will contain a category value which represents the cost of traversing\n that cell.  r.cost  will produce 1) an  output  raster map in\n which each cell contains the lowest total cost of traversing the\n space between each cell and the user-specified points (diagonal\n costs are multiplied by a factor that depends on the dimensions of\n the cell) and 2) a second raster map layer showing the movement \n direction to the next cell on the path back to the start point (see \n  Movement Direction ). This module uses the current \n geographic region settings. The  output  map will be of the same \n data format as the  input  map, integer or floating point.\n  OPTIONS \n The  input   name  is the name of a raster map whose category values\n represent the surface cost. The  output   name  is the name of the\n resultant raster map of cumulative cost. The  outdir   name  is the \n name of the resultant raster map of movement directions (see  Movement Direction ).\n  r.cost  can be run with three different methods of identifying the\n starting point(s). One or more points (geographic coordinate pairs) can be\n provided as specified  start_coordinates  on the command line, from a vector\n points file, or from a raster map.\n All non-NULL cells are considered to be starting points.\n Each  x,y   start_coordinates  pair gives the geographic location of a\n point from which the transportation cost should be figured. As many points as\n desired can be entered by the user. These starting points can also be read\n from a vector points file through the  start_points  option or from a\n raster map through the  start_raster  option.\n  r.cost  will stop cumulating costs when either  max_cost  is reached,\n or one of the stop points given with  stop_coordinates  is reached.\n Alternatively, the stop points can be read from a vector points file with the\n  stop_points  option. During execution, once the cumulative cost to all \n stopping points has been determined, processing stops. \n Both sites read from a vector points file and those given on the command line\n will be processed.\n The null cells in the  input  map can be assigned a (positive floating\n point) cost with the  null_cost  option. \n When input map null cells are given a cost with the  null_cost \n option, the corresponding cells in the output map are no longer null\n cells. By using the  -n  flag, the null cells of the input map are\n retained as null cells in the output map.\n As  r.cost  can run for a very long time, it can be useful to \n use the  --v  verbose flag to track progress.\n The Knight's move ( -k  flag) may be used to improve the accuracy of\n the output. In the diagram below, the center location ( O ) represents a\n grid cell from which cumulative distances are calculated. Those\n neighbors marked with an  X  are always considered for cumulative cost\n updates. With the  -k  option, the neighbors marked with a  K  are\n also considered. \n  . . . . . . . . . . . . . . .\n  .   .   . K .   . K .   .   .\n  . . . . . . . . . . . . . . .\n  .   . K . X . X . X . K .   .\n  . . . . . . . . . . . . . . .\n  .   .   . X . O . X .   .   .\n  . . . . . . . . . . . . . . .\n  .   . K . X . X . X . K .   .\n  . . . . . . . . . . . . . . .\n  .   .   . K .   . K .   .   .\n  . . . . . . . . . . . . . . .\n Knight's move example:\n  \n  Flat cost surface without (left pane) and with the knight's move (right pane).\n The default is to grow the cost outwards in 8 directions.\n Using the knight's move grows it outwards in 16 directions. \n  \n If the  nearest  output parameter is specified, the module will calculate \n for each cell its nearest starting point based on the minimized accumulative cost\n while moving over the cost map.\n  NULL CELLS \n By default null cells in the input raster map are excluded from\n the algorithm, and thus retained in the output map.\n If one wants  r.cost  to transparently cross any region of null cells,\n the  null_cost = 0.0  option should be used. Then null cells just\n propagate the adjacent costs. These cells can be retained as null cells in the\n output map by using the  -n  flag.\n ", "notes": "\n Paths from any point to the nearest starting point of  r.cost  \n can be extracted with  r.path  by \n using the direction output map of  r.cost .\n  Algorithm notes \n The fundamental approach to calculating minimum travel cost is as\n follows:\n The user generates a raster map indicating the cost of\n traversing each cell in the north-south and east-west directions.\n This map, along with a set of starting points are submitted to\n  r.cost . The starting points are put into a list cells from which\n costs to the adjacent cells are to be calculated. The cell on the\n list with the lowest cumulative cost is selected for computing costs to\n the neighboring cells. Costs are computed and those cells are put\n on the list and the originating cell is finalized. This process\n of selecting the lowest cumulative cost cell, computing costs to the\n neighbors, putting the neighbors on the list and removing the\n originating cell from the list continues until the list is empty.\n The most time consuming aspect of this algorithm is the management of\n the list of cells for which cumulative costs have been at least\n initially computed.  r.cost  uses a binary tree with an linked list\n at each node in the tree for efficiently holding cells with identical\n cumulative costs.\n  r.cost , like most all GRASS raster programs, is also made to \n be run on maps larger that can fit in available computer memory. As the \n algorithm works through the dynamic list of cells it can move almost \n randomly around the entire area.  r.cost  divides the entire \n area into a number of pieces and swaps these pieces in and out of \n memory (to and from disk) as needed. This provides a virtual memory \n approach optimally designed for 2-D raster maps. The amount of memory \n to be used by  r.cost  can be controlled with the  memory  \n option, default is 300 MB. For systems with less memory this value will \n have to be set to a lower value.\n  EXAMPLES \n  Consider the following example: \n        Input:\n          COST SURFACE\n        . . . . . . . . . . . . . . .\n        . 2 . 2 . 1 . 1 . 5 . 5 . 5 .\n        . . . . . . . . . . . . . . .\n        . 2 . 2 . 8 . 8 . 5 . 2 . 1 .\n        . . . . . . . . . . . . . . .\n        . 7 . 1 . 1 . 8 . 2 . 2 . 2 .\n        . . . . . . . . . . . . . . .\n        . 8 . 7 . 8 . 8 . 8 . 8 . 5 .\n        . . . . . . . . . . _____ . .\n        . 8 . 8 . 1 . 1 . 5 |  3  | 9 .\n        . . . . . . . . . . |___| . .\n        . 8 . 1 . 1 . 2 . 5 . 3 . 9 .\n        . . . . . . . . . . . . . . .\n Output (using -k):                Output (not using -k):\n    CUMULATIVE COST SURFACE           CUMULATIVE COST SURFACE\n  . . . . . . . . . . . . . . .     . . . .  * * * * *  . . . . . .\n  . 21. 21. 20. 19. 17. 15. 14.     . 22. 21 * 21* 20*  17. 15. 14.\n  . . . . . . . . . . . . . . .     . . . .  * * * * *  . . . . . .\n  . 20. 19. 22. 19. 15. 12. 11.     . 20. 19. 22 * 20*  15. 12. 11.\n  . . . . . . . . . . . . . . .     . . . . . .  * * * * *  . . . .\n  . 22. 18. 17. 17. 12. 11.  9.     . 22. 18. 17 * 18* 13*  11.  9.\n  . . . . . . . . . . . . . . .     . . . . . .  * * * * *  . . . .\n  . 21. 14. 13. 12.  8.  6.  6.     . 21. 14. 13. 12.  8.  6.  6.\n  . . . . . . . . . .  _____. .     . . . . . . . . . . . . . . .\n  . 16. 13.  8.  7.  4 |  0  | 6.     . 16. 13.  8. 7 .  4.  0.  6.\n  . . . . . . . . . .  |___|. .     . . . . . . . . . . . . . . .\n  . 14.  9.  8.  9.  6.  3.  8.     . 14.  9.  8. 9 .  6.  3.  8.\n  . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . .\n The user-provided starting location in the above example is the boxed  3 \n in the above input map. The costs in the output map represent the total\n cost of moving from each box (\"cell\") to one or more (here,\n only one) starting location(s). Cells surrounded by asterisks are\n those that are different between operations using and not using the\n Knight's move ( -k ) option.\n  Output analysis \n The output map can be viewed, for example, as an elevation model in which\n the starting location(s) is/are the lowest point(s). Outputs from  r.cost \n can be used as inputs to  r.path  , \n in order to trace the least-cost path given by this \n model between any given cell and the  r.cost  starting location(s). The \n two programs, when used together, generate least-cost paths or corridors between any \n two map locations (cells).\n  Shortest distance surfaces \n The  r.cost  module allows for computing the shortest distance \n of each pixel from raster lines, such as determining the shortest distances\n of households to the nearby road. For this cost surfaces with cost value 1 are\n used. The calculation is done with  r.cost  as follows\n (example for Spearfish region):\n   g.region raster=roads -p\n   r.mapcalc \"area.one = 1\"\n   r.cost -k input=area.one output=distance start_raster=roads\n   d.rast distance\n   d.rast.num distance\n   #transform to metric distance from cell distance using the raster resolution:\n   r.mapcalc \"dist_meters = distance * (ewres()+nsres())/2.\"\n   d.rast dist_meters\n  Movement Direction \n The movement direction surface is created to record the sequence of\n movements that created the cost accumulation surface. This movement \n direction surface can be used by  r.path  \n to recover a path from an end point back to the start point. \n The direction of each cell points towards the next cell. \n The directions are recorded as degrees CCW from East:\n        112.5      67.5         i.e. a cell with the value 135 \n 157.5  135   90   45   22.5    means the next cell is to the north-west\n        180   x   360           \n 202.5  225  270  315  337.5\n        247.5     292.5\n  Cost allocation \n Example: calculation of the cost allocation map \"costalloc\" and the cumulative\n cost map \"costsurf\" for given starting points (map \"sources\") and given\n cost raster map \"costs\":\n r.cost input=costs start_raster=sources output=costsurf nearest=costalloc\n  Find the minimum cost path \n Once  r.cost  computes the cumulative cost map and an associated \n movement direction map,  r.path \n can be used to find the minimum cost path.\n ", "see_also": ["r.walk", "r.path", "r.in.ascii", "r.mapcalc", "r.out.ascii"], "authors": ["Antony Awaida, Intelligent Engineering Systems Laboratory, M.I.T."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.cost"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.contour.html", "name": "r.contour", "definition": "- Produces a vector map of specified contours from a raster map.", "keywords": ["raster", "surface", "contours", "vector"], "synopsis": "r.contour [-t] input=name output=name  [step=float]   [levels=float[,float,...]]   [minlevel=float]   [maxlevel=float]   [cut=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "step", "flag": "step", "dataType": "String", "optional": true, "explanation": "Increment between contour levels", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "levels", "flag": "levels", "dataType": "String", "optional": true, "explanation": "List of contour levels", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "minlevel", "flag": "minlevel", "dataType": "String", "optional": true, "explanation": "Minimum contour level", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxlevel", "flag": "maxlevel", "dataType": "String", "optional": true, "explanation": "Maximum contour level", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cut", "flag": "cut", "dataType": "String", "optional": true, "explanation": "Minimum number of points for a contour line (0 -> no limit)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.contour  produces a vector map of specified contours from input raster map.\n Contours can be produced using a comma-separated list of values\n in  levels , or at some regular increment using the  step \n parameter, using  minlevel  and  maxlevel  as minimum and\n maximum contour values, respectively. If no  minlevel \n or  maxlevel  is specified, the minimum and maximum cell values\n in the  input  raster map will be used.\n ", "notes": "\n  r.contour  will either step through incremental contours or produce\n contours from a list of levels, not both. If both a list of levels and\n a step are specified, the list will be produced and the step will be ignored.\n  Zero is treated as a valid data value by  r.contour .\n  If a contour level exactly matches a category value in the raster map,\n the contour line may backtrack on itself, causing illegal arcs to be produced\n in the output vector map.\n  The optional  cut  parameter allows the user to specify a minimum number of\n raster cells eligilble to be included in a contour line written to the  output  \n vector map. It acts like a filter, omitting spurs, single points, etc., making the output more generalized.\n ", "see_also": [], "authors": ["Terry Baker, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.contour"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.compress.html", "name": "r.compress", "definition": "- Compresses and decompresses raster maps.", "keywords": ["raster", "map management", "compression"], "synopsis": "r.compress [-upg] map=name[,name,...]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "u", "flag": "-u", "explanation": "Uncompress the map Print compression information and data type of input map(s) Print compression information in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print compression information and data type of input map(s) Print compression information in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print compression information in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of existing raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.compress  can be used to compress or decompress raster maps. \n Additionally, it prints information about the compression method and \n data type of the input raster map(s).\n All raster maps (those imported for the first time and those newly \n generated) are compressed by default using the ZLIB compression \n method (see below). Related no data files (i.e.: NULL files), if \n present, are compressed by default unless a specific environment \n variable is set to explicitly disable NULL file compression \n ( GRASS_COMPRESS_NULLS , see below).\n During compression or re-compression,  r.compress  compresses \n raster maps using the method specified by means of the environment \n variable  GRASS_COMPRESSOR . The default compression method is  \n ZLIB's \"deflate\" algorithm (LZ77-based). Raster maps that contain very \n little information (such as boundary, geology, soils and land use maps) \n can be greatly reduced in size. Some raster maps are shrunk to roughly \n 1% of their original sizes. \n All newly generated raster maps are automatically stored as compressed\n data with varying methods depending on the raster format (i.e.,\n CELL: integer; FCELL: single precision; DCELL: double precision; see\n below). All GRASS GIS modules are able to read both compressed and\n uncompressed raster maps.\n Raster maps that are already compressed might be compressed again, \n either by setting a different method with  GRASS_COMPRESSOR  \n (supported methods: RLE, ZLIB, LZ4, BZIP2, ZSTD) or, for the case of \n ZLIB compression, by changing the compression level with the \n environment variable  GRASS_ZLIB_LEVEL .\n Compressed raster maps may be decompressed using  r.compress  \n with the  -u  flag. If a raster map was already decompressed and \n the  -u  flag is set, the module simply informs the user that the \n map is already decompressed and exits.\n Information about the compression method and data type of the input \n raster map(s) can be printed in shell style with the  -g  flag. In \n this case, the module prints to  stdout  one line per input map \n with the fields \"input map name\", \"data type\", \n \"name of data compression method\", \"NULL file \n compression\" separated by the pipe character. NULL file \n compression is indicated with \"YES\" or \"NO\". \n  TERMINOLOGY \n   INTEGER map (CELL data type): a raster map of INTEGER type (whole\n   numbers only) \n   FLOAT map (FCELL data type): a raster map of FLOAT type (4 bytes,\n   7-9 digits precision) \n   DOUBLE map (DCELL data type): a raster map of DOUBLE type (8 bytes,\n   15-17 digits precision) \n   NULL: represents \"no data\" in raster maps; to be distinguished from\n   0 (zero) data value \n  OVERVIEW OF AVAILABLE COMPRESSION ALGORITHMS \n The following compression methods are available (set by\n  export GRASS_COMPRESSOR= method ):\n  NONE  (uncompressed) \n  RLE   (generic Run-Length Encoding of single bytes; deprecated) \n  ZLIB  (DEFLATE, good speed and compression -  default compression )\n  with zlib compression levels ( export GRASS_ZLIB_LEVEL=X ): -1..9\n    (-1 is default which corresponds to ZLIB level 6) \n  note:  export GRASS_ZLIB_LEVEL=0  is equal to copying the data\n     as-is from source to destination \n  LZ4   (fastest, low compression) \n  BZIP2  (slowest, high compression) \n  ZSTD  (compared to ZLIB, faster and higher compression, much faster decompression) \n Important: the NULL file compression can be turned off with \n  export GRASS_COMPRESS_NULLS=0 . Raster maps with NULL file \n compression can only be opened with GRASS GIS 7.2.0 or later. NULL file \n compression for a particular raster map can be managed with  r.null -z .\n The NULL file compression is using the LZ4 method as being the best compromise\n between speed and compression rate.\n  COMPRESSION ALGORITHM DETAILS \n All GRASS GIS raster map types are by default ZLIB compressed, i.e. using\n ZLIB's deflate algorithm. Through the environment variable\n  GRASS_COMPRESSOR  the compression method can be set to RLE, ZLIB,\n LZ4, BZIP2, or ZSTD.\n Integer (CELL type) raster maps can be compressed with RLE if\n the environment variable  GRASS_COMPRESSOR  exists and is set to \n RLE. However, this is not recommended.\n Floating point (FCELL, DCELL) raster maps never use RLE compression;\n they are either compressed with ZLIB, LZ4, BZIP2, ZSTD or are uncompressed.\n  RLE \n  DEPRECATED  Run-Length Encoding, poor compression ratio but \n fast. It is kept for backwards compatibility to read raster maps \n created with GRASS 6. It is only used for raster maps of type CELL.\n FCELL and DCELL maps are never and have never been compressed with RLE.\n  ZLIB \n  ZLIB's deflate is the default compression method for all raster \n maps. GRASS GIS 7 uses by default 1 as ZLIB compression level which is the \n best compromise between speed and compression ratio, also when \n compared to other available compression methods. Valid levels are in \n the range [1, 9] and can be set with the environment variable \n  GRASS_ZLIB_LEVEL . \n  LZ4 \n  LZ4 is a very fast compression method, about as fast as no \n compression. Decompression is also very fast. The compression ratio is \n generally higher than for RLE but worse than for ZLIB. LZ4 is \n recommended if disk space is not a limiting factor. \n  BZIP2 \n  BZIP2 can provide compression ratios much higher than the other \n methods, but only for large raster maps (> 10000 columns). For large \n raster maps, disk space consumption can be reduced by 30 - 50% when \n using BZIP2 instead of ZLIB's deflate. BZIP2 is the slowest compression \n and decompression method. However, if reading from / writing to a \n storage device is the limiting factor, BZIP2 compression can speed up \n raster map processing. Be aware that for smaller raster maps, BZIP2 \n compression ratio can be worse than other compression methods.  \n  ZSTD \n  ZSTD (Zstandard) provides compression ratios higher than ZLIB but \n lower than BZIP2 (for large data). ZSTD compresses up to 4x faster than \n ZLIB, and usually decompresses 6x faster than ZLIB. ZSTD is the \n recommended default compression method.  \n ", "notes": "\n  Compression method number scheme \n The used compression method is encoded with numbers. In the internal\n  cellhd  file, the value for \"compressed\" is 1 for RLE, 2\n for ZLIB, 3 for LZ4, 4 for BZIP2, and 5 for ZSTD.\n Obviously, decompression is controlled by the raster map's compression,\n not by the environment variable.\n  Formats \n Conceptually, a raster data file consists of rows of cells, with each \n row containing the same number of cells. A cell consists of one or more \n bytes. For CELL maps, the number of bytes per cell depends on the \n category values stored in the cell. Category values in the range 0-255 \n require 1 byte per cell, while category values in the range 256-65535 \n require 2 bytes, and category values in the range above 65535 require 3 \n (or more) bytes per cell.\n FCELL maps always have 4 bytes per cell and DCELL maps always have 8 \n bytes per cell.\n Since GRASS GIS 7.0.0, the default compression method for \n Integer (CELL) raster maps is ZLIB and no longer RLE.\n  ZLIB compression levels \n If the environment variable  GRASS_ZLIB_LEVEL  exists and\n its value can be parsed as an integer, it determines the compression\n level used when newly generated raster maps are compressed using ZLIB\n compression. This applies to all raster map types (CELL, FCELL, DCELL).\n If the variable does not exist, or the value cannot be parsed as an\n integer, ZLIB's compression level 1 will be used.\n  EXAMPLES \n Printing of current compression state:\n r.compress compressed_no -p\n   <compressed_no> (method 0: NONE). Data type: <CELL>\n Applying RLE compression to a copy of the uncompressed map (not recommended!):\n # compression of map using the deprecated RLE compression\n g.copy raster=compressed_no,compressed_RLE\n export GRASS_COMPRESSOR=RLE # RLE\n r.compress compressed_RLE \n r.compress compressed_RLE -p \n   <compressed_RLE> is compressed (method 1: RLE). Data type: <CELL>\n unset GRASS_INT_ZLIB\n Applying ZLIB compression to a copy of the uncompressed map:\n # compression of map using ZLIB compression\n g.copy raster=compressed_no,compressed_ZLIB\n export GRASS_COMPRESSOR=ZLIB # ZLIB\n r.compress compressed_ZLIB\n r.compress compressed_ZLIB -p\n   <compressed_ZLIB> is compressed (method 2: ZLIB). Data type: <CELL>\n unset GRASS_INT_ZLIB\n Applying BZIP2 compression to a copy of the ZLIB-compressed map:\n # compression of map using BZIP2 compression\n g.copy raster=compressed_ZLIB,compressed_BZIP2\n export GRASS_COMPRESSOR=BZIP2 # BZIP2\n r.compress compressed_BZIP2\n r.compress compressed_BZIP2 -p\n   <compressed_BZIP2> is compressed (method 4: BZIP2). Data type: <CELL>\n unset GRASS_COMPRESSOR\n Applying ZSTD compression to a copy of the BZIP2-compressed map:\n # compression of map using ZSTD compression\n g.copy raster=compressed_BZIP2,compressed_ZSTD\n export GRASS_COMPRESSOR=ZSTD # ZSTD\n r.compress compressed_ZSTD\n r.compress compressed_ZSTD -p\n   <compressed_ZSTD> is compressed (method 5: ZSTD). Data type: <CELL>\n unset GRASS_COMPRESSOR\n ", "see_also": ["r.info", "r.null", "r.support"], "authors": ["James Westervelt and Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.compress"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.composite.html", "name": "r.composite", "definition": "- Combines red, green and blue raster maps into a single composite raster map.", "keywords": ["raster", "composite", "RGB"], "synopsis": "r.composite [-dc] red=name green=name blue=name  [levels=integer]   [level_red=integer]   [level_green=integer]   [level_blue=integer]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Dither Use closest color Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Use closest color Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <red>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <green>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <blue>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "levels", "flag": "levels", "dataType": "String", "optional": true, "explanation": "Number of levels to be used for each component", "defaultValue": "32", "alternatives": ["1-256"], "isInputFile": false, "isOutputFile": false}, {"parameter": "level_red", "flag": "level_red", "dataType": "String", "optional": true, "explanation": "Number of levels to be used for <red>", "defaultValue": null, "alternatives": ["1-256"], "isInputFile": false, "isOutputFile": false}, {"parameter": "level_green", "flag": "level_green", "dataType": "String", "optional": true, "explanation": "Number of levels to be used for <green>", "defaultValue": null, "alternatives": ["1-256"], "isInputFile": false, "isOutputFile": false}, {"parameter": "level_blue", "flag": "level_blue", "dataType": "String", "optional": true, "explanation": "Number of levels to be used for <blue>", "defaultValue": null, "alternatives": ["1-256"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n This program combines three raster maps to form a\n composite RGB map. For each input map layer, the corresponding\n component from the map's color table is used (e.g. for\n the red map, the red component is used, and so on). In\n general, the maps should use a grey-scale color table.\n ", "notes": "\n The default number of intensity levels for each component is 32,\n resulting in a total of 32768 possible colors (equivalent to 15 bits\n per pixel). If significantly more levels than this are used, not only\n will  r.composite  take longer to run, but displaying the\n resulting layer with  d.rast  will\n also be significantly slower.\n  Floyd-Steinberg dithering is optionally used with the  -d  flag.\n  EXAMPLES \n  RGB composite of three satellite bands \n Color composite of a LANDSAT scene (North Carolina sample dataset):\n g.region raster=lsat7_2002_10\n r.composite blue=lsat7_2002_10 green=lsat7_2002_20 red=lsat7_2002_30 \n              output=lsat7_2002_rgb\n  RGB composite with dithering \n Creating a composite RGB raster using 32 color levels per layer, with dithering:\n r.composite -d red=elevation.r green=elevation.g blue=elevation.b \n              output=elev.composite\n ", "see_also": ["d.rast", "d.rgb", "r.blend", "r.colors", "r.rgb"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.composite"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.colors.stddev.html", "name": "r.colors.stddev", "definition": "- Sets color rules based on stddev from a raster map's mean value.", "keywords": ["raster", "color table"], "synopsis": "r.colors.stddev [-bz] map=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "b", "flag": "-b", "explanation": "Color using standard deviation bands Force center at zero Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Force center at zero Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.colors.stddev  set raster map color rules based on standard\n deviations from a map's mean value, either as a continuous color gradient\n or in color bands per standard deviation (S.D.) from the mean.\n  With the color band option values less that 1 S.D. from the mean are\n colored green, within 1-2 S.D. are colored yellow, within 2-3 S.D. are\n colored red, and beyond 3 S.D. are colored black.\n  For a differences map there is an option to lock the center of the color\n table at zero. Values more than two S.D. below the mean will be colored blue;\n values below the mean but less than 2 S.D. away will transition to white,\n and above the mean the colors will simularly transition to full red at +2 S.D.\n  EXAMPLE \n North Carolina sample dataset location:\n g.region raster=elevation -p\n r.colors.stddev elevation\n ", "notes": "", "see_also": ["r.colors", "r.univar", "v.colors"], "authors": ["Hamish Bowman,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.colors.stddev"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.colors.out.html", "name": "r.colors.out", "definition": "- Exports the color table associated with a raster map.", "keywords": ["raster", "color table", "export"], "synopsis": "r.colors.out [-p] map=name  [rules=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Output values as percentages Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Path to output rules file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.colors.out  allows the user to export the color table for a\n raster map to a file which is suitable as input\n to  r.colors .\n  EXAMPLES \n r.colors.out map=el_D782_6m rules=rules.txt\n r.colors map=el_D783_6m rules=rules.txt\n ", "notes": "", "see_also": ["r.colors"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.colors.out"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.colors.html", "name": "r.colors", "definition": "- Creates/modifies the color table associated with a raster map.", "keywords": ["raster", "color table"], "synopsis": "r.colors [-rwlngae]  [map=name[,name,...]]   [file=name]   [color=style]   [raster=name]   [raster_3d=name]   [rules=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Remove existing color table Only write new color table if it does not already exist List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Only write new color table if it does not already exist List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": true, "explanation": "Name of raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Input file with one map name per line", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Name of color table", "defaultValue": null, "alternatives": ["aspect", "aspectcolr", "bcyr", "bgyr", "blues", "byg", "byr", "celsius", "corine", "curvature", "differences", "elevation", "etopo2", "evi", "fahrenheit", "gdd", "grass", "greens", "grey", "grey.eq", "grey.log", "grey1.0", "grey255", "gyr", "haxby", "kelvin", "ndvi", "ndwi", "oranges", "population", "population_dens", "precipitation", "precipitation_daily", "precipitation_monthly", "rainbow", "ramp", "random", "reds", "roygbiv", "rstcurv", "ryb", "ryg", "sepia", "slope", "soilmoisture", "srtm", "srtm_plus", "terrain", "viridis", "water", "wave"], "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Raster map from which to copy color table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster_3d", "flag": "raster_3d", "dataType": "String", "optional": true, "explanation": "3D raster map from which to copy color table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Path to rules file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.colors  allows the user to create and/or modify the color\n table for a raster map or several raster maps at once. \n The raster maps (specified on the command line\n by  map  or as  file  using an input file with one map name per line) \n must exist in the user's current mapset search path.\n  The  raster  option allows user to specify a raster map  name \n from which to copy the color map.\n  The  raster_3d  option allows user to specify a 3D raster\n map  name  from which to copy the color map.\n  The  -e  flag equalizes the original raster's color table. It can\n preclude the need for  grey.eq  rule, when used as\n  -e color= grey . Note however, that this will not yield\n a color table identical to  color=grey.eq ,\n because  grey.eq  scales the fraction by 256 to get a grey\n level, while  -e  uses it to interpolate the original color table. If the original color table is a 0-255 grey scale,  -e \n is effectively scaling the fraction by 255. Different algorithms are\n used.  -e  is designed to work with any color table, both the\n floating point and the integer raster maps.\n  The  -g  flag divides the raster's grey value range into 100\n logarithmically equal steps (where \"step\" is a rule with the\n same grey level for the start and end points). It can preclude the\n need for  grey.log  rule, when used as  -g\n color= grey . Note however, that this will not yield a\n color table identical to  color=grey.log . Different algorithms\n are used. Unlike  color= grey.log ,  -g  is designed\n to work with both floating point and integer rasters, without\n performance issues with large datasets, of any original color\n table. Logarithmic scaling doesn't work on negative values. In the\n case when the value range includes zero, there's no realistic\n solution.\n  The  -e  and  -g  flags are not mutually exclusive.\n  If the user specifies the  -w  flag, the current color table file for\n the input map will not be overwritten. This means that the color table is\n created only if the  map  does not already have a color table. If this\n option is not specified, the color table will be created if one does not\n exist, or modified if it does.\n  Color table types  aspect, grey, grey.eq  (histogram-equalized\n grey scale),  byg  (blue-yellow-green),  byr \n (blue-yellow-red),  gyr  (green-yellow-red),  rainbow, ramp,\n ryg  (red-yellow-green),  random , and  wave  are\n pre-defined color tables that  r.colors  knows how to create\n without any further input.\n In case several input raster maps are provided the range (min, max) of all maps \n will be used for color table creation. Hence the created color table will span from\n the smallest minimum to the largest maximum value of all input raster maps and\n will be applied to all input raster maps.\n  In general, tables which associate colors with percentages (aspect, bcyr, byg,\n byr, elevation, grey, gyr, rainbow, ramp, ryb, ryg and wave) can be applied to\n any data, while those which use absolute values (aspectcolr, curvature, etopo2,\n evi, ndvi, population, slope, srtm, and terrain) only make sense for data with\n certain ranges.\n One can get a rough idea of the applicability of a colour table by reading the\n corresponding rules file ( $GISBASE/etc/colors/<name> ).\n For example the  slope  rule is defined as:\n 0  255:255:255\n 2  255:255:0\n 5  0:255:0\n 10 0:255 255\n 15 0:0:255\n 30 255:0:255\n 50 255:0:0\n 90 0:0:0\n  This is designed for the slope map generated\n by  r.slope.aspect , where the\n value is a slope angle between 0 and 90 degrees.\n  Similarly, the  aspectcolr  rule:\n 0 white\n 1 yellow\n 90 green\n 180 cyan\n 270 red\n 360 yellow\n  is designed for the aspect maps produced\n by  r.slope.aspect , where the\n value is a heading between 0 and 360 degrees.\n  The  rules  color table type will cause  r.colors  to read\n color table specifications from standard input (stdin) and will build\n the color table accordingly.\n  Using color table type  rules , there are  two ways to\n build a color table:   by category values and by\n \"percent\" values.\n  To build a color table by category values' indices, the user should\n determine the range of category values in the raster map with which\n the color table will be used. Specific category values will then be\n associated with specific colors. Note that a color does not have to be\n assigned for every valid category value because  r.colors  will\n interpolate a color ramp to fill in where color specification rules\n have been left out. The format of such a specification is as follows:\n category_value color_name\n category_value color_name\n .. ..\n .. ..\n category_value color_name\n end\n  Each category value must be valid for the raster map, category values\n must be in ascending order and only use standard GRASS color names\n (aqua, black, blue, brown, cyan, gray, green, grey, indigo, magenta,\n orange, purple, red, violet, white, yellow).\n  Colors can also be specified by color numbers each in the range\n 0-255. The format of a category value color table specification using\n color numbers instead of color names is as follows:\n category_value red_number:green_number:blue_number\n category_value red_number:green_number:blue_number\n .. .. .. ..\n .. .. .. ..\n category_value red_number:green_number:blue_number\n end\n  Specifying a color table by \"percent\" values allows one to\n treat a color table as if it were numbered from 0 to 100. The format\n of a \"percent\" value color table specification is the same\n as for a category value color specification, except that the category\n values are replaced by \"percent\" values, each from 0-100, in\n ascending order. The format is as follows:\n percent_value% color_name\n percent_value% color_name\n .. ..\n .. ..\n percent_value% color_name\n end\n  Using \"percent\" value color table specification rules,\n colors can also be specified by color numbers each in the range\n 0-255. The format of a percent value color table specification using\n color numbers instead of color names is as follows:\n percent_value% red_number:green_number:blue_number\n percent_value% red_number:green_number:blue_number\n .. .. .. ..\n .. .. .. ..\n percent_value% red_number:green_number:blue_number\n end\n  Note that you can also mix these  two methods of color\n table specification; for example:\n 0 black\n 10% yellow\n 78 blue \n 100% 0:255:230\n end\n  To set the NULL (no data) color, use the \"nv\" (null values) parameter:\n 0 black\n 10% yellow\n nv white\n end\n  To set the color to used for undefined values (beyond the range of the\n color rules) use the \"default\" parameter:\n 0 red\n 1 blue\n default grey\n end\n ", "notes": "\n All color tables are stored in  $GISBASE/etc/colors/ . Further\n user-defined color tables can also be stored in this directory for\n access from the  color  parameter or in a user defined directory.\n See also  r.colors.out  for printing color tables easily to the\n terminal.\n The color table assigned to a raster map is stored in\n  $GISDBASE/location/mapset/colr/ .\n  EXAMPLES \n The below example shows how you can specify colors for a three\n category map, assigning red to category 1, green to category 2, and\n blue to category 3. Start by using a text editor to create the\n following rules specification file (save it with the\n name  rules.file ):\n 1 red\n 2 green\n 3 blue\n end\n  The color table can then by assigned to map  threecats  by the\n following GRASS commands (two ways are available):\n # read input from stdin\n cat rules.file | r.colors map=threecats rules=-\n # read directly from file\n r.colors map=threecats rules=rules.file\n  To create a natural looking lookup table (LUT) for true map layer\n  elevation , use the following rules specification file. It will\n assign light green shades to the lower elevations (first 20% of the\n LUT), and then darker greens (next 15%, and next 20%) and light browns\n (next 20%) for middle elevations, and darker browns (next 15%) for\n higher elevations, and finally yellow for the highest peaks (last 10%\n of LUT).\n 0% 0:230:0\n 20% 0:160:0\n 35% 50:130:0\n 55% 120:100:30\n 75% 120:130:40\n 90% 170:160:50\n 100% 255:255:100\n  To invert the current rules: \n r.colors map=current_raster -n rast=current_raster\n ", "see_also": ["d.colortable", "d.histogram", "d.legend", "r.colors.out", "r.colors.stddev", "r.support", "r.univar", "v.colors", "v.colors.out", "r3.colors", "r3.colors.out"], "authors": ["Michael Shapiro and David Johnson"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.colors"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.coin.html", "name": "r.coin", "definition": "- Tabulates the mutual occurrence (coincidence) of categories for two raster map layers.", "keywords": ["raster", "statistics"], "synopsis": "r.coin [-w] first=name second=name units=string  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "w", "flag": "-w", "explanation": "Wide report, 132 columns (default: 80) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "first", "flag": "first", "dataType": "String", "optional": false, "explanation": "Name of first input raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "second", "flag": "second", "dataType": "String", "optional": false, "explanation": "Name of second input raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": false, "explanation": "Unit of measure", "defaultValue": null, "alternatives": ["c", "p", "x", "y", "a", "h", "k", "m"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.coin  tabulates the mutual occurrence of two\n raster map layers' categories with respect to one another.\n This analysis program respects the current geographic\n region and mask settings.\n  r.coin \n tabulates the coincidence of category values among the two\n map layers and prepares the basic table from which the\n report is to be created.  This tabulation is followed by an\n indication of how long the coincidence table will be.  If\n the table is extremely long, the user may decide that\n viewing it is not so important after all, and may cancel\n the request at this point.  Assuming the user continues,\n  r.coin  then allows the user to choose one of eight\n units of measure in which the report results can be given.\n These units are:\n  c   cells \n  p   percent cover of region \n  x   percent of <map name> category (column) \n  y   percent of <map name> category (row) \n  a   acres \n  h   hectares \n  k   square kilometers \n  m   square miles \n Note that three of these options give results as percentage\n values:  \"p\" is based on the grand total number of cells;\n \"x\" is based on only column totals; and \"y\" is based on\n only row totals.  Only one unit of measure can be selected\n per report output.  Type in just one of the letters\n designating a unit of measure followed by a\n <RETURN>.  The report will be printed to the screen\n for review.  After reviewing the report on the screen, the\n user is given several options.  The report may be saved to\n a file and/or sent to a printer.  If printed, it may be\n printed with either 80 or 132 columns.  Finally, the user\n is given the option to rerun the coincidence tabulation\n using a different unit of measurement.\n ", "notes": "\n It is  not  a good idea to run  r.coin  on a\n map layer which has a monstrous number of categories (e.g.,\n unreclassed elevation).  Because  r.coin  reports\n information for each and every category, it is better to\n reclassify those categories (using  r.reclass )\n into a more manageable number prior to running\n  r.coin  on the reclassed raster map layer.\n  EXAMPLE \n Below is a sample of tabular output produced by\n  r.coin .  Here, map output is stated in units of\n square miles.  The report tabulates the coincidence of the\n Spearfish sample database's  owner  and\n  road  raster map layers' categories.  The\n  owner  categories in this case refer to whether the\n land is in private hands (category 1) or is owned by the\n U.S. Forest Service (category 2). The  roads  map\n layer categories refer to various types of roads (with the\n exception of category value \"0\", which indicates \"no data\";\n i.e., map locations at which no roads exist).\n  r.coin  does not report category labels. The user\n should run\n  r.report  or \n  r.category  \n to obtain this information. \n The body of the report is arranged in panels. The map layer\n with the most categories is arranged along the vertical\n axis of the table; the other, along the horizontal axis.\n Each panel has a maximum of 5 categories (9 if printed)\n across the top. In addition, the last two columns reflect a\n cross total of each column for each row.  All of the\n categories of the map layer arranged along the vertical\n axis are included in each panel.  There is a total at the\n bottom of each column representing the sum of all the rows\n in that column. A second total represents the sum of all\n the non-zero category rows. A cross total (Table Row Total)\n of all columns for each row appears in a separate panel.\n Note how the following information may be obtained from the sample report. \n In the Spearfish data base, in area not owned by the Forest Service, there\n are 50.63 square miles of land not used for roads. Roads make up 9.27 square\n miles of land in this area.\n  Of the total 102.70 square miles in Spearfish, 42.80 \n square miles is owned by the Forest Service. \n In total, there are 14.58 square miles of roads. \n  There are more category 2 roads outside Forest Service land \n (2.92 mi. sq.) \n than there are inside Forest land boundaries (0.72 mi. sq.). \n  Following is a sample report. \n +------------------------------------------------------------+\n |                    COINCIDENCE TABULATION REPORT           |\n |------------------------------------------------------------|\n |Location: spearfish    Mapset: PERMANENT   Date: Wed Jun 1  |\n |                                                            |\n | Layer 1: owner          -- Ownership                       |\n | Layer 2: roads          -- Roads                           |\n | Mask:    none                                              |\n |                                                            |\n | Units:   square miles                                      |\n |------------------------------------------------------------|\n | Window:                North: 4928000.00                   |\n |          West: 590000.00               East: 609000.00     |\n |                        South: 4914000.00                   |\n +------------------------------------------------------------+\n Panel #1 of 1\n +--------------------------------------------------------+\n |        | owner                 |    Panel Row Total    |\n |   cat# |         1 |         2 |   w cat 0 | w/o cat 0 |\n |--------------------------------------------------------|\n |r     0 |     50.63 |     37.49 |     88.12 |     88.12 |\n |o     1 |      1.53 |      0.68 |      2.21 |      2.21 |\n |a     2 |      2.92 |      0.72 |      3.64 |      3.64 |\n |d     3 |      3.97 |      2.57 |      6.54 |      6.54 |\n |s     4 |      0.65 |      1.36 |      2.00 |      2.00 |\n |      5 |      0.19 |      0.00 |      0.19 |      0.19 |\n |--------------------------------------------------------|\n |Total   |           |           |           |           |\n |with 0  |     59.90 |     42.80 |    102.70 |    102.70 |\n |--------------------------------------------------------|\n |w/o 0   |      9.27 |      5.32 |     14.58 |     14.58 |\n +--------------------------------------------------------+\n +--------------------------------+\n |        |    Table Row Total    |\n |   cat# |   w cat 0 | w/o cat 0 |\n |--------------------------------|\n |r     0 |     88.12 |     88.12 |\n |o     1 |      2.21 |      2.21 |\n |a     2 |      3.64 |      3.64 |\n |d     3 |      6.54 |      6.54 |\n |s     4 |      2.00 |      2.00 |\n |      5 |      0.19 |      0.19 |\n |--------------------------------|\n |Total   |           |           |\n |with 0  |    102.70 |    102.70 |\n |--------------------------------|\n |w/o 0   |     14.58 |     14.58 |\n +--------------------------------+\n  r.coin  calculates the coincidence of two raster\n map layers.  Although  r.coin  allows the user to\n rerun the report using different units, it is not possible\n to simply rerun the report with different map layers.  In\n order to choose new map layers, it is necessary to rerun\n  r.coin. \n ", "see_also": ["g.region", "r.category", "r.describe", "r.reclass", "r.report", "r.stats"], "authors": ["Michael O'Shea,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.coin"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.clump.html", "name": "r.clump", "definition": "- Recategorizes data in a raster map by grouping cells that form physically discrete areas into unique categories.", "keywords": ["raster", "statistics", "reclass", "clumps"], "synopsis": "r.clump [-dg] input=name[,name,...]  [output=name]   [title=string]   [threshold=float]   [minsize=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Clump also diagonal cells Clumps are also traced along diagonal neighboring cells Print only the number of clumps in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print only the number of clumps in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Threshold to identify similar cells", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "minsize", "flag": "minsize", "dataType": "String", "optional": true, "explanation": "Minimum clump size in cells", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.clump  finds all areas of contiguous cell category values \n (connected components) in the input raster map. NULL values in the \n input are ignored. It assigns a unique category value to each such area \n (\"clump\") in the resulting output raster map.\n Category distinctions in the input raster map are preserved.  This\n means that if distinct category values are adjacent, they will NOT be\n clumped together. The user can\n run  r.reclass  prior\n to  r.clump  to recategorize cells and reassign cell category\n values.\n  r.clump  can also perform \"fuzzy\" clumping where \n neighboring cells that are not identical but similar to each other are \n clumped together. Here, the spectral distance between two cells is \n scaled to the range [0, 1] and compared to the  threshold  \n value. Cells are clumped together if their spectral distance is \u2264 \n  threshold . The result is very sensitive to this \n  threshold  value, a recommended start value is 0.01, then \n increasing or decreasing this value according to the desired output. \n Once a suitable threshold has been determined, noise can be reduced by \n merging small clumps with the  minsize  option.\n  r.clump  can also use multiple raster maps of any kind (CELL, \n FCELL, DCELL) as input. In this case, the spectral distance between \n cells is used to determine the similarity of two cells. This means that \n input maps must be metric: the difference cell 1 - cell 2 must make \n sense. Categorical maps, e.g. land cover, can not be used in this case. \n Examples for valid inpat maps are satellite imagery, vegetation \n indices, elevation, climatic parameters etc.\n ", "notes": "\n By default, the resulting clumps are connected only by their four \n direct neighbors (left, right, top, bottom). The  -d  flag \n activates also diagonal clump tracing.\n  r.clump  works properly with raster map that contains only\n \"fat\" areas (more than a single cell in width). Linear\n elements (lines that are a single cell wide) may or may not be clumped\n together depending on the direction of the line - horizontal and\n vertical lines of cells are considered to be contiguous, but diagonal\n lines of cells are not considered to be contiguous and are broken up\n into separate clumps unless the  -d  flag is used.\n A random color table and other support files are generated for the\n output raster map.\n  EXAMPLES \n Perform clumping on \"lakes\" map (North Carolina sample dataset) and report area sizes for each lake individually rather by waterbody type:\n g.region raster=lakes -p\n # report sizes by waterbody type\n r.report lakes units=h\n # clump per raster polygon\n r.clump lakes out=lakes_individual\n # report sizes by individual waterbody\n r.report lakes_individual units=h\n Perform fuzzy clumping on Landsat 7 2002 imagery (North Carolina sample dataset)\n g.region raster=lsat7_2002_10 -p\n r.clump in=lsat7_2002_10,lsat7_2002_20,lsat7_2002_30,lsat7_2002_40,lsat7_2002_50,lsat7_2002_70 \n          out=lsat7_2002_clump threshold=0.045\n # reduce noise\n r.clump in=lsat7_2002_10,lsat7_2002_20,lsat7_2002_30,lsat7_2002_40,lsat7_2002_50,lsat7_2002_70 \n          out=lsat7_2002_clump_min10 threshold=0.045 minsize=10\n ", "see_also": ["r.average", "r.buffer", "r.distance", "r.grow", "r.mapcalc", "r.mfilter", "r.neighbors", "r.to.vect", "r.reclass", "r.statistics", "r.support"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.clump"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.circle.html", "name": "r.circle", "definition": "- Creates a raster map containing concentric rings around a given point.", "keywords": ["raster", "buffer", "geometry", "circle"], "synopsis": "r.circle [-b] output=name coordinates=east,north  [min=float]   [max=float]   [multiplier=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "b", "flag": "-b", "explanation": "Generate binary raster map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "The coordinate of the center (east,north)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "min", "flag": "min", "dataType": "String", "optional": true, "explanation": "Minimum radius for ring/circle map (in meters)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max", "flag": "max", "dataType": "String", "optional": true, "explanation": "Maximum radius for ring/circle map (in meters)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "multiplier", "flag": "multiplier", "dataType": "String", "optional": true, "explanation": "Data value multiplier", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This module creates an output raster map centered on the  x,y  values specified\n with the  coordinate  parameter, out to the edge of the current region.\n The output cell values increase linearly from the specified center. The  min  \n and  max  parameters control the inner and outer output raster map radii, respectively. \n  The  mult  parameter can be used to multiply the output raster cells by a common factor.\n Note that this parameter does not affect the output raster position or size; only the z-values\n are changed with this parameter. \n  Binary-output raster maps (solid circles of one value) can be created\n with the  -b  flag. Raster maps so created can be used to create\n binary filters for use in  i.ifft  (inverse Fourier transformations;\n apply filter with  r.mask ).\n  EXAMPLES \n Generate a raster circle at current map center with a radius of 300m and outwardly\n increasing raster values:\n EASTCENTER=`g.region -c |  awk ' /center easting:/ { print $3 }'`\n NORTHCENTER=`g.region -c | awk ' /center northing:/ { print $3 }'`\n r.circle output=circle coordinate=${EASTCENTER},${NORTHCENTER} max=300\n Generate a binary raster ring around current map center with an inner radius \n of 500m and an outer radius of 1000m:\n EASTCENTER=`g.region -c |  awk ' /center easting:/ { print $3 }'`\n NORTHCENTER=`g.region -c | awk ' /center northing:/ { print $3 }'`\n r.circle -b output=circle coordinate=${EASTCENTER},${NORTHCENTER} min=500 max=1000\n ", "notes": "", "see_also": ["g.region", "g.remove", "g.rename", "i.fft", "i.ifft", "r.mask"], "authors": ["Bill Brown, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.circle"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.category.html", "name": "r.category", "definition": "- Manages category values and labels associated with user-specified raster map layers.", "keywords": ["raster", "category"], "synopsis": "r.category map=name  [cats=range[,range,...]]   [values=float[,float,...]]   [separator=character]   [raster=name]   [rules=name]   [format=string]   [coefficients=mult1,offset1,mult2,offset2]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "values", "flag": "values", "dataType": "String", "optional": true, "explanation": "Comma separated value list", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "tab", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Raster map from which to copy category table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "File containing category label rules (or \"-\" to read from stdin)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Default label or format string for dynamic labeling", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "coefficients", "flag": "coefficients", "dataType": "String", "optional": true, "explanation": "Dynamic label coefficients", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.category  prints the category values and labels for the raster map\n layer specified by  map= name  to standard output. You can also\n use it to set category labels for a raster map.\n The user can specify all needed parameters on the command line, and run the\n program non-interactively. If the user does not specify any categories\n (e.g., using the optional  cats= range [, range ,...]\n argument), then all the category values and labels for the named raster map\n layer that occur in the map are printed.  The entire  map  is read\n using  r.describe , to determine which\n categories occur in the  map . If a listing of categories is\n specified, then the labels for those categories only are printed. The\n  cats  may be specified as single category values, or as ranges of\n values. The user may also (optionally) specify that a field separator other\n than a space or tab be used to separate the category value from its\n corresponding category label in the output, by using the\n  separator= character | space | tab  option (see example\n below). If no field separator is specified by the user, a tab is used to\n separate these fields in the output, by default.\n The output is sent to standard output in the form of one category per line,\n with the category value first on the line, then an ASCII TAB character (or\n whatever single character or space is specified using the  separator \n parameter), then the label for the category.\n ", "notes": "\n Any ASCII TAB characters which may be in the label are replaced by spaces. \n  The output from  r.category  can be redirected into a file, or piped into\n another program.\n  Input from a file \n The  rules  option allows the user to assign category labels from values\n found in a file. The label can refer to a single category, range of\n categories, floating point value, or a range of floating point values.\n The format is given as follows (when separator is set to colon; no white space\n must be used after the separator):\n cat:Label\n val1:val2:Label\n If the filename is given as \"-\", the category labels are read from  stdin \n  Default and dynamic category labels \n Default and dynamic category labels can be created for categories that\n are not explicitly labeled.\n The coefficient line can be followed by explicit category labels\n which override the format label generation.\n    0:no data\n    2:\t.\n    5:\t.\t\t      ## explicit category labels\n    7:\t.\n explicit labels can be also of the form:\n    5.5:5:9 label description\n    or\n    15:30  label description\n  In the format line\n  $1  refers to the value  num*5.0+1000  (ie, using the first 2 coefficients)\n  $2  refers to the value  num*5.0+1005  (ie, using the last 2 coefficients)\n    $1.2  will print  $1  with 2 decimal places.\n  Also, the form  $?xxx$yyy$  translates into  yyy  if the category is 1, xxx \n otherwise. The  $yyy$  is optional. Thus\n     $1 meter$?s \n  will become:  \n    1 meter  (for category 1) \n    2 meters  (for category 2), etc.\n  format='Elevation: $1.2 to $2.2 feet'   ## Format Statement \n  coefficients=\"5.0,1000,5.0,1005\"\t## Coefficients \n  The format and coefficients above would be used to generate the\n following statement in creation of the format appropriate category\n string for category \"num\":\n  sprintf(buff,\"Elevation: %.2f to %.2f feet\", num*5.0+1000, num*5.0*1005) \n  Note: while both the format and coefficient lines must be present\n       a blank line for the format string will effectively suppress\n       automatic label generation.\n  To use a \" $ \" in the label without triggering the plural test,\n put \" $$ \" in the format string.\n  Use 'single quotes' when using a \" $ \" on the command line to\n avoid unwanted shell substitution.\n  EXAMPLES \n North Carolina sample dataset:\n  Printing categories \n r.category map=landclass96\n 1\tdeveloped\n 2\tagriculture\n 3\therbaceous\n 4\tshrubland\n 5\tforest\n 6\twater\n 7\tsediment\n prints the values and labels associated with all of the categories in the\n  landclass96  raster map layer.\n r.category map=landclass96 cats=2,5-7 \n 2\tagriculture\n 5\tforest\n 6\twater\n 7\tsediment\n prints only the category values and labels for  landclass96  map layer\n categories  2  and  5  through  7 .\n r.category map=landclass96 cats=3,4 separator=comma\n 3,herbaceous\n 4,shrubland\n prints the values and labels for  landclass96  map layer categories\n  3  and  4 , but uses \" , \" (instead of a tab)\n as the character separating the category values from the category\n values in the output.\n  Adding categories \n Example for defining new category labels, using a colon as separator:\n r.category diseasemap separator=\":\" rules=- << EOF\n 1:potential absence\n 2:potential presence\n EOF\n This sets the categoy values 1 and 2 to respective text labels.\n Alternatively, the rules can be stored in an ASCII text file and loaded\n via the  rules  parameter.\n ", "see_also": [], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.category"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.carve.html", "name": "r.carve", "definition": "- Generates stream channels.", "keywords": ["raster", "hydrology"], "synopsis": "r.carve [-n] raster=name vector=name output=name  [points=name]   [width=float]   [depth=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "No flat areas allowed in flow direction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": false, "explanation": "Name of input raster elevation map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "vector", "flag": "vector", "dataType": "String", "optional": false, "explanation": "Name of input vector map containing stream(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "points", "flag": "points", "dataType": "String", "optional": true, "explanation": "Name for output vector map for adjusted stream points", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Stream width (in meters)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "depth", "flag": "depth", "dataType": "String", "optional": true, "explanation": "Additional stream depth (in meters)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.carve  accepts vector stream data as input, transforms them to\n raster, and subtracts a default-depth + additional-depth from a DEM. If\n the given width is more than 1 cell, it will carve the stream with the\n given width. With the  -n  flag it should eliminate all flat cells within\n the stream, so when and if the water gets into the stream it will\n flow. The  points  option generates x,y,z for points which define the stream\n with the z-value of the bottom of the carved-in stream. These points\n can then be combined with contours to interpolate a new DEM with\n better representation of valleys.\n ", "notes": "\n  r.carve  does not create a depressionless DEM because many\n depressions are in flat areas and not in the streams.\n  EXAMPLE \n North Carolina sample dataset:\n # set computational region\n g.region raster=elev_lid792_1m -p\n # visualize original data\n d.mon wx0\n d.rast elev_lid792_1m\n d.vect streams\n # carve\n r.carve rast=elev_lid792_1m vect=streams out=carved_dem width=3 depth=0.5\n # visualize resulting carved DEM map\n d.rast carved_dem\n # visualize\n r.relief input=elev_lid792_1m output=elev_lid792_1m_shaded\n r.relief input=carved_dem output=carved_dem_shaded\n d.rast elev_lid792_1m_shaded\n d.erase\n d.rast carved_dem_shaded\n # flow accumulation\n r.watershed elevation=elev_lid792_1m accumulation=elev_lid792_1m_accum\n r.watershed elevation=carved_dem accumulation=carved_dem_accum\n d.rast elev_lid792_1m_accum\n d.erase\n d.rast carved_dem_accum\n  \n   \n    \n    \n    \n    Fig: Original 1m LiDAR based DEM with vector streams map on top \n    \n   \n    \n    \n    \n    Fig: Original 1m LiDAR based DEM shown as shaded terrain \n   \n   \n    \n    \n    \n    Fig: Carved 1m LiDAR based DEM \n   \n   \n    \n    \n    \n    Fig: Carved 1m LiDAR based DEM shown as shaded terrain \n   \n   \n    \n    \n    \n    Fig: Flow accumulation in original 1m LiDAR based DEM \n   \n   \n    \n    \n    \n    Fig: Flow accumulation in carved 1m LiDAR based DEM \n   \n  KNOWN ISSUES \n The module does not operate yet in latitude-longitude locations.  It\n has not been thoroughly tested, so not all options may work properly -\n but this was the intention.\n  REFERENCES \n  Terrain\n modeling and Soil Erosion Simulations for Fort Hood and Fort Polk test\n areas , by Helena Mitasova, Lubos Mitas, William M. Brown, Douglas\n M.  Johnston, GMSL (Report for CERL 1999)\n ", "see_also": ["r.flow", "r.fill.dir", "r.watershed"], "authors": ["Bill Brown (GMSL)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.carve"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.buffer.lowmem.html", "name": "r.buffer.lowmem", "definition": "- Creates a raster map showing buffer zones surrounding cells that contain non-NULL category values.", "keywords": ["raster", "buffer"], "synopsis": "r.buffer.lowmem [-z] input=name output=name distances=float[,float,...]  [units=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Ignore zero (0) data cells instead of NULL cells Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "distances", "flag": "distances", "dataType": "String", "optional": false, "explanation": "Distance zone(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Units of distance", "defaultValue": "meters", "alternatives": ["meters", "kilometers", "feet", "miles", "nautmiles"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.buffer.lowmem  creates a new raster map showing buffer\n (a.k.a. \"distance\" or \"proximity\") zones around all cells that contain\n non-NULL category values in an existing raster map. The distances of\n buffer zones from cells with non-zero category values are user-chosen.\n This is the low-memory alternative to the\n classic  r.buffer  module. It is\n much slower than the classic version, but will run on massive raster\n maps without using a lot of RAM. If your raster map is larger than\n 32000x32000 cells on a system with 1 GB of RAM, or larger than\n 90000x90000 cells on a system with 8 GB of RAM, consider using this\n module.\n For more info see manual of  r.buffer .\n  EXAMPLE \n In the following example, the buffer zones would be (in the default units\n of meters): 0-100, 101-200, 201-300, 301-400 and 401-500.\n r.buffer.lowmem input=roads output=roads.buf distances=100,200,300,400,500\n Result:\n r.category input=roads.buf\n       1       distances calculated from these locations\n       2       0-100 meters\n       3       100-200 meters\n       4       200-300 meters\n       5       300-400 meters\n       6       400-500 meters\n ", "notes": "", "see_also": ["g.region", "r.buffer", "r.cost", "r.grow.distance", "r.mapcalc", "r.reclass", "v.buffer"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.buffer.lowmem"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.buffer.html", "name": "r.buffer", "definition": "- Creates a raster map showing buffer zones surrounding cells that contain non-NULL category values.", "keywords": ["raster", "buffer"], "synopsis": "r.buffer [-z] input=name output=name distances=float[,float,...]  [units=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Ignore zero (0) data cells instead of NULL cells Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "distances", "flag": "distances", "dataType": "String", "optional": false, "explanation": "Distance zone(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Units of distance", "defaultValue": "meters", "alternatives": ["meters", "kilometers", "feet", "miles", "nautmiles"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.buffer  creates a new raster map showing\n buffer (a.k.a. \"distance\" or \"proximity\") zones around all\n cells that contain non-NULL category values in an existing\n raster map. The distances of buffer zones from cells with\n non-zero category values are user-chosen and must be positive value(s).\n Suppose, for example, that you want to place buffer zones around\n roads.  This program could create the raster map \n shown below on the right based on road information\n contained in the raster map shown on the left.\n       000000000000000000000000 222233333333333333444444 \n       111000000000000000000000 111222222222223333333333 \n       000111111111100000000000 222111111111122223333333 \n       000000001000011100000000 332222221222211122222222 \n       000000001000000011111111 333333321233222211111111 \n       000000001000000000000000 433333321233333222222222 \n       000000001000000000000000 444443321233333333333333 \n       000000001000000000000000 444443321233443333333333 \n       000000001000000000000000 444443321233444444444444 \n       Category 0: No roads\n       Category 1: Road location \n       Category 2: Buffer Zone 1 around roads \n       Category 3: Buffer Zone 2 around roads \n       Category 4: Buffer Zone 3 around roads \n ", "notes": "\n The user has the option of identifying up to 250 continuous zones.\n The zones are identified by specifying the upper limit of each desired\n zone ( r.buffer  assumes that  0  is the starting\n point).  \"Continuous\" is used in the sense that each category zone's\n lower value is the previous zone's upper value. The first buffer zone\n always has distance  0  as its lower bound. Buffer distances\n can be specified using one of five units with the  units  parameter.\n Distances from cells containing the user-specified category values\n are calculated using the \"fromcell\" method. This method locates each\n cell that contains a category value from which distances are to be\n calculated, and draws the requested distance rings around\n them. This method works very fast when there are few cells\n containing the category values of interest, but works\n slowly when there are numerous cells containing the\n category values of interest spread throughout the area.\n  r.buffer  measures distances from center of cell to\n center of cell using Euclidean distance measure for\n planimetric locations (like UTM) and using ellipsoidal\n geodesic distance measure for latitude/longitude locations.\n  r.buffer  calculates distance zones from all cells having\n non-NULL category values in the  input  map. If the user wishes\n to calculate distances from only selected  input  map category\n values, the user should run (for example)\n  r.reclass  prior to \n  r.buffer , to reclass all categories from which distance zones \n are not desired to be calculated into category NULL. \n The  -z  flag can be used to ignore raster values of zero instead of NULL\n values in the input raster map.\n When working with massive raster regions consider\n the  r.buffer.lowmem  module\n if RAM use becomes a problem. The lowmem version can be > 40x\n slower, but will work with minimal memory requirements. The\n classic  r.buffer  should be able to deal with raster maps of\n 32000x32000 size on a system with 1 GB RAM, and rasters of 90000x90000\n on a system with 8 GB RAM without going into swap.\n  EXAMPLE \n In the following example (North Carolina sample dataset), the buffer zones\n would be (in the default map units of meters):  0-100, 101-200, 201-300,\n 301-400 and 401-500.\n g.region raster=roadsmajor -p\n r.buffer input=roadsmajor output=roadsmajor_buf distances=100,200,300,400,500\n Result:\n r.category input=roads.buf\n       1       distances calculated from these locations\n       2       0-100 meters\n       3       100-200 meters\n       4       200-300 meters\n       5       300-400 meters\n       6       400-500 meters\n  Distances to road \n ", "see_also": ["r.buffer.lowmem", "r.grow", "v.buffer"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.buffer"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.blend.html", "name": "r.blend", "definition": "- Blends color components of two raster maps by a given ratio.", "keywords": ["raster", "composite"], "synopsis": "r.blend [-c] first=name second=name output=basename  [percent=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Combine resulting R,G,B layers into single output map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "first", "flag": "first", "dataType": "String", "optional": false, "explanation": "Name of first raster map for blending", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "second", "flag": "second", "dataType": "String", "optional": false, "explanation": "Name of second raster map for blending", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Basename for red, green and blue output raster maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "percent", "flag": "percent", "dataType": "String", "optional": true, "explanation": "Percentage weight of first map for color blending", "defaultValue": "50", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.blend  blends color components of 2 raster maps by a\n specificed percentage of the first map.\n  EXAMPLE \n Blending the aspect map with the elevation map for a shaded map\n (North Carolina sample dataset):\n g.region raster=aspect -p\n r.blend first=aspect second=elevation output=elev_shade_blend\n d.mon wx0\n d.rgb blue=elev_shade_blend.b green=elev_shade_blend.g red=elev_shade_blend.r\n ", "notes": "", "see_also": ["d.shade", "g.region", "r.shade", "r.colors", "r.his", "r.mapcalc", "r.rgb", "r.support"], "authors": ["Unknown: probably CERL"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.blend"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.basins.fill.html", "name": "r.basins.fill", "definition": "- Generates watershed subbasins raster map.", "keywords": ["raster", "hydrology", "watershed"], "synopsis": "r.basins.fill cnetwork=name tnetwork=name output=name number=integer  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "cnetwork", "flag": "cnetwork", "dataType": "String", "optional": false, "explanation": "Name of input coded stream network raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "tnetwork", "flag": "tnetwork", "dataType": "String", "optional": false, "explanation": "Name of input thinned ridge network raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "number", "flag": "number", "dataType": "String", "optional": false, "explanation": "Number of passes through the dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.basins.fill \n generates a raster map layer depicting subbasins, based \n on input raster map layers for the coded stream network \n (where each channel segment has been \"coded\" with a unique category value) \n and for the ridges within a given watershed. \n The raster map layer depicting ridges should include \n the ridge which defines the perimeter of the watershed. \n The coded stream network can be generated \n as part of the \n  r.watershed  program, \n but the map layer of ridges will need to be created by hand\n (for example, through digitizing done in  wxGUI vector digitizer ).\n The resulting output raster map layer will \n code the subbasins with category values matching \n those of the channel segments passing through them. \n A user-supplied number of passes through the data is \n made in an attempt to fill in these subbasins. \n If the resulting map layer from this program appears to \n have holes within a subbasin, the program should be \n rerun with a higher number of passes. \n ", "notes": "\n The current geographic region setting is ignored. \n Instead, the geographic region for the entire input stream's \n map layer is used. \n ", "see_also": [], "authors": ["Dale White, Dept. of Geography, Pennsylvania State University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.basins.fill"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/ps.map.html", "name": "ps.map", "definition": "- Produces hardcopy PostScript map output.", "keywords": ["postscript", "printing"], "synopsis": "ps.map [-rpeb] input=name output=name  [copies=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Rotate plot 90 degrees List paper formats (name width height left right top bottom(margin)) Create EPS (Encapsulated PostScript) instead of PostScript file Describe map-box's position on the page and exit (inches from top-left of paper) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "List paper formats (name width height left right top bottom(margin)) Create EPS (Encapsulated PostScript) instead of PostScript file Describe map-box's position on the page and exit (inches from top-left of paper) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Create EPS (Encapsulated PostScript) instead of PostScript file Describe map-box's position on the page and exit (inches from top-left of paper) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Describe map-box's position on the page and exit (inches from top-left of paper) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "File containing mapping instructions", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for PostScript output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "copies", "flag": "copies", "dataType": "String", "optional": true, "explanation": "Number of copies to print", "defaultValue": null, "alternatives": ["1-20"], "isInputFile": false, "isOutputFile": false}], "description": "\n  ps.map  is a cartographic mapping program for producing high quality\n hardcopy maps in PostScript format. Output can include a raster map, any\n number of vector overlays, text labels, decorations, and other spatial data.\n  A file of mapping instructions that describes the various spatial and textual\n information to be printed must be prepared prior to running  ps.map .\n ", "notes": "\n  The order of commands is generally unimportant but may affect how some layers\n are drawn. For example to plot  vpoints  above  vareas  list the\n  vpoints  entry first. Raster maps are always drawn first, and only a\n single raster map (or 3 if part of a RGB group) may be used.\n  The hash character (' # ') may be used at the beginning of a line\n to indicate that the line is a comment. Blank lines will also be ignored.\n  Be aware that some mapping instructions require the  end  command\n and some do not. Any instruction that allows subcommands will require\n it, any instruction that does not allow subcommands will not.\n  The resolution and extent of raster maps plotted with  ps.map  are\n controlled by the current region settings via the\n  g.region  module. The output filesize is largely\n a function of the region resolution, so special care should be taken\n if working with large raster datasets. For example if the desired output is\n US-Letter sized paper at 300dpi, with 1\" margins and the raster filling the\n entire page, the usable area on the page will be 6.5\" x 9\", which at 300\n dots/inch is equivalent to a region of 1950 columns x 2700 rows (see \n \" g.region -p \"). Any higher resolution settings will make the\n output file larger, but with a consumer printer you probably won't be able\n to resolve any better detail in the hardcopy.\n  The user can specify negative or greater than 100 percentage values for\n positioning several map decorations and embedded EPS-files, to move them\n outside the current map box region (for example to position a caption,\n barscale, or legend above or below the map box).\n  One point (\"pixel\") is 1/72 of an inch.\n  For users wanting to use special characters (such as accented characters) it\n is important to note that  ps.map  uses  ISO-8859-1  encoding.\n This means that your instructions file will have to be encoded in this\n encoding. If you normally work in a different encoding environment (such as\n  UTF-8 ), you have to transform your file to the  ISO-8859-1 \n encoding, for example by using the  iconv  utility:\n iconv -f UTF-8 -t ISO_8859-1 utf_file > iso_file\n  MAPPING INSTRUCTIONS \n The mapping instructions allow the user to specify various spatial data\n to be plotted. These instructions are normally prepared in a regular\n text file using a system editor. Some instructions are single line\n instructions while others are multiple line. Multiple line instructions\n consist of the main instruction followed by a subsection of one or more\n additional instructions and are terminated with an  end  instruction.\n  Instruction keywords: \n [ \n  border \u00a0|\n  colortable \u00a0|\n  comments \u00a0|\n  copies \u00a0|\n  eps \u00a0|\n  geogrid \u00a0|\n  greyrast \u00a0|\n  grid \u00a0|\n  group \u00a0|\n  header \u00a0|\n  labels \u00a0|\n  line \u00a0|\n  mapinfo \u00a0|\n  maploc \u00a0|\n  maskcolor \u00a0|\n  outline \u00a0|\n  paper \u00a0|\n  point \u00a0|\n  psfile \u00a0|\n  raster \u00a0|\n  read \u00a0|\n  rectangle \u00a0|\n  region \u00a0|\n  rgb \u00a0|\n  scale \u00a0|\n  scalebar \u00a0|\n  setcolor \u00a0|\n  text \u00a0|\n  vareas \u00a0|\n  vlines \u00a0|\n  vpoints \u00a0|\n  vlegend \u00a0|\n  end \n ]\n  Common instructions \n Instructions that may be included in the subsection under several\n different main instructions are:\n  where   x y \n  The top left corner of the bounding box of the item to be plotted\n is located  x  inches from the left edge of the paper and\n  y  inches from the top edge of the paper. If  x  is less than\n or equal to zero, the default horizontal location is used.  If  y \n is less than or equal to zero, the default vertical location is used.\n  font   font name  \n  The name of the PostScript font.\n Fonts present in all PostScript implementations are:\n Times-Roman,\n Times-Italic,\n Times-Bold,\n Times-BoldItalic,\n Helvetica,\n Helvetica-Oblique,\n Helvetica-Bold,\n Helvetica-BoldOblique,\n Courier,\n Courier-Oblique,\n Courier-Bold,\n and\n Courier-BoldOblique .\n The default is Helvetica.\n  fontsize   font size  \n  The size of the PostScript font (in 1/72nds of an inch).\n The default is 10 point.\n  color   name \n  The following colors names are accepted by  ps.map :\n aqua,\n black,\n blue,\n brown,\n cyan,\n gray,\n grey,\n green,\n indigo,\n magenta,\n orange,\n purple,\n red,\n violet,\n white,\n yellow\n  .\n For vectors and some plotting commands you can also specify\n ' none ' or ' R:G:B ' (e.g ' 255:0:0 ').\n  yes|no \n  For options that take a yes or no answer, you can simply use the\n letters \"y\" or \"n\", or type out the full words \"Yes\" or \"No\" if you\n prefer. It is not case-sensitive. Typically the option with have a\n default answer and you only need to specify one if you wish to\n override it.\n  Command usage \n  border \n Controls the border which is drawn around the map area.\n USAGE:   border  [y|n]\n \t color  color\n \t width  #\n \t end \n The  color  may be either a standard GRASS color, a R:G:B triplet,\n or \"none\". The width is specified in points, unless followed by an \"i\"\n in which case it is measured in inches.\n The default is a black border box of width 1 point.\n  The border can be turned off completely with the\n \" border\u00a0n \" instruction. In this case\n the  end  command should not be given as the\n main command will be treated as a single line instruction.\n This example would create a grey border 0.1\" wide.\n EXAMPLE:\n \t border   \n \t color  grey\n \t width  0.1i\n \t end \n  colortable \n Prints the color table legend for the raster map layer anywhere on the page.\n USAGE:\t colortable  [y|n]\n \t where  x y\n \t raster  raster map\n \t range  minimum maximum\n \t width  table width\n \t height  table height (FP legend only)\n \t cols  table columns\n \t font  font name\n \t fontsize  font size\n \t color  text color\n \t nodata  [Y|n]\n \t tickbar  [y|N]\n \t discrete  [y|n]\n \t end \n For a categorical (CELL) map the color table will create a legend displaying\n the colors for each of a raster map's category values along with its\n associated category label. For a floating point (FCELL or DCELL) map a\n continuous gradient legend will be created.\n If  raster  is omitted, the colortable defaults to the previously\n registered raster layer.\n The default location for the colortable is immediately below any other\n map legend information, starting at the left margin.\n The default text color is black.\n Omitting the  colortable  instruction would result in no color table.\n If the colortable is turned off with a \" colortable\u00a0N \"\n instruction the  end  command should not be given as the\n main command will be treated as a single line instruction.\n See also the  vlegend  command for creating vector map\n legends.\n  Categorical (CELL) Maps \n Adding the  nodata N  instruction will prevent the \"no data\" box \n from being drawn (category based legends only). If you have manually\n added a \"no data\" label to the cats/ file it will be shown regardless.\n   \n  Note :  Be careful about asking for color tables for integer\n raster map layers which have many categories, such as elevation.\n This could result in the printing of an extremely long color table!\n In this situation it is useful to use the  discrete N  instruction\n to force a continuous color gradient legend.\n Be aware that the color table only includes categories which\n have a label. You can use the  r.category  module to add labels.\n  Floating point (FCELL and DCELL) Maps \n The legend's  range  can be adjusted for floating point rasters, but if\n set beyond the extent of the map's range be sure that you have set up color \n rules with  r.colors  which cover this range.\n If the map has been given a data-units label with  r.support \n then this label will be displayed.\n For floating point legends  width  is width of color\n band only.  height  is used only for floating point legend.\n A horizontal gradient legend can be achieved by setting the legend\n width greater than its height.\n Adding the  tickbar Y  instruction will change the tick mark style\n so that ticks are drawn across the color table instead of protruding out \n to the right (floating point legends only).\n Adding the  discrete Y  instruction will command the program to treat\n the map as a categorical map. In this way the legend can be created with\n discrete range bands instead of a continuous gradient. You must use the\n  r.category  or  r.support  module to set up the range labels\n first.\n  This example would print a color table immediately below any other map legend\n information, starting at the left margin, with 4 columns:\n EXAMPLE:\n \t colortable  y\n          cols  4\n          width  4\n          end \n  comments \n Prints comments anywhere on the page.\n USAGE:\t comments  commentfile\n \t where  x y\n \t font  font name\n \t fontsize  font size\n \t color  text color\n \t end \n The default location is immediately below the last item item printed,\n starting at the left margin. The default text color is black.\n  If you wish to use parentheses spanning multiple lines you will need to\n quote them with a backslash to prevent the PostScript interpreter from \n getting confused. e.g. ' \\( ' and ' \\) '\n This example prints in blue\n whatever is in the file  veg.comments  starting at\n 1.5 inches from the left edge of the page and 7.25 inches from the top of\n the page, using a 15/72 inch Helvetica Bold font.\n EXAMPLE:\t\n \t raster  vegetation\n \t comments  veg.comments\n \t where  1.5 7.25\n \t font  Helvetica Bold\n \t fontsize  15\n \t color  blue\n \t end \n Presumably, the file\n  veg.comments \n contain comments\n pertaining to the raster map layer  vegetation ,\n such as \"This map was created by classifying a LANDSAT TM image\".\n  copies \n Specifies the number of copies to be printed.\n USAGE:\t copies  n\n Each page will be printed n times.\n  This instruction is identical to the  copies  command line parameter.\n  eps \n Places EPS (Encapsulated PostScript) pictures on the output map.\n USAGE:\t eps  east north\n \t eps  x% y%\n \t epsfile  EPS file\n \t scale  #\n \t rotate  #\t\n \t masked  [y|n]\n \t end \t\n The EPS picture location is entered in the main \n instruction line by giving either the map \n coordinates or by using percentages of the geographic region.\n The EPS picture will be  centered  at the given position.\n The user must specify full EPS file path  epsfile .\n The user may also specify the  scale  of the icon\n (default is 1.0), the  rotate  i.e. rotation in degrees\n (default is 0)\n and whether the point is to be  masked \n by the current mask.\n (See manual entry for  r.mask  \n for more information on the mask.)\n This example would place a EPS file ./epsf/logo.eps\n at the point (E456000 N7890000).  This picture would be\n rotated 20 degrees clockwise, 3 times bigger than\n in original file and would not be masked by the current mask.\n EXAMPLE:\n \t eps  456000 7890000\n \t epsfile  ./epsf/logo.eps     \n \t scale  3\n \t rotate  20\t\n \t masked  n\n \t end \t\n Of course, multiple EPS pictures may be drawn with multiple\n  eps \n instructions.\n  geogrid \n Overlays a geographic grid onto the output map.\n USAGE:\t geogrid  spacing unit\n \t color  color\n \t numbers  # [color]\n \t font  font name\n \t fontsize  font size\n \t width  #\n \t end \n The  spacing  and spacing unit of the geographic grid is given \n on the main instruction line.  The  spacing  unit is given as one of  d  for\n degrees,  m  for minutes, and  s  for seconds. \n The subsection instructions allow the user to specify\n the  color  of the geographic grid lines,\n whether coordinate  numbers  should appear\n on the geographic grid lines, the  width \n of the lines (accepts decimal points [floating points] \n as well as integers), and\n if they should appear every grid line (1), every other grid line \n (2), etc., and what color the numbers should be.  The defaults are\n black grid lines, unnumbered.\n NOTE: The  geogrid  draws grid numbers on the east and south borders of the map.\n This example would overlay a blue geographic grid with a spacing of 30 minutes\n onto the output map.  Alternate grid\n lines would be numbered with yellow numbers.\n EXAMPLE:\n \t geogrid  30 m   \n \t color  blue\n \t numbers  2 yellow\n \t end \n  greyrast \n Selects a raster map layer for output in shades of grey.\n USAGE:\t greyrast  mapname\n For each \n  ps.map \n run, only one raster map layer can be requested (using either the\n  greyrast  or the  raster  instruction).\n  grid \n Overlays a coordinate grid onto the output map.\n USAGE:\t grid  spacing\n \t color  color\n \t numbers  # [color]\n \t cross  cross size\n \t font  font name\n \t fontsize  font size\n \t width  #\n \t end \n The  spacing  of the grid is given (in the geographic coordinate\n system units) on the main instruction line.  The subsection instructions\n allow the user to specify\n the  color  of the grid lines,\n whether coordinate  numbers  should appear\n on the grid lines, and if they\n should appear every grid line (1), every other grid line \n (2), etc., and what color the numbers should be.  \n The  cross  argument draws grid intersection crosses instead of grid lines, \n with cross size given in geographic coordinate system units.\n The defaults are black grid lines, unnumbered.\n This example would overlay a green grid with a spacing of 10000 meters\n (for a metered database, like UTM) onto the output map.  Alternate grid\n lines would be numbered with red numbers.\n EXAMPLE:\n \t grid  10000   \n \t color  green\n \t numbers  2 red\n \t end \n  group \n Selects an RGB imagery group for output.\n USAGE:\t group   groupname \n This is similar to  raster , except that it uses an imagery group\n instead of a raster map layer. The group must contain three raster map\n layers, comprising the red, green and blue bands of the image.\n  header \n Prints the map header above the map.\n USAGE:\t header \n \t file  header file\n \t font  font name\n \t fontsize  font size\n \t color  text color\n \t end \n If the  file  sub-instruction is absent the header will consist\n of the map's title  \n and the location's description. \n The text will be centered on the page above the map.\n The default text color is black.\n  If the  file  sub-instruction is given the header will consist\n of the text in the text file specified, with some special formatting keys:\n  %%   - a literal %\n  %n   - ? newline ?\n  %_   - horizontal bar\n  %c   - \"<raster name> in mapset <mapset name>\"\n  %d   - today's date\n  %l   - location name\n  %L   - Location's text description\n  %m   - mapset name\n  %u   - user name\n  %x   - mask info\n  %-   - advance to this character column number (see example below)\n Example header file:\n %_\n LOCATION: %-27l  DATE: %d\n MAPSET:   %-27m  USER: %u\n RASTER MAP: %c\n MASK:     %x\n %_\n Produced by: US Army CERL, Champaign Illinois\n Software:    GRASS\n %_\n This example prints (in red) whatever is in the file  soils.hdr  above\n the map, using a 20/72 inch  Courier  font.\n EXAMPLE:\t\n \t header \n \t file  soils.hdr\n \t font  Courier\n \t fontsize  20\n \t color  red\n \t end \n  labels \n Selects a labels file for output (see manual entry for\n  v.label \n ). \n USAGE:\t labels   labelfile\n \t font  font name\n \t end \n  NOTE: ps.map can read new option 'ROTATE:' from labels file, which\n specifies counter clockwise rotation in degrees. \n  This example would paint labels from the labels file called\n  town.names .  Presumably, these labels would indicate the names of\n towns on the map.\n EXAMPLE:\t\n \t labels  town.names\n \t end \n  line \n Draws lines on the output map.\n USAGE:\t line  east north east north\n \t line  x% y% x% y%\n \t color  color\n \t width  #\n \t masked  [y|n]\n \t end \n The beginning and ending points of the line are entered on the main\n instruction.  These points can be defined either by map coordinates or\n by using percentages of the geographic region.\n The user may also specify line  color ,  width \n in points (1/72\"; accepts decimal values as well as integers),\n and if the line is to be  masked  by the current mask.\n (See manual entry for  r.mask \n   for more information on the mask.)\n The line  width  (if given) is measured in points; an  i \n directly following the number indicates that the width is given in\n inches instead.\n This example would draw a yellow line from the point x=10% y=80%\n to the point x=30% y=70%.\n This line would be 2 points wide (2/72\") and would appear even if\n there is a mask.\n EXAMPLE:\n \t line  10% 80% 30% 70%\n \t color  yellow\n \t width  2\n \t masked  n\n \t end \n Of course, multiple lines may be drawn with multiple\n  line \n instructions.\n  mapinfo \n Prints the portion of the map legend containing the scale, grid and\n region information, on or below the map.\n USAGE:\t mapinfo \n \t where  x y\n \t font  font name\n \t fontsize  font size\n \t color  text color\n \t background  box color|none\n \t border  color|none\n \t end \n The default location is immediately below the map,\n starting at the left edge of the map.\n The default text color is black.\n The default background box color is white.\n  border  will draw a border around the legend using the specified color.\n  (see  NAMED COLORS )\n This example prints (in brown) the scale, grid and region information\n immediately below the map and starting 1.5 inches from the left edge\n of the page, using a 12/72 inch  Courier  font.\n EXAMPLE:\n \t mapinfo \n \t where  1.5 0\n \t font  Courier\n \t fontsize  12\n \t color  brown\n \t end \n  maploc \n Positions the map on the page.\n USAGE:\t maploc   x y [width height]\n The upper left corner of the map will be positioned  x  inches from\n the left edge of the page and  y  inches from the top of the page.\n If  width  and  height  (in inches) are present, the map will be\n rescaled, if necessary, to fit.\n This example positions the upper left corner of the map 2.0 inches from\n the left edge and 3.5 inches from the top edge of the map.\n EXAMPLE:\n \t maploc  2.0 3.5\n  maskcolor \n Color to be used for mask.\n USAGE:\t maskcolor   color\n  outline \n Outlines the areas of a raster map layer with a specified color.\n USAGE:\t outline \n \t color   color\n \t width   width of line in points\n \t end \n Distinct areas of the raster map will be separated from each other visually\n by drawing a border (or outline) in the specified\n  color \n (default: black). For \n  width \n the program accepts decimal points [floating points] as well as integers.\n Note: it is\n important the user enter the instruction  end  even if a color is not\n chosen.\n (It is hoped that in the future the outline of a different raster map\n layer other than the one currently being painted may be placed on the map.)\n This example would outline the category areas of the\n  soils \n raster map layer\n in grey.\n EXAMPLE:\t\n \t raster  soils\n \t outline    \n \t color  grey\n \t width  2\n \t end \n  paper \n Specifies paper size and margins.\n USAGE:\t paper  paper name\n \t height  #\n \t width  #\n \t left  #\n \t right  #\n \t bottom  #\n \t top  #\n \t end \t\n  paper  may select predefined paper name\n  (a4,a3,a2,a1,a0,us-legal,us-letter,us-tabloid).\n  Default paper size is a4. The measures are defined in  inches .\n  left ,  right ,  bottom  and  top  are paper margins.\n If the plot is rotated with the  -r  command line flag, measures\n are applied to the  rotated  page.\n EXAMPLE:\n \t paper  a3\n \t end \t\n EXAMPLE:\n \t paper \n \t width  10\n \t height  10\n \t left  2\n \t right  2\n \t bottom  2\n \t top  2\n \t end \t\n  point \n Places additional points or icons on the output map.\n USAGE:\t point  east north\n \t point  x% y%\n \t color  color\n \t fcolor  color\n \t symbol  symbol group/name\n \t size  #\n \t width  #\n \t rotate  #\n \t masked  [y|n]\n \t end \t\n The point location is entered in the main instruction line by giving either\n the map coordinates or by using percentages of the geographic region.\n The user may also specify the point  color ,\n the  size  of symbol in points,\n the rotation angle (in degrees CCW), \n and whether the point is to be  masked  by the current mask.\n (See manual entry for    r.mask \n   for more information on the mask.)\n The symbol line  width  (if given) is measured in points; an  i \n directly following the number indicates that the width is given in inches\n instead. If a  width  is not given it will be set proportional to the\n symbol size.\n  This example would place a purple diamond (from icon file\n  diamond ) at the point (E456000 N7890000).  This diamond would be the \n the size of a 15 points and would not be masked by the current mask.\n EXAMPLE:\n \t point  456000 7890000\n \t fcolor  purple     \n \t color  black     \n \t symbol  basic/diamond\n \t size  15\n \t masked  n\n \t end \t\n Of course, multiple points may be drawn with multiple\n  point \n instructions.\n  psfile \n Copies a file containing PostScript commands into the output file.\n  Note: \n  ps.map \n will not search for this file.  The user must be in the\n correct directory or specify the full path on the  psfile  instruction.\n (Note to /bin/csh users: ~ won't work with this instruction).\n USAGE:\t psfile  filename\n This example copies the file \"logo.ps\" into the output file.\n EXAMPLE:\t\n \t psfile  logo.ps\n  raster \n Selects a raster map layer for output.\n USAGE:\t raster  mapname\n For each  ps.map  run, only one raster map layer (or set\n of layers or imagery group; see below) can be requested. If no\n raster map layer is requested, a completely white map will be\n produced. It can be useful to select no raster map layer in\n order to provide a white background for vector maps.\n  Note that an imagery group selected with the  group \n option, or a set of three raster layers selected with the\n  rgb  option, count as a raster map layer for the\n purposes of the preceding paragraph.\n  The PostScript file's internal title will be set to the raster map's\n title, which in turn may be set with the  r.support  module.\n  This example would paint a map of the raster map layer  soils .\n EXAMPLE:\t\n \t raster  soils\n  read \n Provides  ps.map  with a previously prepared input stream.\n USAGE:\t read  previously prepared UNIX file\n Mapping instructions can be placed into a file and read into\n  ps.map. \n  Note: \n  ps.map \n will not search for this file.  The user must be in the\n correct directory or specify the full path on the  read  instruction.\n (Note to /bin/csh users: ~ won't work with this instruction).\n This example reads the UNIX file  pmap.roads  into  ps.map .\n This file may contain all the  ps.map  instructions for placing\n the vector map layer  roads  onto the output map.\n EXAMPLE: \n \t read  pmap.roads\n The user may have created this file because this vector map layer\n is particularly useful for many  ps.map \n outputs.  By using the  read  option, the user need not enter all the input\n for the  vector  instruction, but simply  read  the previously prepared\n file with the correct instructions.\n  rectangle \n Draws rectangle on the output map.\n USAGE:\t rectangle  east north east north\n \t rectangle  x% y% x% y%\n \t color  color\n \t fcolor  fill color\t\n \t width  #\n \t masked  [y|n]\n \t end \n The two corners of the rectangle are entered on the main\n instruction.  These points can be defined either by map coordinates or\n by using percentages of the geographic region.\n The user may also specify line\n  color , fill color  fcolor ,  width \n in points (accepts decimal points [floating points] as well as integers),\n and if the rectangle is to be  masked  by the current mask.\n (See manual entry for  r.mask \n for more information on the mask.)\n The border line  width  (if given) is measured in points; an  i \n directly following the number indicates that the width is given in inches\n instead.\n Multiple rectangles may be drawn by using multiple  rectangle  instructions.\n This example would draw a yellow rectangle filled by green from the point x=10% y=80%\n to the point x=30% y=70%.\n The border line would be 1/16\" wide and would appear even if there is a mask.\n EXAMPLE:\n \t rectangle  10% 80% 30% 70%\n \t color  yellow\n \t fcolor  green\t\n \t width  0.0625i\n \t masked  n\n \t end \n  region \n Places the outline of a smaller geographic region\n on the output.\n USAGE:\t region  regionfile\n \t color  color\n \t width  #\n \t end \n Geographic region settings are created and saved using   the \n  g.region  module.\n The  ps.map   region  option can be used to show an outline of\n a smaller region which was printed on a separate run of  ps.map \n on other user-created maps.\n  The user can specify the  color \n and the  width  in point units (accepts decimal points\n [floating points] as well as integers) of the outline.\n The default is a black border of one point width (1/72\").\n  This example would place a white outline, 2 points wide, of the\n geographic region called  fire.zones  onto the output map.\n This geographic region would have been created and saved using \n  g.region .\n EXAMPLE:\n \t region  fire.zones\n \t color  white\n \t width  2\n \t end \n  rgb \n Selects three raster map layers for output as an RGB color image.\n USAGE:\t rgb   red   green   blue \n This is similar to  raster , except that it uses three\n raster map layers instead of a single layer. The three layers\n are composed to form a color image, similar to  d.rgb .\n For each layer, only one of the components of the layer's color\n table is used: the red component for the red layer, and so on. \n This will give the desired result if all of the layers have a\n grey-scale color table, or if each layer's color table uses the\n hue appropriate to the layer.\n  scale \n Selects a scale for the output map.\n USAGE:\t scale   scale \n The scale can be selected either as:\n   \n  a relative ratio, e.g. 1:25000;\n   \n  an absolute width of the printed map, e.g. 10 inches;\n   \n  the number of printed paper panels, e.g. 3 panels\n  .I \n (at the present time, only 1 panel is supported);\n   \n  the number of miles per inch, e.g. 1 inch equals 4 miles.\n This example would set the scale of the map to 1 unit = 25000\n units.\n EXAMPLE:\t\n \t scale  1:25000\n  scalebar \n Draws a scalebar on the map.\n USAGE:\t scalebar  [f|s]\n \t where  x y\n \t length  overall distance in map units\n \t units  [auto|meters|kilometers|feet|miles|nautmiles]\n \t height  scale height in inches\n \t segment  number of segments\n \t numbers  #\n \t fontsize  font size\n \t background  [Y|n]\n \t end \n Draw one of two types of scale bar.\n Fancy (f) draws alternating black and white scale boxes.\n Simple (s) draws a plain line scale. The default type is fancy.\n The subsection instructions allow the user to set  where  the scalebar\n is placed, the  length  of the scalebar (in geographic coordinate\n system units, or those given by  units ),\n the  height  of the scalebar in inches, and the number of\n  segments  (or tics for simple). The  number  of annotations\n numbers every n-th segment.\n The  background  command can turn off the background box for the text.\n  The scalebar  length  is the only required argument. The defaults are a\n fancy scalebar with 4 segments, each segment labeled, and a height of 0.1\n inches. The default location is 2 inches from the top of the page and\n halfway across.\n  NOTE: The scalebar is centered on the location given.\n  This example draws a simple scalebar 1000 meters (for a metered database,\n like UTM) long, with tics every 200 meters, labeled every second tic.\n The scalebar is drawn 5 inches from the top and 4 inches from the left\n and is 0.25 inches high.\n EXAMPLE:\n \t scalebar  s\n \t where  4 5\n \t length  1000\n \t height  0.25\n \t segment  5\n \t numbers  2\n \t end \n  setcolor \n Overrides the color assigned to one or more categories\n of the raster map layer.\n USAGE:\t setcolor  cat(s) color\n This example would set the color for categories 2,5 and 8 of the raster\n map layer  watersheds  to white and category 10 to green.\n ( NOTE : no spaces are inserted between the category values.)\n EXAMPLE:\t\n \t raster  watersheds\n \t setcolor  2,5,8 white\n \t setcolor  10 green\n Of course,  setcolor \n can be requested more than once to override the default color for additional\n categories.  More than one category can be changed for each request by listing\n all the category values separated by commas (but with no spaces). Also ranges\n can be included, for example \"1,2,6-10,12\". Colors for \" null \" and the\n \" default \" (i.e. out-of-range) color may also be reassigned.\n  text \n Places text on the map.\n USAGE:\t text   east north text\n \t text   x% y% text\n \t font  fontname\n \t color  color|none\n \t width  #\n \t hcolor  color|none\n \t hwidth  #\n \t background  color|none\n \t border  color|none\n \t fontsize  font size\n \t size  #\n \t ref  reference point\n \t rotate  degrees CCW\n \t xoffset  #\n \t yoffset  #\n \t opaque  [y|n]\n \t end \n The user specifies where the text will be placed by\n providing map coordinates or percentages of the geographic region.\n The text follows these coordinates on the same instruction line.\n More than one line of text can be specified by notating the end of a line with\n  \\n (e.g. USA \\n  CERL).\n  The user can then specify various text features:\n  font: \n the PostScript font. Common possibilities are listed at the start of this\n help page. The default is  Helvetica .\n  color \n (see  NAMED COLORS );\n  width \n of the lines used to draw the text to make thicker letters\n (accepts decimal points [floating points] as well as integers);\n  size  and  fontsize. \u00a0\n  size  gives the vertical height of the letters in meters on the\n ground (text size will grow or shrink depending on the scale at which\n the map is painted). Alternatively  fontsize  can set the font\n size directly. If neither  size  or  fontsize  is given, a \n default font size of 10 will be used;\n  the highlight color ( hcolor ) and\n the width of the highlight color ( hwidth );\n  the text-enclosing-box  background  color;\n the text box  border  color;\n  ref. \n This reference point specifies the text handle - what\n part of the text should be placed on the location specified by the map\n coordinates.  Reference points can refer to:\n [lower|upper|center] [left|right|center] of the text to be printed;\n The default is center center, i.e. the text is centered on the reference point.\n  rotate \n sets the text rotation angle, measured in degrees counter-clockwise.\n  yoffset ,\n which provides finer placement of text by shifting the\n text a vertical distance in points (1/72\") from the specified north.\n The vertical offset will shift the location to the south if positive,\n north if negative;\n  xoffset ,\n which shifts the text a horizontal distance in points from\n the specified east The horizontal offset will shift the location east if \n positive, west if negative;\n  opaque ,\n whether or not the text should be  opaque  to vectors.  Entering  no \n to the opaque option will allow the user to see any vectors which go\n through the text's background box.  Otherwise, they will end at the box's edge.\n The following example would place the text  SPEARFISH LAND COVER \n at the coordinates E650000 N7365000. The text would be a total of\n 3 points wide (2 pixels of red text and 1 pixel black highlight), have a white\n background enclosed in a red box, and be 500 meters in size.  The lower right\n corner of the text would be centered over the coordinates provided.  All\n vectors on the map would stop at the border of this text.\n EXAMPLE:\t\n \t text  650000 7365000 SPEARFISH LAND COVER\n \t font  romand\n \t color  red\n \t width  2\n \t hcolor  black\n \t hwidth  1\n \t background  white\n \t border  red\n \t size  500\n \t ref  lower left \n \t opaque  y\n \t end \n  vareas \n Selects a vector map layer for output and plots areas.\n USAGE:\t vareas  vectormap\n \t layer  # (layer number used with cats/where option)\n \t cats  list of categories (e.g. 1,3,5-7)\n \t where  SQL where statement\n \t masked  [y|n]\n \t color  color\n \t fcolor  color\n \t rgbcolumn  column\n \t width  #\n \t label  label to use in legend\n \t lpos  position in legend\n \t pat  pattern file\n \t pwidth  #\n \t scale  #\n \t end \n The user can specify:\n  color  - color of the vector lines or area boundaries;\n  fcolor  - the area fill color;\n  rgbcolumn  - name of color definition column used for the area fill color;\n  width  - width of the vectors lines or area boundaries in points\n (accepts decimal points [floating points] as well as integers);\n  masked  - whether or not the raster map layer is to be masked\n by the current mask;\n (see manual entry  r.mask \n for more information on the mask)\n  cats  - which categories should be plotted (default is all);\n  where  - select features using a SQL where statement.\n For example:  vlastnik = 'Cimrman' ;\n  label  - for description in  vlegend .\n Default is: map(mapset);\n  lpos  - position vector is plotted in legend. If lpos is\n 0 then this vector is omitted in legend. If more vectors used the \n same lpos then their symbols in legend are merged and label for\n first vector is used.\n  pat  - full path to pattern file. The pattern file contains header and\n simple PostScript commands. It is similar to EPS but more limited, meaning that\n while each pattern file is a true EPS file, most EPS files are not useful as pattern\n files because they contain restricted commands. Color   of patterns\n are set by  fcolor  (red, green, ..., none, R:G:B) . Color of the boundaries remain set\n by the  color  instruction.\n Pattern may be scaled with the  scale  command. Several standard hatching\n patterns are provided in  $GISBASE/etc/paint/patterns/ .\n Demonstrative images can be found on the\n  GRASS Wiki site .\n You can also create your own custom pattern files in a text editor. \n Example of pattern file:\n %!PS-Adobe-2.0 EPSF-1.2\n %%BoundingBox: 0 0 10 10\n newpath\n 5 0 moveto\n 5 10 lineto\n stroke\n  scale  - pattern scale\n  pwidth  - pattern line width, width is used by pattern until the width is overwritten\n in pattern file.\n EXAMPLE:\t\n \t vareas  forest\n \t color  blue\n \t width  1\n \t masked  y\n \t cats  2,5-7\t\n \t end \n  vlines \n Selects a vector map layer for output and plots lines.\n USAGE:\t vlines  vectormap\n \t type  line and/or boundary\n \t layer  # (layer number used with cats/where option)\n \t cats  list of categories (e.g. 1,3,5-7)\n \t where  SQL where statement like: vlastnik = 'Cimrman'\n \t masked  [y|n]\n \t color  color\n \t rgbcolumn  column\n \t width  #\n \t cwidth  #\n \t hcolor  color\n \t hwidth  #\n \t offset  #\n \t coffset  #\n \t ref  left|right\n \t style  00001111\n \t linecap  style\n \t label  label\n \t lpos  #\n \t end \n The user can specify:\n  type  - the default is lines only;\n  color  - color of the vector lines or area boundaries;\n  rgbcolumn  - name of color definition column used for the vector lines\n or area boundaries;\n  width  - width of the vectors lines or area boundaries in points\n (accepts decimal points [floating points] as well as integers);\n  cwidth  - width of the vectors lines. If cwidth is used then \n width of line is equal to cwidth * category value and width is \n used in legend;\n  hcolor  - the highlight color for the vector lines;\n  hwidth  - the width of the highlight color in points;\n  offset  (experimental) - offset for the vectors lines in points (1/72\")\n for plotting parallel lines in distance equal to offset (accepts positive or \n negative decimal points). Useful to print streets with several parallel lanes;\n  coffset  (experimental) - offset for the vectors lines. If coffset\n is used then  offset of line is equal to coffset * category value and offset\n is used in legend;\n  ref  (experimental) - line justification. \n  masked  - whether or not the raster map layer is to be masked\n by the current mask;\n (see manual entry  r.mask \n for more information on the mask);\n  style  - the line style allows the vectors to be dashed in different\n patterns.  This is done by either typing \"solid\", \"dashed\", \"dotted\", or\n \"dashdotted\", or as a series of 0's and 1's in a desired sequence or pattern.\n The first block of repeated zeros or ones represents \"draw\", the second\n block represents \"blank\".\n An even number of blocks will repeat the pattern, an odd number of blocks\n will alternate the pattern.\n The default is \"solid\";\n  linecap  - the linecap specifies the look of the ends of the line,\n or the end of the dashes in a dashed line. The parameters are:\n 'butt' for butt caps (default), 'round' for round caps and 'extended_butt'\n for extended butt caps. The shape of the round and the extended butt caps\n is related to the line thickness: for round butts the radius is half the\n linewidth, while for extended butt the line will extend for half the linewidth.  \n  cats  - which categories should be plotted (default is all);\n  label  - for description in  vlegend .\n Default is: map(mapset);\n  lpos  - position vector is plotted in legend. If lpos is\n 0 then this vector is omitted in legend. If more vectors used the \n same lpos then their symbols in legend are merged and label for\n first vector is used.\n EXAMPLE:\t\n \t vlines  streams\n \t color  blue\n \t width  2\n \t hcolor  white\n \t hwidth  1\n \t masked  y\n \t cats  2\t\n \t label  Streams - category 2\n \t end \n  vpoints \n Selects vector point data to be placed on the output map\n USAGE:\t vpoints  vectormap\n \t type  point and/or centroid\n \t layer  # (layer number used with cats/where/sizecol options)\n \t cats  list of categories (e.g. 1,3,5-7)\n \t where  SQL where statement like: vlastnik = 'Cimrman'\n \t masked  [y|n]\n \t color  color\n \t fcolor  color\n \t rgbcolumn  column\n \t width  #\n \t eps  epsfile\t\n \t symbol  symbol group/name\t\n \t size  #\n \t sizecolumn  attribute column used for symbol sizing\n \t scale  scaling factor for sizecolumn values\n \t rotate  #\n \t rotatecolumn  column\n \t label  legend label\n \t lpos  position in legend\n \t end \n The user may specify the\n the  color  of the sites (see section on  NAMED COLORS );\n either the GRASS  symbol  or\n the  eps  Encapsulated Postscript file to be used to represent the presence of a site\n (if ' $ ' is used in the EPS file path it will be replaced by category number); \n and  rotate  (in degrees) for counter-clockwise rotation.\n The size of the icon (number of times larger than the size it is in\n the icon file) is typically given by the  size  option. Alternatively\n the size of the symbol or EPS graphic can be taken from an attribute column \n by using the  sizecolumn  command. The value given by  sizecolumn  may be\n scaled by using the  scale  factor setting (default scaling is 1.0).\n In a similar manner symbol color can be read from  rgbcolumn \n and the rotation angle read from  rotatecolumn .\n EXAMPLE:\n \t vpoints  windmills\n \t color  blue\n \t symbol  mills/windmill\n \t size  10\n \t end \n  vlegend \n Prints the portion of the map legend containing the \n vector information, on or below the map.\n USAGE:\t vlegend \n \t where  x y\n \t font  font name\n \t fontsize  font size\n \t width  width of color symbol\n \t cols  number of columns to print\n \t span  column separation\n \t border  color|none\n \t end \n The default location is immediately below the legend containing the\n scale, grid and region information, starting at the left edge of the map.\n If the  where  instruction is present and  y  is less than or\n equal to zero, the vector legend will be positioned immediately below\n the map, starting  x  inches from the left edge of the page.\n  width  is the width in inches of the color symbol (for lines)\n in front of the legend text. The default is 1/24 * fontsize inches.\n  cols  is the number of columns to split the legend into. The\n default is one column. The maximum number of columns is 10, or equal\n to the number of legend entries if there are less than 10 entries.\n  span  is the column separation distance between the left edges of\n two columns in a multicolumn legend. It is given in inches.\n The default is automatic scaling based on the left margin and the right\n hand side of the map box.\n  border  will draw a border around the legend using the specified color.\n  (see  NAMED COLORS )\n  Alternatively, the user can create a custom legend by using the \n  rectangle ,  point , and \n  text  instructions.\n  See also the  colortable  command for creating\n raster map legends.\n  This example prints the vector legend\n immediately below the map and starting 4.5 inches from the left edge\n of the page, using a 12/72 inch Helvetica font.\n EXAMPLE:\t\n \t vlegend \n \t where  4.5 0\n \t font  Courier\n \t fontsize  12\n \t end \n  end \n Terminates input and begin painting the map.\n USAGE:\t end \n  EXAMPLES \n The following are examples of  ps.map  script files.\n  Simple example \n The file has been named  simple_map.txt :\n  # this ps.map example draws a map of Wake county, NC \n  raster  elevation\n  vlines  roadsmajor\n    color  30:144:255\n    width  2\n    end \n  text  50% 105% Wake County Terrain and Roads\n     size  550\n     end \n  end \n Generate map as Postsript file:\n ps.map input=simple_map.txt output=simple_map.ps\n  Figure: Result of for the a simple Wake county terrain and roads example \n  More complicated example \n The following is content of a file named  elevation_map.txt :\n  # this ps.map example draws a map of Wake county, NC \n  raster  elevation\n  colortable  y\n    where  1 6.0\n    cols  4\n    width  4\n    font  Helvetica\n    end \n  setcolor  6,8,9 white\n  setcolor  10 green\n  vlines  streams\n    width  0.1\n    color  blue\n    masked  n\n    label  streams\n    end \n  vlines  roadsmajor\n    width  1.5\n    style  1111\n    color  grey\n    masked  n\n    label  major roads\n    end \n  vlegend \n    where  4.5 0\n    font  Courier\n    fontsize  8\n    end \n  text  30% 100% Wake County Terrain\n    color  black\n    width  1\n    background  white\n    size  550\n    ref  lower left\n    end \n  text  92% -25% meters\n    color  black\n    width  1\n    background  white\n    size  550\n    ref  lower left\n    end \n  scale  1:125000\n  scalebar  f\n    where  1.5 5.5\n    length  5000\n    height  0.05\n    segment  5\n    numbers  5\n    end \n  geogrid  60 s\n    color  gray\n    numbers  2 black\n    end \n  paper  a4\n     end \n  end \n This script file can be entered at the command line:\n # First set the region\n g.region raster=elevation\n # Generate map as Postsript file\n ps.map input=elevation_map.txt output=elevation.ps\n  Figure: Result of for the more complicated Wake county, NC example \n  More examples can be found on the\n  GRASS Wiki \n help site.\n  CHANGES BETWEEN VERSION 5.0.x/5.4.x and 6.0 \n  Devices and ps.select do not exist any more. Paper is defined by the\n  paper  instruction.  \n  vpoints  are used instead of  sites  (points are read from vector). \n  vector  is substituted by  vpoints ,  vlines  and  vareas . \n  Symbols are used instead of icons (different format and directory). \n  Map legend can be printed in columns. \n ", "see_also": ["g.gui.psmap", "g.region", "v.label", "wxGUI"], "authors": ["Paul Carlson, USDA, SCS, NHQ-CGIS"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/ps/ps.map"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/m.transform.html", "name": "m.transform", "definition": "- Computes a coordinate transformation based on the control points.", "keywords": ["miscellaneous", "transformation", "GCP"], "synopsis": "m.transform [-srx] group=name order=integer  [format=string[,string,...]]   [input=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Display summary information Reverse transform of coords file or coeff. dump Target east,north coordinates to local x,y Display transform matrix coefficients Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Reverse transform of coords file or coeff. dump Target east,north coordinates to local x,y Display transform matrix coefficients Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "x", "flag": "-x", "explanation": "Display transform matrix coefficients Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": false, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": false, "explanation": "Rectification polynomial order", "defaultValue": "1", "alternatives": ["1-3"], "isInputFile": false, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Output format", "defaultValue": "fd,rd", "alternatives": ["idx", "src", "dst", "fwd", "rev", "fxy", "rxy", "fd", "rd"], "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "File containing coordinates to transform (\"-\" to read from stdin)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}], "description": "\n  m.transform  is an utility to compute transformation\n based upon GCPs and output error measurements.\n If coordinates are given with the  input  file option or fed from \n  stdin , both the input and the output format is \"x y\" with one \n coordinate pair per line. Reverse transform is performed with the \n  -r  flag.\n The  format  option determines how control points are printed out. \n A summary on the control points can be printed with the  -s  flag. \n The summary includes maximum deviation observed when transforming GCPs \n and overall RMS. The  format  option is ignored when coordinates \n are given with the  input  file option.\n ", "notes": "\n The transformations are:\n  order=1:\n     e = [E0 E1][1].[1]\n         [E2  0][e] [n]\n    \n     n = [N0 N1][1].[1]\n         [N2  0][e] [n]\n order=2:\n     e = [E0 E1 E3][1 ] [1 ]\n         [E2 E4  0][e ].[n ]\n         [E5  0  0][e\u00b2] [n\u00b2]\n    \n     n = [N0 N1 N3][1 ] [1 ]\n         [N2 N4  0][e ].[n ]\n         [N5  0  0][e\u00b2] [n\u00b2]\n order=3:\n     e = [E0 E1 E3 E6][1 ] [1 ]\n         [E2 E4 E7  0][e ].[n ]\n         [E5 E8  0  0][e\u00b2] [n\u00b2]\n         [E9  0  0  0][e\u00b3] [n\u00b3]\n    \n     n = [N0 N1 N3 N6][1 ] [1 ]\n         [N2 N4 N7  0][e ].[n ]\n         [N5 N8  0  0][e\u00b2] [n\u00b2]\n         [N9  0  0  0][e\u00b3] [n\u00b3]\n [\".\" = dot-product, (AE).N = N'EA.]\n  In other words, order=1 and order=2 are equivalent to order=3 with\n the higher coefficients equal to zero.\n ", "see_also": ["i.rectify", "v.rectify", "v.transform"], "authors": ["Brian J. Buckley"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/misc/m.transform"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/m.proj.html", "name": "m.proj", "definition": "- Converts coordinates from one projection to another (cs2cs frontend).", "keywords": ["miscellaneous", "projection", "transformation"], "synopsis": "m.proj [-iodec]  [coordinates=east,north]   [input=name]   [output=name]   [separator=character]   [proj_in=string]   [proj_out=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Use LL WGS84 as input and current location as output projection Use current location as input and LL WGS84 as output projection Output long/lat in decimal degrees, or other projections with many decimal places Include input coordinates in output file Include column names in output file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Use current location as input and LL WGS84 as output projection Output long/lat in decimal degrees, or other projections with many decimal places Include input coordinates in output file Include column names in output file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Output long/lat in decimal degrees, or other projections with many decimal places Include input coordinates in output file Include column names in output file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Include input coordinates in output file Include column names in output file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Include column names in output file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Input coordinates to reproject", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input coordinate file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output coordinate file (omit to send to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator (format: input[,output])", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "proj_in", "flag": "proj_in", "dataType": "String", "optional": true, "explanation": "Input projection parameters (PROJ.4 style)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "proj_out", "flag": "proj_out", "dataType": "String", "optional": true, "explanation": "Output projection parameters (PROJ.4 style)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This program allows a user to convert coordinates from one projection\n to another. Coordinates can be read from one file, converted, and\n results written to another file. Alternatively, if the  input=- ,\n eastings and northings may be passed to the program directly from\n standard input. If the  output  option is omitted, the results\n are sent directly to standard output. In this way  m.proj  can\n be used as a simple frontend to\n the  PROJ.4 \n  cs2cs  utility. The  -i  or  -o  flags make the task\n especially easy for the common problem of converting to or from lat/long\n WGS84.\n  Note : This program does not transform GRASS maps, it is\n designed to determine the equivalent coordinate values of an\n individual position or list of\n positions. Use  v.proj  to reproject\n vector maps or  r.proj  for raster maps.\n ", "notes": "\n  cs2cs  expects input data to formatted as  x y , so if\n working with latitude-longitude data be sure to send the  x \n value first, i.e.,  longitude\u00a0latitude . Output data will\n be exported using the same convention.\n  cs2cs  will treat a third data column as a  z  value\n (elevation) and will modify the value accordingly. This usually\n translates into small but real differences in that data column.\n  cs2cs  does not expect the input stream to contain column\n headings, only numbers. If your data file has lines you wish to have\n passed through without being processed, they must start with the\n ' # ' character.\n If sending  m.proj  data from standard input, be aware that the\n data is first stored to a temporary file before being processed\n with  cs2cs .  It is therefore not advisable to\n send  m.proj  data from an open data stream. The module will\n stop listening for incoming data after 2 seconds of inactivity. You\n may use the projection parameters gleaned from  m.proj 's\n verbose mode ( --verbose ) with  cs2cs  directly in this case.\n Custom projection parameters can be used via the  proj_in  and\n  proj_out  options. Full documentation of the projection\n parameter format may be found on\n the  PROJ.4  website. Using\n these options will fully override the default parameters the module\n would normally use.\n By using the  --verbose  verbose flag, the user can see exactly\n what projection parameters will be used in the conversion as well as\n some other informative messages.\n If output is to lat/long, it will be formatted using PROJ.4's\n Degree:Minute:Second (DMS) convention\n of  DDDdMM'SSS.SS\"H . This can be handy if you wish to quickly\n convert lat/long decimal degree data into its DMS equivalent. \n Alternatively, to have  m.proj  output data in decimal degrees,\n use the  -d  flag. This flag can also be used with non-lat/long\n data to force a higher number of decimal places (the  cs2cs \n default is 2).\n Note that Lat/long output can be converted to GRASS's DMS convention\n ( DDD:MM:SSS.SSSH ) by piping the results of  m.proj \n through the  sed  stream editor as follows.\n m.proj -o ... | sed -e 's/d/:/g' -e \"s/'/:/g\"  -e 's/\"//g'\n  EXAMPLES \n The examples are suitable for the North Carolina sample dataset if not\n stated otherwise:\n  Reproject vector point coordinate pairs to Long/Lat WGS84 \n The  m.proj  module is designed to work seamlessly with point\n data exported from the GIS\n with  v.out.ascii , as the\n following example shows.\n # Long/Lat WGS84 output in DMS\n v.out.ascii bridges | m.proj -o input=-\n # Long/Lat WGS84 output in decimal degree\n v.out.ascii bridges | m.proj -o -d input=-\n  Reproject Long/Lat WGS84 coordinate pair to current map projection \n To convert a Long/Lat WGS84 coordinate pair to the current map projection\n using the  -i  flag which sets the target projection parameters\n automatically from the current location definition:\n echo \"-78.61168178 33.92225767\" | m.proj -i input=-\n 645513.47|19180.31|0.00\n The same, but load points from a file named  waypoints.txt  and\n continue on to import the results into a GRASS vector points map in\n the current map projection:\n # check file content\n cat waypoints.txt \n -78.43977824 33.89587173\n -78.54944691 33.88964566\n -78.51078074 33.88141495\n -77.14037951 35.60543020\n # reproject points and generate vector map on the fly\n m.proj -i input=waypoints.txt | v.in.ascii input=- output=test_pnts \n # verify result\n v.db.select test_pnts cat|dbl_1|dbl_2|dbl_3\n 1|661427.74|16329.14|0\n 2|651285.43|15586.79|0\n 3|654867.21|14690.64|0\n 4|778074.58|207402.6|0\n  Custom projection parameter usage \n To transform points from a UTM projection (here specified with detailed\n projection definition rather than using an EPSG code) into the\n Gauss-Kr\u00fcger Grid System, importing from and exporting to files:\n m.proj proj_in=\"+proj=utm +name=utm +a=6378137.0 +es=0.006694380 \n      +zone=32 +unfact=1.0\" proj_out=\"+proj=tmerc +name=tmerc \n      +a=6377397.155 +es=0.0066743720 +lat_0=0.0 +lon_0=9.0 +k=1.0 \n      +x_0=3500000.0\" input=utm.coord.txt output=new.gk.coord.txt\n Projection parameters provided in the above case:  +proj \n (projection type),  +name  (projection name),  +a \n (ellipsoid: equatorial radius),  +es  (ellipsoid:\n eccentricity squared),  +zone  (zone for the area),\n  +unfact  (conversion factor from meters to other units,\n e.g. feet),  +lat_0  (standard parallel),  +lon_0 \n (central meridian),  +k  (scale factor) and  +x_0 \n (false easting). Sometimes false northing is needed which is coded as\n  +y_0 .  Internally, the underlying\n  PROJ.4  projection library\n performs an inverse projection to latitude-longitude and then projects\n the coordinate list to the target projection.\n   Datum conversions are automatically handled by the\n PROJ.4 library if\n  +datum  setings are specified on  both  the input  and  output\n projections on the command line. The  +towgs84  parameter can be used to \n define either 3 or 7 term datum transform coefficients, satisfying this requirement.\n  If a datum is specified there is no need for the  +ellps=  or underlying\n parameters,  +a= ,  +es= , etc.\n Another custom parameter usage example:\n m.proj proj_in=\"+proj=tmerc +datum=ire65 +lat_0=53.5 +lon_0=-8 +x_0=200000 \n      +y_0=250000 +k=1.000035\" proj_out=\"+proj=ll +datum=wgs84\" input=wpt.txt\n or without datum transformation:\n m.proj proj_in=\"+proj=tmerc +ellps=modif_airy +lat_0=53.5 +lon_0=-8 +x_0=200000 \n      +y_0=250000 +k=1.000035\" proj_out=\"+proj=ll +datum=wgs84\" input=wpt.txt\n In this example no datum transformation will take place as a datum was\n not specified for the input projection. The datum specified for the\n output projection will thus be silently ignored and may be left out;\n all that is achieved a simple conversion from projected to geodetic\n co-ordinates, keeping the same datum (and thus also the same\n ellipsoid).\n For more usage examples, see the documentation for the\n  PROJ.4   cs2cs  program.\n  REFERENCES \n    Evenden, G.I.\n       (1990)  Cartographic\n       projection procedures for the UNIX environment - a user's\n       manual .  USGS Open-File Report 90-284 (OF90-284.pdf) See\n       also there: Interim Report and 2nd Interim Report on Release 4,\n       Evenden 1994). \n    PROJ.4  Cartographic Projection Library \n ", "see_also": ["g.proj", "r.proj", "v.proj", "i.rectify", "v.in.ascii", "v.out.ascii"], "authors": ["M. Hamish Bowman, Dept. Marine Science, Otago University, New Zealand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/m.proj"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/m.nviz.script.html", "name": "m.nviz.script", "definition": "- Creates fly-through script to run in NVIZ.", "keywords": ["miscellaneous", "graphics", "raster", "raster3d", "vector", "visualization"], "synopsis": "m.nviz.script [-fckoe] input=name output=name  [name=string]   [route=east,north[,east,north,...]]  dist=float ht=float frames=integer  [start=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Full render -- Save images Fly at constant elevation (ht) Include command in the script to output a KeyFrame file Render images off-screen Enable vector and sites drawing Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Fly at constant elevation (ht) Include command in the script to output a KeyFrame file Render images off-screen Enable vector and sites drawing Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "k", "flag": "-k", "explanation": "Include command in the script to output a KeyFrame file Render images off-screen Enable vector and sites drawing Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Render images off-screen Enable vector and sites drawing Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Enable vector and sites drawing Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of output script", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "name", "flag": "name", "dataType": "String", "optional": true, "explanation": "Prefix of output images (default = NVIZ)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "route", "flag": "route", "dataType": "String", "optional": true, "explanation": "Route coordinates (east,north)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dist", "flag": "dist", "dataType": "String", "optional": false, "explanation": "Camera layback distance (in map units)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ht", "flag": "ht", "dataType": "String", "optional": false, "explanation": "Camera height above terrain", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "frames", "flag": "frames", "dataType": "String", "optional": false, "explanation": "Number of frames", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start", "flag": "start", "dataType": "String", "optional": true, "explanation": "Start frame number (default=0)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  m.nviz.script  program allows the user to easily create a script\n that can be run in NVIZ to fly through a terrain.\n The NVIZ flight path can be supplied on the command line as comma\n separated coordinates. The program optionally allows a KeyFrame\n file to created (after running the script). This KeyFrame file can\n be loaded into the  Keyframe Animation  panel for fine\n tuning or editing.\n  The script generated by  m.nviz.script  can be run from the NVIZ\n command line (nviz script=script_name) or after NVIZ is started by\n selecting  Scripting->Play Script .\n  OPTIONS \n  Flags: \n  -f \n  Full render\n  The script will draw all loaded NVIZ data and save scene to PPM image.\n  -c \n  Flay at constant elevation\n  With this flag the camera will be set to an elevation given by the\n \t ht=  parameter. The default is to fly at  ht= \n \tabove the topography (i.e. camera height = elevation + ht)\n  -k \n  Output KeyFrame file\n  Generate a KeyFrame file that can be loaded from the NVIZ\n \t Keyframe Animation  panel. The KeyFrame file is\n \tautomatically assigned the script name with a\n \t .kanimator  extension.\n  -o \n  Render the animation in an off-screen context\n  -e \n  Enable vector and sites drawing\n  Parameters: \n  input \n  The name of the GRASS raster map with elevation data. \n  This should be the same file that will be loaded in NVIZ.\n  output \n  The name of the NVIZ script to create.\n  name \n  The prefix for output images if running in full render mode ( -f ).\n  The defulat preifix is NVIZ (eg. NVIZ0000.ppm).\n  dist \n  The distance of the camera behind the center of view.\n  ht \n  The height of the camera above the center of view.\n  If the the  -c  flag is set, the height represents the actual camera height.\n  frames \n  The number of frames in the animation.\n  start \n  The starting frame number (default = 0).\n   This option may be useful in full render mode when creating an\n animation in sections. For example the user may wish to start at frame\n number 2000.\n  route \n  The comma separated geographic coordinates for keyframe locations.\n  EXAMPLE \n To interactively create an NVIZ animation from raster elev.rast with\n 500 frames and the camera set to 50 meters above and 250 meters behind\n the scene, run the following:\n g.region raster=elevation.dem\n d.rast elevation.dem\n m.nviz.script -k input=elevation.dem output=nviz.script dist=2400 ht=1220 frames=1000\n In the above the example the user is prompted to select the route from the GRASS monitor.\n The output script, 'nviz.script.nvscr', can then be run in NVIZ:\n nviz elevation=elevation.dem script=nviz.script.nvscr\n  NOTES / HINTS \n The user must select at least four key-frame locations (points)\n  otherwise an error is generated.\n  If the GRASS region is changed the  m.nviz.script  command must be re-run.\n  The current GRASS region and the user supplied parameters are included\n as a comment at the top of the output script. This information can be\n used to easily re-create the animation.\n  The camera position is calculated backwards from the supplied\n position(s). It is possible that the camera position will lie outside\n the current window, in which case a non-fatal error is generated\n (Error: selected point is outside region).  This error can result in\n jerky movements during the animation.  To correct this problem reduce\n the  dist=  parameter or increase the current region.\n  Loading the script into NVIZ \n The user can run the script at arbitrary resolution. To re-run it at\n higher spatial resolution or different settings, the user first loads\n the surface and sets the resolution, lighting, etc. Then internally\n the script generated by  m.nviz.script  is run. Alternatively, the\n user can run nviz with a previuosly saved state and the\n  m.nviz.script  generated script:\n nviz state=saved.state script=nviz.script.nvscr\n  Keyframe animator script \n Running the script generated by  m.nviz.script  within NVIZ, a new script for\n kanimator (keyframe animator) is created. The kanimator panel offers\n fine tuning of the speed (frame rate) as well as editing individual\n frames or inserting new frames. This new kanimator script has to be\n loaded from the Kanimator panel in NVIZ. In the Kanimator panel there\n are Save and Load button which allow the user to save and re-load a\n kanimator script. Once loaded, the key frames will appear in the GUI\n and can then be edited there.\n ", "notes": "", "see_also": ["wxGUI 3D viewer (NVIZ)"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/misc/m.nviz.script"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/m.nviz.image.html", "name": "m.nviz.image", "definition": "- Creates a 3D rendering of GIS data.", "keywords": ["miscellaneous", "visualization", "graphics", "raster", "vector", "raster3d"], "synopsis": "m.nviz.image [-anb]  [elevation_map=name[,name,...]]   [elevation_value=value[,value,...]]   [color_map=name[,name,...]]   [color=name[,name,...]]   [mask_map=name[,name,...]]   [transparency_map=name[,name,...]]   [transparency_value=value[,value,...]]   [shininess_map=name[,name,...]]   [shininess_value=value[,value,...]]   [emission_map=name[,name,...]]   [emission_value=value[,value,...]]   [mode=string[,string,...]]   [resolution_fine=value[,value,...]]   [resolution_coarse=value[,value,...]]   [style=string[,string,...]]   [shading=string[,string,...]]   [wire_color=name[,name,...]]   [surface_position=x,y,z[,x,y,z,...]]   [vline=name[,name,...]]   [vline_layer=string[,string,...]]   [vline_width=value[,value,...]]   [vline_width_column=name[,name,...]]   [vline_color=name[,name,...]]   [vline_color_column=name[,name,...]]   [vline_mode=string[,string,...]]   [vline_height=value[,value,...]]   [vline_position=x,y,z[,x,y,z,...]]   [vpoint=name[,name,...]]   [vpoint_layer=string[,string,...]]   [vpoint_size=value[,value,...]]   [vpoint_size_column=name[,name,...]]   [vpoint_width=value[,value,...]]   [vpoint_width_column=name[,name,...]]   [vpoint_color=name[,name,...]]   [vpoint_color_column=name[,name,...]]   [vpoint_marker=string[,string,...]]   [vpoint_marker_column=name[,name,...]]   [vpoint_mode=string[,string,...]]   [vpoint_position=x,y,z[,x,y,z,...]]   [volume=name[,name,...]]   [volume_mode=string[,string,...]]   [volume_shading=string[,string,...]]   [volume_position=x,y,z[,x,y,z,...]]   [volume_resolution=value[,value,...]]   [isosurf_level=volume:value[,volume:value,...]]   [isosurf_color_map=name[,name,...]]   [isosurf_color_value=name[,name,...]]   [isosurf_transparency_map=name[,name,...]]   [isosurf_transparency_value=value[,value,...]]   [isosurf_shininess_map=name[,name,...]]   [isosurf_shininess_value=value[,value,...]]   [slice=volume:axis[,volume:axis,...]]   [slice_position=x1,x2,y1,y2,z1,z2[,x1,x2,y1,y2,z1,z2,...]]   [slice_transparency=value[,value,...]]   [bgcolor=name]   [position=x,y]   [height=value]   [perspective=value]   [twist=value]   [zexag=value]   [focus=x,y,z]   [light_position=x,y,z]   [light_color=name]   [light_brightness=integer]   [light_ambient=integer]   [fringe=string[,string,...]]   [fringe_color=name]   [fringe_elevation=integer]   [cplane=value[,value,...]]   [cplane_position=x,y,z[,x,y,z,...]]   [cplane_rotation=value[,value,...]]   [cplane_tilt=value[,value,...]]   [cplane_shading=string]   [arrow_position=x,y]   [arrow_size=value]   [arrow_color=name]  output=name format=string size=width,height  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Use draw mode for all loaded surfaces Toggles normal direction of all isosurfaces (changes light effect) Draw volume box Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Toggles normal direction of all isosurfaces (changes light effect) Draw volume box Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Draw volume box Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation_map", "flag": "elevation_map", "dataType": "String", "optional": true, "explanation": "Name of raster map(s) for elevation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elevation_value", "flag": "elevation_value", "dataType": "String", "optional": true, "explanation": "Constant elevation value(s) to use instead of a raster DEM", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color_map", "flag": "color_map", "dataType": "String", "optional": true, "explanation": "Name of raster map(s) for color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Color value(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mask_map", "flag": "mask_map", "dataType": "String", "optional": true, "explanation": "Name of raster map(s) for mask", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "transparency_map", "flag": "transparency_map", "dataType": "String", "optional": true, "explanation": "Name of raster map(s) for transparency", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "transparency_value", "flag": "transparency_value", "dataType": "String", "optional": true, "explanation": "Transparency value(s)", "defaultValue": null, "alternatives": ["0-255"], "isInputFile": false, "isOutputFile": false}, {"parameter": "shininess_map", "flag": "shininess_map", "dataType": "String", "optional": true, "explanation": "Name of raster map(s) for shininess", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "shininess_value", "flag": "shininess_value", "dataType": "String", "optional": true, "explanation": "Shininess value(s)", "defaultValue": null, "alternatives": ["0-255"], "isInputFile": false, "isOutputFile": false}, {"parameter": "emission_map", "flag": "emission_map", "dataType": "String", "optional": true, "explanation": "Name of raster map(s) for emission", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "emission_value", "flag": "emission_value", "dataType": "String", "optional": true, "explanation": "Emission value(s)", "defaultValue": null, "alternatives": ["0-255"], "isInputFile": false, "isOutputFile": false}, {"parameter": "mode", "flag": "mode", "dataType": "String", "optional": true, "explanation": "Draw mode", "defaultValue": "fine", "alternatives": ["coarse", "fine", "both"], "isInputFile": false, "isOutputFile": false}, {"parameter": "resolution_fine", "flag": "resolution_fine", "dataType": "String", "optional": true, "explanation": "Fine resolution", "defaultValue": "6", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "resolution_coarse", "flag": "resolution_coarse", "dataType": "String", "optional": true, "explanation": "Coarse resolution", "defaultValue": "9", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "style", "flag": "style", "dataType": "String", "optional": true, "explanation": "Draw style", "defaultValue": "surface", "alternatives": ["wire", "surface"], "isInputFile": false, "isOutputFile": false}, {"parameter": "shading", "flag": "shading", "dataType": "String", "optional": true, "explanation": "Shading", "defaultValue": "gouraud", "alternatives": ["flat", "gouraud"], "isInputFile": false, "isOutputFile": false}, {"parameter": "wire_color", "flag": "wire_color", "dataType": "String", "optional": true, "explanation": "Wire color", "defaultValue": "136:136:136", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "surface_position", "flag": "surface_position", "dataType": "String", "optional": true, "explanation": "Surface position", "defaultValue": "0,0,0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vline", "flag": "vline", "dataType": "String", "optional": true, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vline_layer", "flag": "vline_layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vline_width", "flag": "vline_width", "dataType": "String", "optional": true, "explanation": "Vector line width", "defaultValue": "2", "alternatives": ["1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vline_width_column", "flag": "vline_width_column", "dataType": "String", "optional": true, "explanation": "Name of width definition column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vline_color", "flag": "vline_color", "dataType": "String", "optional": true, "explanation": "Vector line color", "defaultValue": "blue", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vline_color_column", "flag": "vline_color_column", "dataType": "String", "optional": true, "explanation": "Name of color definition column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vline_mode", "flag": "vline_mode", "dataType": "String", "optional": true, "explanation": "Vector line display mode", "defaultValue": "surface", "alternatives": ["surface", "flat"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vline_height", "flag": "vline_height", "dataType": "String", "optional": true, "explanation": "Vector line height", "defaultValue": "0", "alternatives": ["0-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vline_position", "flag": "vline_position", "dataType": "String", "optional": true, "explanation": "Vector lines position", "defaultValue": "0,0,0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint", "flag": "vpoint", "dataType": "String", "optional": true, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_layer", "flag": "vpoint_layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_size", "flag": "vpoint_size", "dataType": "String", "optional": true, "explanation": "Icon size (map units)", "defaultValue": "100", "alternatives": ["0-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_size_column", "flag": "vpoint_size_column", "dataType": "String", "optional": true, "explanation": "Name of size definition column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_width", "flag": "vpoint_width", "dataType": "String", "optional": true, "explanation": "Icon width", "defaultValue": "2", "alternatives": ["1-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_width_column", "flag": "vpoint_width_column", "dataType": "String", "optional": true, "explanation": "Name of width definition column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_color", "flag": "vpoint_color", "dataType": "String", "optional": true, "explanation": "Icon color", "defaultValue": "blue", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_color_column", "flag": "vpoint_color_column", "dataType": "String", "optional": true, "explanation": "Name of color definition column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_marker", "flag": "vpoint_marker", "dataType": "String", "optional": true, "explanation": "Icon marker", "defaultValue": "sphere", "alternatives": ["x", "box", "sphere", "cube", "diamond", "dec_tree", "con_tree", "aster", "gyro", "histogram"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_marker_column", "flag": "vpoint_marker_column", "dataType": "String", "optional": true, "explanation": "Name of marker definition column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_mode", "flag": "vpoint_mode", "dataType": "String", "optional": true, "explanation": "3D vector point display mode", "defaultValue": "3D", "alternatives": ["surface", "3D"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vpoint_position", "flag": "vpoint_position", "dataType": "String", "optional": true, "explanation": "Vector points position", "defaultValue": "0,0,0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "volume", "flag": "volume", "dataType": "String", "optional": true, "explanation": "Name of 3D raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "volume_mode", "flag": "volume_mode", "dataType": "String", "optional": true, "explanation": "Volume draw mode", "defaultValue": "isosurface", "alternatives": ["isosurface", "slice"], "isInputFile": false, "isOutputFile": false}, {"parameter": "volume_shading", "flag": "volume_shading", "dataType": "String", "optional": true, "explanation": "Volume shading", "defaultValue": "gouraud", "alternatives": ["flat", "gouraud"], "isInputFile": false, "isOutputFile": false}, {"parameter": "volume_position", "flag": "volume_position", "dataType": "String", "optional": true, "explanation": "Volume position", "defaultValue": "0,0,0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "volume_resolution", "flag": "volume_resolution", "dataType": "String", "optional": true, "explanation": "Volume resolution", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "isosurf_level", "flag": "isosurf_level", "dataType": "String", "optional": true, "explanation": "Isosurface level", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "isosurf_color_map", "flag": "isosurf_color_map", "dataType": "String", "optional": true, "explanation": "Name of volume for isosurface color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "isosurf_color_value", "flag": "isosurf_color_value", "dataType": "String", "optional": true, "explanation": "Isosurface color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "isosurf_transparency_map", "flag": "isosurf_transparency_map", "dataType": "String", "optional": true, "explanation": "Name of 3D raster map(s) for isosurface transparency", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "isosurf_transparency_value", "flag": "isosurf_transparency_value", "dataType": "String", "optional": true, "explanation": "Transparency value(s)for isosurfaces", "defaultValue": null, "alternatives": ["0-255"], "isInputFile": false, "isOutputFile": false}, {"parameter": "isosurf_shininess_map", "flag": "isosurf_shininess_map", "dataType": "String", "optional": true, "explanation": "Name of 3D raster map(s) for shininess", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "isosurf_shininess_value", "flag": "isosurf_shininess_value", "dataType": "String", "optional": true, "explanation": "Shininess value(s) for isosurfaces", "defaultValue": null, "alternatives": ["0-255"], "isInputFile": false, "isOutputFile": false}, {"parameter": "slice", "flag": "slice", "dataType": "String", "optional": true, "explanation": "Volume slice parallel to given axis (x, y, z)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "slice_position", "flag": "slice_position", "dataType": "String", "optional": true, "explanation": "Volume slice position", "defaultValue": "0,1,0,1,0,1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "slice_transparency", "flag": "slice_transparency", "dataType": "String", "optional": true, "explanation": "Volume slice transparency", "defaultValue": "0", "alternatives": ["0-255"], "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "position", "flag": "position", "dataType": "String", "optional": true, "explanation": "Viewpoint position (x,y model coordinates)", "defaultValue": "0.84,0.16", "alternatives": ["0.0-1.0"], "isInputFile": false, "isOutputFile": false}, {"parameter": "height", "flag": "height", "dataType": "String", "optional": true, "explanation": "Viewpoint height (in map units)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "perspective", "flag": "perspective", "dataType": "String", "optional": true, "explanation": "Viewpoint field of view (in degrees)", "defaultValue": "40", "alternatives": ["1-180"], "isInputFile": false, "isOutputFile": false}, {"parameter": "twist", "flag": "twist", "dataType": "String", "optional": true, "explanation": "Viewpoint twist angle (in degrees)", "defaultValue": "0", "alternatives": ["-180-180"], "isInputFile": false, "isOutputFile": false}, {"parameter": "zexag", "flag": "zexag", "dataType": "String", "optional": true, "explanation": "Vertical exaggeration", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "focus", "flag": "focus", "dataType": "String", "optional": true, "explanation": "Focus to point on surface (from SW corner in map units)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "light_position", "flag": "light_position", "dataType": "String", "optional": true, "explanation": "Light position (x,y,z model coordinates)", "defaultValue": "0.68,-0.68,0.80", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "light_color", "flag": "light_color", "dataType": "String", "optional": true, "explanation": "Light color", "defaultValue": "white", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "light_brightness", "flag": "light_brightness", "dataType": "String", "optional": true, "explanation": "Light brightness", "defaultValue": "80", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "light_ambient", "flag": "light_ambient", "dataType": "String", "optional": true, "explanation": "Light ambient", "defaultValue": "20", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "fringe", "flag": "fringe", "dataType": "String", "optional": true, "explanation": "Fringe edges", "defaultValue": null, "alternatives": ["nw", "ne", "sw", "se"], "isInputFile": false, "isOutputFile": false}, {"parameter": "fringe_color", "flag": "fringe_color", "dataType": "String", "optional": true, "explanation": "Fringe color", "defaultValue": "grey", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fringe_elevation", "flag": "fringe_elevation", "dataType": "String", "optional": true, "explanation": "Fringe elevation", "defaultValue": "55", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cplane", "flag": "cplane", "dataType": "String", "optional": true, "explanation": "Cutting plane index (0-5)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cplane_position", "flag": "cplane_position", "dataType": "String", "optional": true, "explanation": "Cutting plane x,y,z coordinates", "defaultValue": "0,0,0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cplane_rotation", "flag": "cplane_rotation", "dataType": "String", "optional": true, "explanation": "Cutting plane rotation along the vertical axis", "defaultValue": "0", "alternatives": ["0-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "cplane_tilt", "flag": "cplane_tilt", "dataType": "String", "optional": true, "explanation": "Cutting plane tilt", "defaultValue": "0", "alternatives": ["0-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "cplane_shading", "flag": "cplane_shading", "dataType": "String", "optional": true, "explanation": "Cutting plane color (between two surfaces)", "defaultValue": "clear", "alternatives": ["clear", "top", "bottom", "blend", "shaded"], "isInputFile": false, "isOutputFile": false}, {"parameter": "arrow_position", "flag": "arrow_position", "dataType": "String", "optional": true, "explanation": "Place north arrow at given position \u00a0\u00a0\u00a0\u00a0(in screen coordinates from bottom left corner)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arrow_size", "flag": "arrow_size", "dataType": "String", "optional": true, "explanation": "North arrow size (in map units)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arrow_color", "flag": "arrow_color", "dataType": "String", "optional": true, "explanation": "North arrow color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output image file (without extension)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": false, "explanation": "Graphics file format", "defaultValue": "ppm", "alternatives": ["ppm", "tif"], "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": false, "explanation": "Size (width, height) of output image", "defaultValue": "640,480", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  m.nviz.image  allows users to realistically render multiple\n  surfaces  (raster data) in a 3D space, optionally using\n thematic coloring, draping 2D  vector  data over the surfaces,\n displaying 3D vector data in the space, and visualization\n of  volume  data (3D raster data) from the command line.\n  EXAMPLE \n Render elevation map in a 3D space.\n g.region raster=elevation\n m.nviz.image elevation_map=elevation output=elev perspective=15\n ", "notes": "", "see_also": ["wxGUI 3D viewer"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/misc/m.nviz.image"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/m.measure.html", "name": "m.measure", "definition": "- Measures the lengths and areas of features.", "keywords": ["miscellaneous", "measurement", "distance", "area"], "synopsis": "m.measure [-g] coordinates=east,north[,east,north,...]  [units=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "Coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Units", "defaultValue": null, "alternatives": ["miles", "feet", "meters", "kilometers", "acres", "hectares"], "isInputFile": false, "isOutputFile": false}], "description": "\n  m.measure  provides the user with a way to measure the lengths\n and areas of lines and polygons. Areas can be stated in acres,\n hectares, square miles, square meters and square kilometers.\n  EXAMPLES \n Distance example in a latitude-longitude location (on great circle, i.e. an orthodrome):\n Bonn_DE=\"7.09549,50.73438\"\n Philadelphia_US=\"-75.16379,39.95233\"\n m.measure coordinates=\"$Bonn_DE,$Philadelphia_US\" units=kilometers \n Length:  6217.916452 kilometers\n  Visualization (with d.geodesic) of m.measure distance example \n As an example for the North Carolina sample dataset, here four points\n describing a square of 1000m side length:\n m.measure units=meters \n    coordinates=922000,2106000,923000,2106000,923000,2107000,922000,2107000\n Length:  3000.000000 meters\n Area:    1000000.000000 square meters\n # script style output:\n m.measure -g units=hectares \n    coordinates=922000,2106000,923000,2106000,923000,2107000,922000,2107000\n units=meters,square meters\n length=3000.000000\n area=1000000.000000\n ", "notes": "", "see_also": ["d.geodesic"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/misc/m.measure"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.mfilter.html", "name": "r.mfilter", "definition": "- Performs raster map matrix filter.", "keywords": ["raster", "algebra", "statistics", "filter"], "synopsis": "r.mfilter [-z] input=name output=name filter=name  [repeat=integer]   [title=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Apply filter only to null data values Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "filter", "flag": "filter", "dataType": "String", "optional": false, "explanation": "Path to filter file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "repeat", "flag": "repeat", "dataType": "String", "optional": true, "explanation": "Number of times to repeat the filter", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Output raster map title", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.mfilter  filters the raster  input  to produce the\n raster  output  according to the matrix  filter  designed\n by the user (see  FILTERS  below).\n The filter is applied  repeat  times (default  value  is 1).\n The  output  raster map layer can be given a  TITLE  if desired.\n (This TITLE should be put in quotes if it contains more than one word.)\n With  -z  flag the filter is applied only to null values in\n the input raster map layer.  The non-null category values are not changed.\n Note that if there is more than one filter step, this rule is applied to the\n intermediate raster map layer -- only null category values which result from\n the first filter will be changed.  In most cases this will NOT be the\n desired result. Hence -z should be used only with single step filters.\n The  filter  parameter defines the name of an existing, user-created\n UNIX ASCII file whose contents is a matrix defining the way in which the\n  input  file will be filtered. The format of this file is described\n below, under FILTERS.\n The  repeat  parameter defines the number of times the  filter \n is to be applied to the  input  data.\n  FILTERS \n The  filter  file is a normal UNIX ASCII file designed by the user.\n It has the following format:\n      TITLE      TITLE\n      MATRIX     n\n                   .\n      n lines of n values\n                   .\n      DIVISOR    d\n      TYPE        S/P\n  TITLE \n  A one-line TITLE for the filter.\n If a TITLE was not specified on the command line, it can be specified here.\n This TITLE would be used to construct a TITLE for the resulting raster map\n layer.  It should be a one-line description of the filter.\n  MATRIX \n  The matrix (n x n) follows on the next n lines.   n  must be\n an odd integer greater than or equal to 3.\n The matrix itself consists of n rows of n values.\n The values must be separated from each other by at least 1 blank.\n  DIVISOR \n  The filter divisor is  d .  If not specified, the default is 1.\n If the divisor is zero (0), then the divisor is dependent on the\n category values in the neighborhood\n (see HOW THE FILTER WORKS below).\n  TYPE \n  The filter type.   S  means sequential, while  P  mean parallel.\n If not specified, the default is S.\n Sequential filtering happens in place.  As the filter is applied to the\n raster map layer, the category values that were changed in neighboring\n cells affect the resulting category value of the current\n cell being filtered.\n  Parallel filtering happens in such a way that the original raster\n map layer category values are used to produce the new category value.\n  More than one filter may be specified in the filter file.\n The additional filter(s) are described just like the first.\n For example, the following describes two filters:\n  EXAMPLE FILTER FILE \n       TITLE     3x3 average, non-null data only, followed by 5x5 average\n      MATRIX    3\n      1 1 1\n      1 1 1\n      1 1 1\n      DIVISOR   0\n      TYPE      P\n      MATRIX    5\n      1 1 1 1 1\n      1 1 1 1 1\n      1 1 1 1 1\n      1 1 1 1 1\n      1 1 1 1 1\n      DIVISOR   25\n      TYPE      P\n  HOW THE FILTER WORKS \n The filter process produces a new category value for each cell\n in the input raster map layer by multiplying the category values of the\n cells in the n x n neighborhood around the center cell\n by the corresponding matrix value and adding them together.\n If a divisor is specified, the sum is divided by this divisor.\n (If a zero divisor was specified, then\n the divisor is computed for each cell as the sum of the MATRIX\n values where the corresponding input cell is non-null.)\n If more than one filter step is specified, either because the\n repeat value was greater than one or because the filter file\n contained more than one matrix, these steps are performed\n sequentially. This means that first one filter is applied to\n the entire input raster map layer to produce an intermediate result;\n then the next filter is applied to the intermediate result to\n produce another intermediate result;  and so on, until the\n final filter is applied.  Then the output cell is written.\n ", "notes": "\n If the resolution of the geographic region does not agree with the\n resolution of the raster map layer, unintended resampling of the original\n data may occur.  The user should be sure that the geographic region\n is set properly.\n ", "see_also": ["g.region", "r.clump", "r.neighbors", "r.resamp.filter"], "authors": ["Glynn Clements. Based upon r.mfilter, by Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.mfilter"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.mask.html", "name": "r.mask", "definition": "- Creates a MASK for limiting raster operation.", "keywords": ["raster", "mask"], "synopsis": "r.mask [-ir]  [raster=name]   [maskcats=string]   [vector=name]   [layer=string]   [cats=range]   [where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Create inverse mask Remove existing mask (overrides other options) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Remove existing mask (overrides other options) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Name of raster map to use as mask", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maskcats", "flag": "maskcats", "dataType": "String", "optional": true, "explanation": "Raster values to use for mask", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vector", "flag": "vector", "dataType": "String", "optional": true, "explanation": "Name of vector map to use as mask", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name (vector)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values (vector)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword (vector)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.mask  - Facilitates creation of a raster \"MASK\" map to\n control raster operations.\n The MASK is only applied when  reading  an existing GRASS raster map,\n for example when used in a module as an input map.\n The MASK will block out certain areas of a raster map from analysis and/or\n display, by \"hiding\" them from sight of other GRASS modules. Data falling\n within the bounaries of the MASK can be modified and operated upon by other\n GRASS raster modules; data falling outside the MASK is treated as if it were NULL.\n Because the MASK is actually only a reclass map named \"MASK\", it can be\n copied, renamed, removed, and used in analyses, just like other GRASS\n raster map layers.  The user should be aware that a MASK remains in\n place until a user renames it to something other than \"MASK\", or removes\n it using \" r.mask -r \" or  g.remove .\n Grid cells in the MASK map containing  0  or  NULL \n will replace data with NULL, while cells containing other values will allow\n data to pass through unaltered.\n To restore raster operations to normal (i.e., all cells of the current region),\n remove the MASK file by setting the  -r  remove MASK flag. In this case, a\n dummy value must also be given for the input parameter.\n A MASK also can be removed by using  g.remove \n or by renaming it to any other name with  g.rename .\n ", "notes": "\n The above method for specifying a \"mask\" may seem\n counterintuitive.  Areas inside the MASK are not hidden;\n areas outside the MASK will be ignored until the MASK file\n is removed.\n The MASK is read as an integer map. If MASK is actually a\n floating-point map, the values will be converted to integers using the\n map's quantisation rules (this defaults to round-to-nearest, but can\n be changed with r.quant).\n  r.mask  uses  r.reclass  to create a reclassification of an\n existing raster map and name it  MASK . A reclass map takes up less space, but\n is affected by any changes to the underlying map from which it was created.\n The user can select category values from the input raster to use in the MASK\n with the  maskcats  parameter; if  r.mask  is run from the\n command line, the category values listed in  maskcats  must be quoted\n (see example below).\n Somewhat similar program functions to those performed by\n  r.mask  can be done using  r.mapcalc , \n  g.region , and other commands.\n  EXAMPLES \n The examples are based on the North Carolina sample dataset.\n Create a raster mask, for contraining the calculation of\n univariate statistics of the elevation values for \"lakes\":\n # set computation region to lakes raster map\n g.region raster=lakes -p\n # use lakes as MASK\n r.mask raster=lakes\n # get statistics for elevation pixels of lakes:\n r.univar elevation\n Remove the raster mask (\"MASK\" map) with the -r flag:\n r.mask -r\n Creating a mask from selected categories in the North Carolina\n 'geology_30m' raster map:\n g.region raster=geology_30m -p\n r.category geology_30m\n d.mon wx0\n d.rast geology_30m\n r.mask raster=geology_30m maskcats=\"217 thru 720\"\n d.mon wx0\n d.rast geology_30m\n ", "see_also": ["g.region", "r.mapcalc", "r.reclass", "g.remove", "g.rename"], "authors": ["Michael Barton, Arizona State University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.mask"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.mapcalc.html", "name": "r.mapcalc", "definition": "- Raster map calculator.", "keywords": ["raster", "algebra"], "synopsis": "r.mapcalc [-sl]  [expression=string]   [region=string]   [file=name]   [seed=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Generate random seed (result is non-deterministic) List input and output maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List input and output maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": true, "explanation": "Expression to evaluate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "region", "flag": "region", "dataType": "String", "optional": true, "explanation": "The computational region that should be used.", "defaultValue": "current", "alternatives": ["current", "intersect", "union"], "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "File containing expression(s) to evaluate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "seed", "flag": "seed", "dataType": "String", "optional": true, "explanation": "Seed for rand() function", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.mapcalc  performs arithmetic on raster map layers.\n New raster map layers can be created which are arithmetic expressions\n involving existing raster map layers, integer or floating point constants,\n and functions.\n  Program use \n  r.mapcalc  expression have the form:\n  result =  expression \n  where  result  is the name of a raster map layer\n to contain the result of the calculation and\n  expression  is any legal arithmetic expression involving existing\n raster map layers (except  result  itself), integer or floating point constants,\n and functions known to the calculator.\n Parentheses are allowed in the expression and may be nested to any depth.\n  result  will be created in the user's current mapset.\n As  expression=  is the first option, it is the default. This\n means that passing an expression on the command line is possible\n as long as the expression is quoted and a space is included before the\n first  =  sign.\n Example ('foo' is the resulting map):\n r.mapcalc \"foo = 1\"\n or:\n r.mapcalc 'foo = 1'\n An unquoted expression (i.e. split over multiple arguments) won't\n work, nor will omitting the space before the = sign:\n r.mapcalc 'foo=1'\n Sorry, <foo> is not a valid parameter\n To read command from the file, use file=\n explicitly, e.g.:\n r.mapcalc file=file\n or:\n r.mapcalc file=- < file\n or:\n r.mapcalc file=- <<EOF\n foo = 1\n EOF\n  The formula entered to  r.mapcalc  by the user is recorded both in the\n  result  map title (which appears in the category file for  result )\n and in the history file for  result .\n  Some characters have special meaning to the command shell. If the user\n     is entering input to  r.mapcalc  on the command line, expressions\n     should be enclosed within single quotes. See NOTES, below.\n  Computational regions in r.mapcalc \n     By default  r.mapcalc  uses the current region\n     as computational region that\n     was set with  g.region  for processing.\n     Sometimes it is necessary to use a region that is derived from the\n     raster maps in the expression to set the computational region.\n     This is of high importance for modules that use r.mapcalc internally\n     to process time series of satellite images that all have different\n     spatial extents. A module that requires this feature\n     is  t.rast.algebra .\n     The  region  option of  r.mapcalc \n     was implemented to address this requirement.\n     It allows computing and using a region based on\n     all raster maps in an expression. Three modes are supported:\n      \n         Setting the  region  parameter to  current \n         will result in the use of the current region\n         as computational region. This is the default.\n         The current region can be set with  g.region .\n      \n      \n         The parameter  union  will force r.mapcalc\n         to compute the disjoint union of all regions from raster\n         maps specified in the expression. This\n         computed region will then be used as computational region at runtime.\n         The region of the mapset will not be modified.\n         The smallest spatial resolution\n         of all raster maps will be used for processing.\n      \n      \n         The parameter  intersect  will force r.mapcalc\n         to compute the intersection of all regions from raster\n         maps specified in the expression. This\n         computed region will then be used as computational region at runtime.\n         The region of the mapset will not be modified.\n         The smallest spatial resolution\n         of all raster maps will be used for processing.\n      \n  Operators and order of precedence \n The following operators are supported:\n      Operator   Meaning                    Type        Precedence\n      --------------------------------------------------------------\n      -          negation                   Arithmetic  12\n      ~          one's complement           Bitwise     12\n      !          not                        Logical     12\n      ^          exponentiation             Arithmetic  11\n      %          modulus                    Arithmetic  10\n      /          division                   Arithmetic  10\n      *          multiplication             Arithmetic  10\n      +          addition                   Arithmetic   9\n      -          subtraction                Arithmetic   9\n      <<         left shift                 Bitwise      8\n      >>         right shift                Bitwise      8\n      >>>        right shift (unsigned)     Bitwise      8\n      >          greater than               Logical      7\n      >=         greater than or equal      Logical      7\n      <          less than                  Logical      7\n      <=         less than or equal         Logical      7\n      ==         equal                      Logical      6\n      !=         not equal                  Logical      6\n      &          bitwise and                Bitwise      5\n      |          bitwise or                 Bitwise      4\n      &&         logical and                Logical      3\n      &&&        logical and[1]             Logical      3\n      ||         logical or                 Logical      2\n      |||        logical or[1]              Logical      2\n      ?:         conditional                Logical      1\n (modulus is the remainder upon division)\n  [1] The &&& and ||| operators handle null values differently to other\n operators. See the section entitled  NULL support  below for more\n details.\n  The operators are applied from left to right, with those of higher precedence\n applied before those with lower precedence.\n Division by 0 and modulus by 0 are acceptable and give a NULL result.\n The logical operators give a 1 result if the comparison is true, 0 otherwise.\n  Raster map layer names \n Anything in the expression which is not a number, operator, or function name\n is taken to be a raster map layer name.\n Examples:\n elevation\n x3\n 3d.his\n  Most GRASS raster map layers meet this naming convention.\n However, if a raster map layer has a name which conflicts with the\n above rule, it should be quoted.  For example, the expression\n x = a-b\n  would be interpreted as:  x equals a minus b, whereas\n x = \"a-b\"\n  would be interpreted as:  x equals the raster map layer named  a-b \n  Also\n x = 3107\n  would create  x  filled with the number 3107, while\n x = \"3107\"\n  would copy the raster map layer  3107  to the raster map layer  x .\n  Quotes are not required unless the raster map layer names\n look like numbers or contain operators, OR unless the program\n is run non-interactively.  Examples given here assume the\n program is run interactively.  See NOTES, below.\n  r.mapcalc  will look for the raster map layers according to the\n user's current mapset search path.\n It is possible to override the search path and specify the mapset\n from which to select the raster map layer.\n This is done by specifying the raster map layer name in the form:\n name@mapset\n  For example, the following is a legal expression:\n result = x@PERMANENT / y@SOILS\n  The mapset specified does not have to be in the mapset search path.\n (This method of overriding the mapset search path is common to all\n GRASS commands, not just  r.mapcalc .)\n  The neighborhood modifier \n Maps and images are data base files stored in raster format, i.e.,\n two-dimensional matrices of integer values.\n In  r.mapcalc , maps may be followed by a  neighborhood  modifier that\n specifies a relative offset from the current cell being evaluated.  The format is\n  map[r,c] , where  r  is the row offset and  c  is the column offset.\n For example,  map[1,2]  refers to the cell one row below and two columns\n to the right of the current cell,  map[-2,-1]  refers to the cell\n two rows above and one column to the left of the current cell,\n and  map[0,1]  refers to the cell one column to the right of the current cell.\n This syntax permits the development of neighborhood-type filters within a single\n map or across multiple maps.\n  Raster map layer values from the category file \n Sometimes it is desirable to use a value associated with a category's\n  label  instead of the category value itself.  If a raster\n map layer name is preceded by the  @ \n operator, then the labels in the category file for the raster map layer\n are used in the expression instead of the category value.\n  For example, suppose that the raster map layer  soil.ph \n (representing soil pH values) has a category file with labels as follows:\n cat     label\n ------------------\n 0       no data\n 1       1.4\n 2       2.4\n 3       3.5\n 4       5.8\n 5       7.2\n 6       8.8\n 7       9.4\n  Then the expression:\n result = @soils.ph\n  would produce a result with category values\n 0, 1.4, 2.4, 3.5, 5.8, 7.2, 8.8 and 9.4.\n  Note that this operator may only be applied to raster map layers\n and produces a floating point value in the expression.\n Therefore, the category label must start with a valid number.\n If the category label is integer, it will be represented by\n a floating point number. I the category label does not start\n with a number or is missing, it will be represented by NULL\n (no data) in the resulting raster map.\n  Grey scale equivalents and color separates \n It is often helpful to manipulate the colors assigned to map categories.\n This is particularly useful when the spectral properties of cells have meaning\n (as with imagery data), or when the map category values represent real\n quantities (as when category values reflect true elevation values).\n Map color manipulation can also aid visual recognition, and map printing.\n  The # operator can be used to either convert map category values to their\n grey scale equivalents or to extract the red, green, or blue components\n of a raster map layer into separate raster map layers.\n result = #map\n  converts each category value in  map  to a value in the range 0-255 which\n represents the grey scale level implied by the color for the category.\n If the map has a grey scale color table, then the grey level is what\n #map evaluates to.  Otherwise, it is computed as:\n  0.10 * red + 0.81 * green + 0.01 * blue\n  Alternatively, you can use:\n result = y#map\n  to use the NTSC weightings:\n  0.30 * red + 0.59 * green + 0.11 * blue\n  Or, you can use:\n result = i#map\n  to use equal weightings:\n  0.33 * red + 0.33 * green + 0.33 * blue\n  The # operator has three other forms:  r#map, g#map, b#map.\n These extract the red, green, or blue components in the named raster map,\n respectively.  The GRASS shell script  r.blend  extracts each of these\n components from two raster map layers, and combines them by a user-specified\n percentage.\n These forms allow color separates to be made.  For example, to\n extract the red component from  map \n and store it in the new 0-255 map layer  red ,\n the user could type:\n red = r#map\n  To assign this map grey colors type:\n  r.colors  map=red color=rules\n black\n white\n  To assign this map red colors type:\n  r.colors  map=red color=rules\n black\n red\n  Functions \n The functions currently supported are listed in the table below.\n The type of the result is indicated in the last column.\n  F  means that the functions always results in a floating point value,\n  I  means that the function gives an integer result, and\n  *  indicates that the result is float if any of the arguments to the\n function are floating point values and integer if all arguments are integer.\n function                description                                     type\n ---------------------------------------------------------------------------\n abs(x)                  return absolute value of x                      *\n acos(x)                 inverse cosine of x (result is in degrees)      F\n asin(x)                 inverse sine of x (result is in degrees)        F\n atan(x)                 inverse tangent of x (result is in degrees)     F\n atan(x,y)               inverse tangent of y/x (result is in degrees)   F\n cos(x)                  cosine of x (x is in degrees)                   F\n double(x)               convert x to double-precision floating point    F\n eval([x,y,...,]z)       evaluate values of listed expr, pass results to z\n exp(x)                  exponential function of x                       F\n exp(x,y)                x to the power y                                F\n float(x)                convert x to single-precision floating point    F\n graph(x,x1,y1[x2,y2..]) convert the x to a y based on points in a graph F\n graph2(x,x1[,x2,..],y1[,y2..])\n                         alternative form of graph()                     F\n if                      decision options:                               *\n if(x)                   1 if x not zero, 0 otherwise\n if(x,a)                 a if x not zero, 0 otherwise\n if(x,a,b)               a if x not zero, b otherwise\n if(x,a,b,c)             a if x > 0, b if x is zero, c if x < 0\n int(x)                  convert x to integer [ truncates ]              I\n isnull(x)               check if x = NULL\n log(x)                  natural log of x                                F\n log(x,b)                log of x base b                                 F\n max(x,y[,z...])         largest value of those listed                   *\n median(x,y[,z...])      median value of those listed                    *\n min(x,y[,z...])         smallest value of those listed                  *\n mode(x,y[,z...])        mode value of those listed                      *\n nmax(x,y[,z...])        largest value of those listed, excluding NULLs  *\n nmedian(x,y[,z...])     median value of those listed, excluding NULLs   *\n nmin(x,y[,z...])        smallest value of those listed, excluding NULLs *\n nmode(x,y[,z...])       mode value of those listed, excluding NULLs     *\n not(x)                  1 if x is zero, 0 otherwise\n pow(x,y)                x to the power y                                *\n rand(a,b)               random value x : a <= x < b                     *\n round(x)                round x to nearest integer                      I\n round(x,y)              round x to nearest multiple of y\n round(x,y,z)            round x to nearest y*i+z for some integer i\n sin(x)                  sine of x (x is in degrees)                     F\n sqrt(x)                 square root of x                                F\n tan(x)                  tangent of x (x is in degrees)                  F\n xor(x,y)                exclusive-or (XOR) of x and y                   I\n Internal variables:\n  row()                  current row of moving window                    I\n  col()                  current col of moving window                    I\n  nrows()                number of rows in computation region            I\n  ncols()                number of columns in computation region         I\n  x()                    current x-coordinate of moving window           F\n  y()                    current y-coordinate of moving window           F\n  ewres()                current east-west resolution                    F\n  nsres()                current north-south resolution                  F\n  area()                 area of current cell in square meters           F\n  null()                 NULL value\n Note, that the row() and col() indexing starts with 1.\n  Floating point values in the expression \n Floating point numbers are allowed in the expression. A floating point\n number is a number which contains a decimal point:\n     2.3   12.0   12.   .81\n Floating point values in the expression are handled in a special way.\n With arithmetic and logical operators, if either operand is float,\n the other is converted to float and the result of the operation is float.\n This means, in particular that division of integers results in a\n (truncated) integer, while division of floats results in an accurate\n floating point value.  With functions of type * (see table above),\n the result is float if any argument is float, integer otherwise.\n  Note: If you calculate with integer numbers, the resulting map will\n be integer. If you want to get a float result, add the decimal point\n to integer number(s).\n  If you want floating point division, at least one of the arguments has\n to be a floating point value. Multiplying one of them by 1.0 will\n produce a floating-point result, as will using float():\n       r.mapcalc \"ndvi = float(lsat.4 - lsat.3) / (lsat.4 + lsat.3)\"\n  NULL support \n  Division by zero should result in NULL.\n  Modulus by zero should result in NULL.\n  NULL-values in any arithmetic or logical operation should result\n in NULL. (however, &&& and ||| are treated specially, as described below).\n  The &&& and ||| operators observe the following axioms even when x is NULL:\n \tx &&& false == false\n \tfalse &&& x == false\n \tx ||| true == true\n \ttrue ||| x == true\n  NULL-values in function arguments should result in NULL (however,\n if(), eval() and isnull() are treated specially, as described below).\n  The eval() function always returns its last argument\n  The situation for if() is:\n if(x)\n \tNULL if x is NULL; 0 if x is zero; 1 otherwise\n if(x,a)\n \tNULL if x is NULL; a if x is non-zero; 0 otherwise\n if(x,a,b)\n \tNULL if x is NULL; a if x is non-zero; b otherwise\n if(x,n,z,p)\n \tNULL if x is NULL; n if x is negative;\n z if x is zero; p if x is positive\n  The (new) function isnull(x) returns: 1 if x is NULL;\n 0 otherwise. The (new) function null()\n (which has no arguments) returns an integer NULL.\n  Non-NULL, but invalid, arguments to functions should result in NULL.\n Examples:\n log(-2)\n sqrt(-2)\n pow(a,b) where a is negative and b is not an integer\n  NULL support: Please note that any math performed with NULL cells always\n results in a NULL value for these cells. If you want to replace a NULL cell\n on-the-fly, use the isnull() test function in a if-statement.\n  Example: The users wants the NULL-valued cells to be treated like zeros. To\n add maps A and B (where B contains NULLs) to get a map C the user can use a\n construction like: \n C = A + if(isnull(B),0,B)\n  NULL and conditions: \n  For the one argument form:\n if(x) = NULL\t\tif x is NULL\n if(x) = 0\t\tif x = 0\n if(x) = 1\t\totherwise (i.e. x is neither NULL nor 0).\n  For the two argument form:\n if(x,a) = NULL\t\tif x is NULL\n if(x,a) = 0\t\tif x = 0\n if(x,a) = a\t\totherwise (i.e. x is neither NULL nor 0).\n  For the three argument form:\n if(x,a,b) = NULL\tif x is NULL\n if(x,a,b) = b\t\tif x = 0\n if(x,a,b) = a\t\totherwise (i.e. x is neither NULL nor 0).\n  For the four argument form:\n if(x,a,b,c) = NULL\tif x is NULL\n if(x,a,b,c) = a\t\tif x > 0\n if(x,a,b,c) = b\t\tif x = 0\n if(x,a,b,c) = c\t\tif x < 0\n More generally, all operators and most functions return NULL if *any*\n of their arguments are NULL.\n The functions if(), isnull() and eval() are exceptions.\n The function isnull() returns 1 if its argument is NULL and 0 otherwise.\n If the user wants the opposite, the ! operator, e.g. \"!isnull(x)\" must be\n used.\n  All forms of if() return NULL if the first argument is NULL. The 2, 3\n and 4 argument forms of if() return NULL if the \"selected\" argument is\n NULL, e.g.:\n if(0,a,b) = b\tregardless of whether a is NULL\n if(1,a,b) = a\tregardless of whether b is NULL\n eval() always returns its last argument, so it only returns NULL if\n the last argument is NULL.\n  Note : The user cannot test for NULL using the == operator, as that\n returns NULL if either or both arguments are NULL, i.e. if x and y are\n both NULL, then \"x == y\" and \"x != y\" are both NULL rather than 1 and\n 0 respectively.\n The behaviour makes sense if the user considers NULL as representing an\n unknown quantity. E.g. if x and y are both unknown, then the values of\n \"x == y\" and \"x != y\" are also unknown; if they both have unknown\n values, the user doesn't know whether or not they both have the same value.\n ", "notes": "\n  Usage from command line \n Extra care must be taken if the expression is given on the command line.\n Some characters have special meaning to the UNIX shell.\n These include, among others:\n * ( ) > & |\n  It is advisable to put single quotes around the expression; e.g.:\n 'result = elevation * 2'\n Without the quotes, the *, which has special meaning to the UNIX shell,\n would be altered and  r.mapcalc  would see something other than the *.\n  Multiple computations \n In general, it's preferable to do as much as possible in each\n r.mapcalc command. E.g. rather than:\n         r.mapcalc \"$GIS_OPT_OUTPUT.r = r#$GIS_OPT_FIRST * .$GIS_OPT_PERCENT + (1.0 - .$GIS_OPT_PERCENT) * r#$GIS_OPT_SECOND\"\n         r.mapcalc \"$GIS_OPT_OUTPUT.g = g#$GIS_OPT_FIRST * .$GIS_OPT_PERCENT + (1.0 - .$GIS_OPT_PERCENT) * g#$GIS_OPT_SECOND\"\n         r.mapcalc \"$GIS_OPT_OUTPUT.b = b#$GIS_OPT_FIRST * .$GIS_OPT_PERCENT + (1.0 - .$GIS_OPT_PERCENT) * b#$GIS_OPT_SECOND\"\n  use:\n \tr.mapcalc <<EOF\n         $GIS_OPT_OUTPUT.r = r#$GIS_OPT_FIRST * .$GIS_OPT_PERCENT + (1.0 - .$GIS_OPT_PERCENT) * r#$GIS_OPT_SECOND\n         $GIS_OPT_OUTPUT.g = g#$GIS_OPT_FIRST * .$GIS_OPT_PERCENT + (1.0 - .$GIS_OPT_PERCENT) * g#$GIS_OPT_SECOND\n         $GIS_OPT_OUTPUT.b = b#$GIS_OPT_FIRST * .$GIS_OPT_PERCENT + (1.0 - .$GIS_OPT_PERCENT) * b#$GIS_OPT_SECOND\n         EOF\n  as the latter will read each input map only once.\n  Backwards compatibility \n For the backwards compatibility with GRASS 6,\n if no options are given, it manufactures  file=-  (which reads from\n stdin), so you can continue to use e.g.:\n r.mapcalc < file\n or:\n r.mapcalc <<EOF\n foo = 1\n EOF\n But unless you need compatibility with previous GRASS GIS versions, use  file= \n explicitly, as stated above.\n When the map name contains uppercase letter(s) or a dot which are not\n allowed to be in module option names, the  r.mapcalc  command will\n be valid also without quotes:\n r.mapcalc elevation_A=1\n r.mapcalc elevation.1=1\n However, this syntax is not recommended as quotes as stated above more safe.\n Using quotes is both backwards compatible and valid in future.\n  Interactive input in command line \n For formulas that the user enters from standard input\n (rather than from the command line), a line continuation feature now exists.\n If the user adds a backslash to the end of an input line,  r.mapcalc  assumes that\n the formula being entered by the user continues on to the next input line.\n There is no limit to the possible number of input lines\n or to the length of a formula.\n  If the  r.mapcalc  formula entered by the user is very long,\n the map title will contain only some of it, but most (if not all) of\n the formula will be placed into the history file for the  result  map.\n  Raster MASK handling \n  r.mapcalc  follows the common GRASS behavior of raster MASK handling,\n so the MASK is only applied when reading an existing GRASS raster map.\n This implies that, for example, the command:\n r.mapcalc \"elevation_exaggerated = elevation * 3\"\n create a map respecting the masked pixels if MASK is active.\n However, when creating a map which is not based on any map,\n e.g. a map from a constant:\n r.mapcalc \"base_height = 200.0\"\n the created raster map is limited only by a computation region\n but it is not affected by an active MASK.\n This is expected because, as mentioned above, MASK is only applied when reading,\n not when writing a raster map.\n If also in this case the MASK should be applied, an if() statement including the\n MASK should be used, e.g.:\n r.mapcalc \"base_height = if(MASK, 200.0, null())\"\n When testing MASK related expressions keep in mind that when MASK is active\n you don't see data in masked areas even if they are not NULL.\n See  r.mask  for details.\n  eval function \n If the output of the computation should be only one map\n but the expression is so complex that it is better to split it\n to several expressions, the  eval  function can be used:\n r.mapcalc << EOF\n eval(elev_200 = elevation - 200, \n       elev_5 = 5 * elevation, \n       elev_p = pow(elev_5, 2))\n elevation_result = (0.5 * elev_200) + 0.8 * elev_p\n EOF\n This example uses unix-like  << EOF  syntax to provide\n input to  r.mapcalc .\n Note that the temporary variables (maps) are not created\n and thus it does not matter whether they exists or not.\n In the example above, if map  elev_200  exists it will not be\n overwritten and no error will be generated.\n The reason is that the name  elev_200  now denotes the temporary\n variable (map) and not the existing map.\n The following parts of the expression will use the temporary  elev_200 \n and the existing  elev_200  will be left intact and will not be used.\n If a user want to use the existing map, the name of the temporary variable\n (map) must be changed.\n  Using the same map for input and output results \n A map cannot be used both as an input and as an output as in\n this invalid expression  oldmap = oldmap + 1 , instead\n a subsequent rename using  g.rename  is\n needed when the same name is desired:\n r.mapcalc \"newmap = oldmap + 1\"\n g.rename raster=newmap,oldmap\n  Random number generator initialization \n  The pseudo-random number generator used by the rand() function can\n be initialised to a specific value using the  seed  option.\n This can be used to replicate a previous calculation.\n  Alternatively, it can be initialised from the system time and the\n PID using the  -r  flag. This should result in a different seed\n being used each time.\n  In either case, the seed will be written to the map's history, and\n can be seen using  r.info .\n  If you want other people to be able to verify your results, it's\n preferable to use the  seed  option to supply a seed which is\n either specified in the script or generated from a determenistic process\n such as a pseudo-random number generator given an explicit seed.\n  Note that the rand() function will generate a fatal error if neither\n the  seed  option nor the  -s  flag are given.\n  EXAMPLES \n To compute the average of two raster map layers\n  a  and  b :\n ave = (a + b)/2\n To form a weighted average:\n ave = (5*a + 3*b)/8.0\n To produce a binary representation of the raster map layer\n  a  so that category 0 remains 0 and all other categories become 1:\n mapmask = a != 0\n This could also be accomplished by:\n mapmask = if(a)\n To mask raster map layer  b  by raster map layer  a :\n result = if(a,b)\n To change all values below 5 to NULL:\n newmap = if(map<5, null(), 5)\n To create a map with random values in a defined range (needs either the\n usage of  -s  flag or the  seed  parameter). The precision of\n the input values determines the output precision (the resulting\n  raster map type ):\n # write result as integer map (CELL)\n random_int   = rand(-100,100)\n # write result as double precision floating point map (DCELL)\n random_dcell = rand(-100.0,100.0)\n # write result as double precision floating point map (FCELL)\n random_fcell = float(rand(-100.0,100.0))\n The graph() function allows users to specify a x-y conversion using\n pairs of x,y coordinates.\n In some situations a transformation from one value to another is not\n easily established mathematically, but can be represented by a 2-D\n graph and then linearly interpolated. The graph() function provides\n the opportunity to accomplish this.\n An x-axis value is provided to the graph function along with\n the associated graph represented by a series of x,y pairs.  The x\n values must be monotonically increasing (each larger than or equal to\n the previous).  The graph function linearly interpolates between\n pairs.  Any x value lower the lowest x value (i.e. first) will have\n the associated y value returned.  Any x value higher than the last\n will similarly have the associated y value returned.  Consider the\n request:\n newmap = graph(map, 1,10, 2,25, 3,50)\n X (map) values supplied and y (newmap) values returned:\n 0, 10\n 1, 10\n 1.5, 17.5\n 2.9, 47.5\n 4, 50\n 100, 50\n  KNOWN ISSUES \n The  result  variable on the left hand side of the equation should not\n appear in the  expression  on the right hand side.\n  mymap = if( mymap > 0, mymap, 0) \n  Any maps generated by a  r.mapcalc  command only exist after the entire\n command has completed. All maps are generated concurrently, row-by-row\n (i.e. there is an implicit \"for row in rows {...}\" around the entire expression).\n Thus the  # ,  @ , and  [ ]  operators cannot be used on a map\n generated within same  r.mapcalc  command run.\n Consequently, the following (strikethrough code) does not work:\n newmap = oldmap * 3.14\n  othermap = newmap[-1, 0] / newmap[1, 0] \n  Continuation lines must end with a  \\  and have  no  trailing\n white space (blanks or tabs). If the user does leave white space at the end of\n continuation lines, the error messages produced by  r.mapcalc  will\n be meaningless and the equation will not work as the user intended.\n This is particularly important for the  eval()  function.\n Currently, there is no comment mechanism in  r.mapcalc .\n Perhaps adding a capability that would cause the entire line to be\n ignored when the user inserted a # at the start of a line\n as if it were not present, would do the trick.\n  The function should require the user to type \"end\" or \"exit\" instead\n of simply a blank line. This would make separation of multiple scripts\n separable by white space.\n  r.mapcalc  does not print a warning in case of operations on\n NULL cells. It is left to the user to utilize the  isnull()  function.\n ", "see_also": ["g.region", "r.bitpattern", "r.blend", "r.colors", "r.fillnulls"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.mapcalc"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.simpson.html", "name": "r.li.simpson", "definition": "- Calculates Simpson's diversity index on a raster map", "keywords": ["raster", "landscape structure analysis", "diversity index"], "synopsis": "r.li.simpson input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.simpson  calculates the \"Simpson's diversity index\" as: \n    \n with:\n  i : patch type \n  m : number of different patch types \n  p i : proportional abundance of \n patch type  i   \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the input raster map contains only NULL values then  r.li.simpson \n returns NULL.\n  EXAMPLES \n To calculate Simpson's diversity index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.simpson input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.simpson input=forests conf=movwindow7 out=forests_simpson_mov7\n r.univar forests_simpson_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.simpson input=forests conf=movwindow7 out=forests_simpson_mov7\n # verify\n r.univar forests_simpson_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_simpson_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Serena Pallecchi student of Computer Science University of Pisa (Italy)."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.simpson"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.shape.html", "name": "r.li.shape", "definition": "- Calculates shape index on a raster map", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.shape input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.shape  calculates the landscape shape index as:\n LSI = 0.25 * E / sqrt(A)\n with:\n    E : sum of all edges \n    A : sum of all patch areas \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the input raster map contains only NULL values then  r.li.shape \n returns NULL.\n  EXAMPLES \n To calculate the shape index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.shape input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.shape input=forests conf=movwindow7 out=forests_shape_mov7\n r.univar forests_shape_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.shape input=forests conf=movwindow7 out=forests_shape_mov7\n # verify\n r.univar forests_shape_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_shape_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Claudio Porta and Lucio Davide Spano, students of Computer Science University of Pisa (Italy)."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.shape"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.shannon.html", "name": "r.li.shannon", "definition": "- Calculates Shannon's diversity index on a raster map", "keywords": ["raster", "landscape structure analysis", "diversity index"], "synopsis": "r.li.shannon input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.shannon  calculates the \"Shannon's diversity index\" as: \n    \n with:\n  i : patch type \n  m : number of different patch types \n  p i : proportional abundance of \n patch type  i   \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the input raster map contains only NULL values then  r.li.shannon \n returns NULL.\n  EXAMPLES \n To calculate Shannon's diversity index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.shannon input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.shannon input=forests conf=movwindow7 out=forests_shannon_mov7\n r.univar forests_shannon_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.shannon input=forests conf=movwindow7 out=forests_shannon_mov7\n # verify\n r.univar forests_shannon_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_shannon_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Serena Pallecchi student of Computer Science University of Pisa (Italy)."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.shannon"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.richness.html", "name": "r.li.richness", "definition": "- Calculates richness index on a raster map", "keywords": ["raster", "landscape structure analysis", "diversity index"], "synopsis": "r.li.richness input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.richness  calculates the \"richness diversity index\" as:\n with:\n    m : number of different patch types \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the input raster map contains only NULL values then  r.li.richness \n returns 0. \n  EXAMPLES \n To calculate the richness diversity index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.richness input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.richness input=forests conf=movwindow7 out=forests_richness_mov7\n r.univar forests_richness_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.richness input=forests conf=movwindow7 out=forests_richness_mov7\n # verify\n r.univar forests_richness_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_richness_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Serena Pallecchi student of Computer Science University of Pisa (Italy)."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.richness"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.renyi.html", "name": "r.li.renyi", "definition": "- Calculates Renyi's diversity index on a raster map", "keywords": ["raster", "landscape structure analysis", "diversity index"], "synopsis": "r.li.renyi input=name config=name alpha=string output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "alpha", "flag": "alpha", "dataType": "String", "optional": false, "explanation": "Alpha value is the order of the generalized entropy", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.renyi  calculates the \"Renyi's diversity index\" as: \n    \n with:\n    H : Renyi entropy \n    alpha : order of the generalized entropy \n    i : patch type \n    S : number of different patch types \n    p i : proportional abundance of \n patch type  i   \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the input raster map contains only NULL values then  r.li.renyi \n returns NULL.\n  EXAMPLES \n To calculate Renyi's diversity index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.renyi input=my_map conf=my_conf output=my_out alpha=0.6\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.renyi input=forests conf=movwindow7 out=forests_renyi_mov7_a06 alpha=0.6\n r.univar forests_renyi_mov7_a06\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.renyi input=forests conf=movwindow7 out=forests_renyi_mov7\n # verify\n r.univar forests_renyi_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_renyi_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Luca Delucchi and Duccio Rocchini, Fondazione E. Mach (Italy), based on the"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.renyi"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.pielou.html", "name": "r.li.pielou", "definition": "- Calculates Pielou's diversity index on a raster map", "keywords": ["raster", "landscape structure analysis", "diversity index"], "synopsis": "r.li.pielou input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.pielou   calculates the \"Pielou's diversity index\" as:  \n    \n with:\n    J : Pielou eveness index \n    H' : Shannon index \n    S : number of classes \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the input raster contains NULL value cells,  r.li.pielou \n returns NULL for these cells.\n  EXAMPLES \n To calculate Pielou's diversity index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.pielou input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.pielou input=forests conf=movwindow7 out=forests_pielou_mov7\n r.univar forests_pielou_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.pielou input=forests conf=movwindow7 out=forests_pielou_mov7\n # verify\n r.univar forests_pielou_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_pielou_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Luca Delucchi and Duccio Rocchini, Fondazione E. Mach (Italy), based on the"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.pielou"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.patchnum.html", "name": "r.li.patchnum", "definition": "- Calculates patch number index on a raster map, using a 4 neighbour algorithm.", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.patchnum input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.patchnum  calculates the \"patch number index\" as: \n   f(sample_area)= Patch_Number  \n This index is calculated using a 4 neighbour algorithm, diagonal cells \n are ignored when tracing a patch.\n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the sample area contains only NULL values then it is considered to \n have zero patches.  \n  EXAMPLES \n To calculate patch number index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.patchnum input=my_map conf=my_conf out=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.patchnum input=forests conf=movwindow7 out=forests_patchnum_mov7\n r.univar forests_patchnum_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.patchnum input=forests conf=movwindow7 out=forests_patchnum_mov7\n # verify\n r.univar forests_patchnum_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_patchnum_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Michael Shapiro - CERL (patch identification)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.patchnum"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.patchdensity.html", "name": "r.li.patchdensity", "definition": "- Calculates patch density index on a raster map, using a 4 neighbour algorithm", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.patchdensity input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.patchdensity  calculates the \"patch density index\", \n the number of patches per square kilometer, as:\n PD = Npatch / A\n with:\n    A :sampling area size \n    Npatch : number of patches \n This index is calculated using a 4 neighbour algorithm, diagonal cells \n are ignored when tracing a patch.\n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n A sample area of only NULL values is considered to have zero patches, \n that is, the result is always \u2265 0.\n  EXAMPLES \n To calculate patch density index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.patchdensity input=my_map conf=my_conf output=my_out\n Example for Spearfish forest areas:\n g.region raster=landcover.30m -p\n # extract forested areas:\n r.category landcover.30m\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43, 1, null())\"\n # patch density (7x7 moving window defined in g.gui.rlisetup):\n r.li.patchdensity forests conf=movwindow7 out=forests_p_dens7\n r.univar forests_p_dens7\n d.rast.leg forests_p_dens7\n r.to.vect forests out=forests feature=area\n d.vect forests type=boundary\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.patchdensity input=forests conf=movwindow7 out=forests_patchdensity_mov7\n # verify\n r.univar forests_patchdensity_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_patchdensity_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Michael Shapiro - CERL (patch identification)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.patchdensity"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.padsd.html", "name": "r.li.padsd", "definition": "- Calculates standard deviation of patch area a raster map", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.padsd input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.padsd  calculates the standard deviation of patch \n area sizes in hectares as: \n    \n with: \n    MPS : mean patch area size \n    a i : area of patch i \n    N patch : number of patches \n This index is calculated using a 4 neighbour algorithm, diagonal cells \n are ignored when tracing a patch.\n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n The result is NULL if the sample area contains only NULL values.\n  EXAMPLES \n To calculate patch area distribution standard deviation index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.padsd input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.padsd input=forests conf=movwindow7 out=forests_padsd_mov7\n r.univar forests_padsd_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.padsd input=forests conf=movwindow7 out=forests_padsd_mov7\n # verify\n r.univar forests_padsd_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_padsd_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Michael Shapiro - CERL (patch identification)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.padsd"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.padrange.html", "name": "r.li.padrange", "definition": "- Calculates range of patch area size on a raster map", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.padrange input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.padrange  calculates the range of patch area sizes in \n hectares as: \n    \n with: \n    a max : max patch area size \n    a min : min patch area size \n This index is calculated using a 4 neighbour algorithm, diagonal cells \n are ignored when tracing a patch.\n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the sample area contains only NULL values then  r.li.padrange \n returns NULL. \n  EXAMPLES \n To calculate range of patch area size index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.padrange input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.padrange input=forests conf=movwindow7 out=forests_padrange_mov7\n r.univar forests_padrange_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.padrange input=forests conf=movwindow7 out=forests_padrange_mov7\n # verify\n r.univar forests_padrange_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_padrange_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Michael Shapiro - CERL (patch identification)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.padrange"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.padcv.html", "name": "r.li.padcv", "definition": "- Calculates coefficient of variation of patch area on a raster map", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.padcv input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.padcv  calculates the coefficient of variation of patch \n area sizes in hectares as: \n    \n with: \n   SD : standard deviation of patch area size\n       \n    MPS : mean patch area size  \n    a i : area of patch i \n    N patch : number of patches \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n The result is NULL if the sample area contains only NULL values.\n  EXAMPLES \n To calculate patch area distribution coefficient of variation index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.padcv input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.padcv input=forests conf=movwindow7 out=forests_padcv_mov7\n r.univar forests_padcv_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.padcv input=forests conf=movwindow7 out=forests_padcv_mov7\n # verify\n r.univar forests_padcv_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_padcv_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Michael Shapiro - CERL (patch identification)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.padcv"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.mps.html", "name": "r.li.mps", "definition": "- Calculates mean patch size index on a raster map, using a 4 neighbour algorithm", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.mps input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.mps  (mean patch size) calculates the mean size of the \n patches in the sampling area as: \n MPS = A / Npatch\n with:\n    A :sampling area size without null cells \n    Npatch : number of patches \n The unit of the mean size is hectare.\n This index is calculated using a 4 neighbour algorithm, diagonal cells \n are ignored when tracing a patch.\n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the sample area contains only NULL value cells,  r.li.mps \n returns 0 (zero).  \n  EXAMPLES \n To calculate mean path size index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.mps input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.mps input=forests conf=movwindow7 out=forests_mps_mov7\n r.univar forests_mps_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.mps input=forests conf=movwindow7 out=forests_mps_mov7\n # verify\n r.univar forests_mps_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_mps_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Michael Shapiro - CERL (patch identification)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.mps"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.mpa.html", "name": "r.li.mpa", "definition": "- Calculates mean pixel attribute index on a raster map", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.mpa input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.mpa  (mean pixel attribute) calculates the average value of the\n attribute of all the non-null cells in the sampling area as: \n    \n with: \n    i : attribute \n    m : number of non-null attributes in the sampling area  \n    w i : number of cells of attribute i \n    size : size of sampling area (in cells) \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the input raster map contains only NULL values then  r.li.mpa  considers to\n have 0 patches. \n If area is 0  r.li.mpa  returns -1; it is possible only if the\n raster is masked  \n If you want to change these -1 values to NULL, run subsequently on the resulting map:\n r.null setnull=-1 input=my_map\n after index calculation.\n  EXAMPLES \n To calculate the mean pixel attribute index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.mpa input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.mpa input=forests conf=movwindow7 out=forests_mpa_mov7\n r.univar forests_mpa_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.mpa input=forests conf=movwindow7 out=forests_mpa_mov7\n # verify\n r.univar forests_mpa_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_mpa_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Serena Pallecchi student of Computer Science University of Pisa (Italy)."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.mpa"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.edgedensity.html", "name": "r.li.edgedensity", "definition": "- Calculates edge density index on a raster map, using a 4 neighbour algorithm", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.edgedensity [-b] input=name config=name output=name  [patch_type=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "b", "flag": "-b", "explanation": "Exclude border edges Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "patch_type", "flag": "patch_type", "dataType": "String", "optional": true, "explanation": "The value of the patch type", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.li.edgedensity  calculates: \n      the density of all edges of patch type  k \n \t \n \t, or\n      the density of all edges in the sampling area if  k  is \n         not specified,\n \t \n  with:\n  k : patch type \n  m : number of patch types \n  n : number of edge segments of patch type k \n  e ik  :total edge length in \n the landscape involving patch type k \n    Area : total landscape area \n The unit is meters per hectare.\n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the input raster map contains only NULL values then  r.li.edgedensity \n consider to have 0 patches. \n If area is 0  r.li.edgedensity  returns NULL; this is only possible if input\n raster is masked.\n  EXAMPLES \n To calculate the edge density index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.edgedensity input=my_map conf=my_conf output=my_out\n To calculate edge density index of patch_type 34, using\n \"my_conf\" configuration file and on map \"my_map\", saving results in \"my_out\"\n file run: \n r.li.edgedensity input=my_map conf=my_conf output=my_out patch_type=34\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.edgedensity input=forests conf=movwindow7 out=forests_edgedens_mov7\n r.univar forests_edgedens_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.edgedensity input=forests conf=movwindow7 out=forests_edgedensity_mov7\n # verify\n r.univar forests_edgedensity_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_edgedensity_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Serena Pallecchi student of Computer Science University of Pisa (Italy)."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.edgedensity"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.dominance.html", "name": "r.li.dominance", "definition": "- Calculates dominance's diversity index on a raster map", "keywords": ["raster", "landscape structure analysis", "diversity index"], "synopsis": "r.li.dominance input=name config=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.dominance  calculates the \"dominance diversity index\" as: \n    \n with:\n  i : patch type \n  m : number of different patch types \n  p i : proportional abundance of \n patch type  i   \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the input raster map contains only NULL values then \n  r.li.dominance  returns NULL.\n  EXAMPLES \n To calculate the dominance diversity index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.dominance input=my_map conf=my_conf output=my_out\n Forest map (Spearfish sample dataset) example:\n g.region raster=landcover.30m -p\n r.mapcalc \"forests = if(landcover.30m >= 41 && landcover.30m <= 43,1,null())\"\n r.li.dominance input=forests conf=movwindow7 out=forests_dominance_mov7\n r.univar forests_dominance_mov7\n Forest map (North Carolina sample dataset) example:\n g.region raster=landclass96 -p\n r.mapcalc \"forests = if(landclass96 == 5, 1, null() )\"\n r.li.dominance input=forests conf=movwindow7 out=forests_dominance_mov7\n # verify\n r.univar forests_dominance_mov7\n r.to.vect input=forests output=forests type=area\n d.mon wx0\n d.rast forests_dominance_mov7\n d.vect forests type=boundary\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Serena Pallecchi student of Computer Science University of Pisa (Italy)."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.dominance"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.li.cwed.html", "name": "r.li.cwed", "definition": "- Calculates contrast weighted edge density index on a raster map", "keywords": ["raster", "landscape structure analysis", "patch index"], "synopsis": "r.li.cwed input=name config=name path=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "config", "flag": "config", "dataType": "String", "optional": false, "explanation": "Configuration file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "path", "flag": "path", "dataType": "String", "optional": false, "explanation": "Name of file that contains the weight to calculate the index", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.li.cwed  (contrast weighted edge density) calculates the\n edge density between patch types specified:  \n   \n  with:\n    k : attribute \n    m : number of non-null attributes in the sampling area \n    e ik : total length of edge in \n  landscape between patch types i and k \n   d ik : dissimilarity (edge contrast\n  weight) between patch types i and k \n    Area : total landscape area \n The input file contains a row for each couple of patch type that we want to\n consider in the calculation. Each row must be saved using this syntax: \n  patchType1,patchType2,dissimilarityBetweenPatchType1andPatchType2 \n ", "notes": "\n Do not use absolute path names for the  config  and  output \n file/map parameters.\n If the \"moving window\" method was selected in  g.gui.rlisetup , then the\n output will be a raster map, otherwise an ASCII file will be generated in\n the folder  C:\\Users\\userxy\\AppData\\Roaming\\GRASS7\\r.li\\output\\ \n (MS-Windows) or  $HOME/.grass7/r.li/output/  (GNU/Linux).\n If the sample area contains only NULL values it is considered to\n have 0 patch and CWED=0. If Area is 0  r.li.cwed  returns -1.\n This is only possible if the map is masked. \n If you want to change these -1 values to NULL, run subsequently on the resulting map:\n r.null setnull=-1 input=my_map\n after index calculation.\n  EXAMPLES \n To calculate the contrast weighted edge density index on map  my_map , using\n  my_conf  configuration file (previously defined with\n  g.gui.rlisetup ) and saving results in  my_out , run:\n r.li.cwed input=my_map conf=my_conf output=my_out \n            path=/path/to/weights.csv\n  Example for input \"weights.csv\" file:\n 12,16,0.65\n 44,123,0.32\n 56,12,0.54\n 23,66,0.99\n ", "see_also": [ "g.gui.rlisetup"], "authors": ["Serena Pallecchi student of Computer Science University of Pisa (Italy)."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.li/r.li.cwed"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.latlong.html", "name": "r.latlong", "definition": "- Creates a latitude/longitude raster map.", "keywords": ["raster", "latitude", "longitude", "projection"], "synopsis": "r.latlong [-l] input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "Longitude output Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output latitude or longitude raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.latlong  creates a latitude (degree decimal) map, or longitude\n if the -l flag is used, from any map in any projection using PROJ.4 library. \n This is an input to  r.sun  and  i.evapo.potrad .\n ", "notes": "\n The PROJ.4  website .\n  TODO \n Datum transform is not implemented, the same datum is taken as output.\n  EXAMPLE \n g.region raster=elevation -p\n r.latlong input=elevation output=latitude\n ", "see_also": ["r.sun", "r.sunhours"], "authors": ["Yann Chemin, International Rice Research Institute, The Philippines"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.latlong"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.lake.html", "name": "r.lake", "definition": "- Fills lake at given point to given level.", "keywords": ["raster", "hydrology", "hazard", "flood"], "synopsis": "r.lake [-no] elevation=name water_level=float  [lake=name]   [coordinates=east,north]   [seed=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Use negative depth values for lake raster map Overwrite seed map with result (lake) map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Overwrite seed map with result (lake) map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "water_level", "flag": "water_level", "dataType": "String", "optional": false, "explanation": "Water level", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lake", "flag": "lake", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Seed point coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "seed", "flag": "seed", "dataType": "String", "optional": true, "explanation": "Input raster map with given starting point(s) (at least 1 cell > 0)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  The module fills a lake to a target water level from a given start point. The user\n can think of it as  r.grow  with additional\n checks for elevation. The resulting\n raster map contains cells with values representing lake depth and NULL for all other \n cells beyond the lake. Lake depth is reported relative to specified water level\n (specified level = 0 depth).\n  This module uses a 3x3 moving window approach to find all cells that\n match three criteria and to define the lake:\n   cells are below the specified elevation (i.e., water level); \n   cells are connected with an initial cell (seed or coordinates pair value); \n   cells are not NULL or masked. \n  The water level must be in DEM units.\n ", "notes": "\n The seed (starting) point can be a raster map with at least one\n cell value greater than zero, or a seed point can be specified as an E,\n N coordinate pair. If the seed is specified as a coordinate pair, an additional\n check is done to make sure that the target water level is above the level of \n the DEM. When a raster map is used as a seed, however, no such checks are done. \n Specifying a target water level below surface represented by DEM will result in an \n empty map. Note: a raster lake map created in a previous run can also be used\n as a seed map for a new run to simulate rising water levels.\n The module will create a new map ( lake=foo ) or can be set to replace\n the input ( seed=bar ) map if the  -o  flag is used.  The user can use\n  -o  flag to create animations of rising water level without\n producing a separate map for each frame.  An initial seed map must be created \n to start the sequence, and will be overwritten during subsequent runs with resulting\n water levels maps (i.e., a single file serves for both input and output).\n Negative output (the  -n  flag) is useful for visualisations in NVIZ. \n It equals the mapcalc's expression  \"negative = 0 - positive\" .\n  r.mapcalc equivalent - for GRASS hackers \n This module was initially created as a script using\n  r.mapcalc .\n This had some limitations - it was slow and no\n checks where done to find out required iteration count. The shell script \n code (using  r.mapcalc ) used\n in the original script is shown below:\n ${seedmap} = if( ${dem}, \n  if( if( isnull(${seedmap}),0,${seedmap}>0), ${wlevel}-${dem}, \n   if( \n    if(isnull(${seedmap}[-1,0]),0, ${seedmap}[-1,0]>0 && ${wlevel}>${dem}) ||\n    if(isnull(${seedmap}[-1,1]),0, ${seedmap}[-1,1]>0 && ${wlevel}>${dem}) ||\n    if(isnull(${seedmap}[0,1]), 0, ${seedmap}[0,1]>0  && ${wlevel}>${dem}) ||\n    if(isnull(${seedmap}[1,1]), 0, ${seedmap}[1,1]>0  && ${wlevel}>${dem}) ||\n    if(isnull(${seedmap}[1,0]), 0, ${seedmap}[1,0]>0  && ${wlevel}>${dem}) ||\n    if(isnull(${seedmap}[1,-1]),0, ${seedmap}[1,-1]>0 && ${wlevel}>${dem}) ||\n    if(isnull(${seedmap}[0,-1]),0, ${seedmap}[0,-1]>0 && ${wlevel}>${dem}) ||\n    if(isnull(${seedmap}[-1,-1]),0, ${seedmap}[-1,-1]>0 && ${wlevel}>${dem}),\n   ${wlevel}-${dem}, null() )))\n The  ${seedmap}  variable is replaced by seed map names,  ${dem} \n with DEM map name, and  ${wlevel}  with target water level. To get\n single water level, this code block is\n called with same level numerous times (in a loop) as the lake grows by single cells\n during single run.\n  KNOWN ISSUES \n    The entire map is loaded into RAM. \n    A completely negative seed map will not work! At least one cell must have \n     a value > 0. Output from  r.lake -n   cannot  be used\n     as input in the next run. \n  EXAMPLE \n Example of small flooding along a street (North Carolina sample dataset):\n g.region raster=elev_lid792_1m -p\n # water accumulation next to street dam\n r.lake elev_lid792_1m coordinates=638759.3,220264.1 water_level=113.4 lake=flooding\n # draw resulting lake map over shaded terrain map\n r.relief input=elev_lid792_1m output=elev_lid792_1m_shade\n d.rast elev_lid792_1m_shade\n d.rast flooding\n d.vect streets_wake\n  \n Small flooding along a street ( r.lake , using Lidar 1m DEM)\n ", "see_also": ["r.mapcalc", "r.grow", "r.plane"], "authors": ["Maris Nartiss (maris.nartiss gmail.com)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.lake"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.kappa.html", "name": "r.kappa", "definition": "- Calculates error matrix and kappa parameter for accuracy assessment of classification result.", "keywords": ["raster", "statistics", "classification"], "synopsis": "r.kappa [-wh] classification=name reference=name  [output=name]   [title=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "w", "flag": "-w", "explanation": "Wide report 132 columns (default: 80) No header in the report Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "No header in the report Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "classification", "flag": "classification", "dataType": "String", "optional": false, "explanation": "Name of raster map containing classification result", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "reference", "flag": "reference", "dataType": "String", "optional": false, "explanation": "Name of raster map containing reference classes", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file containing error matrix and kappa", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for error matrix and kappa", "defaultValue": "ACCURACY ASSESSMENT", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.kappa  tabulates the error matrix of classification result by\n crossing classified map layer with respect to reference map layer.  Both\n overall  kappa  (accompanied by its  variance ) and\n conditional  kappa  values are calculated.  This analysis program\n respects the current geographic region and mask settings.\n  r.kappa  calculates the error matrix of the\n two map layers and prepares the table from which the report\n is to be created.   kappa  values for overall and\n each classes are computed along with their variances. Also\n percent of commission and ommission error, total correct\n classified result by pixel counts, total area in pixel\n counts and percentage of overall correctly classified\n pixels are tabulated.\n The report will be write to an output file which is in\n plain text format and named by user at prompt of running\n the program.\n The body of the report is arranged in panels.  The\n classified result map layer categories is arranged along\n the vertical axis of the table, while the reference map\n layer categories along the horizontal axis.  Each panel has\n a maximum of 5 categories (9 if wide format) across the\n top.  In addition, the last column of the last panel\n reflects a cross total of each column for each row.  All of\n the categories of the map layer arranged along the vertical\n axis, i.e., the reference map layer,  are included in each\n panel.  There is a total at the bottom of each column\n representing the sum of all the rows in that column.\n ", "notes": "\n It is recommended to reclassify categories of classified\n result map layer into a more manageable number before\n running  r.kappa  on the classified raster map\n layer. Because  r.kappa  calculates and then reports\n information for each and every category.\n  NA 's in output file mean non-applicable in case\n  MASK  exists.\n The  Estimated kappa value  in  r.kappa  is the value\n only for one class, i.e. the observed agreement between the\n classifications for those observations that have been classified by\n classifier 1 into the class i. In other words, here the choice of\n reference is important.\n It is calculated as:\n kpp[i] = (pii[i] - pi[i] * pj[i]) / (pi[i] - pi[i] * pj[i]);\n where=\n  pii[i] is the probability of agreeement (i.e. number of pixels for which there is agreement divided by total number of assessed pixels) \n  Pi[i] is the probability of classification i having classified the point as i \n  Pj[i] is the probability of classification j having classified the point as i. \n  EXAMPLE \n Example for North Carolina sample dataset:\n g.region raster=landclass96 -p\n r.kappa -w classification=landuse96_28m reference=landclass96\n Verification of classified LANDSAT scene against training areas:\n r.kappa -w classification=lsat7_2002_classes reference=training\n ", "see_also": ["g.region", "r.category", "r.mask", "r.reclass", "r.report", "r.stats"], "authors": ["Tao Wen, University of Illinois at Urbana-Champaign, Illinois"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.kappa"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.info.html", "name": "r.info", "definition": "- Outputs basic information about a raster map.", "keywords": ["raster", "metadata", "extent", "history"], "synopsis": "r.info [-grseh] map=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print raster array information in shell script style Print range in shell script style Print stats in shell script style Print extended metadata information in shell script style Print raster history instead of info Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Print range in shell script style Print stats in shell script style Print extended metadata information in shell script style Print raster history instead of info Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Print stats in shell script style Print extended metadata information in shell script style Print raster history instead of info Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Print extended metadata information in shell script style Print raster history instead of info Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Print raster history instead of info Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.info  reports some basic information about a\n user-specified raster map layer.  This map layer must exist\n in the user's current mapset search path.  Information\n about the map's boundaries, resolution, projection, data\n type, category number, data base location and mapset, \n the timestamp and history are put into a table and written to standard\n output. The types of information listed can also be found\n in the  cats ,  cellhd , and  hist \n directories under the mapset in which the named map is\n stored.\n The user can save the tabular output to a file \n by using the UNIX redirection mechanism (>); for example, the user \n might save a report on the  soils  map layer in a file called \n  soil.txt  by typing: \n r.info map=soils > soil.txt\n   \n ", "notes": "\n On large maps, the total number of cells in the map may not be displayed \n with an accurate number. This is only cosmetic.\n Some standards (ISO-C90) and compilers do not support the 'long long' type \n as a 64-bit type. In the case that GRASS GIS was built with such a compiler, \n an accuracy message may be displayed in the output of  r.info  \n after Total Cells.\n  EXAMPLES \n Below is a full report produced by  r.info  for the raster map \n  slope  in the North Carolina sample data base: \n r.info slope\n  +----------------------------------------------------------------------------+\n  | Map:      slope                          Date: Tue Nov  7 01:11:23 2006    |\n  | Mapset:   PERMANENT                      Login of Creator: helena          |\n  | Location: nc_spm_08_grass7                                                 |\n  | DataBase: /grassdata                                                       |\n  | Title:    South-West Wake county: slope in degrees ( slope_ned10m )        |\n  | Timestamp: none                                                            |\n  |----------------------------------------------------------------------------|\n  |                                                                            |\n  |   Type of Map:  raster               Number of Categories: 255             |\n  |   Data Type:    FCELL                                                      |\n  |   Rows:         1350                                                       |\n  |   Columns:      1500                                                       |\n  |   Total Cells:  2025000                                                    |\n  |        Projection: Lambert Conformal Conic                                 |\n  |            N:     228500    S:     215000   Res:    10                     |\n  |            E:     645000    W:     630000   Res:    10                     |\n  |   Range of data:    min = 0  max = 38.68939                                |\n  |                                                                            |\n  |   Data Source:                                                             |\n  |    raster elevation file elev_ned10m                                       |\n  |                                                                            |\n  |                                                                            |\n  |   Data Description:                                                        |\n  |    generated by r.slope.aspect                                             |\n  |                                                                            |\n  |   Comments:                                                                |\n  |    slope map elev = elev_ned10m                                            |\n  |    zfactor = 1.00 format = degrees                                         |\n  |    min_slope = 0.000000                                              |\n  |                                                                            |\n  +----------------------------------------------------------------------------+\n Alternatively, the output from  r.info  may be confined to a more terse\n subset of the available information by passing various flags to the module:\n Output in shell script style, useful for eval ( eval `r.info -g slope` ):\n r.info -g slope\n north=228500\n south=215000\n east=645000\n west=630000\n nsres=10\n ewres=10\n rows=1350\n cols=1500\n cells=2025000\n datatype=FCELL\n ncats=255\n Output the map data range:\n r.info -r slope\n min=0\n max=38.68939\n Output the extended map data metadata in shell style:\n r.info -e slope\n map=slope\n mapset=PERMANENT\n location=nc_spm_08_grass7\n database=/grassdata\n date=\"Tue Nov  7 01:11:23 2006\"\n creator=\"helena\"\n title=\"South-West Wake county: slope in degrees (slope_ned10m)\"\n timestamp=\"none\"\n units=\"none\"\n vdatum=\"none\"\n source1=\"raster elevation file elev_ned10m\"\n source2=\"\"\n description=\"generated by r.slope.aspect\"\n comments=\"slope map elev = elev_ned10mzfactor = 1.00 format = degreesmin_slp_allowed = 0.000000\"\n ", "see_also": ["g.mapsets", "r.coin", "r.describe", "r.report", "r.stats", "r.support", "r.univar", "r.what"], "authors": ["Michael O'Shea,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.info"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.xyz.html", "name": "r.in.xyz", "definition": "- Creates a raster map from an assemblage of many coordinates using univariate statistics.", "keywords": ["raster", "import", "statistics", "conversion", "aggregation", "binning", "ASCII", "LIDAR"], "synopsis": "r.in.xyz [-sgi] input=name output=name  [method=string]   [separator=character]   [x=integer]   [y=integer]   [z=integer]   [skip=integer]   [zrange=min,max]   [zscale=float]   [value_column=integer]   [vrange=min,max]   [vscale=float]   [type=string]   [percent=integer]   [pth=integer]   [trim=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Scan data file for extent then exit In scan mode, print using shell script style Ignore broken lines Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "In scan mode, print using shell script style Ignore broken lines Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Ignore broken lines Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "ASCII file containing input data (or \"-\" to read from stdin)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Statistic to use for raster values", "defaultValue": "mean", "alternatives": ["n", "min", "max", "range", "sum", "mean", "stddev", "variance", "coeff_var", "median", "percentile", "skewness", "trimmean"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "x", "flag": "x", "dataType": "String", "optional": true, "explanation": "Column number of x coordinates in input file (first column is 1)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y", "flag": "y", "dataType": "String", "optional": true, "explanation": "Column number of y coordinates in input file", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "z", "flag": "z", "dataType": "String", "optional": true, "explanation": "Column number of data values in input file", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "skip", "flag": "skip", "dataType": "String", "optional": true, "explanation": "Number of header lines to skip at top of input file", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zrange", "flag": "zrange", "dataType": "String", "optional": true, "explanation": "Filter range for z data (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Scale to apply to z data", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "value_column", "flag": "value_column", "dataType": "String", "optional": true, "explanation": "Alternate column number of data values in input file", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vrange", "flag": "vrange", "dataType": "String", "optional": true, "explanation": "Filter range for alternate value column data (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vscale", "flag": "vscale", "dataType": "String", "optional": true, "explanation": "Scale to apply to alternate value column data", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of raster map to be created", "defaultValue": "FCELL", "alternatives": ["CELL", "FCELL", "DCELL"], "isInputFile": false, "isOutputFile": false}, {"parameter": "percent", "flag": "percent", "dataType": "String", "optional": true, "explanation": "Percent of map to keep in memory", "defaultValue": "100", "alternatives": ["1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "pth", "flag": "pth", "dataType": "String", "optional": true, "explanation": "Pth percentile of the values", "defaultValue": null, "alternatives": ["1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "trim", "flag": "trim", "dataType": "String", "optional": true, "explanation": "Discard <trim> percent of the smallest and <trim> percent of the largest observations", "defaultValue": null, "alternatives": ["0-50"], "isInputFile": false, "isOutputFile": false}], "description": "\n The  r.in.xyz  module will load and bin ungridded x,y,z ASCII data\n into a new raster map. The user may choose from a variety of statistical\n methods in creating the new raster. Gridded data provided as a stream of\n x,y,z points may also be imported.\n Please note that the current region extents and resolution are used for\n the import. It is therefore recommended to first use the  -s \n flag to get the extents of the input points to be imported, then\n adjust the current region accordingly, and only then proceed with the\n actual import.\n  r.in.xyz  is designed for processing massive point cloud datasets,\n for example raw LIDAR or sidescan sonar swath data. It has been tested with\n datasets as large as tens of billion of points (705GB in a single file).\n   \n Available statistics for populating the raster are ( method ):\n  n          number of points in cell \n  min        minimum value of points in cell \n  max        maximum value of points in cell \n  range      range of points in cell \n  sum        sum of points in cell \n  mean       average value of points in cell \n  stddev     standard deviation of points in cell \n  variance   variance of points in cell \n  coeff_var coefficient of variance of points in cell \n  median     median value of points in cell \n  percentile \u00a0 \n     p th  percentile of points in cell \n  skewness   skewness of points in cell \n  trimmean   trimmed mean of points in cell \n  Variance  and derivatives use the biased estimator (n). [subject to change]\n  Coefficient of variance  is given in percentage and defined as\n  (stddev/mean)*100 .\n It is also possible to bin and store another data column (e.g. backscatter)\n while simultaneously filtering and scaling both the data column values and\n the z range.\n ", "notes": "\n  Gridded data \n If data is known to be on a regular grid  r.in.xyz  can reconstruct\n the map perfectly as long as some care is taken to set up the region\n correctly and that the data's native map projection is used. A typical\n method would involve determining the grid resolution either by examining\n the data's associated documentation or by studying the text file. Next scan\n the data with  r.in.xyz 's  -s  (or  -g ) flag to find the\n input data's bounds. GRASS uses the cell-center raster convention where\n data points fall within the center of a cell, as opposed to the grid-node\n convention. Therefore you will need to grow the region out by half a cell\n in all directions beyond what the scan found in the file. After the region\n bounds and resolution are set correctly with  g.region , run\n  r.in.xyz  using the  n  method and verify that n=1 at all places.\n  r.univar  can help. Once you are confident that the region exactly\n matches the data proceed to run  r.in.xyz  using one of the  mean,\n min, max , or  median  methods. With n=1 throughout, the result\n should be identical regardless of which of those methods are used.\n  Memory use \n While the  input  file can be arbitrarily large,  r.in.xyz \n will use a large amount of system memory for large raster regions (10000x10000).\n If the module refuses to start complaining that there isn't enough memory,\n use the  percent  parameter to run the module in several passes.\n In addition using a less precise map format ( CELL  [integer] or\n  FCELL  [floating point]) will use less memory than a  DCELL \n [double precision floating point]  output  map. Methods such as  n,\n min, max, sum  will also use less memory, while  stddev, variance,\n and coeff_var  will use more.\n The aggregate functions  median, percentile, skewness  and\n  trimmed mean  will use even more memory and may not be appropriate\n for use with arbitrarily large input files .\n The default map  type = FCELL  is intended as compromise between\n preserving data precision and limiting system resource consumption.\n If reading data from a  stdin  stream, the program can only run using\n a single pass.\n  Setting region bounds and resolution \n You can use the  -s  scan flag to find the extent of the input data\n (and thus point density) before performing the full import. Use\n  g.region  to adjust the region bounds to match. The  -g  shell\n style flag prints the extent suitable as parameters for  g.region .\n A suitable resolution can be found by dividing the number of input points\n by the area covered. e.g.\n wc -l inputfile.txt\n g.region -p\n # points_per_cell = n_points / (rows * cols)\n g.region -e\n # UTM location:\n # points_per_sq_m = n_points / (ns_extent * ew_extent)\n # Lat/Lon location:\n # points_per_sq_m = n_points / (ns_extent * ew_extent*cos(lat) * (1852*60)^2)\n If you only intend to interpolate the data with  r.to.vect  and\n  v.surf.rst , then there is little point to setting the region\n resolution so fine that you only catch one data point per cell -- you might\n as well use \" v.in.ascii\u00a0-zbt \" directly.\n  Filtering \n Points falling outside the current region will be skipped. This includes\n points falling  exactly  on the southern region bound.\n (to capture those adjust the region with \" g.region s=s-0.000001 \";\n see  g.region )\n  Blank lines and comment lines starting with the hash symbol ( # )\n will be skipped.\n The  zrange  parameter may be used for filtering the input data by\n vertical extent. Example uses might include preparing multiple raster\n sections to be combined into a 3D raster array with  r.to.rast3 , or\n for filtering outliers on relatively flat terrain.\n In varied terrain the user may find that  min  maps make for a good\n noise filter as most LIDAR noise is from premature hits. The  min  map\n may also be useful to find the underlying topography in a forested or urban\n environment if the cells are over sampled.\n The user can use a combination of  r.in.xyz   output  maps to create\n custom filters. e.g. use  r.mapcalc  to create a  mean-(2*stddev) \n map. [In this example the user may want to include a lower bound filter in\n  r.mapcalc  to remove highly variable points (small  n ) or run\n  r.neighbors  to smooth the stddev map before further use.]\n  Alternate value column \n The  value_column  parameter can be used in specialized cases when you\n want to filter by z-range but bin and store another column's data. For\n example if you wanted to look at backscatter values between 1000 and 1500\n meters elevation. This is particularly useful when using  r.in.xyz \n to prepare depth slices for a 3D raster \u2014 the  zrange  option defines\n the depth slice but the data values stored in the voxels describe an\n additional dimension. As with the z column, a filtering range and scaling\n factor may be applied.\n  Reprojection \n If the raster map is to be reprojected, it may be more appropriate to reproject\n the input points with  m.proj  or  cs2cs  before running\n  r.in.xyz .\n  Interpolation into a DEM \n The vector engine's topographic abilities introduce a finite memory overhead\n per vector point which will typically limit a vector map to approximately\n 3 million points (~ 1750^2 cells). If you want more, use the  r.to.vect \n  -b  flag to skip building topology. Without topology, however, all\n you'll be able to do with the vector map is display with  d.vect  and\n interpolate with  v.surf.rst .\n Run  r.univar  on your raster map to check the number of non-NULL cells\n and adjust bounds and/or resolution as needed before proceeding.\n Typical commands to create a DEM using a regularized spline fit:\n r.univar lidar_min\n r.to.vect -z type=point in=lidar_min out=lidar_min_pt\n v.surf.rst in=lidar_min_pt elev=lidar_min.rst\n  Import of x,y,string data \n  r.in.xyz  is expecting numeric values as z column. In order to \n perform a occurrence count operation even on x,y data with non-numeric \n attribute(s), the data can be imported using either the x or y \n coordinate as a fake z column for  method = n  (count \n number of points per grid cell), the z values are ignored anyway.\n  EXAMPLES \n  Import of x,y,z ASCII into DEM \n Sometimes elevation data are delivered as x,y,z ASCII files instead of a raster\n matrix. The import procedure consists of a few steps: calculation of the\n map extent, setting of the computational region accordingly with an additional\n extension into all directions by half a raster cell in order to register the\n elevation points at raster cell centers.\n Note: if the z column is separated by several spaces from the coordinate columns,\n it may be sufficient to adapt the  z  position value.\n # Important: observe the raster spacing from the ASCII file:\n # ASCII file format (example):\n # 630007.5 228492.5 141.99614\n # 630022.5 228492.5 141.37904\n # 630037.5 228492.5 142.29822\n # 630052.5 228492.5 143.97987\n # ...\n # In this example the distance is 15m in x and y direction.\n # detect extent, print result as g.region parameters\n r.in.xyz input=elevation.xyz separator=space -s -g\n # ... n=228492.5 s=215007.5 e=644992.5 w=630007.5 b=55.578793 t=156.32986\n # set computational region, along with the actual raster resolution\n # as defined by the point spacing in the ASCII file:\n g.region n=228492.5 s=215007.5 e=644992.5 w=630007.5 res=15 -p\n # now enlarge computational region by half a raster cell (here 7.5m) to\n # store the points as cell centers:\n g.region n=n+7.5 s=s-7.5 w=w-7.5 e=e+7.5 -p\n # import XYZ ASCII file, with z values as raster cell values\n r.in.xyz input=elevation.xyz separator=space method=mean output=myelev\n # univariate statistics for verification of raster values\n r.univar myelev\n  Import of LiDAR data and DEM creation \n Import the  Jockey's\n Ridge, NC, LIDAR dataset  (compressed file \"lidaratm2.txt.gz\"), and process it\n into a clean DEM:\n # scan and set region bounds\n r.in.xyz -s -g separator=\",\" in=lidaratm2.txt\n g.region n=35.969493 s=35.949693 e=-75.620999 w=-75.639999\n g.region res=0:00:00.075 -a\n # create \"n\" map containing count of points per cell for checking density\n r.in.xyz in=lidaratm2.txt out=lidar_n separator=\",\" method=n zrange=-2,50\n # check point density [rho = n_sum / (rows*cols)]\n r.univar lidar_n\n # create \"min\" map (elevation filtered for premature hits)\n r.in.xyz in=lidaratm2.txt out=lidar_min separator=\",\" method=min zrange=-2,50\n # set computational region to area of interest\n g.region n=35:57:56.25N s=35:57:13.575N w=75:38:23.7W e=75:37:15.675W\n # check number of non-null cells (try and keep under a few million)\n r.univar lidar_min\n # convert to points \n r.to.vect -z type=point in=lidar_min out=lidar_min_pt\n # interpolate using a regularized spline fit\n v.surf.rst in=lidar_min_pt elev=lidar_min.rst\n # set color scale to something interesting\n r.colors lidar_min.rst rule=bcyr -n -e\n # prepare a 1:1:1 scaled version for NVIZ visualization (for lat/lon input)\n r.mapcalc \"lidar_min.rst_scaled = lidar_min.rst / (1852*60)\"\n r.colors lidar_min.rst_scaled rule=bcyr -n -e\n  TODO \n   Support for multiple map output from a single run. \n       method=string[,string,...] output=name[,name,...] \n      This can be easily handled by a wrapper script, with the added\n      benefit of it being very simple to parallelize that way.\n  KNOWN ISSUES \n   \" nan \" can leak into  coeff_var  maps.\n    Cause unknown. Possible work-around: \" r.null setnull=nan \"\n If you encounter any problems (or solutions!) please contact the GRASS\n Development Team.\n ", "see_also": ["g.region", "m.proj", "r.fillnulls", "r.in.ascii", "r.in.lidar", "r3.in.xyz", "r.mapcalc", "r.neighbors", "r.out.xyz", "r.to.rast3", "r.to.vect", "r.univar", "v.in.ascii", "v.surf.rst"], "authors": ["Hamish Bowman, Department of Marine Science, University of Otagom New Zealand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.in.xyz"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.wms.html", "name": "r.in.wms", "definition": "- Downloads and imports data from WMS/WMTS/NASA OnEarth server.", "keywords": ["raster", "import", "OGC web services"], "synopsis": "r.in.wms [-co] url=string output=name layers=string[,string,...]  [styles=string[,string,...]]   [format=string]   [srs=integer]   [driver=string]   [wms_version=string]   [maxcols=integer]   [maxrows=integer]   [urlparams=string]   [username=string]   [password=string]   [method=string]   [region=string]   [bgcolor=string]   [capfile=name]   [capfile_output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Get the server capabilities then exit Do not request transparent data Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Do not request transparent data Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "url", "flag": "url", "dataType": "String", "optional": false, "explanation": "Typically starts with \"http://\"", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "layers", "flag": "layers", "dataType": "String", "optional": false, "explanation": "Layer(s) to request from the map server", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "styles", "flag": "styles", "dataType": "String", "optional": true, "explanation": "Layer style(s) to request from the map server", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Image format requested from the server", "defaultValue": "png", "alternatives": ["geotiff", "tiff", "jpeg", "gif", "png", "png8"], "isInputFile": false, "isOutputFile": false}, {"parameter": "srs", "flag": "srs", "dataType": "String", "optional": true, "explanation": "EPSG code of requested source projection", "defaultValue": "4326", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Driver used to communication with server", "defaultValue": "WMS_GRASS", "alternatives": ["WMS_GDAL", "WMS_GRASS", "WMTS_GRASS", "OnEarth_GRASS"], "isInputFile": false, "isOutputFile": false}, {"parameter": "wms_version", "flag": "wms_version", "dataType": "String", "optional": true, "explanation": "WMS standard version", "defaultValue": "1.1.1", "alternatives": ["1.1.1", "1.3.0"], "isInputFile": false, "isOutputFile": false}, {"parameter": "maxcols", "flag": "maxcols", "dataType": "String", "optional": true, "explanation": "Maximum columns to request at a time", "defaultValue": "512", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxrows", "flag": "maxrows", "dataType": "String", "optional": true, "explanation": "Maximum rows to request at a time", "defaultValue": "512", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "urlparams", "flag": "urlparams", "dataType": "String", "optional": true, "explanation": "Additional query parameters to pass to the server", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "username", "flag": "username", "dataType": "String", "optional": true, "explanation": "Username for server connection", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "password", "flag": "password", "dataType": "String", "optional": true, "explanation": "Password for server connection", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Interpolation method to use in reprojection", "defaultValue": "nearest", "alternatives": ["nearest", "linear", "cubic", "cubicspline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "region", "flag": "region", "dataType": "String", "optional": true, "explanation": "Request data for this named region instead of the current region bounds", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "capfile", "flag": "capfile", "dataType": "String", "optional": true, "explanation": "Capabilities file to parse (input). It is relevant for WMTS_GRASS and OnEarth_GRASS drivers", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "capfile_output", "flag": "capfile_output", "dataType": "String", "optional": true, "explanation": "File where the server capabilities will be saved ('c' flag)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.in.wms  handles all of downloading and importing raster data\n from an  OGC\n WMS  and  OGC\n WMTS  web mapping servers. It only needs be told the\n desired data to collect (bounds and resolution) via a region, the\n server to get the data from, and the layer or layers to get. It\n downloads the data in tiles, reprojects it, imports it, and patches it\n back together.\n ", "notes": "\n To understand the data you are getting it is necessary to look at the\n capabilities of the WMS server. This should be available via a capabilities\n request (see examples)\n When using GDAL WMS driver ( driver=WMS_GDAL ), the GDAL library\n needs to be built with WMS support,\n see  GDAL WMS  manual page\n for details.\n  Tiled WMS \n Into the parameter  layers  the name of the  TiledGroup  need to\n be inserted from Tile Service file. Time variable can be specified\n in  urlparams  parameter,\n e.g:  urlparams='time=2012-1-1' .\n  EXAMPLES \n  General Get Capabilities Request \n # Topographic WMS with OpenStreetMap by mundialis\n r.in.wms -c url=\"http://ows.mundialis.de/services/service?\"\n r.in.wms -c url=\"http://ows.mundialis.de/services/service?\" | grep Name\n # Czech WMS\n r.in.wms -c url=\"http://wms.cuzk.cz/wms.asp\"\n  Download raster data from WMS server (GetMap request) \n  Open Street Map \n # OSM\n g.region n=90 s=-90 w=-180 e=180 res=0:10:00 -p\n r.in.wms url=\"http://watzmann-geog.urz.uni-heidelberg.de/cached/osm\" layers=osm_auto:all output=osm format=png\n # OSM Overlay WMS (can be used as an overlay for other maps)\n r.in.wms url=\"http://ows.mundialis.de/services/service?\" layer=OSM-Overlay-WMS output=osm_overlay format=png\n # TOPO-OSM-WMS\n r.in.wms url=\"http://ows.mundialis.de/services/service?\" layer=TOPO-OSM-WMS output=topo_osm format=png\n # TOPO-WMS\n r.in.wms url=\"http://ows.mundialis.de/services/service?\" layer=TOPO-WMS output=topo format=png\n More OSM WMS servers can be found online, e.g. on the OSM wiki in a\n  OSM WMS Servers list \n and on the  OSM-WMS-EUROPE  page.\n  Countries and coastlines \n r.in.wms url=\"http://www2.demis.nl/WMS/wms.asp\" layers=Countries,Borders,Coastline output=countries srs=4326 format=png \n  Sentinel-2 satellite cloud free global coverage \n # North Carolina sample data\n g.region raster=elevation -p\n r.in.wms url=\"https://tiles.maps.eox.at/wms?\" layers=s2cloudless output=sentinel2 format=png\n  OGC WMTS Example \n r.in.wms url=\"http://gpp3-wxs.ign.fr/yourAPIkey/geoportail/wmts\" layers=ORTHOIMAGERY.ORTHOPHOTOS output=orthophoto srs=3857 format=jpeg driver=WMTS_GRASS style=normal password=\"*\" username=\"*\"\n Note: username, password and API key can be obtained from  IGN API  website\n  Data covering the Czech Republic \n r.in.wms url=\"http://wms.cuzk.cz/wms.asp\" layers=prehledka_kraju-linie srs=4326 output=kn format=png\n r.in.wms url=\"http://geoportal.cuzk.cz/WMTS_ORTOFOTO/WMTService.aspx\" layers=orto output=ortofoto srs=3857 format=jpeg driver=WMTS_GRASS style=default\n Note: data are provided by  Czech office for surveying, mapping and cadastre .\n  REQUIREMENTS \n  r.in.wms \n requires the  gdalwarp \n utility from the GDAL/OGR library.\n  REFERENCES \n    OGC WMS \n    OGC WMTS \n ", "see_also": ["r.in.gdal", "r.patch", "r.colors", "r.composite", "v.in.wfs"], "authors": ["Stepan Turek, Czech Technical University in Prague, Czech Republic (bachelor's final project 2012, mentor: Martin Landa)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.in.wms"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.srtm.html", "name": "r.in.srtm", "definition": "- Imports SRTM HGT files into raster map.", "keywords": ["raster", "import"], "synopsis": "r.in.srtm [-1] input=name  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "1", "flag": "-1", "explanation": "Input is a 1-arcsec tile (default: 3-arcsec) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of SRTM input tile (file without .hgt.zip extension)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map (default: input tile)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.in.srtm  imports SRTM hgt files into GRASS.\n SRTM Version 1 and improved Version 2 data sets can be downloaded from \n NASA at this site: \n  http://dds.cr.usgs.gov/srtm/ \n Gap-filled SRTM Version 3 data can be downloaded from USGS at this site: \n  http://e4ftl01.cr.usgs.gov/SRTM/SRTMGL3.003/2000.02.11/ \n ", "notes": "\n SRTM tiles are of 1 degree by 1 degree size. The SRTM filename contains the\n coordinates which refer to the  center  of the lower left pixel (e.g., N51E010: \n lower left cell center at 10E, 51N). To identify a tile name, a grid can be easily\n visualized in the GRASS monitor:\n d.grid size=1\n To import TOPEX/SRTM30 PLUS data, use  r.in.bin .\n ", "see_also": ["r.in.bin"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.in.srtm"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.poly.html", "name": "r.in.poly", "definition": "- Creates raster maps from ASCII polygon/line/point data files.", "keywords": ["raster", "import"], "synopsis": "r.in.poly input=name output=name  [title=phrase]   [type=string]   [null=integer]   [rows=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file; or \"-\" to read from stdin", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of raster map to be created", "defaultValue": "CELL", "alternatives": ["CELL", "FCELL", "DCELL"], "isInputFile": false, "isOutputFile": false}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "Integer representing NULL value data cell", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rows", "flag": "rows", "dataType": "String", "optional": true, "explanation": "Number of rows to hold in memory", "defaultValue": "4096", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.in.poly  allows the creation of GRASS binary\n raster maps from ASCII files in the current directory\n containing polygon, linear, and point features.\n The  input  file is an ASCII text file containing the\n polygon, linear, and point feature definitions.\n The format of this file is described in the\n  INPUT FORMAT  section below.\n The number of raster  rows  to hold in memory is per default 4096.\n This parameter allows users with less memory (or more) on their\n system to control how much memory  r.in.poly  uses.\n Usually the default value is fine.\n ", "notes": "\n The data will be imported using the current region settings to set the\n new raster map's bounds and resolution. Any features falling outside\n the current region will be cropped. The region settings are contolled\n with the  g.region  module.\n The format is a simplified version of the standard GRASS vector ASCII\n format used by  v.in.ascii .\n Polygons are filled, i.e. they define an area.\n  Input Format \n The input format for the  input  file consists of\n sections describing either polygonal areas, linear features, or\n point features. The basic format is:\n A                      <for polygonal areas>\n     easting northing\n     .\n     .\n     .\n =   cat# label\n L                      <for linear features>\n     easting northing\n     .\n     .\n     .\n =   cat# label\n P                      <for single cell point features>\n     easting northing\n =   cat# label\n The  A  signals the beginning of a filled polygon.\n It must appear in the first column.\n The  L  signals the beginning of a linear feature.\n It also must appear in the first column.\n The  P  signals the beginning of a single cell point feature.\n Again, it must appear in the first column.\n The coordinates of the vertices of the polygon, or the coordinates defining\n the linear or point feature follow and must have a space in the first\n column and at least one space between the  easting  and the\n  northing.  To give meaning to the features, the\n \" = \" indicates that the feature currently being\n processed has category value  cat#  (which must be\n an integer) and a  label  (which may be more than\n one word, or which may be omitted).\n  EXAMPLE \n An area described by four points:\n A\n   591316.80   4926455.50\n   591410.25   4926482.40\n   591434.60   4926393.60\n   591341.20   4926368.70\n = 42 stadium\n ", "see_also": ["r.colors", "d.rast.edit", "g.region", "r.in.xyz", "r.patch", "v.in.ascii", "wxGUI vector digitizer"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.in.poly"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.png.html", "name": "r.in.png", "definition": "- Imports non-georeferenced PNG format image.", "keywords": ["raster", "import", "PNG"], "synopsis": "r.in.png [-fh] input=name output=name  [title=string]   [gamma=float]   [alpha=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Create floating-point map (0.0 - 1.0) Output image file header only and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Output image file header only and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for created raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "gamma", "flag": "gamma", "dataType": "String", "optional": true, "explanation": "Display gamma", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "alpha", "flag": "alpha", "dataType": "String", "optional": true, "explanation": "Alpha threshold", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.in.png  imports a PNG image as a GRASS raster map.\n ", "notes": "", "see_also": ["r.import", "r.in.gdal", "r.out.png"], "authors": ["Michael Shapiro"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.in.png"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.mat.html", "name": "r.in.mat", "definition": "- Imports a binary MAT-File(v4) to a GRASS raster.", "keywords": ["raster", "import"], "synopsis": "r.in.mat input=name  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input MAT-File(v4)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map (override)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.in.mat  will import a GRASS raster map from a Version 4 MAT-File \n which was created with Matlab or Octave.\n Attributes such as map title and bounds will also be imported if they exist.\n Specifically, the following array variables will be read: \n     map_data \n     map_name \n     map_title \n     map_northern_edge \n     map_southern_edge \n     map_eastern_edge \n     map_western_edge \n Any other variables in the MAT-file will be simply skipped over. \n The ' map_name ' variable is optional, if it exists, and is valid, the \n new map will be thus named. If it doesn't exist or a name is specified with\n the  output=  option, the raster map's name will be set to \n \" MatFile \" or the name specified respectively.\n (maximum 64 characters; normal GRASS naming rules apply)\n The ' map_title ' variable is optional, the map's title is set if it \n exists.\n The ' map_northern_edge ' and like variables are mandatory unless the \n user is importing to a \"XY\" non-georeferenced location\n (e.g. imagery data). Latitude and longitude values should be in decimal form.\n ", "notes": "\n  r.in.mat  imports a Version 4 MAT-File. These files can be \n successfully created with more modern versions of Matlab and Octave\n (see \"EXAMPLES\" below). \n Everything should be Endian safe, so the file to be imported can be simply \n copied between different system architectures without binary translation\n (caveat: see \"TODO\" below). \n As there is no IEEE value for  NaN  in integer arrays, GRASS's null \n value may be used to represent it within these maps. Usually Matlab will save \n any integer based matrix with  NaN  values as a double-precision \n floating point array, so this usually isn't an issue. To save space, once the \n map is loaded into GRASS you can convert it back to an integer map with the \n following command:\n r.mapcalc \"int_map = int(MATFile_map)\"\n  NaN  values in either floating point or double-precision floating point\n matrices should translate into null values as expected. \n  r.in.mat  must load the entire map array into memory before writing,\n therefore it might have problems with  huge  arrays.\n (a 3000x4000 DCELL map uses about 100mb RAM) \n GRASS defines its map bounds at the outer-edge of the bounding cells, not at\n the coordinates of their centroids. Thus, the following Matlab commands may \n be used to determine and check the map's resolution information will be correct:\n     [rows cols] = size(map_data)\n     x_range = map_eastern_edge - map_western_edge\n     y_range = map_northern_edge - map_southern_edge\n     ns_res = y_range/rows\n     ew_res = x_range/cols\n Remember Matlab arrays are referenced as  (row,column) ,\n i.e.  (y,x) .\n In addition,  r.in.mat  and  r.out.mat  make for a nice \n binary container format for transferring georeferenced maps around, \n even if you don't use Matlab or Octave. \n  EXAMPLES \n In Matlab, save with:\n save filename.mat map_* -v4\n In Octave, save with:\n save -mat4-binary filename.mat map_*\n  TODO \n Robust support for mixed-Endian importation.\n  (This is a work in progress, please help by reporting any failures to the\n GRASS bug tracking system ; you will need to login with an OSGeo Userid)\n Add support for importing map history, category information, color map, etc.\n if they exist.\n Option to import a version 5 MAT-File, with map and support information \n stored in a single structured array.\n  KNOWN ISSUES \n If you encounter any problems, please contact the GRASS Development Team.\n ", "see_also": ["r.out.mat", "r.in.ascii", "r.in.bin", "r.mapcalc", "r.null"], "authors": ["Hamish Bowman"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.in.mat"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.lidar.html", "name": "r.in.lidar", "definition": "- Creates a raster map from LAS LiDAR points using univariate statistics.", "keywords": ["raster", "import", "LIDAR", "statistics", "conversion", "aggregation", "binning"], "synopsis": "r.in.lidar [-penosgijdv]  [input=name]   [output=name]   [file=name]   [method=string]   [type=string]   [base_raster=name]   [zrange=min,max]   [zscale=float]   [intensity_range=min,max]   [intensity_scale=float]   [percent=integer]   [pth=integer]   [trim=float]   [resolution=float]   [return_filter=string]   [class_filter=integer[,integer,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print LAS file info and exit Use the extent of the input for the raster extent Set internally computational region extents based on the point cloud Set computation region to match the new raster map Set computation region to match the 2D extent and resolution of the newly created new raster map Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Scan data file for extent then exit In scan mode, print using shell script style Use intensity values rather than Z values Uses intensity values everywhere as if they would be Z coordinates Use Z values for filtering, but intensity values for statistics Use base raster resolution instead of computational region For getting values from base raster, use its actual resolution instead of computational region resolution Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Use the extent of the input for the raster extent Set internally computational region extents based on the point cloud Set computation region to match the new raster map Set computation region to match the 2D extent and resolution of the newly created new raster map Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Scan data file for extent then exit In scan mode, print using shell script style Use intensity values rather than Z values Uses intensity values everywhere as if they would be Z coordinates Use Z values for filtering, but intensity values for statistics Use base raster resolution instead of computational region For getting values from base raster, use its actual resolution instead of computational region resolution Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Set computation region to match the new raster map Set computation region to match the 2D extent and resolution of the newly created new raster map Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Scan data file for extent then exit In scan mode, print using shell script style Use intensity values rather than Z values Uses intensity values everywhere as if they would be Z coordinates Use Z values for filtering, but intensity values for statistics Use base raster resolution instead of computational region For getting values from base raster, use its actual resolution instead of computational region resolution Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Scan data file for extent then exit In scan mode, print using shell script style Use intensity values rather than Z values Uses intensity values everywhere as if they would be Z coordinates Use Z values for filtering, but intensity values for statistics Use base raster resolution instead of computational region For getting values from base raster, use its actual resolution instead of computational region resolution Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Scan data file for extent then exit In scan mode, print using shell script style Use intensity values rather than Z values Uses intensity values everywhere as if they would be Z coordinates Use Z values for filtering, but intensity values for statistics Use base raster resolution instead of computational region For getting values from base raster, use its actual resolution instead of computational region resolution Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "In scan mode, print using shell script style Use intensity values rather than Z values Uses intensity values everywhere as if they would be Z coordinates Use Z values for filtering, but intensity values for statistics Use base raster resolution instead of computational region For getting values from base raster, use its actual resolution instead of computational region resolution Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Use intensity values rather than Z values Uses intensity values everywhere as if they would be Z coordinates Use Z values for filtering, but intensity values for statistics Use base raster resolution instead of computational region For getting values from base raster, use its actual resolution instead of computational region resolution Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "j", "flag": "-j", "explanation": "Use Z values for filtering, but intensity values for statistics Use base raster resolution instead of computational region For getting values from base raster, use its actual resolution instead of computational region resolution Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Use base raster resolution instead of computational region For getting values from base raster, use its actual resolution instead of computational region resolution Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Use only valid points Points invalid according to APSRS LAS specification will be filtered out Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "LAS input file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "File containing names of LAS input files", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Statistic to use for raster values", "defaultValue": "mean", "alternatives": ["n", "min", "max", "range", "sum", "mean", "stddev", "variance", "coeff_var", "median", "percentile", "skewness", "trimmean"], "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of raster map to be created", "defaultValue": "FCELL", "alternatives": ["CELL", "FCELL", "DCELL"], "isInputFile": false, "isOutputFile": false}, {"parameter": "base_raster", "flag": "base_raster", "dataType": "String", "optional": true, "explanation": "Subtract raster values from the Z coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zrange", "flag": "zrange", "dataType": "String", "optional": true, "explanation": "Filter range for Z data (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Scale to apply to Z data", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "intensity_range", "flag": "intensity_range", "dataType": "String", "optional": true, "explanation": "Filter range for intensity values (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "intensity_scale", "flag": "intensity_scale", "dataType": "String", "optional": true, "explanation": "Scale to apply to intensity values", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "percent", "flag": "percent", "dataType": "String", "optional": true, "explanation": "Percent of map to keep in memory", "defaultValue": "100", "alternatives": ["1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "pth", "flag": "pth", "dataType": "String", "optional": true, "explanation": "pth percentile of the values", "defaultValue": null, "alternatives": ["1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "trim", "flag": "trim", "dataType": "String", "optional": true, "explanation": "Discard given percentage of the smallest and largest values", "defaultValue": null, "alternatives": ["0-50"], "isInputFile": false, "isOutputFile": false}, {"parameter": "resolution", "flag": "resolution", "dataType": "String", "optional": true, "explanation": "Output raster resolution", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "return_filter", "flag": "return_filter", "dataType": "String", "optional": true, "explanation": "Only import points of selected return type", "defaultValue": null, "alternatives": ["first", "last", "mid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "class_filter", "flag": "class_filter", "dataType": "String", "optional": true, "explanation": "Only import points of selected class(es)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  r.in.lidar  module loads LAS LiDAR point clouds into a new\n raster map using binning. The user may choose from a variety of\n statistical methods which will be used for binning when creating\n the new raster.\n Since a new raster map is created during the binning, the binning of\n points depends on the current computational region settings\n (extent and resolution) by default (see more about binning below).\n When using the  -e  flag, the binning will be done in the extent\n of the point cloud, so the resulting raster will have extent based on\n the input point cloud.\n When the  resolution=value  parameter is used,\n the binning is done using the provided resolution and the resulting\n raster will have that resolution (see more below for more information\n about extent and resolution management).\n  r.in.lidar  is designed for processing massive point cloud \n datasets, for example raw LiDAR or sidescan sonar swath data. It has \n been tested with large datasets (see below for memory management \n notes).\n  Binning \n The main different of  r.in.lidar  in comparison to\n  r.in.lidar  is that\n  r.in.lidar  creates a raster instead of just importing the\n points into GRASS GIS. However,  r.in.lidar  does not merely\n rasterizes the points from the point cloud.  r.in.lidar \n uses binning to derive values for individual raster cells,\n so the value of a cell is typically an aggregation of values\n of individual points falling into one cell.\n In general binning is the conversion of points into a regular grid.\n The binning of points with X and Y coordinates starts with the overlay\n of a grid of bins over the points.\n In the basic case, binning is a method which counts the number of\n points which fall into one raster cell, i.e. bin. The number of points\n per cell (bin) indicates the density of points in the point cloud.\n The cell (bin) is always square or rectangular in case of\n  r.in.lidar  because the result is GRASS GIS 2D raster.\n The result of binning where the number of point per cell is counted\n is sometimes called 2D (two dimensional) histogram because\n a histogram is used in univariate statistics (in one dimension)\n to count the number samples falling into a given bin.\n  \n     Figure: The binning on left was used to count number of points per\n     (sometimes also called 2D histogram). The numbers in cells are\n     examples of counts, the rest is represented by the color.\n     The binning on right was used with mean to create a surface\n     based on the values associated with the points. The numbers\n     show examples of cell values. Note also the cells without any points\n     which were assigned the NULL value.\n The basic concept of binning is extended when the points have another\n value associated with them. For LiDAR data this value can be the Z\n coordinate or intensity. The value for a given cell (bin) is computed\n using univariate statistics from the values of all points in the cell.\n For example, computing the mean value of Z coordinates can yield\n a raster representing the digital elevation model. Another example is\n the range of Z coordinates which can be used as a rough estimate of\n vegetation height.\n  Statistics \n Available statistics for populating the output raster map are:\n  n \n  This computes the number (count) of points per cell. The result\n is a indicator of spatially variable density of points in the given\n area. \n  min \n  This finds the minimum of point values in each cell.\n It can be useful when finding topography in a forested or urban\n environment and there is a lot of points per one cells (terrain is\n oversampled considering the desired resolution).\n It can also create surfaces independent on the noise from premature\n hits as it will always select the lowest point.\n  max \n  This finds the maximum of point values in each cell.\n In connection with  base_raster  it can yield maximum vegetation\n of feature height per cell.\n For this purpose, it is usually much more appropriate than  mean \n which would yield heights mostly influenced by the vertical\n distribution of points.\n  range \n  This computes the range of point values in each cell.\n The range of Z coordinates per cell can be used as a rough estimate of\n vegetation height when the cells are small enough, slopes low\n and the area is mostly vegetated.\n However, for more profound analysis, the base raster together with\n different statistics is recommended. \n  sum \n  This computes the sum of point values per cell.\n This is useful especially when intensity is used as a value\n (flags  -i  and  -j ). \n  mean \n  This is a mean (average) value of point values in cell.\n When used with Z coordinates (the default) and points from the ground\n class, the resulting raster is a digital elevation model.\n When intensity is used as a point value, the resulting raster contains\n mean intensity per cell.\n Note that  mean  gives heights influenced by the vertical\n distribution of points \n  stddev \n  This computes the standard deviation of point values for each\n cell. \n  variance \n  This computes the variance of point values for each cell.\n Variance and derivatives use the biased estimator (n)\n [note that this might be subject to change]. \n  coeff_var \n  This computes the coefficient of variance of point values for each\n cell. Coefficient of variance is given in percentage and defined as\n  (stddev/mean)*100 . \n  median \n  This computes the median of point values for each cell \n  percentile \n  p th  (nth) percentile of points in cell \n  skewness \n  This is a skewness of point values in cell \n  trimmean \n  This is a trimmed mean of point values in cell.\n Trimmed mean also know as truncated mean is a mean\n computed after discarding values at the low end and at the high end.\n How many values to discard is given by the  trim  option\n in percent. In statistics the usual percentage of trimmed values ranges\n from 5 to 25 percent. \n Note that different statistics have different memory requirements\n (see below for details).\n  Filtering \n Points falling outside the current computational region will be skipped.\n This includes points falling  exactly  on the southern region\n bound. To capture those adjust the region with:\n g.region s=s-0.000001\n See  g.region  for details about\n computation region handling in GRASS GIS.\n The  zrange  parameter may be used for filtering the input data by\n vertical extent. Example uses include\n filtering out extreme outliers and outliers on relatively flat terrain.\n This parameter can be also used for cutting the point cloud into\n vertical sections preparing it for further processing\n by separate sections, together as if it would be an imagery group\n (see  i.group ), or combined into\n a 3D raster using  r.to.rast3 .\n In for these last examples, it might actually be more advantageous\n to use  r3.in.lidar  module.\n The  zrange  parameter is especially powerful when used\n together with the  base_raster  parameter. The  zrange \n is applied to Z values after the  base_raster  reduction.\n     Figure: This is the principle of zrange filter. Points with the\n     Z coordinate value below the lower value in the range (here 180)\n     are filtered out (blue points) and same applies for points above\n     higher value in the range (here 250). All other points are preserved\n     (green points).\n A LiDAR pulse can have multiple returns. The first return values can be \n used to obtain a digital surface model (DSM) where e.g. canopy cover is \n represented. The last return values can be used to obtain a digital \n terrain model (DTM) where e.g. the forest floor instead of canopy \n cover is represented. The  return_filter  option allows selecting\n one of first, mid, or last returns. Return number and number of returns\n in the pulse associated with each point are compared to determine\n if the point is first, mid, or last return.\n LiDAR points often come as already classified into standardized classes.\n For example, class number 2 represents ground. For other classes see\n LAS format specification in references. The  class_filter  option\n allows selecting one or more classes using numbers (integers) separated\n by comma.\n In varied terrain the user may find that  min  maps make for a good\n noise filter as most LIDAR noise is from premature hits. The  min  map\n may also be useful to find the underlying topography in a forested or urban\n environment if the cells are oversampled.\n The user can use a combination of  r.in.lidar   output  maps\n to create custom raster-based filters, for examplee, use\n  r.mapcalc  to create\n a  mean-(2*stddev)  map. (In this example the user may want to\n include a lower bound filter in  r.mapcalc  to remove highly\n variable points (small  n ) or run  r.neighbors  to\n smooth the stddev map before further use.)\n Note that proper filtering of the input points in not only critical for\n the analysis itself but it can also speed up the processing.\n  Reduction to a base raster \n For analysis of features on the terrain surface, especially vegetation\n it is advantageous to remove the influence of the terrain on heights\n because the height above the terrain is important (e.g. height of\n a tree) rather than height of the top of the tree above the see level.\n In this case, the base raster would be digital elevation model\n which can be one derived from the point cloud, or obtained in\n some other way. LiDAR data often come with precomputed DEMs\n (quality should be checked in this case) and there is often a DEM\n available for a given area (fit with the point cloud, especially\n vertical, and resolution should be checked).\n     Figure: This is a profile of base raster (in orange) representing\n     digital elevation model and selected points, e.g. first return,\n     from point cloud (green dots). By default the points would create\n     a digital surface model (thin brown line) but after reducing the\n     Z coordinates using the base raster, the created surface is a\n     derived from the height of points relative to the base raster.\n The usage of base raster is not limited to digital elevation model.\n The base raster can be any surface which has some relation to the\n point values, for example digital surface model representing\n top of the canopy.\n  Setting extent and resolution \n Since the creation of raster maps depends on the computational \n region settings (extent and resolution), as default the current \n region extents and resolution are used for the import. When using \n the  -e  flag along with the  resolution=value  \n parameter, the region used for the new raster will be based\n the point cloud extent and the provided resolution. It is therefore\n recommended to first use the  -s  flag to get the extents of the\n LiDAR point cloud to be imported, then adjust the current region extent\n and resolution accordingly, and only then proceed with the actual import.\n Another option is to automatically set the region extents based on the\n LAS dataset itself ( -e  flag) along with the desired raster\n resolution. The best option is to know the point cloud extent ahead,\n e.g. from tiling scheme, and use it. See below for details.\n Since the  r.in.lidar  generates a raster map through binning \n from the original LiDAR points, the target computational region \n extent and resolution have to be determined. A typical workflow \n would involve the examination of the LAS data's associated \n documentation or the scan of the LAS data file with\n  r.in.lidar 's  -s  (or  -g ) flag to find the input\n data's bounds.\n Another option is to automatically set the region extents based on the\n LAS dataset extent ( -e  flag) along with the desired raster\n resolution using the  resolution  parameter.\n Using the  -s  scan flag, the extent of the input data (and thus\n point density) is printed. To check this is recommended before performing\n the full import. The  -g  shell style flag prints the extent suitable\n as command line parameters for  g.region .\n A simpler option is to automatically set the region extents based on the\n LAS dataset ( -e  flag) along with the target raster resolution using\n the  resolution  parameter. Also here it is recommended to verify\n and optimize the resulting region settings with  g.region  prior\n to importing the dataset.\n ", "notes": "\n  Format and projection support \n The typical file extensions for the LAS format are .las and .laz\n (compressed). The compressed LAS (.laz) format can be imported only if\n libLAS has been compiled with LASzip support. It is also recommended to\n compile libLAS with GDAL which is used to test if the LAS projection\n matches that of the GRASS location.\n  LAS file import preparations \n Note that the scanning ( -s  or  -g  flags) needs to iterate\n over the whole point cloud. This will take a long time for large\n datasets, so if the user knows the approximate extent of the dataset,\n for example because it dataset for one county or tiling scheme is\n available as vector polygons, it is much more advantageous to provide\n the extent information instead of retrieving it from the dataset.\n The same applies to the  -e  flag which also needs to perform\n scanning before the binning begins.\n Also note that the scanning does not apply any filters, so the\n extent determined by scanning can be theoretically bigger than\n the extent actively used during the binning.\n This behavior ensures that the newly created raster has always\n the same extent regardless the filters used.\n However, for most cases (considering the point cloud and the resolution\n used) there is no difference between the extent without filters applied\n and the extent if the filters would be applied.\n  Memory consumption \n While the  input  file can be arbitrarily large,  r.in.lidar \n will use a large amount of system memory (RAM) for large raster regions\n (> 10000x10000 pixels).\n If the module refuses to start complaining that there isn't enough memory,\n use the  percent  parameter to run the module in several passes.\n In addition using a less precise map format ( CELL  [integer] or\n  FCELL  [floating point]) will use less memory than a  DCELL \n [double precision floating point]  output  map.\n For  method = n , the  CELL  format is used\n automatically.\n The  mean  and  range  methods will use average amount\n of memory (comparing to other methods).\n Methods such as  n, min, max , and  sum  will use\n less memory,\n while  stddev, variance , and  coeff_var  will use more.\n The memory usage for regular statistics mentioned above is based solely\n on region (raster) size.\n However, the aggregate functions  median, percentile, skewness \n and  trimmean  will use more memory and may not be\n appropriate for use with arbitrarily large input files without\n a small value for the  percent  option because unlike\n the other statistics memory use for these also depends on\n the number of data points.\n The default map  type = FCELL  is intended as compromise between\n preserving data precision and limiting system resource consumption.\n  Trim option \n Trim option value is used only when calculating trimmed mean values.\n Attempt to use it with other statistical methods will result in an error.\n  EXAMPLES \n Simple example of binning of point from a LAS file into a newly created\n raster map in an existing location/mapset (using metric units):\n # set the computational region automatically, resol. for binning is 5m\n r.in.lidar -e -o input=points.las resolution=5 output=lidar_dem_mean\n g.region raster=lidar_dem_mean -p\n r.univar lidar_dem_mean\n  Finding suitable extent and resolution \n Using the  -s  scan flag, the extent of the input data (and thus\n point density) is printed. To check this is recommended before performing\n the full import. The  -g  shell style flag prints the extent suitable\n as command line parameters for  g.region .\n A simpler option is to automatically set the region extents based on the\n LAS dataset ( -e  flag) along with the target raster resolution using\n the  resolution  parameter. Also here it is recommended to verify\n and optimize the resulting region settings with  g.region  prior\n to importing the dataset.\n For the output raster map, a  suitable resolution  can be found by\n dividing the number of input points by the area covered (this requires\n an iterative approach as outlined here):\n # print LAS metadata (Number of Points)\n r.in.lidar -p input=points.las\n #   Number of Point Records: 1287775\n # scan for LAS points cloud extent\n r.in.lidar -sg input=points.las output=dummy -o\n # n=2193507.740000 s=2190053.450000 e=6070237.920000 w=6066629.860000 b=-3.600000 t=906.000000\n # set computation region to this extent\n g.region n=2193507.740000 s=2190053.450000 e=6070237.920000 w=6066629.860000 -p\n # print resulting extent\n g.region -p\n #  rows:       3454\n #  cols:       3608\n # points_per_cell = n_points / (rows * cols)\n # Here: 1287775 / (3454 * 3608) = 0.1033359 LiDAR points/raster cell\n # As this is too low, we need to select a lower raster resolution\n g.region res=5 -ap\n #  rows:       692\n #  cols:       723\n #  Now: 1287775 / (692 * 723) = 2.573923 LiDAR points/raster cell\n # import as mean\n r.in.lidar input=points.las output=lidar_dem_mean method=mean -o\n # import as max\n r.in.lidar input=points.las output=lidar_dem_max method=max -o\n # import as p'th percentile of the values\n r.in.lidar input=points.las output=lidar_dem_percentile_95 \n             method=percentile pth=95 -o\n  Mean value DEM in perspective view, imported from LAS file \n Further hints: how to calculate number of LiDAR points/square meter:\n g.region -e\n   # Metric location:\n   # points_per_sq_m = n_points / (ns_extent * ew_extent)\n   # Lat/Lon location:\n   # points_per_sq_m = n_points / (ns_extent * ew_extent*cos(lat) * (1852*60)^2)\n  Serpent Mound dataset \n This example is analogous to the example used in the GRASS wiki page for\n  importing LAS as raster DEM .\n  The sample LAS data are in the file \"Serpent Mound Model LAS Data.las\", \n available at \n  appliedimagery.com :\n # print LAS file info\n r.in.lidar -p input=\"Serpent Mound Model LAS Data.las\"\n # using v.in.lidar to create a new location\n # create location with projection information of the LAS data\n v.in.lidar -i input=\"Serpent Mound Model LAS Data.las\" location=Serpent_Mound\n # quit and restart GRASS in the newly created location \"Serpent_Mound\"\n # scan the extents of the LAS data\n r.in.lidar -sg input=\"Serpent Mound Model LAS Data.las\"\n # set the region to the extents of the LAS data, align to resolution\n g.region n=4323641.57 s=4320942.61 w=289020.90 e=290106.02 res=1 -ap\n # import as raster DEM\n r.in.lidar input=\"Serpent Mound Model LAS Data.las\" \n             output=Serpent_Mound_Model_LAS_Data method=mean\n  Figure: Elevation for the whole area of Serpent Mound dataset \n  Height above ground \n The mean height above ground of the points can be computed for each\n raster cell (the ground elevation is given by the raster map\n  elevation ):\n g.region raster=elevation -p\n r.in.lidar input=points.las output=mean_height_above_ground base_raster=elevation method=mean\n In this type of computation, it might be advantageous to change the resolution\n to match the precision of the points rather than deriving it from the base raster.\n  Multiple file input \n The file option requres a file that contains a list of file names with the full \n path. For example, a list of files in the directory /home/user/data:\n points1.laz\n points2.laz\n points3.laz\n would be lised in the file as:\n /home/user/data/points1.laz\n /home/user/data/points2.laz\n /home/user/data/points3.laz\n On Linux and OSX, this file can be automatically generated with the command:\n ls /home/user/data/*.laz > /home/user/data/filelist.txt\n On Windows:\n dir /b c:\\users\\user\\data\\*.laz > c:\\users\\user\\data\\filelist.txt\n The mean height above ground example above would then be:\n g.region raster=elevation -p\n r.in.lidar file=/home/user/data/filelist.txt output=mean_height_above_ground base_raster=elevation method=mean\n In Python, the list of files can be created using the  glob \n Python module:\n import glob\n import gscript\n     \n file_list_name = '/home/user/data/filelist.txt'\n with open(, mode='w') as file_list:\n     for path in glob.iglob('/home/user/data/lidar/*.las'):\n         file_list.write(path + \"\\n \")\n gscript.run_command('r.in.lidar', file=file_list_name,\n                     output='mean_height_above_ground',\n                     base_raster='elevation' method='mean')\n  KNOWN ISSUES \n  The \" nan \" value (as defined in C language) can leak into\n      coeff_var  raster maps. Cause is unknown. Possible\n     work-around is:  r.null setnull=nan  or\n      r.mapcalc 'no_nan = if(map == map, map, null())' .\n  Only one method can be applied for a single run and multiple map\n     output from a single run\n     (e.g.  method=string[,string,...] output=name[,name,...] \n     or  n=string mean=string ) is no supported.\n       \n If you encounter any problems (or solutions!) please contact the GRASS\n Development Team.\n ", "see_also": ["g.region", "r.in.xyz", "r.mapcalc", "r.univar", "v.in.lidar", "r3.in.lidar", "v.vect.stats", "v.lidar.correction", "v.lidar.edgedetection", "v.lidar.growing", "v.outlier", "v.surf.bspline"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.in.lidar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.gridatb.html", "name": "r.in.gridatb", "definition": "- Imports GRIDATB.FOR map file (TOPMODEL) into a GRASS raster map.", "keywords": ["raster", "import"], "synopsis": "r.in.gridatb input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "GRIDATB i/o map file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.in.gridatb  imports GRIDATB.FOR map file (TOPMODEL) into GRASS\n raster map.\n ", "notes": "", "see_also": ["r.topmodel", "r.out.gridatb"], "authors": ["Huidae Cho based on code from Keith Beven"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.in.gridatb"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.gdal.html", "name": "r.in.gdal", "definition": "- Imports raster data into a GRASS raster map using GDAL library.", "keywords": ["raster", "import", "create location"], "synopsis": "r.in.gdal [-ojeflakcrp] input=name output=name  [band=integer[,integer,...]]   [memory=integer]   [target=name]   [title=phrase]   [offset=integer]   [num_digits=integer]   [map_names_file=name]   [location=name]   [table=file]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Perform projection check only and exit Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset List supported formats and exit Force Lat/Lon maps to fit into geographic coordinates (90N,S; 180E,W) Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Keep band numbers instead of using band color names Create the location specified by the \"location\" parameter and exit. Do not import the raster file. Limit import to the current region Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "j", "flag": "-j", "explanation": "Perform projection check only and exit Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset List supported formats and exit Force Lat/Lon maps to fit into geographic coordinates (90N,S; 180E,W) Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Keep band numbers instead of using band color names Create the location specified by the \"location\" parameter and exit. Do not import the raster file. Limit import to the current region Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset List supported formats and exit Force Lat/Lon maps to fit into geographic coordinates (90N,S; 180E,W) Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Keep band numbers instead of using band color names Create the location specified by the \"location\" parameter and exit. Do not import the raster file. Limit import to the current region Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "List supported formats and exit Force Lat/Lon maps to fit into geographic coordinates (90N,S; 180E,W) Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Keep band numbers instead of using band color names Create the location specified by the \"location\" parameter and exit. Do not import the raster file. Limit import to the current region Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Force Lat/Lon maps to fit into geographic coordinates (90N,S; 180E,W) Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Keep band numbers instead of using band color names Create the location specified by the \"location\" parameter and exit. Do not import the raster file. Limit import to the current region Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Keep band numbers instead of using band color names Create the location specified by the \"location\" parameter and exit. Do not import the raster file. Limit import to the current region Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "k", "flag": "-k", "explanation": "Keep band numbers instead of using band color names Create the location specified by the \"location\" parameter and exit. Do not import the raster file. Limit import to the current region Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Create the location specified by the \"location\" parameter and exit. Do not import the raster file. Limit import to the current region Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Limit import to the current region Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print number of bands and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of raster file to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "band", "flag": "band", "dataType": "String", "optional": true, "explanation": "Band(s) to select (default is all bands)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used (in MB)", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "target", "flag": "target", "dataType": "String", "optional": true, "explanation": "Name of GCPs target location", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "offset", "flag": "offset", "dataType": "String", "optional": true, "explanation": "Offset to be added to band numbers", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "num_digits", "flag": "num_digits", "dataType": "String", "optional": true, "explanation": "Zero-padding of band number by filling with leading zeros up to given number", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "map_names_file", "flag": "map_names_file", "dataType": "String", "optional": true, "explanation": "Name of the output file that contains the imported map names", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Name for new location to create", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": true, "explanation": "File prefix for raster attribute tables", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.in.gdal  allows a user to create a GRASS GIS raster map layer,\n or imagery group, from any GDAL supported raster map format, with an optional \n title. The imported file may also be optionally used to create a new location.\n  GDAL supported raster formats \n Full details on all GDAL supported formats are available at:\n  http://www.gdal.org/formats_list.html \n Selected formats out of the more than 140 supported formats:\n Long Format Name                              Code           Creation  Georeferencing Maximum file size\n ---------------------------------------------+-------------+----------+--------------+-----------------\n ADRG/ARC Digitilized Raster Graphics          ADRG              Yes      Yes          --\n Arc/Info ASCII Grid                           AAIGrid           Yes      Yes          2GB\n Arc/Info Binary Grid (.adf)                   AIG               No       Yes          --\n Arc/Info Export E00 GRID                      E00GRID           No       Yes          --\n ArcSDE Raster                                 SDE               No       Yes          --\n ASCII Gridded XYZ                             XYZ               Yes      Yes          --\n BSB Nautical Chart Format (.kap)              BSB               No       Yes          --\n CEOS (Spot for instance)                      CEOS              No       No           --\n DB2                                           DB2               Yes      Yes          No limits\n DODS / OPeNDAP                                DODS              No       Yes          --\n EarthWatch/DigitalGlobe .TIL                  TIL               No       No           --\n ENVI .hdr Labelled Raster                     ENVI              Yes      Yes          No limits\n Envisat Image Product (.n1)                   ESAT              No       No           --\n EOSAT FAST Format                             FAST              No       Yes          --\n Epsilon - Wavelet compressed images           EPSILON           Yes      No           --\n Erdas 7.x .LAN and .GIS                       LAN               No       Yes          2GB\n ERDAS Compressed Wavelets (.ecw)              ECW               Yes      Yes           \n Erdas Imagine (.img)                          HFA               Yes      Yes          No limits\n Erdas Imagine Raw                             EIR               No       Yes          --\n ERMapper (.ers)                               ERS               Yes      Yes\n ESRI .hdr Labelled                            EHdr              Yes      Yes          No limits\n EUMETSAT Archive native (.nat)                MSGN              No       Yes\n FIT                                           FIT               Yes      No           --\n FITS (.fits)                                  FITS              Yes      No           --\n Fuji BAS Scanner Image                        FujiBAS           No       No           --\n GDAL Virtual (.vrt)                           VRT               Yes      Yes          --\n Generic Binary (.hdr Labelled)                GENBIN            No       No           --\n GeoPackage                                    GPKG              Yes      Yes          No limits\n Geospatial PDF                                PDF               Yes      Yes          --\n GMT Compatible netCDF                         GMT               Yes      Yes          2GB\n Golden Software Surfer 7 Binary Grid          GS7BG             Yes      Yes          4GiB\n Graphics Interchange Format (.gif)            GIF               Yes      No           2GB\n GRASS Raster Format                           GRASS             No       Yes          --\n GSat File Format                              GFF               No       No           --\n Hierarchical Data Format Release 4 (HDF4)     HDF4              Yes      Yes          2GiB\n Hierarchical Data Format Release 5 (HDF5)     HDF5              No       Yes          2GiB\n Idrisi Raster                                 RST               Yes      Yes          No limits\n ILWIS Raster Map (.mpr,.mpl)                  ILWIS             Yes      Yes          --\n Image Display and Analysis (WinDisp)          IDA               Yes      Yes          2GB\n In Memory Raster                              MEM               Yes      Yes\n Intergraph Raster                             INGR              Yes      Yes          2GiB\n IRIS                                          IRIS              No       Yes          --\n Japanese DEM (.mem)                           JDEM              No       Yes          --\n JAXA PALSAR Product Reader (Level 1.1/1.5)    JAXAPALSAR        No       No           --\n JPEG2000 (.jp2, .j2k)                         JP2OpenJPEG       Yes      Yes\n JPEG JFIF (.jpg)                              JPEG              Yes      Yes          4GiB\n KMLSUPEROVERLAY                               KMLSUPEROVERLAY   Yes      Yes\n MBTiles                                       MBTiles           Yes      Yes          --\n Meta Raster Format                            MRF               Yes      Yes          --\n Meteosat Second Generation                    MSG               No       Yes\n MG4 Encoded Lidar                             MG4Lidar          No       Yes          --\n Microsoft Windows Device Independent Bitmap   BMP               Yes      Yes          4GiB\n Military Elevation Data (.dt0, .dt1, .dt2)    DTED              Yes      Yes          --\n Multi-resolution Seamless Image Database      MrSID             No       Yes          --\n NASA Planetary Data System                    PDS               No       Yes          --\n NetCDF                                        netCDF            Yes      Yes          2GB\n Netpbm (.ppm,.pgm)                            PNM               Yes      No           No limits\n NITF                                          NITF              Yes      Yes          10GB\n NLAPS Data Format                             NDF               No       Yes          No limits\n NOAA NGS Geoid Height Grids                   NGSGEOID          No       Yes\n NOAA Polar Orbiter Level 1b Data Set (AVHRR)  L1B               No       Yes          --\n OGC Web Coverage Service                      WCS               No       Yes          --\n OGC Web Map Service, and TMS, WorldWind, On EaWMS               No       Yes          --\n OGC Web Map Tile Service                      WMTS              No       Yes          --\n OGDI Bridge                                   OGDI              No       Yes          --\n Oracle Spatial GeoRaster                      GEORASTER         Yes      Yes          No limits\n OziExplorer .MAP                              MAP               No       Yes          --\n OZI OZF2/OZFX3                                OZI               No       Yes          --\n PCI Geomatics Database File                   PCIDSK            Yes      Yes          No limits\n PCRaster                                      PCRaster          Yes      Yes           \n Planet Labs Mosaics API                       PLMosaic          No       Yes          --\n Portable Network Graphics (.png)              PNG               Yes      No           \n PostGIS Raster (previously WKTRaster)         PostGISRaster     No       Yes          --\n RadarSat2 XML (product.xml)                   RS2               No       Yes          4GB\n Rasdaman                                      RASDAMAN          No       No           No limits\n Rasterlite - Rasters in SQLite DB             Rasterlite        Yes      Yes          --\n Raster Product Format/RPF (CADRG, CIB)        RPFTOC            No       Yes          --\n R Object Data Store                           R                 Yes      No           --\n ROI_PAC Raster                                ROI_PAC           Yes      Yes          --\n R Raster (.grd)                               RRASTER           No       Yes          --\n SAGA GIS Binary format                        SAGA              Yes      Yes          --\n SAR CEOS                                      SAR_CEOS          No       Yes          --\n Sentinel 1 SAR SAFE (manifest.safe)           SAFE              No       Yes          No limits\n Sentinel 2                                    SENTINEL2         No       Yes          No limits\n SGI Image Format                              SGI               Yes      Yes          --\n SRTM HGT Format                               SRTMHGT           Yes      Yes          --\n TerraSAR-X Complex SAR Data Product           COSAR             No       No           --\n TerraSAR-X Product                            TSX               Yes      No           --\n TIFF / BigTIFF / GeoTIFF (.tif)               GTiff             Yes      Yes          4GiB/None for BigTIFF\n USGS ASCII DEM / CDED (.dem)                  USGSDEM           Yes      Yes          --\n USGS Astrogeology ISIS cube (Version 3)       ISIS3             No       Yes          --\n USGS SDTS DEM (*CATD.DDF)                     SDTS              No       Yes          --\n Vexcel MFF                                    MFF               Yes      Yes          No limits\n VICAR                                         VICAR             No       Yes          --\n VTP Binary Terrain Format (.bt)               BT                Yes      Yes          --\n WEBP                                          WEBP              Yes      No           --\n WMO GRIB1/GRIB2 (.grb)                        GRIB              No       Yes          2GB\n  Location Creation \n  r.in.gdal  attempts to preserve projection information when importing\n datasets if the source format includes projection information, and if\n the GDAL driver supports it.  If the projection of the source dataset does\n not match the projection of the current location  r.in.gdal  will \n report an error message ( Projection of dataset does not appear to \n match current location ) and then report the PROJ_INFO parameters of\n the source dataset.\n If the user wishes to ignore the difference between the apparent coordinate\n system of the source data and the current location, they may pass the \n  -o  flag to override the projection check. \n If the user wishes to import the data with the full projection definition,\n it is possible to have r.in.gdal automatically create a new location based\n on the projection and extents of the file being read.  This is accomplished\n by passing the name to be used for the new location via the  location \n parameter.  Upon completion of the command, a new location will have been\n created (with only a PERMANENT mapset), and the raster will have been\n imported with the indicated  output  name into the PERMANENT mapset.\n  Support for GCPs \n In case the image contains GCPs they are written to a\n POINTS file within an imagery group. They can directly be used for \n  i.rectify .\n The  target  option allows you to automatically re-project the GCPs\n from their own projection into another projection read from the\n PROJ_INFO file of the location name  target .\n If the  target  location does not exist, a new location will be \n created matching the projection definition of the GCPs. The target of \n the output group will be set to the new location, and \n  i.rectify  can now be used without any further \n preparation. \n Some satellite images (e.g. NOAA/AVHRR, ENVISAT) can contain hundreds \n or thousands of GCPs. In these cases thin plate spline coordinate \n transformation is recommended, either before import with \n  gdalwarp -tps  or after import with  i.rectify -t .\n  Map names: Management of offset and leading zeros \n The  offset  parameter allows adding an offset to band number(s) which\n is convenient in case of the import of e.g. a continuous time series split\n across different input files.\n The  num_digits  parameter allows defining the number of  leading zeros\n (zero padding) in case of band numbers (e.g., to turn  band.1  into\n  band.001 ).\n ", "notes": "\n Import of large files can be significantly faster when setting  memory  to\n the size of the input file.\n The  r.in.gdal  command does support the following features, as long as \n the underlying format driver supports it:\n   Color Table\n   Bands with associated colortables will have the color tables transferred.\n Note that if the source has no colormap, r.in.gdal in GRASS 5.0 will emit\n no colormap.  Use r.colors map=... color=grey to assign a greyscale colormap.\n In a future version of GRASS r.in.gdal will likely be upgraded to automatically\n emit greyscale colormaps. \n   Data Types\n   Most GDAL data types are supported.  Float32 and Float64 type bands\n are translated as GRASS floating point cells (but not double precision ...\n this could be added if needed), and most other types are translated as \n GRASS integer cells.  This includes 16bit integer data sources.  Complex\n (some SAR signal data formats) data bands are translated to two floating\n point cell layers (*.real and *.imaginary). \n   Georeferencing\n   If the dataset has affine georeferencing information, this will be used\n to set the north, south, east and west edges.  Rotational coefficients will\n be ignored, resulting in incorrect positioning for rotated datasets. \n   Projection\n   The datasets projection will be used to compare to the current location\n or to define a new location.  Internally GDAL represents projections in \n OpenGIS Well Known Text format.  A large subset of the total set of GRASS\n projections are supported. \n   Null Values\n   Raster bands for which a null value is recognised by GDAL will have\n the null pixels transformed into GRASS style nulls during import.  Many\n generic formats (and formats poorly supported by GDAL) do not have a way\n of recognising null pixels in which case r.null should be used after the\n import. \n   GCPs\n   Datasets that have Ground Control Points will have them imported as\n a POINTS file associated with the imagery group.  Datasets with only one\n band that would otherwise have been translated as a simple raster map\n will also have an associated imagery group if there are ground control points.\n The coordinate system of the ground control points is reported by r.in.gdal\n but not preserved.  It is up to the user to ensure that the location \n established with i.target has a compatible coordinate system before using\n the points with i.rectify. \n Planned improvements to  r.in.gdal  in the future include support for\n reporting everything known about a dataset if the  output  parameter is not set.\n  Error Messages \n  \"ERROR: Input map is rotated - cannot import.\" \n In this case the image must be first externally rotated, applying the rotation info stored in \n the metadata field of the raster image file. For example, the \n  gdalwarp   software can be used \n to transform the map to North-up (note, there are several gdalwarp parameters to select the\n resampling algorithm):\n gdalwarp rotated.tif northup.tif\n  \"ERROR: Projection of dataset does not appear to match the current location.\" \n You need to create a location whose projection matches the data you\n wish to import. Try using  location  parameter to create a new\n location based upon the projection information in the file. If desired,\n you can then re-project it to another location with  r.proj .\n Alternatively you can override this error by using the  -o  flag.\n  \"WARNING: G_set_window(): Illegal latitude for North\" \n Latitude/Longitude locations in GRASS can not have regions which exceed\n 90\u00b0 North or South. Non-georeferenced imagery will have coordinates\n based on the images's number of pixels: 0,0 in the bottom left; cols,rows\n in the top right. Typically imagery will be much more than 90 pixels tall\n and so the GIS refuses to import it. If you are sure that the data is\n appropriate for your Lat/Lon location and intentd to reset the map's\n bounds with the  r.region  module directly after import you may\n use the  -l  flag to constrain the map coordinates to legal values.\n While the resulting bounds and resolution will likely be wrong for your\n map the map's data will be unaltered and safe. After resetting to known\n bounds with  r.region  you should double check them with\n  r.info , paying special attention to the map resolution. In most\n cases you will want to import into the datafile's native projection, or\n into a simple XY location and use the Georectifaction tools\n ( i.rectify  et al.) to properly project into the target location.\n The  -l  flag should  only  be used if you know the projection\n is correct but the internal georeferencing has gotten lost, and you know\n the what the map's bounds and resolution should be beforehand.\n  EXAMPLES \n  ECAD Data \n The  European Climate Assessment and Dataset (ECAD) project  \n provides climate data for Europe ranging from 1950 - 2015 or later\n ( Terms of use ).\n To import the different chunks of data provided by the project as netCDF files,\n the offset parameter can be used to properly assign numbers to the series\n of daily raster maps from 1st Jan 1950 (in case of importing the ECAD data\n split into multi-annual chunks). The ECAD data must be imported into a\n LatLong location.\n By using the  num_digits  parameter leading zeros are added to the\n map name numbers, allowing for chronological numbering of the imported raster\n map layers, so that  g.list  lists them in the correct order.\n Here, use  num_digits=5  to have a 5 digit suffix with leading zeros (00001 - 99999).\n # Import of ECAD data split into chunks\n # Import precipitation data\n r.in.gdal -o input=rr_0.25deg_reg_1950-1964_v12.0.nc output=precipitation num_digits=5 offset=0\n r.in.gdal -o input=rr_0.25deg_reg_1965-1979_v12.0.nc output=precipitation num_digits=5 offset=5479\n r.in.gdal -o input=rr_0.25deg_reg_1980-1994_v12.0.nc output=precipitation num_digits=5 offset=10957\n r.in.gdal -o input=rr_0.25deg_reg_1995-2015_v12.0.nc output=precipitation num_digits=5 offset=16436\n # Import air pressure data\n r.in.gdal -o input=pp_0.25deg_reg_1950-1964_v12.0.nc output=air_pressure num_digits=5 offset=0\n r.in.gdal -o input=pp_0.25deg_reg_1965-1979_v12.0.nc output=air_pressure num_digits=5 offset=5479\n r.in.gdal -o input=pp_0.25deg_reg_1980-1994_v12.0.nc output=air_pressure num_digits=5 offset=10957\n r.in.gdal -o input=pp_0.25deg_reg_1995-2015_v12.0.nc output=air_pressure num_digits=5 offset=16436\n # Import min temperature data\n r.in.gdal -o input=tn_0.25deg_reg_1950-1964_v12.0.nc output=temperatur_min num_digits=5 offset=0\n r.in.gdal -o input=tn_0.25deg_reg_1965-1979_v12.0.nc output=temperatur_min num_digits=5 offset=5479\n r.in.gdal -o input=tn_0.25deg_reg_1980-1994_v12.0.nc output=temperatur_min num_digits=5 offset=10957\n r.in.gdal -o input=tn_0.25deg_reg_1995-2015_v12.0.nc output=temperatur_min num_digits=5 offset=16436\n # Import max temperature data\n r.in.gdal -o input=tx_0.25deg_reg_1950-1964_v12.0.nc output=temperatur_max num_digits=5 offset=0\n r.in.gdal -o input=tx_0.25deg_reg_1965-1979_v12.0.nc output=temperatur_max num_digits=5 offset=5479\n r.in.gdal -o input=tx_0.25deg_reg_1980-1994_v12.0.nc output=temperatur_max num_digits=5 offset=10957\n r.in.gdal -o input=tx_0.25deg_reg_1995-2015_v12.0.nc output=temperatur_max num_digits=5 offset=16436\n # Import mean temperature data\n r.in.gdal -o input=tg_0.25deg_reg_1950-1964_v12.0.nc output=temperatur_mean num_digits=5 offset=0\n r.in.gdal -o input=tg_0.25deg_reg_1965-1979_v12.0.nc output=temperatur_mean num_digits=5 offset=5479\n r.in.gdal -o input=tg_0.25deg_reg_1980-1994_v12.0.nc output=temperatur_mean num_digits=5 offset=10957\n r.in.gdal -o input=tg_0.25deg_reg_1995-2015_v12.0.nc output=temperatur_mean num_digits=5 offset=16436\n  GTOPO30 DEM \n To avoid that the GTOPO30 data are read incorrectly, you can add a new line\n \"PIXELTYPE SIGNEDINT\" in the .HDR to force interpretation of the file as\n signed rather than unsigned integers. Then the .DEM file can be imported.\n Finally, e.g. the 'terrain' color table can be assigned to the imported map\n with  r.colors .\n  GLOBE DEM \n To import  GLOBE DEM tiles \n (approx 1km resolution, better than GTOPO30 DEM data), the user has to download\n additionally the related  HDR file(s) .\n Finally, e.g. the 'terrain' color table can be assigned to the imported map with  r.colors .\n See also their  DEM portal .\n  Raster file import over network \n Since GDAL 2.x it is possible to import raster data over network\n (see  GDAL Virtual File Systems )\n including  Cloud Optimized GeoTIFF ,\n i.e. access uncompressed and compressed raster data via a http(s) or ftp connection.\n As an example the import of the global SRTMGL1 V003 tiles at 1 arc second (about 30 meters)\n resolution, void-filled:\n r.in.gdal /vsicurl/https://www.datenatlas.de/geodata/public/srtmgl1/srtmgl1.003.tif output=srtmgl1_v003_30m memory=2000\n g.region raster=srtmgl1_v003_30m -p\n r.colors srtmgl1_v003_30m color=srtm_plus\n  Worldclim.org data \n To import the BIL data from  Worldclim , the following\n line has to be added to each .hdr file:\n PIXELTYPE SIGNEDINT\n To import the ESRI Grd data from  Worldclim , the\n broken spatial extent (exceeding the boundaries) needs to be fixed prior to import: \n # example: tmean dataset\n gdal_translate -a_ullr -180 90 180 -60 tmean_1 tmean_1_fixed.tif\n r.in.gdal input=tmean_1_fixed.tif output=tmean_1\n  HDF \n The import of HDF bands requires the specification of the individual bands\n as seen by GDAL:\n # Example MODIS FPAR\n gdalinfo MOD15A2.A2003153.h18v04.004.2003171141042.hdf\n ...\n Subdatasets:\n   SUBDATASET_1_NAME=HDF4_EOS:EOS_GRID:\"MOD15A2.A2003153.h18v04.004.2003171141042.hdf\":MOD_Grid_MOD15A2:Fpar_1km\n   SUBDATASET_1_DESC=[1200x1200] Fpar_1km MOD_Grid_MOD15A2 (8-bit unsigned integer)\n   SUBDATASET_2_NAME=HDF4_EOS:EOS_GRID:\"MOD15A2.A2003153.h18v04.004.2003171141042.hdf\":MOD_Grid_MOD15A2:Lai_1km\n   SUBDATASET_2_DESC=[1200x1200] Lai_1km MOD_Grid_MOD15A2 (8-bit unsigned integer)\n ...\n # import of first band, here FPAR 1km:\n r.in.gdal HDF4_EOS:EOS_GRID:\"MOD15A2.A2003153.h18v04.004.2003171141042.hdf\":MOD_Grid_MOD15A2:Fpar_1km \n            out=fpar_1km_2003_06_02\n # ... likewise for other HDF bands in the file.\n ", "see_also": ["r.colors", "r.import", "r.in.ascii", "r.in.bin", "r.null", "t.register"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.in.gdal"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.bin.html", "name": "r.in.bin", "definition": "- Import a binary raster file into a GRASS raster map layer.", "keywords": ["raster", "import"], "synopsis": "r.in.bin [-fdsbh] input=name output=name  [title=phrase]   [bytes=integer]   [header=integer]   [bands=integer]   [order=string]   [north=float]   [south=float]   [east=float]   [west=float]   [rows=integer]   [cols=integer]   [anull=float]   [flip=string[,string,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Import as floating-point data (default: integer) Import as double-precision floating-point data (default: integer) Signed data (two's complement) Byte swap the data during import Get region info from GMT style header Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Import as double-precision floating-point data (default: integer) Signed data (two's complement) Byte swap the data during import Get region info from GMT style header Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Signed data (two's complement) Byte swap the data during import Get region info from GMT style header Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Byte swap the data during import Get region info from GMT style header Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Get region info from GMT style header Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of binary raster file to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output name or prefix if several bands are imported", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bytes", "flag": "bytes", "dataType": "String", "optional": true, "explanation": "Number of bytes per cell", "defaultValue": null, "alternatives": ["1", "2", "4", "8"], "isInputFile": false, "isOutputFile": false}, {"parameter": "header", "flag": "header", "dataType": "String", "optional": true, "explanation": "Header size in bytes", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bands", "flag": "bands", "dataType": "String", "optional": true, "explanation": "Number of bands in input file", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Output byte order", "defaultValue": "native", "alternatives": ["big", "little", "native", "swap"], "isInputFile": false, "isOutputFile": false}, {"parameter": "north", "flag": "north", "dataType": "String", "optional": true, "explanation": "Northern limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "south", "flag": "south", "dataType": "String", "optional": true, "explanation": "Southern limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "east", "flag": "east", "dataType": "String", "optional": true, "explanation": "Eastern limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "west", "flag": "west", "dataType": "String", "optional": true, "explanation": "Western limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rows", "flag": "rows", "dataType": "String", "optional": true, "explanation": "Number of rows", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cols", "flag": "cols", "dataType": "String", "optional": true, "explanation": "Number of columns", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "anull", "flag": "anull", "dataType": "String", "optional": true, "explanation": "Set Value to NULL", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "flip", "flag": "flip", "dataType": "String", "optional": true, "explanation": "Flip input horizontal and/or vertical", "defaultValue": null, "alternatives": ["h", "v"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.in.bin  allows the user to create a (binary) GRASS raster map layer \n from a variety of binary raster data formats. \n  The   -s  flag is used for importing two's-complement signed data.\n  The   -h  flag is used to read region information from a Generic\n Mapping Tools (GMT) type binary header. It is compatible with GMT binary\n grid types 1 and 2.\n  The north, south, east, and west field values are the coordinates of the \n edges of the geographic region. The rows and cols values describe the dimensions \n of the matrix of data to follow. If the input is a\n  GMT  binary array\n (-h flag), the six dimension fields (north, south, east, west, rows and cols)\n are obtained from the GMT header. If the bytes field is entered incorrectly an \n error will be generated suggesting a closer bytes value. \n  r.in.bin  can be used to import numerous binary arrays including:\n ETOPO30, ETOPO-5, ETOPO-2, Globe DEM, BIL, AVHRR and GMT binary arrays\n (ID 1 & 2).\n ", "notes": "\n If optional parameters are not supplied,  r.in.bin  attempts\n to calculate them. For example if the rows and columns parameters are \n not entered,  r.in.bin  automatically calculates them by subtracting\n south from north and west from east. This will only produce correct\n results if the raster resolution equals 1. Also, if the north, south, \n east, and west parameters are not entered,  r.in.bin  assigns \n them from the rows and columns parameters. In the AVHRR example (see below), \n the raster would be assigned a north=128, south=0, east=128, west=0.\n  The geographic coordinates north, south, east, and west\n describe the outer edges of the geographic region. They run along the edges of \n the cells at the edge of the geographic region and  not  through the \n center of the cells at the edges.\n  Eastern limit of geographic region (in projected coordinates must be east\n of the west parameter value, but in geographical coordinates will wrap\n around the globe; user errors can be detected by comparing the  ewres  and\n  nsres  values of the imported map layer carefully).\n Western limit of geographic region (in projected coordinates must be west\n of the east parameter value, but in geographical coordinates will wrap\n around the globe; user errors can be detected by comparing the  ewres  and\n  nsres  values of the imported map layer carefully).\n  Notes on (non)signed data: If you use the  -s  flag, the highest bit is the \n sign bit. If this is 1, the data is negative, and the data interval is half of \n the unsigned (not exactly).\n  This flag is only used if  bytes=  1. If  bytes  is greater\n than 1, the flag is ignored.\n  EXAMPLES \n  GTOPO30 DEM \n The following is a sample call of  r.in.bin  to import  \n  GTOPO30 DEM \n data:\n r.in.bin -sb input=E020N90.DEM output=gtopo30 bytes=2 north=90 south=40\n east=60 west=20 r=6000 c=4800\n  (you can add \"anull=-9999\" if you want sea level to have a NULL value)\n  GMT \n The following is a sample call of  r.in.bin  to import a GMT \n type 1 (float) binary array:\n r.in.bin -hf input=sample.grd output=sample.grass\n  (-b could be used to swap bytes if required)\n  AVHRR \n The following is a sample call of  r.in.bin  to import an AVHRR image:\n   \n r.in.bin in=p07_b6.dat out=avhrr c=128 r=128\n  ETOPO2 \n The following is a sample call of  r.in.bin  to import \n  ETOPO2 DEM  data (here full data set):\n r.in.bin ETOPO2.dos.bin out=ETOPO2min r=5400 c=10800 n=90 s=-90 w=-180 e=180 bytes=2\n r.colors ETOPO2min rules=terrain\n  TOPEX/SRTM30 PLUS \n The following is a sample call of  r.in.bin  to import \n  SRTM30 PLUS  data:\n r.in.bin -sb input=e020n40.Bathymetry.srtm output=e020n40_topex \n           bytes=2 north=40 south=-10 east=60 west=20 r=6000 c=4800\n r.colors e020n40_topex rules=etopo2\n  GPCP \n The following is a sample call of  r.in.bin  to import GPCP 1DD v1.2 data:\n   \n YEAR=\"2000\"\n MONTH=\"01\"\n # number of days of this month\n MDAYS=`date -d\"${YEAR}-${MONTH}-01 + 1 month - 1 day\" +%d`\n r.in.bin in=gpcp_1dd_v1.2_p1d.${YEAR}${MONTH} out=gpcp_${YEAR}.${MONTH}. \n           order=big bytes=4 -f header=1440 anull=-99999 \n           n=90 s=-90 w=0 e=360 rows=180 cols=360 bands=$MDAYS\n The following is a sample call of  r.in.bin  to import GPCP v2.2 data:\n   \n r.in.bin in=gpcp_v2.2_psg.1979 out=gpcp_1979. \n           order=big bytes=4 -f header=576 anull=-99999 \n           n=90 s=-90 w=0 e=360 rows=72 cols=144 bands=12\n ", "see_also": ["r.import", "r.out.bin", "r.in.ascii", "r.out.ascii", "r.in.gdal", "r.out.gdal", "r.in.srtm"], "authors": ["Jacques Bouchard, France (bouchard@onera.fr)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.in.bin"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.aster.html", "name": "r.in.aster", "definition": "- Georeference, rectify, and import Terra-ASTER imagery and relative DEMs using gdalwarp.", "keywords": ["raster", "import", "imagery", "ASTER", "elevation"], "synopsis": "r.in.aster input=name proctype=string band=string output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input ASTER image", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "proctype", "flag": "proctype", "dataType": "String", "optional": false, "explanation": "ASTER imagery processing type (Level 1A, Level 1B, or relative DEM)", "defaultValue": "L1B", "alternatives": ["L1A", "L1B", "DEM"], "isInputFile": false, "isOutputFile": false}, {"parameter": "band", "flag": "band", "dataType": "String", "optional": false, "explanation": "List L1A or L1B band to translate (1,2,3n,...), or enter 'all' to translate all bands", "defaultValue": "all", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Base name for output raster map (band number will be appended to base name)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.in.aster  rectifies, georeferences, and imports Terra-ASTER imagery \n to current location using gdalwarp, hdf 4, and r.in.gdal, using projection parameters \n from g.proj. It can import Level 1A, Level 1B, and relative DEM products.\n  The program may be run interactively or non-interactively from the command \n   line. In either case, the user must specify an  input  *.hdf file name, \n   the  type  of processing used, the image  band  to import, and an \n    output  GRASS raster map name. \n  The  type  parameter can take values of L1A, L1B, or DEM. \n  The  band  parameter can take values of 1, 2, 3n, 3b, 4-14\n ", "notes": "", "see_also": [], "authors": ["Michael Barton, Arizona State University and Paul Kelly"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.in.aster"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.in.ascii.html", "name": "r.in.ascii", "definition": "- Converts a GRASS ASCII raster file to binary raster map.", "keywords": ["raster", "import", "conversion", "ASCII"], "synopsis": "r.in.ascii [-s] input=name output=name  [type=string]   [title=phrase]   [multiplier=float]   [null_value=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "SURFER (Golden Software) ASCII file will be imported Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of raster map to be created", "defaultValue": null, "alternatives": ["CELL", "FCELL", "DCELL"], "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "multiplier", "flag": "multiplier", "dataType": "String", "optional": true, "explanation": "Multiplier for ASCII data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value data cell", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.in.ascii  allows a user to create a (binary) GRASS raster map\n layer from an ASCII raster input file with (optional) TITLE.\n The GRASS ASCII  input  file has a header section which describes\n the location and size of the data, followed by the data itself.\n The header has 6 lines: \n north:   xxxxxx.xx\n south:   xxxxxx.xx\n east:    xxxxxx.xx\n west:    xxxxxx.xx\n rows:    r \n cols:    c \n The north, south, east, and west field values entered \n are the coordinates of the edges of the geographic region. \n The rows and cols field values entered describe the dimensions \n of the matrix of data to follow. \n The data which follows is  r  rows of  c  integers. \n Optionally the following parameters can be defined in the header section:\n null: nn\n type: float\n multiplier: 2.\n \"null\" defines a string or number to be converted to NULL value (no\n data). \n \"type\" defines the data type (int, float double) and is not required. \n \"multiplier\" is an optional parameter to multiply each cell value.\n ", "notes": "\n The geographic coordinates north, south, east, and west\n describe the outer edges of the geographic region.  They\n run along the edges of the cells at the edge of the\n geographic region and  not  through the center of the cells\n at the edges.\n The NW value occurs at the beginning of the first line of data, and the\n SW value occurs at the beginning of the last line of data.\n The data (which follows the header section) must contain\n  r   x   c  values, but it is not necessary \n that all the data for a row be on one line. A row may be \n split over many lines. \n  r.in.ascii  may import  integer ,  floating point , or  double  cell \n types using the  -i ,  -f , and  -d  flags, respectively. \n The header information in ESRI Raster ASCII files differs from GRASS.  \n To convert an Arc/Info (ArcView) ASCII grid file into GRASS, see \n  r.in.gdal .\n SURFER (Golden Software) ASCII files may be imported by passing the  -s  flag.\n  EXAMPLE \n The following is a sample  input  file to  r.in.ascii : \n north:                   4299000.00\n south:                   4247000.00\n east:                     528000.00\n west:                     500000.00\n rows:                         10   \n cols:                         15   \n null:                      -9999   \n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n ", "see_also": ["r.import", "r.out.ascii", "r.in.gdal", "r.out.gdal", "r.in.bin", "r3.in.ascii"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.in.ascii"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.recode.html", "name": "r.recode", "definition": "- Recodes categorical raster maps.", "keywords": ["raster", "recode categories", "reclassification"], "synopsis": "r.recode [-ad] input=name output=name rules=name  [title=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Align the current region to the input raster map Force output to 'double' raster map type (DCELL) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Force output to 'double' raster map type (DCELL) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of raster map to be recoded", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": false, "explanation": "File containing recode rules", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "", "notes": "", "see_also": [], "authors": ["CERL"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.recode"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.reclass.html", "name": "r.reclass", "definition": "- Reclassify raster map based on category values.", "keywords": ["raster", "reclassification"], "synopsis": "r.reclass input=name output=name rules=name  [title=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of raster map to be reclassified", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": false, "explanation": "File containing reclass rules", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.reclass  creates an  output  map layer\n based on an  input  integer raster map layer.  The output\n map layer will be a reclassification of the input map layer\n based on reclass rules input to  r.reclass , and can\n be treated in much the same way that raster maps are\n treated.  A  TITLE  for the output map layer may be\n (optionally) specified by the user.\n  The reclass rules are read from standard input (i.e., from\n the keyboard, redirected from a file, or piped through\n another program).\n  Before using  r.reclass  the user must know the following:\n  The new categories desired;  and, which old categories fit into \n which new categories.\n  The names of the new categories.\n ", "notes": "\n In fact, the  r.reclass  program does  not  generate any new\n raster map layers (in the interests of disk space conservation).  Instead, a\n  reclass table  is stored which will be used to reclassify the\n original raster map layer each time the new (reclassed) map name\n is requested.  As far as the user (and programmer) is concerned, that\n raster map has been created.\n  r.reclass  only works on an  integer  input raster map; if the\n input map is instead floating point data, you must multiply the input data by some\n factor to achieve whole number input data, otherwise  r.reclass  will round\n the raster values down to the next integer.\n  Also note that although the user can generate a  r.reclass  map\n which is based on another  r.reclass  map,\n the new  r.reclass  map will be stored in GRASS as a reclass\n of the  original  raster map on which the first reclassed map was\n based.  Therefore, while GRASS allows the user to provide  r.reclass  \n map layer information which is based on an already reclassified map\n (for the user's convenience), no  r.reclass  map layer\n (i.e.,  reclass table ) will ever be  stored \n as a  r.reclass  of a  r.reclass .\n  To convert a reclass map to a regular raster map layer, set your\n geographic region settings to match the settings in the header for the\n reclass map (with \" g.region\u00a0raster=reclass_map \", or\n viewable by running  r.info ) \n and then run  r.resample .\n  r.mapcalc  can be used to convert\n a reclass map to a regular raster map layer as well:\n   r.mapcalc \"raster_map = reclass_map\"\n  where  raster_map  is the name to be given to the new raster map,\n and  reclass_map  is an existing reclass map.\n  Because  r.reclass  generates internally simply a table by\n referencing some original raster map layer rather than creating a full\n new reclassed raster map layer, a  r.reclass  map layer will\n no longer be accessible if the original raster map layer, upon which\n it was based, is later removed. Therefore, attempting to remove a\n raster map layer from which a  r.reclass  has been derived\n is only possible if the original map is removed first.\n Alternatively, a  r.reclass  map can be removed including \n its base map by using  g.remove 's\n  -b  flag.\n  A  r.reclass  map is not a true raster map layer.\n Rather, it is a table of reclassification values which reference the\n input raster map layer.  Therefore, users who wish to retain reclassified\n map layers must also save the original input raster map layers\n from which they were generated. Alternatively  r.recode  can be used.\n  Category values which are not explicitly reclassified to a new value\n by the user will be reclassified to NULL.\n  Reclass Rules \n Each line of input must have the following format:\n  input_categories= output_category   [ label ]\n  where each line of input specifies the category values in the\n input raster map layer to be reclassified to the new\n  output_category  category value.  Specification of\n a  label  to be associated with the new output map\n layer category is optional.  If specified, it is recorded\n as the category label for the new category value.  The\n equal sign = is required.  The  input_category(ies) \n may consist of single category values or a range of such\n values in the format \" low  thru  high .\" The\n word \"thru\" must be present.\n  To include all (remaining) values the asterix \"*\" can be used. This\n rule has to be set as last rule. No further rules are accepted after\n setting this rule. The special rule \" * = * \" specifies\n that all categories not expicitly set by one of the above rules\n should be passed through unaltered instead of being set to NULL.\n  Categories to become no data are specified by setting the output\n category value to \" NULL \".\n A line containing only the word  end  terminates the\n input.\n  EXAMPLES \n  Reclass rules examples \n The following examples may help clarify the reclass rules.\n The first example reclassifies categories 1, 2 and 3 in the input raster\n map layer \"roads\" to category 1 with category label \"good quality\" in the output map\n layer, and reclassifies input raster map layer categories 4 and 5 to\n category 2 with the label \"poor quality\" in the output map layer.\n     1 2 3   = 1    good quality\n     4 5     = 2    poor quality\n The following example reclassifies categories 1, 3 and 5 in the input raster\n map layer to category 1 with category label \"poor quality\" in the output\n map layer, and reclassifies input raster map layer categories 2, 4, and 6\n to category 2 with the label \"good quality\" in the output map layer.\n All other values are reclassified to NULL.\n     1 3 5   = 1    poor quality\n     2 4 6   = 2    good quality\n     *       = NULL\n The following example reclassifies input raster map layer categories\n 1 thru 10 to output \n map layer category 1, input map layer categories 11 thru 20 to output map layer\n category 2, and input map layer categories 21 thru 30 to output map layer\n category 3, all without labels. The range from 30 to 40 is reclassified as\n NULL.\n      1 thru 10\t= 1\n     11 thru 20\t= 2\n     21 thru 30\t= 3\n     30 thru 40  = NULL\n The following example shows overlapping rules. Subsequent rules override\n previous rules. Therefore, the below example\n reclassifies input raster map layer categories 1 thru 19 and 51 thru 100\n to category 1 in the output map layer,\n input raster map layer categories 20 thru 24 and 26 thru 50 to\n the output map layer category 2, and input raster map layer category 25\n to the output category 3.\n      1 thru 100\t= 1    poor quality\n     20 thru 50\t= 2    medium quality\n     25\t        = 3    good quality\n The previous example could also have been entered as:\n      1 thru 19  51 thru 100\t= 1    poor quality\n     20 thru 24  26 thru 50\t= 2    medium quality\n     25\t\t\t\t= 3    good quality\n or as:\n      1 thru 19\t = 1    poor quality\n     51 thru 100\t = 1\n     20 thru 24\t = 2\n     26 thru 50\t = 2    medium quality\n     25\t\t = 3    good quality\n The final example was given to show how the labels are handled.  If a new\n category value appears in more than one rule (as is the case with new \n category values 1 and 2),\n the last label which was specified becomes the label for that category.\n In this case the labels are assigned exactly as in the two previous examples.\n  Usage example \n In this example, the 21 classes of the landuse map (North Carolina sample\n dataset) are simplified to 7 classes:\n r.category landuse96_28m\n 0\tnot classified\n 1\tHigh Intensity Developed\n 2\tLow Intensity Developed\n 3\tCultivated\n [...]\n 20\tWater Bodies\n 21      Unconsolidated Sediment\n # use this command or save rules with editor in textfile \"landuserecl.txt\"\n echo \"0 = NULL\n 1 2     = 1 developed\n 3       = 2 agriculture\n 4 6     = 3 herbaceous\n 7 8 9   = 4 shrubland\n 10 thru 18 = 5 forest\n 20      = 6 water\n 21      = 7 sediment\" > landuserecl.txt\n r.reclass input=landuse96_28m output=landclass96_recl \n    rules=landuserecl.txt \n    title=\"Simplified landuse classes 1996\"\n # verify result\n r.category landuse96_recl\n 1\tdeveloped\n 2\tagriculture\n 3\therbaceous\n 4\tshrubland\n 5\tforest\n 6\twater\n 7\tsediment\n ", "see_also": ["r.resample", "r.rescale", "r.recode"], "authors": ["James Westervelt,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.reclass"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.reclass.area.html", "name": "r.reclass.area", "definition": "- Reclasses a raster map greater or less than user specified area size (in hectares).", "keywords": ["raster", "statistics", "aggregation"], "synopsis": "r.reclass.area [-cd] input=name output=name value=float mode=string  [method=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Input map is clumped Clumps including diagonal neighbors Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Clumps including diagonal neighbors Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "value", "flag": "value", "dataType": "String", "optional": false, "explanation": "Value option that sets the area size limit (in hectares)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mode", "flag": "mode", "dataType": "String", "optional": false, "explanation": "Lesser or greater than specified value", "defaultValue": null, "alternatives": ["lesser", "greater"], "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Method used for reclassification", "defaultValue": "reclass", "alternatives": ["reclass", "rmarea"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.reclass.area  reclasses a raster map greater or\n less than a user specified area size (in hectares).\n If the  -c  flag is used,  r.reclass.area  will skip the creation\n of a clumped raster and assume that the input raster is already clumped.\n  EXAMPLES \n In this example, the ZIP code map in the North Carolina sample dataset location\n is filtered for large areas (removing smaller areas from the map):\n g.region raster=zipcodes -p\n r.report zipcodes unit=h\n # extract only areas greater than 2000 ha, NULL otherwise:\n r.reclass.area input=zipcodes output=zipcodes_larger2000ha \n                 mode=greater value=2000\n r.report zipcodes_larger2000ha unit=h\n In this example, the ZIP code map in the North Carolina sample dataset location\n is filtered for smaller areas which are substituted with the value of the respective\n adjacent area with largest shared boundary:\n # reclass by substitutional removing of areas minor of 1000 ha\n r.reclass.area input=zipcodes output=zipcodes_minor1000ha \n                 mode=lesser value=1000 method=rmarea\n ", "notes": "", "see_also": ["r.reclass", "r.clump", "r.stats"], "authors": ["NRCS,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.reclass.area"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.random.surface.html", "name": "r.random.surface", "definition": "- Generates random surface(s) with spatial dependence.", "keywords": ["raster", "surface", "random"], "synopsis": "r.random.surface [-u] output=string[,string,...]  [distance=float]   [exponent=float]   [flat=float]   [seed=integer]   [high=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "u", "flag": "-u", "explanation": "Uniformly distributed cell values Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": true, "explanation": "Maximum distance of spatial correlation (value >= 0.0)", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "exponent", "flag": "exponent", "dataType": "String", "optional": true, "explanation": "Distance decay exponent (value > 0.0)", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "flat", "flag": "flat", "dataType": "String", "optional": true, "explanation": "Distance filter remains flat before beginning exponent", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "seed", "flag": "seed", "dataType": "String", "optional": true, "explanation": "Random seed (SEED_MIN >= value >= SEED_MAX), default [random]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "high", "flag": "high", "dataType": "String", "optional": true, "explanation": "Maximum cell value of distribution", "defaultValue": "255", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.random.surface  generates a spatially dependent random surface. \n The random surface is composed of values representing the deviation from the\n mean of the initial random values driving the algorithm. The initial random\n values are independent Gaussian random deviates with a mean of 0 and\n standard deviation of 1. The initial values are spread over each output map\n using filter(s) of diameter distance.  The influence of each random value on\n nearby cells is determined by a distance decay function based on exponent.\n If multiple filters are passed over the output maps, each filter is given a\n weight based on the weight inputs.  The resulting random surface can have\n  any  mean and variance, but the theoretical mean of an infinitely\n large map is 0.0 and a variance of 1.0. Description of the algorithm is in\n the  NOTES  section.\n  The random surface generated are composed of floating point numbers, and\n saved in the category description files of the output map(s).  Cell values\n are uniformly or normally distributed between 1 and high values inclusive\n (determined by whether the  -u  flag is used). The category names\n indicate the average floating point value and the range of floating point\n values that each cell value represents.\n  r.random.surface's  original goal is to generate random fields for\n spatial error modeling. A procedure to use  r.random.surface  in\n spatial error modeling is given in the  NOTES  section.\n  Detailed parameter description \n  output \n  Random surface(s). The cell values are a random distribution\n between the low and high values inclusive.  The category values of the\n output map(s) are in the form  #.# #.# to #.#  where each #.#\n is a floating point number. The first number is the average of the\n random values the cell value represents. The other two numbers are the\n range of random values for that cell value. The  average  mean\n value of generated  output  map(s) is 0. The  average \n variance of map(s) generated is 1. The random values represent the\n standard deviation from the mean of that random surface. \n  distance \n  Distance determines the spatial dependence of the output\n map(s). The distance value indicates the minimum distance at which two\n map cells have no relationship to each other. A distance value of 0.0\n indicates that there is no spatial dependence (i.e., adjacent cell\n values have no relationship to each other). As the distance value\n increases, adjacent cell values will have values closer to each other. But the range and distribution of cell values over the output\n map(s) will remain the same.  Visually, the clumps of lower and higher\n values gets larger as distance increases. If multiple values are\n given, each output map will have multiple filters, one for each set of\n distance, exponent, and weight values. \n  exponent \n  Exponent determines the distance decay exponent for a particular\n filter. The exponent value(s) have the property of determining\n the  texture  of the random surface. Texture will decrease as\n the exponent value(s) get closer to 1.0. Normally, exponent will be\n 1.0 or less. If there are no exponent values given, each filter will\n be given an exponent value of 1.0. If there is at least one exponent\n value given, there must be one exponent value for each distance value. \n  flat \n  Flat determines the distance at which the filter. \n  weight \n  Weight determines the relative importance of each filter. For\n example, if there were two filters driving the algorithm and\n weight=1.0, 2.0 was given in the command line: The second filter would\n be twice as important as the first filter. If no weight values are\n given, each filter will be just as important as the other filters\n defining the random field. If weight values exist, there must be a\n weight value for each filter of the random field. \n  high \n  Specifies the high end of the range of cell values in the output\n map(s). Specifying a very large high value will minimize\n the  errors  caused by the random surface's discretization. The\n word errors is in quotes because errors in discretization are often\n going to cancel each other out and the spatial statistics are far more\n sensitive to the initial independent random deviates than any\n potential discretization errors. \n  seed \n  Specifies the random seed(s), one for each map,\n that  r.random.surface  will use to generate the initial set of\n random values that the resulting map is based on. If the random seed\n is not given,  r.random.surface  will get a seed from the\n process ID number. \n ", "notes": "\n While most literature uses the term random field instead of random surface,\n this algorithm always generates a surface. Thus, its use of random surface.\n  r.random.surface  builds the random surface using a filter algorithm\n smoothing a map of independent random deviates. The size of the filter is\n determined by the largest distance of spatial dependence. The shape of the\n filter is determined by the distance decay exponent(s), and the various\n weights if different sets of spatial parameters are used. The map of\n independent random deviates will be as large as the current region PLUS the\n extent of the filter. This will eliminate edge effects caused by the\n reduction of degrees of freedom. The map of independent random deviates will\n ignore the current mask for the same reason.\n  One of the most important uses for  r.random.surface  is to determine\n how the error inherent in raster maps might effect the analyses done with\n those maps.\n  REFERENCES \n Random Field Software for GRASS by Chuck Ehlschlaeger\n    As part of my dissertation, I put together several programs that help\n GRASS (4.1 and beyond) develop uncertainty models of spatial data. I hope\n you find it useful and dependable. The following papers might clarify their\n use:\n   Ehlschlaeger, C.R., Shortridge, A.M., Goodchild, M.F., 1997. \n  Visualizing spatial data uncertainty using animation. \n  Computers & Geosciences 23, 387-395. doi:10.1016/S0098-3004(97)00005-8 \n  Modeling\n Uncertainty in Elevation Data for Geographical Analysis , by\n Charles R. Ehlschlaeger, and Ashton M.  Shortridge. Proceedings of the\n 7th International Symposium on Spatial Data Handling, Delft,\n Netherlands, August 1996. \n  Dealing\n with Uncertainty in Categorical Coverage Maps: Defining, Visualizing,\n and Managing Data Errors , by Charles Ehlschlaeger and Michael\n Goodchild.  Proceedings, Workshop on Geographic Information Systems at\n the Conference on Information and Knowledge Management, Gaithersburg\n MD, 1994. \n  Uncertainty\n in Spatial Data: Defining, Visualizing, and Managing Data\n Errors , by Charles Ehlschlaeger and Michael\n Goodchild. Proceedings, GIS/LIS'94, pp. 246-253, Phoenix AZ,\n 1994. \n ", "see_also": ["r.random", "r.random.cells", "r.mapcalc", "r.surf.random"], "authors": ["Charles Ehlschlaeger, Michael Goodchild, and Chih-chang Lin; National Center for Geographic Information and Analysis, University of California, Santa Barbara."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.random.surface"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.random.html", "name": "r.random", "definition": "- Creates a raster map layer and vector point map containing randomly located points.", "keywords": ["raster", "sampling", "vector", "random", "level1"], "synopsis": "r.random [-zidb] input=name  [cover=name]  npoints=number[%]  [raster=name]   [vector=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Generate points also for NULL category Report information about input raster and exit Generate vector points as 3D points Do not build topology Do not build topology in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Report information about input raster and exit Generate vector points as 3D points Do not build topology Do not build topology in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Generate vector points as 3D points Do not build topology Do not build topology in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Do not build topology in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "cover", "flag": "cover", "dataType": "String", "optional": true, "explanation": "Name of cover raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "npoints", "flag": "npoints", "dataType": "String", "optional": false, "explanation": "The number of points to allocate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "vector", "flag": "vector", "dataType": "String", "optional": true, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  The program  r.random  allows the user to create a\n raster map layer and/or a vector points map containing \n coordinates of points whose locations have been randomly\n determined.  The program locates these randomly generated\n vector points (sites) within the current geographic region and mask (if\n any), on non-NULL category value data areas within a\n user-specified raster map layer. If the user sets the\n  -z  flag, points will be randomly generated across all\n cells (even those with NULL values).\n  The category values and\n corresponding category names already associated with the\n random point locations in the  input  map layer are\n assigned to these points in the  raster_output  map\n layer. If the  -z  is specified, then a unique entry\n is made for the value used where the  input  was NULL.\n This value is at least 1 less than the smallest value in the\n  input  raster and is given a medium gray color.\n ", "notes": "\n  If a  cover  raster map is specified and the  cover  map\n contains NULL (no data) values, these points are suppressed in the\n resulting  vector_output  or  raster_output  map.\n  The  vector_output  file created by  r.random \n contains vector points that represent the  center points  of the\n randomly generated cells.  A  value  attribute contains the cell value\n of the  input  raster (or the assigned value\n when  -z  is used).  \n If a  cover  map is additionally specified, a second\n column   covervalue  is populated with raster values from\n the  cover  map.\n  If the user sets the  -b  flag, vector points are written without\n topology to minimize the required resources. This is suitable input\n to  v.surf.rst  and other vector modules.\n  The user may specify the quantity of random locations to be\n generated either as a  positive integer  (e.g., 10),\n or as a  percentage of the raster map layer's cells  \n (e.g., 10%, or 3.05%).  The number of cells considered for \n the percentage reflects whether or not the  -z  flag\n was given. Options are 0-100; percentages less than\n one percent may be stated as decimals.\n  Flag  -i  prints the raster map's name and location, \n the total number of cells under the current region settings, and\n the number of NULL valued cells under the current region settings.\n Then module exits without doing anything.  Useful for deciding on the number\n of sites to have  r.random  create.\n  WARNING:  this feature may be removed in future. Use \n  g.region  and \n  r.report \n instead.\n g.region -p\n r.report map=inputmap units=c null=* nsteps=1\n  To create random vector point locations within some, but not all, \n non-zero categories of the input raster map layer, \n the user must first create a reclassified raster map layer \n of the original raster map layer (e.g., using the GRASS \n program  r.reclass ) \n that contains only the desired categories, \n and then use the reclassed raster map layer as input to  r.random .\n  EXAMPLES \n  Random vector elevation points sampled from elevation map in the\n Spearfish region, result stored in 2D vector map:\n g.region raster=elevation.10m -p\n r.random elevation.10m vector=elevrand n=100\n v.db.select elevrand\n v.univar elevrand col=value type=point\n  Random vector elevation points sampled from elevation map in the\n Spearfish region with collocated values sampled from landuse map,\n result stored in 3D vector map:\n g.region raster=elevation.10m -p\n r.random -d elevation.10m cover=landcover.30m vector=luserand3d n=100\n # data output (value: elevation, covervalue: landuse class):\n v.db.select luserand3d\n cat|value|covervalue\n 1|1151.406616|81\n 2|1172.121216|71\n 3|1183.219604|71\n ...\n  KNOWN ISSUES \n It's not possible to use the  -i  flag and not also specify the  n  \n parameter.\n ", "see_also": ["g.region", "r.reclass", "v.random", "v.surf.rst"], "authors": ["Dr. James Hinthorne, GIS Laboratory, Central Washington University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.random"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.random.cells.html", "name": "r.random.cells", "definition": "- Generates random cell values with spatial dependence.", "keywords": ["raster", "sampling", "random", "autocorrelation"], "synopsis": "r.random.cells output=name distance=float  [ncells=integer]   [seed=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": false, "explanation": "Maximum distance of spatial correlation (value >= 0.0)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ncells", "flag": "ncells", "dataType": "String", "optional": true, "explanation": "Maximum number of cells to be created", "defaultValue": null, "alternatives": ["1-"], "isInputFile": false, "isOutputFile": false}, {"parameter": "seed", "flag": "seed", "dataType": "String", "optional": true, "explanation": "Random seed (SEED_MIN >= value >= SEED_MAX) (default [random])", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.random.cells  generates a random sets of raster cells that are\n at least  distance  apart. The cells are numbered from 1 to the\n numbers of cells generated, all other cells are NULL (no data). Random\n cells will not be generated in areas masked off.\n  Detailed parameter description \n  output \n  Random cells. Each random cell has a unique non-zero cell value\n ranging from 1 to the number of cells generated. The heuristic for\n this algorithm is to randomly pick cells until there are no cells\n outside of the chosen cell's buffer of radius  distance . \n  distance \n  Determines the minimum distance the centers of the random cells\n will be apart. \n  seed \n  Specifies the random seed that\n  r.random.cells  will use to generate the cells. If the random seed\n is not given,  r.random.cells  will get a seed from the process ID\n number. \n ", "notes": "\n The original purpose for this program was to generate independent\n random samples of cells in a study area. The  distance  value is\n the amount of spatial autocorrelation for the map being studied. \n  EXAMPLE \n  Random cells in given distances \n North Carolina sample dataset example:\n g.region n=228500 s=215000 w=630000 e=645000 res=100 -p\n r.random.cells output=random_500m distance=500\n  Limited number of random points \n Here is another example where we will create given number of vector points\n with the given minimal distances.\n Let's star with setting the region (we use large cells here):\n g.region raster=elevation\n g.region rows=20 cols=20 -p\n Then we generate random cells and we limit their count to 20:\n r.random.cells output=random_cells distance=1500 ncells=20 seed=200\n Finally, we convert the raster cells to points using\n  r.to.vect  module:\n r.to.vect input=random_cells output=random_points type=point\n An example of the result is at the Figure below on the left\n in comparison with the result without the cell limit on the right.\n Additionally, we can use  v.perturb  module\n to add random spatial deviation to their position so that they are not\n perfectly aligned with the grid. We cannot perturb the points too much,\n otherwise we might seriously break the minimal distance we set earlier.\n v.perturb input=random_points output=random_points_moved parameters=50 seed=200\n In the above examples, we were using fixed seed. This is advantageous when\n we want to generate (pseudo) random data, but we want to get reproducible\n results at the same time.\n     Figure: Generated cells with limited number of cells (upper left),\n     derived vector points (lower left), cells without a count limit\n     (upper right) and corresponding vector points (lower right)\n  REFERENCES \n Random Field Software for GRASS GIS by Chuck Ehlschlaeger\n    As part of my dissertation, I put together several programs that help\n GRASS (4.1 and beyond) develop uncertainty models of spatial data. I hope\n you find it useful and dependable. The following papers might clarify their\n use:\n   Ehlschlaeger, C.R., Shortridge, A.M., Goodchild, M.F., 1997. \n  Visualizing spatial data uncertainty using animation. \n  Computers & Geosciences 23, 387-395. doi:10.1016/S0098-3004(97)00005-8 \n  Modeling Uncertainty in Elevation Data for Geographical Analysis , by\n Charles R. Ehlschlaeger, and Ashton M.  Shortridge. Proceedings of the\n 7th International Symposium on Spatial Data Handling, Delft,\n Netherlands, August 1996. \n  Dealing\n with Uncertainty in Categorical Coverage Maps: Defining, Visualizing,\n and Managing Data Errors , by Charles Ehlschlaeger and Michael\n Goodchild.  Proceedings, Workshop on Geographic Information Systems at\n the Conference on Information and Knowledge Management, Gaithersburg\n MD, 1994. \n  Uncertainty\n in Spatial Data: Defining, Visualizing, and Managing Data\n Errors , by Charles Ehlschlaeger and Michael\n Goodchild. Proceedings, GIS/LIS'94, pp. 246-253, Phoenix AZ,\n 1994. \n ", "see_also": ["r.random.surface", "r.random", "v.random", "r.to.vect", "v.perturb"], "authors": ["Charles Ehlschlaeger; National Center for Geographic Information and Analysis, University of California, Santa Barbara."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.random.cells"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.quantile.html", "name": "r.quantile", "definition": "- Compute quantiles using two passes.", "keywords": ["raster", "algebra", "statistics", "percentile", "quantile"], "synopsis": "r.quantile [-r] input=name  [quantiles=integer]   [percentiles=float[,float,...]]   [bins=integer]   [file=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Generate recode rules based on quantile-defined intervals Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "quantiles", "flag": "quantiles", "dataType": "String", "optional": true, "explanation": "Number of quantiles", "defaultValue": "4", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "percentiles", "flag": "percentiles", "dataType": "String", "optional": true, "explanation": "List of percentiles", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bins", "flag": "bins", "dataType": "String", "optional": true, "explanation": "Number of bins to use", "defaultValue": "1000000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.quantile  computes quantiles in a manner suitable\n for use with large amounts of data. It is using two passes.\n  EXAMPLE \n Calculation of elevation quantiles (printed to standard-out):\n g.region raster=elevation -p\n r.quantile input=elevation percentiles=0.1,1,10,25,50,75,90,99,99.9\n The output of  r.quantile  can be used for quantile classification:\n g.region raster=elevation -p\n r.quantile elevation quantiles=5 -r --quiet | r.recode elevation \n             out=elev_quant5 rules=-\n ", "notes": "", "see_also": ["r.mode", "r.quant", "r.quantile", "r.series", "r.stats", "r.stats.quantile", "r.stats.zonal", "r.statistics", "r.univar", "v.rast.stats"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.quantile"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.quant.html", "name": "r.quant", "definition": "- Produces the quantization file for a floating-point map.", "keywords": ["raster", "statistics", "quantization"], "synopsis": "r.quant [-tr] input=string[,string,...]  [rules=name]   [basemap=string]   [fprange=dmin,dmax]   [range=min,max]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Truncate floating point data Round floating point data Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Round floating point data Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Raster map(s) to be quantized", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Path to rules file (\"-\" to read from stdin)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "basemap", "flag": "basemap", "dataType": "String", "optional": true, "explanation": "Base map to take quant rules from", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fprange", "flag": "fprange", "dataType": "String", "optional": true, "explanation": "Floating point range: dmin,dmax", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "range", "flag": "range", "dataType": "String", "optional": true, "explanation": "Integer range: min,max", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.quant  produces the quantization file for a floating-point map.\n The  map  parameter defines the map for which the rules are to be\n created. If more than one map is specified, then this implies that the\n floating-point range is the miniumum and maximum of all the maps together,\n unless either basemap=map or fprange=min,max is specified.\n   Quant rules  \n The quant rules have to be entered interactively.\n  If rules is specified, the input has the form:  \n               value1:value2:cat1:[cat2]  \n where value1 and value2 are floating point values and cat1 cand cat2 are\n integers. If cat2 is missing, it is taken to be equal to cat1. All values\n can be \"*\" which means infinity.\n ", "notes": "\n It is an error for both basemap and fprange to be specified.\n ", "see_also": ["r.support", "r.null"], "authors": ["Michael Shapiro, Olga Waupotitsch, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.quant"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.proj.html", "name": "r.proj", "definition": "- Re-projects a raster map from given location to the current location.", "keywords": ["raster", "projection", "transformation", "import"], "synopsis": "r.proj [-lnpg] location=name  [mapset=name]   [input=name]   [dbase=path]   [output=name]   [method=string]   [memory=integer]   [resolution=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "List raster maps in input mapset and exit Do not perform region cropping optimization Print input map's bounds in the current projection and exit Print input map's bounds in the current projection and exit (shell style) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Do not perform region cropping optimization Print input map's bounds in the current projection and exit Print input map's bounds in the current projection and exit (shell style) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print input map's bounds in the current projection and exit Print input map's bounds in the current projection and exit (shell style) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print input map's bounds in the current projection and exit (shell style) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": false, "explanation": "Location containing input raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapset", "flag": "mapset", "dataType": "String", "optional": true, "explanation": "Mapset containing input raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input raster map to re-project", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "dbase", "flag": "dbase", "dataType": "String", "optional": true, "explanation": "Path to GRASS database of input location", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map (default: same as 'input')", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Interpolation method to use", "defaultValue": "nearest", "alternatives": ["nearest", "bilinear", "bicubic", "lanczos", "bilinear_f", "bicubic_f", "lanczos_f"], "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used (in MB)", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "resolution", "flag": "resolution", "dataType": "String", "optional": true, "explanation": "Resolution of output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.proj  projects a raster map in a specified mapset of a\n specified location from the projection of the input location to a raster map\n in the current location. The projection information is taken from the\n current PROJ_INFO files, as set and viewed with \n  g.proj .\n  Introduction \n  Map projections \n Map projections are a method of representing information from a curved\n surface (usually a spheroid) in two dimensions, typically to allow\n indexing through cartesian coordinates.  There are a wide variety of\n projections, with common ones divided into a number of classes,\n including cylindrical and pseudo-cylindrical, conic and pseudo-conic,\n and azimuthal methods, each of which may be conformal, equal-area, or\n neither.\n  The particular projection chosen depends on the purpose of the\n project, and the size, shape and location of the area of interest.\n For example, normal cylindrical projections are good for maps which are of greater extent east-west than north-south and in equatorial\n regions, while conic projections are better in mid-latitudes;\n transverse cylindrical projections are used for maps which are of\n greater extent north-south than east-west; azimuthal projections are\n used for polar regions.  Oblique versions of any of these may also be\n used.  Conformal projections preserve angular relationships, and\n better preserve arc-length, while equal-area projections are more\n appropriate for statistical studies and work in which the amount of\n material is important.\n  Projections are defined by precise mathematical relations, so the\n method of projecting coordinates from a geographic reference frame\n (latitude-longitude) into a projected cartesian reference frame (eg\n metres) is governed by these equations.  Inverse projections can also\n be achieved.  The public-domain Unix software package  PROJ.4 \n [1] has been designed to perform these transformations, and the user's\n manual contains a detailed description of over 100 useful projections.\n This also includes a programmers library of the projection methods to\n support other software development.\n  Thus, converting a vector map - in which objects are located with\n arbitrary spatial precision - from one projection into another is\n usually accomplished by a simple two-step process: first the location\n of all the points in the map are converted from the source through an\n inverse projection into latitude-longitude, and then through a forward\n projection into the target.  (Of course the procedure will be one-step\n if either the source or target is in geographic coordinates.)\n  Converting a raster map, or image, between different projections,\n however, involves additional considerations.  A raster may be\n considered to represent a sampling of a process at a regular, ordered\n set of locations.  The set of locations that lie at the intersections\n of a cartesian grid in one projection will not, in general, coincide\n with the sample points in another projection.  Thus, the conversion of\n raster maps involves an interpolation step in which the values of\n points at intermediate locations relative to the source grid are\n estimated.\n  Projecting vector maps within the GRASS GIS \n GIS data capture, import and transfer often requires a projection\n step, since the source or client will frequently be in a different\n projection to the working projection.\n  In some cases it is convenient to do the conversion outside the\n package, prior to import or after export, using software such\n as  PROJ.4 's\n  cs2cs  [1]. This is an easy\n method for converting an ASCII file containing a list of coordinate points,\n since there is no topology to be preserved and  cs2cs  can be used to\n process simple lists using a one-line command. The  m.proj  module\n provides a handy front end to  cs2cs . \n  Vector maps is generally more complex, as parts of the data stored in\n the files will describe topology, and not just coordinates. In GRASS\n GIS the\n  v.proj  module is provided to reproject\n vector maps, transferring topology and attributes as well as node coordinates.\n This program uses the projection definition and parameters which are stored in\n the PROJ_INFO and PROJ_UNITS files in the PERMANENT mapset directory for every\n GRASS location.\n  Design of r.proj \n As discussed briefly above, the fundamental step in re-projecting a\n raster is resampling the source grid at locations corresponding to the\n intersections of a grid in the target projection. The basic procedure\n for accomplishing this, therefore, is as follows:\n  r.proj  converts a map to a new geographic projection. It\n reads a map from a different location, projects it and write it out to\n the current location. The projected data is resampled with one of four\n different methods: nearest neighbor, bilinear, bicubic iterpolation or\n lanczos.\n  The  method=nearest  method, which performs a nearest neighbor\n assignment, is the fastest of the three resampling methods. It is\n primarily used for categorical data such as a land use classification,\n since it will not change the values of the data\n cells. The  method=bilinear  method determines the new value of\n the cell based on a weighted distance average of the 4 surrounding\n cells in the input map. The  method=bicubic  method determines the\n new value of the cell based on a weighted distance average of the 16\n surrounding cells in the input map. The  method=lanzcos  method\n determines the new value of the cell based on a weighted distance\n average of the 25 surrounding cells in the input map. Compared to\n bicubic, lanczos puts a higher weight on cells close to the center and a\n lower weight on cells away from the center, resulting in slightly\n better contrast.\n  The bilinear, bicubic and lanczos interpolation methods are most\n appropriate for continuous data and cause some smoothing. The amount\n of smoothing decreases from bilinear to bicubic to lanczos. These\n options should not be used with categorical data, since the cell\n values will be altered.\n  In the bilinear, bicubic and lanczos methods, if any of the surrounding\n cells used to interpolate the new cell value are null, the resulting\n cell will be null, even if the nearest cell is not null. This will\n cause some thinning along null borders, such as the coasts of land\n areas in a DEM. The bilinear_f, bicubic_f and lanczos_f interpolation\n methods can be used if thinning along null edges is not desired.\n These methods \"fall back\" to simpler interpolation methods\n along null borders.  That is, from lanczos to bicubic to bilinear to\n nearest.\n  If nearest neighbor assignment is used, the output map has the same\n raster format as the input map. If any of the interpolations is used,\n the output map is written as floating point.\n  Note that, following normal GRASS conventions, the coverage and\n resolution of the resulting grid is set by the current region\n settings, which may be adjusted\n using  g.region . The target raster\n will be relatively unbiased for all cases if its grid has a similar\n resolution to the source, so that the resampling/interpolation step is\n only a local operation.  If the resolution is changed significantly,\n then the behaviour of the generalisation or refinement will depend on\n the model of the process being represented.  This will be very\n different for categorical versus numerical data.  Note that three\n methods for the local interpolation step are provided.\n  r.proj  supports general datum transformations, making use of\n the  PROJ.4  co-ordinate system translation library.\n ", "notes": "\n If  output  is not specified it is set to be the same as input map\n name.\n If  mapset  is not specified, its name is assumed to be the same\n as the current mapset's name.\n If  dbase  is not specified it is assumed to be the current\n database. The user only has to specify  dbase  if the source\n location is stored in another separate GRASS database.\n To avoid excessive time consumption when reprojecting a map the region\n and resolution of the target location should be set appropriately\n beforehand.\n  A simple way to do this is to check the projected bounds of the input\n map in the current location's projection using the  -p \n flag. The  -g  flag reports the same thing, but in a form which\n can be directly cut and pasted into\n a  g.region  command. After setting\n the region in that way you might check the cell resolution with\n \" g.region -p \" then snap it to a regular grid\n with  g.region 's  -a \n flag. E.g.\n  g.region -a res=5 -p . Note that this is just a rough guide.\n  A more involved, but more accurate, way to do this is to generate a\n vector \"box\" map of the region in the source location using\n   v.in.region -d .\n This \"box\" map is then reprojected into the target location with\n  v.proj . Next the region in the\n target location is set to the extent of the new vector map\n with  g.region  along with the\n desired raster resolution ( g.region -m  can be used in\n Latitude/Longitude locations to measure the geodetic length of a\n pixel).\n  r.proj  is then run for the raster map the user wants to\n reproject.  In this case a little preparation goes a long way.\n  When reprojecting whole-world maps the user should disable\n map-trimming with the  -n  flag. Trimming is not useful here\n because the module has the whole map in memory anyway. Besides that,\n world \"edges\" are hard (or impossible) to find in projections other\n than latitude-longitude so results may be odd with trimming.\n  EXAMPLES \n  Inline method \n With GRASS running in the destination location use the  -g  flag\n to show the input map's bounds once projected into the current working\n projection, then use that to set the region bounds before performing\n the reprojection:\n # calculate where output map will be\n r.proj input=elevation location=ll_wgs84 mapset=user1 -p\n Source cols: 8162\n Source rows: 12277\n Local north: -4265502.30382993\n Local south: -4473453.15255565\n Local west: 14271663.19157564\n Local east: 14409956.2693866\n # same calculation, but in a form which can be cut and pasted into a g.region call\n r.proj input=elevation location=ll_wgs84 mapset=user1 -g\n n=-4265502.30382993 s=-4473453.15255565 w=14271663.19157564 e=14409956.2693866 rows=12277 cols=8162\n g.region n=-4265502.30382993 s=-4473453.15255565 \n    w=14271663.19157564 e=14409956.2693866 rows=12277 cols=8162 -p\n projection: 99 (Mercator)\n zone:       0\n datum:      wgs84\n ellipsoid:  wgs84\n north:      -4265502.30382993\n south:      -4473453.15255565\n west:       14271663.19157564\n east:       14409956.2693866\n nsres:      16.93824621\n ewres:      16.94352828\n rows:       12277\n cols:       8162\n cells:      100204874\n # round resolution to something cleaner\n g.region res=17 -a -p\n projection: 99 (Mercator)\n zone:       0\n datum:      wgs84\n ellipsoid:  wgs84\n north:      -4265487\n south:      -4473465\n west:       14271653\n east:       14409965\n nsres:      17\n ewres:      17\n rows:       12234\n cols:       8136\n cells:      99535824\n # finally, perform the reprojection\n r.proj input=elevation location=ll_wgs84 mapset=user1 memory=800\n  v.in.region method \n # In the source location, use v.in.region to generate a bounding box around the\n # region of interest:\n v.in.region -d output=bounds type=area\n # Now switch to the target location and import the vector bounding box \n # (you can run v.proj -l to get a list of vector maps in the source location):\n v.proj input=bounds location=source_location_name output=bounds_reprojected\n # Set the region in the target location with that of the newly-imported vector\n # bounds map, and align the resolution to the desired cell resolution of the \n # final, reprojected raster map:\n g.region vector=bounds_reprojected res=5 -a\n # Now reproject the raster into the target location\n r.proj input=elevation.dem output=elevation.dem.reproj \n  location=source_location_name mapset=PERMANENT res=5 method=bicubic\n  REFERENCES \n     Evenden, G.I.  (1990)  Cartographic\n       projection procedures for the UNIX environment - a user's manual. \n     USGS Open-File Report 90-284 (OF90-284.pdf)\n     See also there: Interim Report and 2nd Interim Report on Release 4, Evenden 1994).\n     Richards, John A. (1993), Remote Sensing Digital Image Analysis,\n     Springer-Verlag, Berlin, 2nd edition.\n  PROJ 4 : Projection/datum support library.\n  Further reading \n      ASPRS Grids and Datum \n      Projections Transform List  (PROJ.4)\n      MapRef -\n       The Collection of Map Projections and Reference Systems for Europe  \n      Information and Service System for European Coordinate Reference Systems - CRS \n      Cartographical Map Projections  by Carlos A. Furuti\n ", "see_also": ["g.region", "g.proj", "i.rectify", "m.proj", "r.support", "r.stats", "v.proj", "v.in.region"], "authors": ["Martin Schroeder, University of Heidelberg, Germany"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.proj"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.profile.html", "name": "r.profile", "definition": "- Outputs the raster map layer values lying on user-defined line(s).", "keywords": ["raster", "profile", "transect"], "synopsis": "r.profile [-gc] input=name  [output=name]   [coordinates=east,north[,east,north,...]]   [file=name]   [resolution=float]   [null_value=string]   [units=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Output easting and northing in first two columns of four column output Output RRR:GGG:BBB color values for each profile point Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Output RRR:GGG:BBB color values for each profile point Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name of file for output (use output=- for stdout)", "defaultValue": "-", "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Profile coordinate pairs", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Name of input file containing coordinate pairs", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "resolution", "flag": "resolution", "dataType": "String", "optional": true, "explanation": "Resolution along profile (default = current region resolution)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Units", "defaultValue": null, "alternatives": ["meters", "kilometers", "feet", "miles"], "isInputFile": false, "isOutputFile": false}], "description": "\n This program outputs two or four column (with  -g ) data to stdout or \n an ASCII file. The default two column output consists of cumulative profile \n length and raster value. The optional four column output consists \n of easting, northing, cumulative profile length, and raster value. Profile\n end or \"turning\" points can be set manually with the  coordinates \n argument. The profile resolution, or distance between profile\n points, is obtained from the current region resolution, or can be manually\n set with the  resolution  argument.\n The  coordinates  parameter can be set to comma separated geographic\n coordinates for profile line endpoints.\n Alternatively the coordinate pairs can be piped from the text file specified\n by  file  option, or if set to \"-\", from  stdin .\n In these cases the coordinate pairs should be given one comma separated pair\n per line.\n The  resolution  parameter sets the distance between each profile point\n (resolution). The resolution must be provided in GRASS database units (i.e.\n decimal degrees for Lat Long databases and meters for UTM). By default\n  r.profile  uses the resolution of the current GRASS region.\n The  null  parameter can optionally be set to change the character\n string representing null values.\n  OUTPUT FORMAT \n The multi column output from  r.profile  is intended for easy use in\n other programs.  The output can be piped (|) directly into other programs or\n saved to a file for later use. Output with geographic coordinates ( -g )\n is compatible with  v.in.ascii  and can \n be piped direcly into this program.\n r.profile -g input=elevation coordinates=... | v.in.ascii output=elevation_profile separator=space\n The 2 column output is compatible with most plotting programs.\n The optional RGB output provides the associated GRASS colour value for\n each profile point.\n  Option  units  enables to set units of the profile length output.\n If the units are not specified, current location units will be used.\n In case of geographic locations (latitude/longitude), meters are used as default unit.\n ", "notes": "\n The profile resolution is measured exactly from the supplied end or\n \"turning\" point along the profile. The end of a profile segment will be an\n exact multiple of the profile resolution and will therefore not always match\n the end point coordinates entered for the segmanet.\n  To extract the numbers in scripts, following parameters can be used:\n r.profile input=dgm12.5 coordinates=3570631,5763556 2>/dev/null\n This filters out the everything except the numbers.\n  EXAMPLES \n  Extraction of values along profile defined by coordinates (variant 1) \n Extract a profile with coordinates (wayoints) provided on the command line\n (North Carolina data set):\n g.region raster=elevation -p\n r.profile -g input=elevation output=profile_points.csv \n            coordinates=641712,226095,641546,224138,641546,222048,641049,221186\n This will extract a profile along the track defined by the three coordinate\n pairs. The output file \"profile_points.csv\" contains\n east,north,distance,value (here: elevation).\n  Extraction of values along profile defined by coordinates (variant 2) \n Coordinate pairs can also being \"piped\" into  r.profile  (variant 2a):\n r.profile elevation resolution=1000 file=- << EOF\n 641712,226095\n 641546,224138\n 641546,222048\n 641049,221186\n EOF\n Coordinate pairs can also being \"piped\" into  r.profile  (variant 2b):\n echo \"641712,226095\n 641546,224138\n 641546,222048\n 641049,221186\" > coors.txt\n cat coors.txt | r.profile elevation resolution=1000 file=-\n The output is printed into the terminal (unless the  output  parameter\n is used) and looks as follows:\n Using resolution: 1000 [meters]\n Output columns:\n Along track dist. [meters], Elevation\n Approx. transect length: 1964.027749 [meters]\n  0.000000 84.661507\n  1000.000000 98.179062\n Approx. transect length: 2090.000000 [meters]\n  1964.027749 83.638138\n  2964.027749 89.141029\n  3964.027749 78.497757\n Approx. transect length: 995.014070 [meters]\n  4054.027749 73.988029\n ", "see_also": ["v.in.ascii", "r.what", "r.transect", "wxGUI profile tool"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.profile"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.plane.html", "name": "r.plane", "definition": "- Creates raster plane map given dip (inclination), aspect (azimuth) and one point.", "keywords": ["raster", "elevation"], "synopsis": "r.plane output=name dip=float azimuth=float easting=float northing=float elevation=float  [type=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "dip", "flag": "dip", "dataType": "String", "optional": false, "explanation": "Dip of plane in degrees", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "azimuth", "flag": "azimuth", "dataType": "String", "optional": false, "explanation": "Azimuth of the plane in degrees", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "easting", "flag": "easting", "dataType": "String", "optional": false, "explanation": "Easting coordinate of a point on the plane", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "northing", "flag": "northing", "dataType": "String", "optional": false, "explanation": "Northing coordinate of a point on the plane", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Elevation coordinate of a point on the plane", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of raster map to be created", "defaultValue": "FCELL", "alternatives": ["CELL", "FCELL", "DCELL"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.plane  creates a tilted plane raster map given user-specified\n parameters for inclination, azimuth, and the geographic location of a\n point on the plane. \n The angle orientations of the  azimuth  parameter increase counter-clockwise,\n i.e., 0 degree = N, 45 degree = NW, 90 degree = W etc.\n Increasing values of the  dip  parameter progressively lower (or dip) the northern\n half of the plane, and incline the southern half, assuming the  azimuth  parameter \n is held constant at 0 degrees.\n ", "notes": "", "see_also": [], "authors": ["Stefan J\u00e4ger (1994), University of Heidelberg during a stay at USGS"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.plane"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.path.html", "name": "r.path", "definition": "- Traces paths from starting points following input directions.", "keywords": ["raster", "hydrology", "cost surface"], "synopsis": "r.path [-can] input=name format=string  [values=name]   [raster_path=name]   [vector_path=name]   [start_coordinates=east,north[,east,north,...]]   [start_points=name[,name,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Copy input cell values on output Accumulate input values along the path Count cell numbers along the path Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Accumulate input values along the path Count cell numbers along the path Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Count cell numbers along the path Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input direction", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": false, "explanation": "Format of the input direction map", "defaultValue": "auto", "alternatives": ["auto", "degree", "45degree", "bitmask"], "isInputFile": false, "isOutputFile": false}, {"parameter": "values", "flag": "values", "dataType": "String", "optional": true, "explanation": "Name of input raster values to be used for output", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "raster_path", "flag": "raster_path", "dataType": "String", "optional": true, "explanation": "Name for output raster path map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "vector_path", "flag": "vector_path", "dataType": "String", "optional": true, "explanation": "Name for output vector path map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "start_coordinates", "flag": "start_coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates of starting point(s) (E,N)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_points", "flag": "start_points", "dataType": "String", "optional": true, "explanation": "Name of starting vector points map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.path  traces a path from starting points following input \n directions. Such a movement direction map can be generated with \n  r.walk , \n  r.cost , \n  r.slope.aspect ,\n  r.watershed , or\n  r.fill.dir ,\n provided that the direction is in degrees, measured counterclockwise\n from east.\n Alternatively, bitmask-encoded directions can be provided where each \n bit position corresponds to a specific neighbour. A path will continue \n to all neighbours with their bit set. This means a path can split and \n merge. Such bitmasked directions can be created with the  -b  \n flag of  r.cost  and \n  r.walk .\n Direction encoding for neighbors of x\n     \n   135  90  45          7 8 1\n   180  x  360          6 x 2\n   225 270 315          5 4 3\n   \n   degrees           bit positions\n   CCW from East\n A path stops when the direction is zero or negative, indicating a stop \n point or outlet.\n The  output  raster map will show one or more least-cost paths\n between each user-provided location(s) and the target points (direction \n \u2264 0). By default, the  output  will be an integer CELL map with\n the id of the start points along the least cost path, and null cells elsewhere.\n With the  -c  ( copy ) flag, the values raster map cell values are\n copied verbatim along the path. With the  -a  ( accumulate )\n flag, the accumulated cell value from the starting point up to the current\n cell is written on output. With either the  -c  or the  -a  flags, the\n  raster_path  map is created with the same cell type as\n the  values  raster map (integer, float or double).  With\n the  -n  ( number ) flag, the cells are numbered consecutively from the starting point to the final point.\n The  -c ,  -a , and  -n  flags are mutually incompatible.\n The  start_coordinates  parameter consists of map E and N grid \n coordinates of a starting point. Each x,y pair is the easting and \n northing (respectively) of a starting point from which a path will be \n traced following  input  directions. The  start_points  \n parameter can take multiple vector maps containing additional starting \n points.\n ", "notes": "\n The directions are recorded as degrees CCW from East, the Knight's move \n of r.cost and r.walk is considered:\n        112.5     67.5          \n 157.5  135   90  45   22.5     \n        180   x   0            \n 202.5  225  270  315  337.5\n        247.5     292.5\n i.e. a cell with the value 135 means the next cell is to the North-West, \n and a cell with the value 157.5 means that the next cell is to the \n West-North-West.\n  EXAMPLES \n  Hydrological path \n We are using the full North Carolina sample dataset.\n First we create the two points from a text file using\n  v.in.ascii  module\n (here the text file is CSV and we are using unix here-file syntax\n with EOF, in GUI just enter the values directly for the parameter input):\n v.in.ascii input=- output=start format=point separator=comma <<EOF\n 638667.15686275,220610.29411765\n 638610.78431373,220223.03921569\n EOF\n We need to supply a direction raster map to the  r.path  module. \n To get these directions, we use the\n  r.watershed  module:\n r.watershed elevation=elev_lid792_1m accumulation=accum drainage=drain_dir\n The directions are categorical and we convert them to degrees using\n raster algebra:\n r.mapcalc \"drain_deg = if(drain_dir != 0, 45. * abs(drain_dir), null())\"\n Now we are ready to extract the drainage paths starting at the two points.\n r.path input=drain_deg raster_path=drain_path vector_path=drain_path start_points=start\n Before we visualize the result, we set a color table for the elevation\n we are using and create a shaded relief map:\n r.colors map=elev_lid792_1m color=elevation\n r.relief input=elev_lid792_1m output=relief\n We visualize the input and output data:\n d.shade shade=relief color=elev_lid792_1m\n d.vect map=drain_path color=0:0:61 width=4 legend_label=\"drainage paths\"\n d.vect map=start color=none fill_color=224:0:0 icon=basic/circle size=15 legend_label=origins\n d.legend.vect -b\n  \n  Figure: Drainage paths from two points where directions from\n r.watershed were used \n  Least-cost path \n We compute bitmask encoded movement directions using  r.walk: \n g.region swwake_30m -p\n # create friction map based on land cover\n r.recode input=landclass96 output=friction rules=- << EOF\n 1:3:0.1:0.1\n 4:5:10.:10.\n 6:6:1000.0:1000.0\n 7:7:0.3:0.3\n EOF\n # without Knight's move\n r.walk -b elevation=elev_ned_30m friction=friction output=walkcost \n      outdir=walkdir start_coordinates=635576,216485\n r.path input=walkdir start_coordinates=640206,222795 \n      raster_path=walkpath vector_path=walkpath\n # with Knight's move\n r.walk -b -k elevation=elev_ned_30m friction=friction output=walkcost_k \n      outdir=walkdir_k start_coordinates=635576,216485\n r.path input=walkdir_k start_coordinates=640206,222795 \n      raster_path=walkpath_k vector_path=walkpath_k\n # without Knight's move and without bitmask encoding (single direction)\n r.walk elevation=elev_ned_30m friction=friction output=walkcost_s \n      outdir=walkdir_s start_coordinates=635576,216485\n r.path input=walkdir_s start_coordinates=640206,222795 \n      raster_path=walkpath_s vector_path=walkpath_s\n The extracted least-cost path splits and merges on the way from \n the start point to the stop point (start point for r.walk). Note the \n gaps in the raster path when using the Knight's move.\n  \n      \n  Figure: Comparison of shortest paths using single directions and \n multiple bitmask encoded directions without and with Knight's move \n ", "see_also": ["g.region", "r.cost", "r.walk", "r.watershed", "r.fill.dir", "r.basins.fill", "r.terraflow", "r.mapcalc"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.path"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.patch.html", "name": "r.patch", "definition": "- Creates a composite raster map layer by using known category values from one (or more) map layer(s) to fill in areas of \"no data\" in another map layer.", "keywords": ["raster", "geometry", "mosaicking", "merge", "patching", "aggregation", "series"], "synopsis": "r.patch [-zs] input=name[,name,...] output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Use zero (0) for transparency instead of NULL Do not create color and category files Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Do not create color and category files Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of raster maps to be patched together", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n The GRASS program  r.patch  allows the user to build a new\n raster map the size and resolution of the current region by assigning\n known data values from input raster maps to the cells in this region.\n This is done by filling in \"no data\" cells, those that do not yet\n contain data, contain NULL data, or, optionally contain 0 data,\n with the data from the first input map.\n Once this is done the remaining holes are filled in by the next input map,\n and so on.\n This program\n is useful for making a composite raster map layer from two or more adjacent\n map layers, for filling in \"holes\" in a raster map layer's data (e.g., in\n digital elevation data), or for updating an older map layer with more recent\n data. The current geographic region definition and mask settings are\n respected.\n  Figure: Result of patching two raster maps containing NULLs using\n the default settings \n  The first  name  listed in the string\n  input= name , name , name , ... is the name of\n the first map whose data values will be used to fill in \"no data\" cells\n in the current region. The second through last input  name \n maps will be used, in order, to supply data values for for the remaining\n \"no data\" cells.\n  Figure: Result of patching two raster maps using the  -z  flag\n to treat zeros as NULLs \n  Relation to SQL COALESCE() function \n The module is corresponds to the SQL COALESCE() function.\n This function takes two or more arguments and returns\n a copy of its first non-NULL argument. If all arguments are NULL,\n the function returns NULL.\n The  r.patch  module iterates over all cells and for each cell\n of the output raster map uses the first corresponding non-NULL cell\n in the series of the input raster maps.\n  Example of filling areas \n Below, the raster map layer on the far left is  patched \n with the middle ( patching ) raster map layer,\n to produce the  composite  raster map layer on the right.\n The example assumes zero values to be treated as NULLs ( -z  flag).\n   1 1 1 0 2 2 0 0    0 0 1 1 0 0 0 0    1 1 1 1 2 2 0 0\n   1 1 0 2 2 2 0 0    0 0 1 1 0 0 0 0    1 1 1 2 2 2 0 0\n   3 3 3 3 2 2 0 0    0 0 0 0 0 0 0 0    3 3 3 3 2 2 0 0\n   3 3 3 3 0 0 0 0    4 4 4 4 4 4 4 4    3 3 3 3 4 4 4 4\n   3 3 3 0 0 0 0 0    4 4 4 4 4 4 4 4    3 3 3 4 4 4 4 4\n   0 0 0 0 0 0 0 0    4 4 4 4 4 4 4 4    4 4 4 4 4 4 4 4\n Switching the  patched  and the  patching  raster map layers \n produces the following results: \n   0 0 1 1 0 0 0 0    1 1 1 0 2 2 0 0    1 1 1 1 2 2 0 0\n   0 0 1 1 0 0 0 0    1 1 0 2 2 2 0 0    1 1 1 1 2 2 0 0\n   0 0 0 0 0 0 0 0    3 3 3 3 2 2 0 0    3 3 3 3 2 2 0 0\n   4 4 4 4 4 4 4 4    3 3 3 3 0 0 0 0    4 4 4 4 4 4 4 4\n   4 4 4 4 4 4 4 4    3 3 3 0 0 0 0 0    4 4 4 4 4 4 4 4\n   4 4 4 4 4 4 4 4    0 0 0 0 0 0 0 0    4 4 4 4 4 4 4 4\n ", "notes": "\n Frequently, this program is used to patch together adjacent map layers which\n have been digitized separately.  The program \n  v.mkgrid  can be used to make adjacent\n maps align neatly.\n  The user should check the current geographic region settings before running \n  r.patch , to ensure that the region boundaries encompass all of the data desired to be included in the composite map and to ensure that the region resolution is the resolution of the desired data. To set the\n geographic region settings to one or several raster maps, the  g.region \n program can be used:\n g.region raster=map1[,map2[,...]]\n Use of  r.patch  is generally followed by use of the GRASS programs \n  g.remove  and \n  g.rename ;\n  g.remove  is used to remove the original (un-patched) raster map\n layers, while  g.rename  is used to then assign to the newly-created\n composite (patched) raster map layer the name of the original raster map\n layer.\n  r.patch  reads the existing category label files and color tables\n from the  input  maps and creates these files for the patched, \n composite  output  map.  This can be quite time consuming for \n certain maps, especially if there are many different category values \n across the patched maps. The  -s  flag allows disabling the reading\n and creation of these support files,  meaning that the  output  \n map will have no category labels and no explicit color table.\n Number of raster maps to be processed is given by the limit of the\n operating system. For example, both the hard and soft limits are\n typically 1024. The soft limit can be changed with e.g.  ulimit -n\n 1500  (UNIX-based operating systems) but not higher than the hard\n limit. If it is too low, you can as superuser add an entry in\n /etc/security/limits.conf\n # <domain>      <type>  <item>         <value>\n your_username  hard    nofile          1500\n This would raise the hard limit to 1500 file. Be warned that more\n files open need more RAM. See also the Wiki page\n  Hints for large raster data processing .\n Operating systems usually limit the length of the command line\n which limits the number of input raster maps user can pass to the module\n using the option  input . In that case,\n  r.series  can be used instead of\n  r.patch .\n  EXAMPLES \n  Example with three maps \n The input are three maps called roads, water and forest. Primarily,\n we want to use the values from roads, then from water and if no\n other values are available we want to use forest.\n First we set the computation region assuming that the all three maps\n fully overlap and have the same resolution (so we can safely use the\n just the one without further modifications of the region).\n Then we perform the patching.\n g.region raster=roads\n r.patch input=roads,water,forest output=result\n  Example using Bash syntax \n Create a list of maps matching a pattern, extend the region to include them\n all, and patch them together to create a mosaic. Overlapping maps will be \n used in the order listed.\n MAPS=`g.list type=raster sep=, pat=\"map_*\"`\n g.region raster=$MAPS\n r.patch in=$MAPS out=mosaic\n ", "see_also": ["g.region", "g.remove", "g.rename", "r.mapcalc", "r.support", "r.series", "v.mkgrid"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.patch"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.param.scale.html", "name": "r.param.scale", "definition": "- Extracts terrain parameters from a DEM.", "keywords": ["raster", "geomorphology", "terrain", "elevation", "landform"], "synopsis": "r.param.scale [-c] input=name output=name  [slope_tolerance=float]   [curvature_tolerance=float]   [size=integer]   [method=string]   [exponent=float]   [zscale=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Constrain model through central window cell Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map containing morphometric parameter", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "slope_tolerance", "flag": "slope_tolerance", "dataType": "String", "optional": true, "explanation": "Slope tolerance that defines a 'flat' surface (degrees)", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "curvature_tolerance", "flag": "curvature_tolerance", "dataType": "String", "optional": true, "explanation": "Curvature tolerance that defines 'planar' surface", "defaultValue": "0.0001", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Size of processing window (odd number only)", "defaultValue": "3", "alternatives": ["3-499"], "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Morphometric parameter in 'size' window to calculate", "defaultValue": "elev", "alternatives": ["elev", "slope", "aspect", "profc", "planc", "longc", "crosc", "minic", "maxic", "feature"], "isInputFile": false, "isOutputFile": false}, {"parameter": "exponent", "flag": "exponent", "dataType": "String", "optional": true, "explanation": "Exponent for distance weighting (0.0-4.0)", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Vertical scaling factor", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.param.scale  extracts terrain parameters from a digital elevation model. Uses a\n multi-scale approach by fitting a bivariate quadratic polynomial to a given\n window size using least squares.\n  The module calculates the following parameters (terminology is from Wood,\n 1996 with related terminology used in other GRASS modules listed in\n brackets):\n  elev : Generalised elevation value (for resampling purposes at different\n scale) \n  slope : Magnitude of maximum gradient (steepest slope angle) \n  aspect : Direction of maximum gradient (steepest slope direction=flow direction) \n  profc : profile curvature (curvature intersecting with the plane\n defined by  Z  axis and maximum gradient direction). Positive values\n describe convex profile curvature, negative values concave profile\n curvature. \n  planc : plan curvature (horizontal curvature, intersecting with\n the  XY  plane) \n  longc : longitudinal curvature (profile curvature intersecting\n with the plane defined by the surface normal and maximum gradient direction) \n  crosc : cross-sectional curvature (tangential curvature intersecting\n with the plane defined by the surface normal and a tangent to the contour\n - perpendicular to maximum gradient direction) \n  maxic : maximum curvature (can be in any direction) \n  minic : minimum curvature (in direction perpendicular to the direction\n of of maximum curvature) \n  feature : Morphometric features: peaks, ridges, passes, channels, pits and planes \n ", "notes": "\n In  r.param.scale  the direction of maximum gradient (considered\n downslope) is stored as (West is 0 degree, East is +/- 180 degree):\n 0..+180 degree from West to North to East \n 0..-180 degree from West to South to East \n Note that the aspect map is calculated differently from\n  r.slope.aspect .\n  EXAMPLE \n The next commands will create a geomorphological map of the Spearfish sample dataset region:\n g.region raster=elevation.10m -p\n r.param.scale in=elevation.10m output=morphology method=feature size=9\n  Figure: Geomorphological map of a subregion in the Spearfish (SD) area \n  TODO \n Fix bug when `constrain through central cell' option selected. Create color\n tables for all output files (presently only on features).\n  REFERENCES \n    Wood, J. (1996): The Geomorphological characterisation of\n     Digital Elevation Models. Diss., Department of Geography, University\n     of Leicester, U.K online at:\n      http://hdl.handle.net/2381/34503 \n    Java Code in\n      LandSerf \n     that implements the same procedure \n ", "see_also": ["r.geomorphon", "r.slope.aspect"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.param.scale"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.pack.html", "name": "r.pack", "definition": "- Exports a raster map as GRASS GIS specific archive file", "keywords": ["raster", "export", "copying"], "synopsis": "r.pack [-c] input=name  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Switch the compression off Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of raster map to pack up", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (default is <input>.pack)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.pack  collects raster map elements and support files and\n compressed them using  gzip  algorithm for copying. The resulting\n packed file can be afterwards unpacked within a GRASS GIS session\n by  r.unpack .\n Since the selected raster map is not exported but natively stored, the\n current region is not respected. Hence  r.pack  stores the entire\n raster map.\n ", "notes": "\n By default, the name of the pack file is determined from the  input \n parameter. Optionally a different name can be given by  output  parameter.\n Currently only 2D raster maps are supported.\n  EXAMPLE \n Pack up the entire raster map  aspect  into  aspect.pack  file:\n r.pack input=aspect\n The packed raster map file   aspect.pack  can afterwards be unpacked by\n r.unpack input=aspect.pack\n ", "see_also": ["r.unpack", "r.in.gdal", "g.copy", "r.proj", "v.unpack"], "authors": ["Original Bash script written by Hamish Bowman, Otago University, New Zealand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.pack"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.xyz.html", "name": "r.out.xyz", "definition": "- Exports a raster map to a text file as x,y,z values based on cell centers.", "keywords": ["raster", "export", "ASCII", "conversion"], "synopsis": "r.out.xyz [-i] input=name[,name,...]  [output=name]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Include no data values Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n The  r.out.xyz  module exports a raster map as a list of x,y,z\n values into an ASCII text file.\n ", "notes": "\n This module will by default not export x,y coordinates for raster cells\n containing a NULL value. This includes cells masked by a raster MASK.\n Using the flag  -i  also these raster cells will be included in the\n exported data.\n This module, as all GRASS raster modules, will export cells based on the\n current region settings. See the  g.region  module for details.\n The  r.out.ascii  module should be used to export an array (of\n size row x column) containing z values.\n  r.out.xyz  can combine several input raster maps, which can be \n convenient when it comes to e.g. produce ASCII point cloud files.\n  r.out.xyz  is simply a front-end to \" r.stats -1g[n] \".\n  EXAMPLES \n In this example, a LiDAR elevation map in the\n North Carolina sample dataset location is exported to CSV format.\n g.region raster=elev_lid792_1m -p\n r.out.xyz input=elev_lid792_1m output=elev_lid792_1m.csv separator=\",\"\n In this example, elevation data from the North Carolina dataset are\n exported along with R,G,B triplet of the related orthophoto into a\n combined file (requires the import of the supplementary high-resolution\n  color orthophoto , here called \"ortho2010_t792\"):\n g.region raster=elev_lid792_1m res=1 -a -p\n r.out.xyz input=elev_lid792_1m,ortho2010_t792.red,ortho2010_t792.green,ortho2010_t792.blue \n          separator=space output=pointcloud.asc\n # validate: X Y Z R G B\n head -n 3 pointcloud.asc\n 638300.5 220749.5 126.338218689 78 84 71\n 638301.5 220749.5 126.3381958008 93 101 86\n 638302.5 220749.5 126.3414840698 68 77 59\n  TODO \n Implement this script as a  r.out.ascii  option?\n ", "see_also": ["g.region", "r.mask", "r.out.ascii", "r.stats"], "authors": ["M. Hamish Bowman"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.out.xyz"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.vtk.html", "name": "r.out.vtk", "definition": "- Converts raster maps into the VTK-ASCII format.", "keywords": ["raster", "export", "VTK"], "synopsis": "r.out.vtk [-pstvoc]  [input=name[,name,...]]   [output=name]   [elevation=name]   [null=float]   [z=float]   [rgbmaps=string[,string,...]]   [vectormaps=string[,string,...]]   [zscale=float]   [precision=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Create VTK point data instead of VTK cell data (if no elevation map is given) Use structured grid for elevation (not recommended) Use polydata-trianglestrips for elevation grid creation Use polydata-vertices for elevation grid creation (to use with vtkDelauny2D) Scale factor affects the origin (if no elevation map is given) Correct the coordinates to match the VTK-OpenGL precision Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Use structured grid for elevation (not recommended) Use polydata-trianglestrips for elevation grid creation Use polydata-vertices for elevation grid creation (to use with vtkDelauny2D) Scale factor affects the origin (if no elevation map is given) Correct the coordinates to match the VTK-OpenGL precision Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Use polydata-trianglestrips for elevation grid creation Use polydata-vertices for elevation grid creation (to use with vtkDelauny2D) Scale factor affects the origin (if no elevation map is given) Correct the coordinates to match the VTK-OpenGL precision Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Use polydata-vertices for elevation grid creation (to use with vtkDelauny2D) Scale factor affects the origin (if no elevation map is given) Correct the coordinates to match the VTK-OpenGL precision Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Scale factor affects the origin (if no elevation map is given) Correct the coordinates to match the VTK-OpenGL precision Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Correct the coordinates to match the VTK-OpenGL precision Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Raster map(s) to be converted to VTK-ASCII data format", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for VTK-ASCII output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "Value to represent no data cell", "defaultValue": "-99999.99", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "z", "flag": "z", "dataType": "String", "optional": true, "explanation": "Constant elevation (if no elevation map is specified)", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rgbmaps", "flag": "rgbmaps", "dataType": "String", "optional": true, "explanation": "Three (r,g,b) raster maps to create RGB values [redmap,greenmap,bluemap]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vectormaps", "flag": "vectormaps", "dataType": "String", "optional": true, "explanation": "Three (x,y,z) raster maps to create vector values [xmap,ymap,zmap]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Scale factor for elevation", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Number of significant digits (floating point only)", "defaultValue": "12", "alternatives": ["0-20"], "isInputFile": false, "isOutputFile": false}], "description": "\n Outputs  raster  maps in  VTK-ASCII  format.  Map's  are\n valid raster map's in the current mapset.   output  is the name of\n an VTK-ASCII file which will be written in the current working directory.\n If  output  is not specified then  stdout  is used.  \n The module is sensitive to region settings (set with g.region).\n Elevation, scaling, point/celldata, vector and RGB Data are supported.\n If the map is in LL projection, the elevation values will automatically scaled to \n degrees. It is supposed that the elevation values are provided in meters. \n If the elevation values are in a different unit than meters, use \n the scale parameter to convert the units. \n If no elevation map is given, the user can set the height of the map by one value. \n Point or cell data are available. Also scaling is supported for this elevation value. \n The elevation value must be provided in meters.\n The RGB input requires three raster maps: red, green, blue  - in this order. \n The maps must have values between 0 and 255, otherwise you will get lots of warnings\n and the values are set to 0.\n More than one RGB dataset (3 maps) is not supported. \n The vector input requires three raster maps: x, y, z -- defining the vector coordinates  - in this order. \n More than one vector dataset (3 maps) is not supported. \n ", "notes": "\n This filter generates: \n  structured points  with  celldata  or  pointdata  if no elevationfile is given \n  structured grid  (not recommendet) with  pointdata  if an elevationfile is given \n  polydataset  with  pointdata  if an elevationfile is given (default)  \n and puts this in a simple VTK-ASCII file. Nor XML or \n binary output are supported. It is possible to choose more then one raster map\n to be written to the VTK-ASCII file. Each cell-/pointdata is named like the raster map it represents.\n You can visualize this file with the \n  VTK Toolkit , \n  Paraview  and \n  MayaVi  which are based on VTK.\n If you have a raster map with partly no data, use the threshold filter in paraview to \n visualize the valid data. Just filter all data which is greater/lesser than the \n chosen null value in the VTK-ASCII file.\n If elevation map is chosen, a polygonal grid is created with  quads , \n but the user can choose also  triangle strips  or  vertices . \n These dataformats a documented at  VTK Toolkit .\n If the \"-c\" flag is used and the data should be visualised together with other data exported via *.out.vtk\n modules, be sure the \"-c\" flag was also set in these modules.\n But this will only work with data from the SAME location \n (The reference point for the coordinates transformation is based on the center point of the default region).\n  Difference between point- and celldata \n r.out.vtk can export raster cells with different representations.\n     \n        pointdata  -- the cells/values are represented by the center of the cell. \n       Instead of cells, points are created. Each point can hold different values, \n       but the user can only visualize one value at a time. These points can \n       be connected in different ways.\n     \n     \n         celldata  -- is only provided if no elevation map is given. \n        The cells are created with the same hight and width as in GRASS. Each cell \n        can hold different values, but the user can only visualize one value at a time. \n     \n  EXAMPLE \n  Simple Spearfish example \n # set region\n g.region n=4926970 s=4914857 w=591583 e=607793 res=50 -p\n # export the data\n r.out.vtk input=elevation.10m,slope,aspect elevation=elevation.10m output=/tmp/out.vtk\n # visualize in Paraview or other VTK viewer:\n paraview --data=/tmp/out.vtk\n  Spearfish example with RGB data \n #set the region\n g.region n=4926990 s=4914840 w=591570 e=607800 res=30 -p\n # using r.in.wms to create RGB data to get a satellite coverage\n r.in.wms layers=global_mosaic mapserver=http://wms.jpl.nasa.gov/wms.cgi \n           output=wms_global_mosaic\n # export the data to VTK\n r.out.vtk rgbmaps=wms_global_mosaic.red,wms_global_mosaic.green,wms_global_mosaic.blue \n            elevation=elevation.10m output=/tmp/out.vtk\n # visualize in Paraview or other VTK viewer:\n paraview --data=/tmp/out.vtk\n  Paraview RGB visualization notes \n To achieve proper RGB overlay:\n   In Paraview, click \"Apply\"\n   Select the \"Display\" tab and choose \"Color by\" to switch from input scalars to rgb scalars\n   Disable the \"Map Scalars\" check button in the display tab to avoid the use of a lookup table \n ", "see_also": ["r3.out.vtk", "r.out.ascii", "g.region"], "authors": ["Soeren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.vtk"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.vrml.html", "name": "r.out.vrml", "definition": "- Exports a raster map to the Virtual Reality Modeling Language (VRML).", "keywords": ["raster", "export", "VRML"], "synopsis": "r.out.vrml elevation=name  [color=name]   [exaggeration=float]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Name of input color map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "exaggeration", "flag": "exaggeration", "dataType": "String", "optional": true, "explanation": "Vertical exaggeration", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output VRML file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n This module exports a GRASS raster map to the Virtual Reality Modeling\n Language (VRML) format for 3D visualization.\n  This version only outputs raster maps in VRML 1.0 format.\n The newer VRML 2.0 format will be more efficient for geographic\n applications, as it introduces an \"ElevationGrid\" node so that\n only the elevation points will have to be written instead\n of the whole geometry.  The vast majority of VRML viewers\n currently only support VRML 1.0.\n If the extension \"wrl\" (world) is not present in the he\n  output  parameter, it will be added.\n  WARNING \n VRML is not well suited for large geometrys which can result from even\n a small geographic region.  Most viewers seem to bog down with more\n than 12,000 polygons, depending on your hardware & specific\n viewer.  Each grid cell results in two polygons, so a reasonable size\n region would be something less than about 75x75.  For improved\n performance and smaller file size, leave off a color map.  Since VRML\n is ascii text, gzip works very well to significantly compress file\n size. \n ", "notes": "", "see_also": [], "authors": ["Bill Brown, US Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.vrml"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.ppm3.html", "name": "r.out.ppm3", "definition": "- Converts 3 GRASS raster layers (R,G,B) to a PPM image file.", "keywords": ["raster", "export"], "synopsis": "r.out.ppm3 [-c] red=string green=string blue=string output=string  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Add comments to describe the region Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <red>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <green>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": false, "explanation": "Name of raster map to be used for <blue>", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for new PPM file. (use '-' for stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.out.ppm3  converts 3 GRASS raster layers (R,G,B) to a PPM\n image file, using the current region.\n  This program converts a GRASS raster map to a PPM image file\n using the the current region settings.\n  To get the full area and resolutin of the raster map, run:\n g.region raster=[mapname]\n  before running  r.out.ppm3 .\n ", "notes": "\n One pixel is written for each cell value, so if ew_res and ns_res\n differ, the aspect ratio of the resulting image will be off.\n ", "see_also": ["r.out.ppm", "r.in.gdal", "d.rgb"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.ppm3"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.ppm.html", "name": "r.out.ppm", "definition": "- Converts a GRASS raster map to a PPM image file.", "keywords": ["raster", "export"], "synopsis": "r.out.ppm [-gh] input=name  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Output greyscale instead of color Suppress printing of PPM header Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Suppress printing of PPM header Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for new PPM file (use '-' for stdout)", "defaultValue": "<rasterfilename>.ppm", "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.out.ppm  converts a GRASS raster map into a PPM image \n at the pixel resolution of the CURRENTLY DEFINED REGION. \n To get the resolution and region settings of the raster map, run: \n g.region -p raster=[mapname]\n before running  r.out.ppm . \n By default the PPM file created is 24-bit color, rawbits storage.\n You can use the  -g  flag to force  r.out.ppm  to \n output an 8-bit greyscale instead.\n The greyscale conversion uses the NTSC conversion:\n Y = .30*Red + .59*Green + .11*Blue\n  One pixel is written for each cell value, so if  ew_res  and \n  ns_res  differ, the aspect ratio of the resulting image will be off.\n ", "notes": "\n A few ppm file comments are written: the name of the GRASS\n raster map, resolution, etc.  Although these are perfectly legal,\n I've found one PD image utility that chokes on them, so if you need \n a commentless PPM file, use ' out=-\u00a0>\u00a0outfile.ppm '. (When sending \n output to stdout, no comments are written.)\n  HINTS \n You can create a PNG image with NULL values represented by a transparent \n background by using the  PNG driver  with \n  GRASS_RENDER_TRANSPARENT  set to TRUE.\n Alternatively, you can use the  pnmtopng  program from \n  netpbm  to do this:\n r.out.ppm raster\n pnmtopng -transparent white raster.ppm > raster.png\n ", "see_also": ["d.out.file", "r.out.ascii", "r.out.gdal", "r.out.mpeg", "r.out.png", "r.out.ppm3"], "authors": ["Bill Brown, UIUC"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.ppm"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.pov.html", "name": "r.out.pov", "definition": "- Converts a raster map layer into a height-field file for POV-Ray.", "keywords": ["raster", "export"], "synopsis": "r.out.pov input=name output=name  [hftype=integer]   [bias=float]   [scale=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of output povray file (TGA height field file)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "hftype", "flag": "hftype", "dataType": "String", "optional": true, "explanation": "Height-field type (0=actual heights 1=normalized)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bias", "flag": "bias", "dataType": "String", "optional": true, "explanation": "Elevation bias", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Vertical scaling factor", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "", "notes": "", "see_also": [], "authors": ["Klaus D. Meyer, GEUM.tec GbR, eMail:"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.pov"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.png.html", "name": "r.out.png", "definition": "- Export a GRASS raster map as a non-georeferenced PNG image.", "keywords": ["raster", "export", "PNG"], "synopsis": "r.out.png [-tw] input=name output=name  [compression=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Make NULL cells transparent Output world file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Output world file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for new PNG file (use '-' for stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "compression", "flag": "compression", "dataType": "String", "optional": true, "explanation": "Compression level of PNG file", "defaultValue": "6", "alternatives": ["0-9"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.out.png  exports a GRASS raster map in non-georeferenced PNG image\n format, respecting the current region resolution and bounds.\n  Optionally the user can choose to export a World File to provide basic\n georeferencing support. When used with the transparency flag this can\n create images useful for KML, TMS, or WMS overlays. (e.g. for use in\n Google Earth or as OpenLayers tiles) If output is to stdout, the world\n file will be called  png_map.wld .\n ", "notes": "", "see_also": ["r.out.gdal", "r.out.ppm", "r.out.ascii", "r.in.png"], "authors": ["Alex Shevlakov"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.png"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.mpeg.html", "name": "r.out.mpeg", "definition": "- Converts raster map series to MPEG movie.", "keywords": ["raster", "export", "animation"], "synopsis": "r.out.mpeg [-c] view1=name[,name,...]  [view2=name[,name,...]]   [view3=name[,name,...]]   [view4=name[,name,...]]  output=name  [quality=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Convert on the fly, uses less disk space Requires r.out.ppm with stdout option Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "view1", "flag": "view1", "dataType": "String", "optional": false, "explanation": "Name of input raster map(s) for view no.1", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "view2", "flag": "view2", "dataType": "String", "optional": true, "explanation": "Name of input raster map(s) for view no.2", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "view3", "flag": "view3", "dataType": "String", "optional": true, "explanation": "Name of input raster map(s) for view no.3", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "view4", "flag": "view4", "dataType": "String", "optional": true, "explanation": "Name of input raster map(s) for view no.4", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "quality", "flag": "quality", "dataType": "String", "optional": true, "explanation": "Quality factor (1 = highest quality, lowest compression)", "defaultValue": "3", "alternatives": ["1-5"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.out.mpeg  is a tool for combining a series of GRASS raster\n maps into a single MPEG-1\n ( Motion\n Pictures Experts Group ) format file.  MPEG-1 is a\n \"lossy\" video compression format, so the quality of each\n resulting frame of the animation will be much diminished from the\n original raster image.  The resulting output file may then be viewed\n using your favorite mpeg-format viewing program.  MPEG-2 and MPEG-4\n provide much better quality animations.\n  The user may define up to four \"views\", or sub-windows,\n to animate simultaneously.  e.g., View 1 could be rainfall, View 2\n flooded areas, View 3 damage to bridges or levees, View 4 other\n economic damage, all animated as a time series. A black border 2\n pixels wide is drawn around each view. There is an arbitrary limit of\n 400 files per view (400 animation frames).  Temporary files are\n created in the conversion process, so lack of adequate tmp space could\n also limit the number of frames you are able to convert.\n  The environment variable GMPEG_SIZE is checked for a value to use\n as the dimension, in pixels, of the longest dimension of the animation\n image.  If GMPEG_SIZE is not set, the animation size defaults to the\n rows & columns in the current GRASS region, scaling if necessary\n to a default minimum size of 200 and maximum of 500.  These size\n defaults are overridden when using the  -c  flag (see below). The\n resolution of the current GRASS region is maintained, independent of\n image size.  Playback programs have to decode the compressed data\n \"on-the-fly\", therefore smaller dimensioned animations will provide\n higher frame rates and smoother animations.\n  UNIX - style wild cards may be used with the command line version\n in place of a raster map name, but wild cards must be quoted.\n  A quality value of  quality=1  will yield higher quality images,\n but with less compression (larger MPEG file size). Compression ratios\n will vary depending on the number of frames in the animation, but an\n MPEG produced using  quality=5  will usually be about 60% the size\n of the MPEG produced using  quality=1 .\n  Example \n r.out.mpeg view1=\"rain[1-9]\",\"rain1[0-2]\" view2=\"temp*\"\n  If the number of files differs for each view, the view with the\n fewest files will determine the number of frames in the animation.\n  With  -c  flag the module converts \"on the fly\", uses less\n disk space by using  r.out.ppm \n with stdout option to convert frames as needed instead of converting all frames to ppm before encoding.  Only use when encoding a single view.  Use of this option also overrides any size defaults, using\n the  CURRENTLY DEFINED GRASS REGION for the output size . So be\n careful to set region to a reasonable size prior to encoding.\n  KNOWN ISSUES \n MPEG images must be 16-pixel aligned for successful compression, so if\n the rows & columns of the calculated image size (scaled, with\n borders added) are not evenly divisible by 16, a few rows/columns will\n be cut off the bottom & right sides of the image. The MPEG format\n is optimized to recognize image MOTION, so abrupt changes from one\n frame to another will cause a \"noisy\" encoding.\n ", "notes": "\n This program requires the program  mpeg_encode \n (aka  ppmtompeg ):\n  MPEG-1 Video Software Encoder  (Version 1.3; March 14, 1994)\n  Lawrence A. Rowe, Kevin Gong, Ketan Patel, and Dan Wallach Computer Science \n Division-EECS, Univ. of Calif. at Berkeley\n  Available from Berkeley: \n  http://biowiki.org/BerkeleyMpegEncoder \n  or as part of the netpbm package ( ppmtompeg ):\n  http://netpbm.sourceforge.net \n  Use of the  -c  flag requires\n the  r.out.ppm  GRASS module with\n the  stdout  option.\n ", "see_also": ["r.out.ppm"], "authors": ["Bill Brown, U.S. Army Construction Engineering Research Laboratories"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.mpeg"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.mat.html", "name": "r.out.mat", "definition": "- Exports a GRASS raster to a binary MAT-File.", "keywords": ["raster", "export"], "synopsis": "r.out.mat input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output binary MAT file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.out.mat  will export a GRASS raster map to a MAT-File which can\n be loaded into Matlab or Octave for plotting or further analysis. \n Attributes such as map title and bounds will also be exported into \n additional array variables. \n Specifically, the following array variables are created: \n     map_data \n     map_name \n     map_title  (if it exists)\n     map_northern_edge \n     map_southern_edge \n     map_eastern_edge \n     map_western_edge \n In addition,  r.out.mat  makes for a nice binary container format\n for transferring georeferenced maps around, even if you don't use Matlab \n or Octave. \n ", "notes": "\n  r.out.mat  exports a Version 4 MAT-File. These files should \n successfully load into more modern versions of Matlab and Octave \n without any problems. \n Everything should be Endian safe, so the resultant file can be simply \n copied between different system architectures without binary translation.\n As there is no IEEE value for  NaN  for integer maps, GRASS's null \n value is used to represent it within these maps. You'll have to do something \n like this to clean them once the map is loaded into Matlab:\n      map_data(find(map_data < -1e9)) = NaN; \n Null values in maps containing either floating point or double-precision \n floating point data should translate into  NaN  values as expected.\n  r.out.mat  must load the entire map into memory before writing, \n therefore it might have problems with  huge  maps.\n (a 3000x4000 DCELL map uses about 100mb RAM) \n GRASS defines its map bounds at the outer-edge of the bounding cells, not at\n the coordinates of their centroids. Thus, the following Matlab commands may \n be used to determine the map's resolution information:\n     [rows cols] = size(map_data)\n     x_range = map_eastern_edge - map_western_edge\n     y_range = map_northern_edge - map_southern_edge\n     ns_res = y_range/rows\n     ew_res = x_range/cols\n  EXAMPLE \n In Matlab, plot with either:\n imagesc(map_data), axis equal, axis tight, colorbar\n or\n contourf(map_data, 24), axis ij, axis equal, axis tight, colorbar\n  TODO \n Add support for exporting map history, category information, color map, etc.\n Option to export as a version 5 MAT-File, with map and support information \n stored in a single structured array.\n ", "see_also": [], "authors": ["Hamish Bowman"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.mat"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.gridatb.html", "name": "r.out.gridatb", "definition": "- Exports GRASS raster map to GRIDATB.FOR map file (TOPMODEL).", "keywords": ["raster", "export"], "synopsis": "r.out.gridatb input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.out.gridatb  exports a GRASS raster map to GRIDATB.FOR map file\n (TOPMODEL)\n ", "notes": "", "see_also": ["r.topmodel", "r.in.gridatb"], "authors": ["Huidae Cho based on code from Keith Beven"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.gridatb"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.gdal.html", "name": "r.out.gdal", "definition": "- Exports GRASS raster maps into GDAL supported formats.", "keywords": ["raster", "export"], "synopsis": "r.out.gdal [-lcmtf] input=name output=name format=string  [type=string]   [createopt=string[,string,...]]   [metaopt=string[,string,...]]   [nodata=float]   [overviews=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "List supported output formats Do not write GDAL standard colortable Only applicable to Byte or UInt16 data types Do not write non-standard metadata Enhances compatibility with other GIS software Write raster attribute table Some export formats may not be supported Force raster export despite any warnings of data loss Overrides nodata safety check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Do not write GDAL standard colortable Only applicable to Byte or UInt16 data types Do not write non-standard metadata Enhances compatibility with other GIS software Write raster attribute table Some export formats may not be supported Force raster export despite any warnings of data loss Overrides nodata safety check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Do not write non-standard metadata Enhances compatibility with other GIS software Write raster attribute table Some export formats may not be supported Force raster export despite any warnings of data loss Overrides nodata safety check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Write raster attribute table Some export formats may not be supported Force raster export despite any warnings of data loss Overrides nodata safety check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Force raster export despite any warnings of data loss Overrides nodata safety check Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of raster map (or group) to export", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": false, "explanation": "Raster data format to write (case sensitive, see also -l flag)", "defaultValue": "GTiff", "alternatives": ["VRT", "GTiff", "NITF", "HFA", "ELAS", "AAIGrid", "DTED", "PNG", "JPEG", "MEM", "GIF", "XPM", "BMP", "PCIDSK", "PCRaster", "ILWIS", "SGI", "SRTMHGT", "Leveller", "Terragen", "GMT", "netCDF", "HDF4Image", "ISIS2", "ERS", "JPEG2000", "FIT", "RMF", "WMS", "RST", "INGR", "GSAG", "GSBG", "GS7BG", "R", "PNM", "ENVI", "EHdr", "PAux", "MFF", "MFF2", "BT", "LAN", "IDA", "GTX", "NTv2", "CTable2", "ARG", "USGSDEM", "ADRG", "BLX", "Rasterlite", "EPSILON", "PostGISRaster", "SAGA", "KMLSUPEROVERLAY", "XYZ", "HF2", "PDF", "WEBP", "ZMap"], "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Data type", "defaultValue": null, "alternatives": ["Byte", "Int16", "UInt16", "Int32", "UInt32", "Float32", "Float64", "CInt16", "CInt32", "CFloat32", "CFloat64"], "isInputFile": false, "isOutputFile": false}, {"parameter": "createopt", "flag": "createopt", "dataType": "String", "optional": true, "explanation": "Creation option(s) to pass to the output format driver", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "metaopt", "flag": "metaopt", "dataType": "String", "optional": true, "explanation": "Metadata key(s) and value(s) to include", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nodata", "flag": "nodata", "dataType": "String", "optional": true, "explanation": "Assign a specified nodata value to output bands", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "overviews", "flag": "overviews", "dataType": "String", "optional": true, "explanation": "Number of overviews to create for the output dataset", "defaultValue": "0", "alternatives": ["0-5"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.out.gdal  allows a user to export a GRASS raster map layer\n into any GDAL supported raster map format. If a GRASS raster map is\n exported for a particular application, the application's native format\n would be preferable. GeoTIFF is supported by a wide range of\n applications (see also  NOTES  on GeoTIFF below).\n  To specify multiple creation options use a comma separated list\n ( createopt=\"TFW=YES,COMPRESS=DEFLATE\" ).\n  For possible  createopt  and  metaopt  parameters please\n consult the individual\n  supported formats \n pages on the GDAL website.\n The  createopt  parameter may be used to create TFW or World files\n (\"TFW=YES\",\"WORLDFILE=ON\").\n  r.out.gdal  also supports the export of multiband rasters as\n a group, when the imagery group's name is entered as input.\n (created imagery groups with the  i.group \n module)\n  As with most GRASS raster modules, the current region extents and region\n resolution are used, and a MASK is respected if present.\n Use  g.region 's \"align=\", or \"raster=\"\n options if you need to realign the region settings to match the original\n map's before export.\n  SUPPORTED RASTER FORMATS \n The set of  supported \n raster formats  written by  r.out.gdal  depends on the local \n GDAL installation, printed with the  -l  flag. Available may be \n (incomplete list): \n   AAIGrid: Arc/Info ASCII Grid\n   BMP: MS Windows Device Independent Bitmap\n   BSB: Maptech BSB Nautical Charts\n   DTED: DTED Elevation Raster\n   ELAS: ELAS\n   ENVI: ENVI .hdr Labelled\n   FIT: FIT Image\n   GIF: Graphics Interchange Format (.gif)\n   GTiff: GeoTIFF\n   HDF4Image: HDF4 Dataset\n   HFA: Erdas Imagine Images (.img)\n   JPEG2000: JPEG-2000 part 1 (ISO/IEC 15444-1)\n   JPEG: JPEG JFIF\n   MEM: In Memory Raster\n   MFF2: Atlantis MFF2 (HKV) Raster\n   MFF: Atlantis MFF Raster\n   NITF: National Imagery Transmission Format\n   PAux: PCI .aux Labelled\n   PCIDSK: PCIDSK Database File\n   PNG: Portable Network Graphics\n   PNM: Portable Pixmap Format (netpbm)\n   VRT: Virtual Raster\n   XPM: X11 PixMap Format\n ", "notes": "\n  Out of the GDAL data types, the closest match for GRASS CELL, FCELL and\n DCELL rasters are respectively Int32, Float32 and Float64. These are not\n exact equivalents, but they will preserve the maximum possible data range\n and number of decimal places for each respective GRASS raster data type.\n Please keep in mind that not all CELL rasters will require Int32 - e.g.,\n 0-255 CELL raster are covered by the Byte  type  as well.\n Moreover, some GDAL-supported formats do not support all the data types\n possible in GDAL and GRASS. Use  r.info  to\n check the data type and range for your GRASS raster, refer to specific\n format documentation (on the  GDAL website ),\n format vendor's documentation, and e.g. the Wikipedia article\n Typical boundaries of primitive integral types \n for details.\n  Ranges of GDAL data types \n   GDAL data type\t       minimum  \tmaximum\n   Byte  \t\t\t     0  \t    255\n   UInt16\t\t\t     0  \t 65,535\n   Int16, CInt16 \t       -32,768  \t 32,767\n   UInt32\t\t\t     0    4,294,967,295\n   Int32, CInt32 \t-2,147,483,648    2,147,483,647\n   Float32, CFloat32\t       -3.4E38  \t 3.4E38\n   Float64, CFloat64\t     -1.79E308         1.79E308\n  If there is a need to keep file sizes small, use the simplest data type\n covering the data range of the raster(s) to be exported, e.g., if suitable\n use Byte rather than UInt16; use Int16 rather than Int32; or use Float32\n rather than Float64. In addition, the COMPRESS  createopt  used can\n have a very large impact on the size of the output file.\n  Some software may not recognize all of the compression methods\n available for a given file format, and certain compression methods may\n only be supported for certain data types (depends on vendor and version).\n  If the export settings are set such that data loss would occur in the output\n file (i.e, due to the particular choice of data type and/or file type), the\n normal behaviour of  r.out.gdal  in this case would be to issue an error\n message describing the problem and exit without exporting. The  -f  flag\n allows raster export even if some of the data loss tests are not passed, and\n warnings are issued instead of errors.\n  r.out.gdal  exports may appear all black or gray on initial\n display in other GIS software. This is not a bug of  r.out.gdal ,\n but often caused by the default color table assigned by that software.\n The default color table may be grayscale covering the whole range of\n possible values which is very large for e.g. Int32 or Float32. E.g.\n stretching the color table to actual min/max would help (sometimes under\n symbology).\n  GeoTIFF caveats \n GeoTIFF exports can only be displayed by standard image viewers\n if the GDAL data type was set to Byte and the GeoTIFF contains either\n one or three bands. All other data types and numbers of bands can be\n properly read with GIS software only. Although GeoTIFF files usually\n have a .tif extension, these files are not necessarily images but\n first of all spatial raster datasets, e.g. land cover or elevation.\n  When writing out multi-band GeoTIFF images for users of ESRI software or\n ImageMagick, the interleaving mode should be set to \"pixel\" using\n  createopt=\"INTERLEAVE=PIXEL\" . BAND interleaving is slightly more\n efficient, but not supported by some applications.\n This issue only arises when writing out multi-band imagery groups.\n  Improving GeoTIFF compatibility \n To create a GeoTIFF that is highly compatible with various other GIS\n software packages, it is recommended to keep the GeoTIFF file as simple\n as possible. You will have to experiment with which options your\n software is compatible with, as this varies widely between vendors and\n versions. Long term, the less metadata you have to remove the more\n self-documenting (and useful) the dataset will be.\n Here are some things to try:\n  Create a World file with  createopt=\"TFW=YES\" .\n  Do not use GeoTIFF internal compression. Other GIS software often \n supports only a subset of the available compression methods with the \n supported methods differing between GIS software packages. Unfortunately\n this means the output image can be rather huge, but the file can be\n compressed with software like  zip ,  gnuzip , or  bzip2 .\n  Skip exporting the color table. Color tables are not always properly\n rendered, particularly for type UInt16, and the GeoTIFF file can appear\n completely black. If you are lucky the problematic software package has\n a method to reset the color table and assign a new color table\n (sometimes called symbology).\n  Keep metadata simple with  createopt=\"PROFILE=GeoTIFF\"  or \n  createopt=\"PROFILE=BASELINE\" . With BASELINE no GDAL or GeoTIFF\n tags will be written and a World file is required ( createopt=\"TFW=YES\" ).\n  Adding overviews with  gdaladdo  after exporting can speed up display.\n Note that other software might create their own overviews, ignoring existing\n overviews.\n Cloud Optimized GeoTIFFs (COG) can be created with the creation options \n  createopt=TILED=YES,COMPRESS=DEFLATE , followed by \n  gdaladdo  to build overviews.\n  EXAMPLES \n  Export the integer raster basin_50K map to GeoTIFF format \n g.region raster=basin_50K -p\n r.out.gdal input=basin_50K output=basin_50K.tif\n  Export a DCELL raster map in GeoTIFF format suitable for ESRI software \n g.region raster=elevation -p\n r.out.gdal in=elevation output=elevation.tif createopt=\"PROFILE=GeoTIFF,TFW=YES\"\n  Export a raster map in \"Deflate\" compressed GeoTIFF format \n g.region raster=elevation -p\n r.out.gdal in=elevation output=elevation.tif createopt=\"COMPRESS=DEFLATE\"\n  Export R,G,B imagery bands in GeoTIFF format suitable for ESRI software \n i.group group=nc_landsat_rgb input=lsat7_2002_30,lsat7_2002_20,lsat7_2002_10\n g.region raster=lsat7_2002_30 -p\n r.out.gdal in=nc_landsat_rgb output=nc_landsat_rgb.tif type=Byte \n    createopt=\"PROFILE=GeoTIFF,INTERLEAVE=PIXEL,TFW=YES\"\n  Export the floating point raster elevation map to ERDAS/IMG format \n g.region raster=elevation -p\n r.out.gdal input=elevation output=elelevation.img format=HFA type=Float32\n  Export group of image maps as multi-band file \n g.list group\n i.group group=tm7 subgroup=tm7 input=tm7_10,tm7_20,tm7_30,tm7_40,tm7_50,tm7_60,tm7_70\n i.group -l tm7\n g.region raster=tm7_10 -p\n r.out.gdal tm7 output=lsat_multiband.tif\n gdalinfo lsat_multiband.tif\n  Export RGB with alpha channel that encodes NULL cells \n When exporting exporting RGB data rather than GIS data for Web applications\n or generally the scope of visualization, the alpha channel is of use. Here\n the export type is commonly the Byte data type.\n When exporting data with  r.out.gdal , assigning a  nodata \n value (specific parameter of the module) means that any band values\n equal to this nodata value will be interpreted as nodata. Using an additional\n alpha channel means that all pixels with an alpha value of 0 are\n transparent. The alpha channel thus represents per-pixel encoding of \n nodata, just like the GRASS MASK (null file). That means when using an alpha \n channel, you do not need to \"free up\" any particular value, but you can\n use any value you like to replace NULL cells, as long as the value can be \n represented by the Byte data type. It does not matter if that value is \n already present in any of the input bands.\n Hence for \"visual-only\" RGB data export it is needed to create an additional\n alpha channel that encodes all NULL cells and in the RGB bands to be exported\n replace NULL cells with some value in the range 0-255. For example:\n # for simplicity variables are used\n RMAP=\"lsat7_2000_30\"\n GMAP=\"lsat7_2000_20\"\n BMAP=\"lsat7_2000_10\"\n OUTNAME=\"lsat7_2000_RGBA.tif\"\n # extract alpha\n r.mapcalc \"out_a = if(isnull($RMAP) || isnull($GMAP) || isnull($BMAP), 0, 255)\"\n # replace NULL cells with a valid value, extract colors\n # exporting 8 bit RGB data, not GIS data, therefore the `#` operator:\n r.mapcalc \"out_r = if(isnull($RMAP), 0, #$RMAP)\"\n r.mapcalc \"out_g = if(isnull($GMAP), 0, #$GMAP)\"\n r.mapcalc \"out_b = if(isnull($BMAP), 0, #$BMAP)\"\n # create group for export\n i.group group=out_rgba input=out_r,out_g,out_b,out_a\n # remove any MASK because this works only if there are \n # no NULL cells in the bands to be exported \n r.mask -r\n # export the group:\n # add PROFILE=BASELINE to createopt to produce a standard TIFF file\n # without any GTiff extensions\n r.out.gdal input=out_rgba output=$OUTNAME -cm createopt=\"PHOTOMETRIC=RGB,ALPHA=YES\"\n gdalinfo $OUTNAME\n The resulting GeoTIFF file can be used e.g. for Web server applications.\n  GDAL RELATED ERROR MESSAGES \n   \"ERROR 6: SetColorInterpretation() not supported for this dataset.\":\n  This  may  indicate that the color table was not written properly.\n  But usually it will be correct and the message can be ignored. \n   \"ERROR 6: SetNoDataValue() not supported for this dataset.\":\n  The selected output format does not support \"no data\". It is recommended\n  to use a different output format if your data contains NULLs. \n   \"Warning 1: Lost metadata writing to GeoTIFF ... too large to fit in\n  tag.\": The color table metadata may be too large. It is recommended to\n  simplify or not write the color table, or use a different output format or\n  the flags  -c  and  -m . \n ", "see_also": ["r.out.ascii", "r.out.bin", "r.out.mat", "r.out.png", "r.out.ppm", "r.pack"], "authors": ["Vytautas Vebra (oliver4grass at gmail.com)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.gdal"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.bin.html", "name": "r.out.bin", "definition": "- Exports a GRASS raster to a binary array.", "keywords": ["raster", "export"], "synopsis": "r.out.bin [-ifhbs] input=string  [output=string]   [null=float]   [bytes=integer]   [order=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Generate integer output Generate floating-point output Export array with GMT compatible header Generate BIL world and header files Byte swap output Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Generate floating-point output Export array with GMT compatible header Generate BIL world and header files Byte swap output Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Export array with GMT compatible header Generate BIL world and header files Byte swap output Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Generate BIL world and header files Byte swap output Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Byte swap output Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output binary map (use output=- for stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "Value to write out for null", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bytes", "flag": "bytes", "dataType": "String", "optional": true, "explanation": "Number of bytes per cell", "defaultValue": null, "alternatives": ["1", "2", "4", "8"], "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Output byte order", "defaultValue": "native", "alternatives": ["big", "little", "native", "swap"], "isInputFile": false, "isOutputFile": false}], "description": "\n The  r.out.bin  program exports a GRASS raster map to a binary array\n file. Optionally, output can be sent to standard output (stdout) for direct\n input (pipe) into other applications. Data is exported according to the\n original GRASS raster type (e.g. float). If the \"-i\" flag is specified, an\n integer array is output. The region parameters are printed to stderr.\n ", "notes": "\n With the -h flag, data can be directly used by\n  GMT  as Grid Format 1 (float) or \n 2 (short). For example:\n r.out.bin -h input=grass.raster output=new.grd\n grdinfo new.grd=1 (if float)\n  Exported data can be piped directly into the GMT program xyz2grd.\n r.out.bin input=grass.raster output=- | xyz2grd -R....  -ZTLf -\n The example uses the GMT program xyz2grd with the -ZTLf flag indicating that\n a float array was output.\n ", "see_also": ["r.in.bin", "r.in.ascii", "r.in.gdal", "r.out.ascii", "r.out.ascii"], "authors": ["This program is derived from"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.bin"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.out.ascii.html", "name": "r.out.ascii", "definition": "- Converts a raster map layer into a GRASS ASCII text file.", "keywords": ["raster", "export", "ASCII"], "synopsis": "r.out.ascii [-hsmi] input=name  [output=name]   [precision=integer]   [width=integer]   [null_value=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "h", "flag": "-h", "explanation": "Suppress printing of header information Write SURFER (Golden Software) ASCII grid Write MODFLOW (USGS) ASCII array Force output of integer values Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Write SURFER (Golden Software) ASCII grid Write MODFLOW (USGS) ASCII array Force output of integer values Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Write MODFLOW (USGS) ASCII array Force output of integer values Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Force output of integer values Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output ASCII grid map (use out=- for stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Number of significant digits (floating point only)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Number of values printed before wrapping a line (only SURFER or MODFLOW format)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String to represent null cell (GRASS grid only)", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.out.ascii  converts a user-specified raster map layer\n ( input= name ) into an ASCII grid in a text file\n ( output= name ) suitable for export to\n other computer systems.\n The GRASS program  r.in.ascii  can be\n used to perform the reverse function, converting an ASCII file in suitable\n format to GRASS raster map format.\n  To write a SURFER .grd ASCII GRID file (with reverted row order and different\n header) use the  -s  flag:\n r.out.ascii -s input=inname output=outname.grd [dp=value]\n NULL data are coded to \"1.70141e+038\" for SURFER ASCII GRID files (ignoring\n the  null=  parameter).\n ", "notes": "\n The output from  r.out.ascii  may be placed into a file by using the\n UNIX redirection mechanism; e.g.:\n r.out.ascii input=soils output=- > out.file\n The output file out.file can then be printed or copied onto a CDROM\n or floppy disk for export purposes.\n  To export the raster values as x,y,z values of cell centers (one per line)\n use the  r.out.xyz  module.\n ", "see_also": ["r.in.ascii", "r.in.gdal", "r.out.bin", "r.out.gdal", "r.out.xyz"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.out.ascii"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.null.html", "name": "r.null", "definition": "- Manages NULL-values of given raster map.", "keywords": ["raster", "null data"], "synopsis": "r.null [-fincrz] map=name  [setnull=val[-val][,val[-val],...]]   [null=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Only do the work if the map is floating-point Only do the work if the map is integer Only do the work if the map doesn't have a NULL-value bitmap file Create NULL-value bitmap file validating all data cells Remove NULL-value bitmap file Re-create NULL-value bitmap file (to compress or uncompress) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Only do the work if the map is integer Only do the work if the map doesn't have a NULL-value bitmap file Create NULL-value bitmap file validating all data cells Remove NULL-value bitmap file Re-create NULL-value bitmap file (to compress or uncompress) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Only do the work if the map doesn't have a NULL-value bitmap file Create NULL-value bitmap file validating all data cells Remove NULL-value bitmap file Re-create NULL-value bitmap file (to compress or uncompress) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Create NULL-value bitmap file validating all data cells Remove NULL-value bitmap file Re-create NULL-value bitmap file (to compress or uncompress) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Remove NULL-value bitmap file Re-create NULL-value bitmap file (to compress or uncompress) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Re-create NULL-value bitmap file (to compress or uncompress) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map for which to edit null values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "setnull", "flag": "setnull", "dataType": "String", "optional": true, "explanation": "List of cell values to be set to NULL", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "The value to replace the null value by", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The function of  r.null  is to explicitly create the NULL-value\n bitmap file. The intended usage is to update maps that do not have a\n NULL-value bitmap file (i.e. to indicate for each pixel if zero is a valid\n value or is to be considered as NULL, i.e. no data value). The module does\n not work with reclassified maps.\n The design is flexible. Ranges of values can be set to NULL and/or the NULL\n value can be eliminated and replace with a specified value.\n The  setnull  parameter is used to specify values in the ranges to\n be set to NULL.  A range is either a single value (e.g., 5.3), or a pair of\n values (e.g., 4.76-34.56).  Existing NULL-values are left NULL, unless the\n null argument is requested.\n The  null  parameter eliminates the NULL value and replaces it with\n value. This argument is applied only to existing NULL values, and not to the\n NULLs created by the setnull argument.\n ", "notes": "\n Note that the value is restricted to integer if the map is an integer map.\n  r.null and reclassified maps \n  r.null  does not support reclassified maps because, if  r.null \n was run on the reclass raster it would alter the original and any other\n reclass rasters of the original.  Therefore  r.null  does not allow\n recoding reclassified maps (products of  r.reclass ).\n As a workaround, the way to recode such a map is: The user creates a raster\n map out of the reclassified map by copying it: \n r.mapcalc \"newmap = reclass\"\n  NULL data compression \n By default no data files (i.e., NULL files) are not compressed unless a\n specific environment variable is set. The NULL file compression must be\n explicitly turned on with  export GRASS_COMPRESS_NULLS=1 . \n Warning: such raster maps can then only be opened with GRASS GIS 7.2.0 or\n later. NULL file compression can be managed with  r.null -z .\n  EXAMPLES \n Set specific values of a classified map to NULL: \n r.null map=landcover.30m setnull=21,22\n Set NULL-values of a map to a specific value: \n r.null map=fields null=99\n ", "see_also": ["r.compress", "r.support", "r.quant"], "authors": ["U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.null"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.neighbors.html", "name": "r.neighbors", "definition": "- Makes each cell category value a function of the category values assigned to the cells around it, and stores new cell values in an output raster map layer.", "keywords": ["raster", "algebra", "statistics", "aggregation", "neighbor", "focal statistics", "filter"], "synopsis": "r.neighbors [-ac] input=name  [selection=name]  output=name[,name,...]  [method=string[,string,...]]   [size=integer]   [title=phrase]   [weight=name]   [gauss=float]   [quantile=float[,float,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Do not align output with the input Use circular neighborhood Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Use circular neighborhood Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "selection", "flag": "selection", "dataType": "String", "optional": true, "explanation": "Name of an input raster map to select the cells which should be processed", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Neighborhood operation", "defaultValue": "average", "alternatives": ["average", "median", "mode", "minimum", "maximum", "range", "stddev", "sum", "count", "variance", "diversity", "interspersion", "quart1", "quart3", "perc90", "quantile"], "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Neighborhood size", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "weight", "flag": "weight", "dataType": "String", "optional": true, "explanation": "Text file containing weights", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "gauss", "flag": "gauss", "dataType": "String", "optional": true, "explanation": "Sigma (in cells) for Gaussian filter", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "quantile", "flag": "quantile", "dataType": "String", "optional": true, "explanation": "Quantile to calculate for method=quantile", "defaultValue": null, "alternatives": ["0.0-1.0"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.neighbors  looks at each cell in a raster input\n file, and examines the values assigned to the\n cells in some user-defined \"neighborhood\" around it.  It\n outputs a new raster map layer in which each cell is\n assigned a value that is some (user-specified)\n function of the values in that cell's neighborhood.  For\n example, each cell in the output layer might be assigned a\n value equal to the average of the values\n appearing in its 3 x 3 cell \"neighborhood\" in the input\n layer. Note that the centre cell is also included in the calculation.\n  OPTIONS \n The user must specify the names of the raster map layers to\n be used for  input  and  output , the\n  method  used to analyze neighborhood\n values (i.e., the neighborhood function or operation to be\n performed), and the  size  of the neighborhood.\n  The user can optionally\n specify a  selection  map, to compute new values only where the raster\n cells of the selection map are not NULL. In case of a NULL cells,\n the values from the input map are copied into the output map.\n This may useful to smooth only parts of an elevation map (pits, peaks, ...).\n  Example how to use a selection map with method=average: \n input map:\n 1 1  1 1 1\n 1 1  1 1 1\n 1 1 10 1 1\n 1 1  1 1 1\n 1 1  1 1 1\n selection map, NULL values are marked as *:\n * * * * *\n * * 1 * *\n * 1 1 1 *\n * * 1 * *\n * * * * *\n The output map:\n 1 1 1 1 1\n 1 1 2 1 1\n 1 2 2 2 1\n 1 1 2 1 1\n 1 1 1 1 1\n Without using the selection map, the output map would look like this:\n 1 1 1 1 1\n 1 2 2 2 1\n 1 2 2 2 1\n 1 2 2 2 1\n 1 1 1 1 1\n  Optionally, the user can also specify the  TITLE  to\n be assigned to the raster map layer  output , elect\n to not align the resolution of the output with that of the\n input (the  -a  option), and run  r.neighbors \n with a custom matrix weights with the  weight  option.\n These options are described further below.\n  Neighborhood Operation Methods: \n The  neighborhood  operators determine what new \n value a center cell in a neighborhood will have after examining\n values inside its neighboring cells.\n Each cell in a raster map layer becomes the center cell of a neighborhood \n as the neighborhood window moves from cell to cell throughout the map layer.\n  r.neighbors  can perform the following operations:\n  average  \n  The average value within the neighborhood.\n In the following example, the result would be:\n (7*4 + 6 + 5 + 4*3)/9 = 5.6667\n The result is rounded to the nearest integer (in this case 6).\n    Raw Data     Operation     New Data\n    +---+---+---+          +---+---+---+\n    | 7 | 7 | 5 |          |   |   |   |\n    +---+---+---+ average  +---+---+---+\n    | 4 | 7 | 4 |--------->|   | 6 |   |\n    +---+---+---+          +---+---+---+\n    | 7 | 6 | 4 |          |   |   |   |\n    +---+---+---+          +---+---+---+\n  median  \n  The value found half-way through a list of the\n neighborhood's values,\n when these are ranged in numerical order.\n  mode  \n  The most frequently occurring value in the neighborhood.\n  minimum  \n  The minimum value within the neighborhood.\n  maximum  \n  The maximum value within the neighborhood.\n  range \n  The range value within the neighborhood.\n  stddev  \n  The statistical standard deviation of values\n within the neighborhood (rounded to the nearest integer).\n  sum  \n  The sum of values within the neighborhood.\n  count \n  The count of filled (not NULL) cells.\n  variance  \n  The statistical variance of values\n within the neighborhood (rounded to the nearest integer).\n  diversity  \n  The number of different values within the neighborhood.\n In the above example, the diversity is 4.\n  interspersion  \n  The percentage of cells containing values which differ from the values\n assigned to the center cell in the neighborhood, plus 1.\n In the above example, the interspersion is:\n 5/8 * 100 + 1 = 63.5\n The result is rounded to the nearest integer (in this case 64).\n  quart1, quart3 \n  The result will be the first or the third quartile (equal of 25th and 75th percentiles).\n  perc90 \n  The result will be the 90th percentile of neighborhood.\n  quantile \n  Any quantile as specified by \"quantile\" input parameter.\n  Neighborhood Size: \n The neighborhood  size  specifies which cells surrounding any given\n cell fall into the neighborhood for that cell.\n The  size  must be an odd integer and represent the length of one of\n moving window edges in cells.\n For example, a size value of 3 will result in\n                               _ _ _\n                              |_|_|_| \n     3 x 3 neighborhood --->  |_|_|_|\n                              |_|_|_|\n  Matrix weights: \n A custom matrix can be used if none of the neighborhood operation\n methods are desirable by using the  weight .  This option must\n be used in conjunction with the  size  option to specify the\n matrix size.  The weights desired are to be entered into a text file.\n For example, to calculate the focal mean with a matrix  size  of\n 3,\n r.neigbors in=input.map out=output.map size=3 weight=weights.txt\n The contents of the weight.txt file:\n 3 3 3\n 1 4 8\n 9 5 3\n This corresponds to the following 3x3 matrix:\n +-+-+-+\n |3|3|3|\n +-+-+-+\n |1|4|8|\n +-+-+-+\n |9|5|3|\n +-+-+-+\n To calculate an annulus shaped neighborhood the contents of weight.txt file \n may be e.g. for size=5:\n  0 1 1 1 0\n  1 0 0 0 1\n  1 0 0 0 1\n  1 0 0 0 1\n  0 1 1 1 0\n The way that weights are used depends upon the specific aggregate\n ( method ) being used.\n However, most of the aggregates have the property that multiplying all\n of the weights by the same factor won't change the final result (an\n exception is  method=count ).\n Also, most (if not all) of them have the properties that an integer\n weight of N is equivalent to N occurrences of the cell value, and\n having all weights equal to one produces the same result as when\n weights are not used.\n When weights are used, the calculation for  method=average  is:\n   sum(w[i]*x[i]) / sum(w[i])\n In the case where all weights are zero, this will end up with both the\n numerator and denominator to zero, which produces a NULL result.\n  FLAGS \n  -a  \n  If specified,  r.neighbors  will not align the output\n raster map layer with that of the input raster map layer.\n The  r.neighbors  program works in the current geographic region.\n It is recommended, but not required, that the resolution\n of the geographic region be the same as that of the raster map layer.\n By default, if unspecified,\n  r.neighbors  will align these geographic region settings.\n  -c \n This flag will use a circular neighborhood for the moving analysis window,\n centered on the current cell. \n  The exact masks for the first few neighborhood sizes are as follows:\n 3x3     . X .\t\t5x5\t. . X . .\t7x7\t. . . X . . . \n         X O X\t\t\t. X X X .\t\t. X X X X X .\n         . X .\t\t\tX X O X X\t\t. X X X X X .\n \t\t\t\t. X X X .\t\tX X X O X X X\n  \t\t\t\t. . X . .\t\t. X X X X X .\n \t\t\t\t\t\t\t. X X X X X .\n         \t\t\t\t\t\t. . . X . . .\t\t\t\t\t\t\t\n 9x9\t. . . . X . . . .\t\t11x11   . . . . . X . . . . .\n \t. . X X X X X . .\t\t\t. . X X X X X X X . .\n         . X X X X X X X .\t\t\t. X X X X X X X X X .\n         . X X X X X X X .\t\t\t. X X X X X X X X X .\n         X X X X O X X X X\t\t\t. X X X X X X X X X .\n         . X X X X X X X .\t\t\tX X X X X O X X X X X\n         . X X X X X X X .\t\t\t. X X X X X X X X X .\t\n         . . X X X X X . .\t\t\t. X X X X X X X X X .\n         . . . . X . . . .\t\t\t. X X X X X X X X X .\n \t\t\t\t        \t. . X X X X X X X . .\n \t\t\t\t        \t. . . . . X . . . . .\t\n ", "notes": "\n The  r.neighbors  program works in the current geographic region\n with the current mask, if any.  It is recommended, but not required,\n that the resolution of the geographic region be the same as that\n of the raster map layer.  By default,  r.neighbors  will align\n these geographic region settings.  However, the user can select to keep\n original input and output resolutions which are not aligned by specifying\n this (e.g., using the  -a  option).\n  r.neighbors  doesn't propagate NULLs, but computes the\n aggregate over the non-NULL cells in the neighborhood.\n The  -c  flag and the  weights  parameter are mutually exclusive.  Any\n use of the two together will produce an error. Differently-shaped neighborhood\n analysis windows may be achieved by using the  weight=  parameter to\n specify a weights file where all values are equal. The user can also vary the\n weights at the edge of the neighborhood according to the proportion of the cell\n that lies inside the neighborhood circle, effectively anti-aliasing the analysis\n mask.\n For aggregates where a weighted calculation isn't meaningful\n (specifically: minimum, maximum, diversity and interspersion), the\n weights are used to create a binary mask, where zero causes the cell\n to be ignored and any non-zero value causes the cell to be used.\n  r.neighbors  copies the GRASS  color  files associated with\n the input raster map layer for those output map layers that are based\n on the neighborhood average, median, mode, minimum, and maximum.\n Because standard deviation, variance, diversity, and interspersion are indices,\n rather than direct correspondents to input values,\n no  color  files are copied for these map layers.\n (The user should note that although the  color  file is copied\n for  average  neighborhood function output,\n whether or not the color file makes sense for the output\n will be dependent on the input data values.)\n  Propagation of output precision \n The following logic has been implemented: For any aggregate, there are\n two factors affecting the output type:\n   Whether the input map is integer or floating-point.  \n   Whether the weighted or unweighted version of the aggregate is used.  \n These combine to create four possibilities:\n   input type/weight integer float \n   no yes no yes \n   average float float float float \n   median [1] [1] float float \n   mode integer integer [2] [2] \n   minimum integer integer float float \n   maximum integer integer float float \n   range integer integer float float \n   stddev float float float float \n   sum integer float float float \n   count integer float integer float \n   variance float float float float \n   diversity integer integer integer integer \n   interspersion integer integer integer integer \n   quart1 [1] [1] float float \n   quart3 [1] [1] float float \n   perc90 [1] [1] float float \n   quantile [1] [1] float float \n [1] For integer input, quantiles may produce float results from\n interpolating between adjacent values.\n [2] Calculating the mode of floating-point data is essentially\n meaningless.\n \t\n With the current aggregates, there are 5 cases:\n   \n   Output is always float: average, variance, stddev, quantiles (with\n interpolation).  \n   Output is always integer: diversity, interspersion.  \n   Output is integer if unweighted, float if weighted: count.  \n   Output matches input: minimum, maximum, range, mode (subject to\n note 2 above), quantiles (without interpolation).  \n   Output is integer for integer input and unweighted aggregate,\n otherwise float: sum.  \n   \n  EXAMPLES \n  Measure occupancy of neighborhood \n Set up 10x10 computational region to aid visual inspection of results\n g.region rows=10 cols=10\n Fill 50% of computational region with randomly located cells.\n \"distance=0\" will allow filling adjacent cells.\n r.random.cells output=random_cells distance=0 ncells=50\n Count non-empty (not NULL) cells in 3x3 neighborhood\n r.neighbors input=random_cells output=counts method=count\n Optionally - exclude centre cell from the count (= only look around)\n r.mapcalc \"cound_around = if( isnull(random_cells), counts, counts - 1)\"\n ", "see_also": ["g.region", "r.clump", "r.mapcalc", "r.mfilter", "r.statistics", "r.support"], "authors": ["Original version: Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.neighbors"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.mode.html", "name": "r.mode", "definition": "- Finds the mode of values in a cover map within areas assigned the same category value in a user-specified base map.", "keywords": ["raster", "statistics", "algebra"], "synopsis": "r.mode base=string cover=string output=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "base", "flag": "base", "dataType": "String", "optional": false, "explanation": "Base map to be reclassified", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cover", "flag": "cover", "dataType": "String", "optional": false, "explanation": "Coverage map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.mode  calculates the most frequently occurring value (i. e., mode)\n of data contained in a  cover  raster map layer for areas assigned\n the same category value in the user-specified  base  raster map\n layer. These modes are stored in the new  output  map layer.\n  The  output  map is actually a  reclass  of the  base \n map.\n  The  base  parameter defines an existing raster map layer in the user's\n current mapset search path. For each group of cells assigned the same\n category value in the  base  map, the mode of the values assigned\n these cells in the  cover  map will be computed.\n  The  cover  parameter defines an existing raster map layer containing\n the values to be used to compute the mode within each category of the\n  base  map.\n ", "notes": "\n The user should use the results of  r.mode  with care.\n Since this utility assigns a value to each\n cell which is based on global information (i.e., information at spatial \n locations other than just the location of the cell itself), the resultant \n map layer is only valid if the geographic region and mask settings are\n the same as they were at the time that the result map was created.\n  Results are affected by the current region settings and mask.\n  EXAMPLE \n Mode of K-factor (erosion) for Spearfish fields:\n g.region raster=fields -p\n r.mode base=fields cover=soils.Kfactor output=K.by.farm.mode\n r.univar K.by.farm.mode\n ", "see_also": ["g.region", "r.category", "r.clump", "r.describe", "r.mapcalc", "r.mfilter", "r.neighbors", "r.reclass", "r.stats", "r.statistics", "r.univar"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.mode"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.stats.zonal.html", "name": "r.stats.zonal", "definition": "- Calculates category or object oriented statistics (accumulator-based statistics).", "keywords": ["raster", "statistics", "zonal statistics"], "synopsis": "r.stats.zonal [-cr] base=name cover=name method=string output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Cover values extracted from the category labels of the cover map Create reclass map with statistics as category labels Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Create reclass map with statistics as category labels Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "base", "flag": "base", "dataType": "String", "optional": false, "explanation": "Name of base raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cover", "flag": "cover", "dataType": "String", "optional": false, "explanation": "Name of cover raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Method of object-based statistic", "defaultValue": null, "alternatives": ["count", "sum", "min", "max", "range", "average", "avedev", "variance", "stddev", "skewness", "kurtosis", "variance2", "stddev2", "skewness2", "kurtosis2"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.stats.zonal  is a tool to analyse exploratory statistics of a \n floating-point \"cover layer\" according to how it intersects with objects\n in a \"base layer\". A variety of standard statistical measures are possible\n (called \"zonal statistics\" in some GIS).\n  NOTES \n  r.stats.zonal  is intended to be a partial replacement for\n  r.statistics , with support\n for floating-point cover maps at the expense of not supporting\n quantiles. For this, see  r.stats.quantile .\n  EXAMPLE \n In this example, the raster polygon map  zipcodes  in the North \n Carolina sample dataset is used to calculate zonal raster statistics using\n the  elevation  raster map: \n g.region raster=zipcodes -p\n # pixel count in zipcode areas\n r.stats.zonal base=zipcodes cover=elevation method=count output=zipcodes_elev_count\n r.colors zipcodes_elev_count color=gyr -g\n # average elevation in zipcode areas\n r.stats.zonal base=zipcodes cover=elevation method=average output=zipcodes_elev_avg\n r.colors zipcodes_elev_avg color=elevation -g\n ", "notes": "", "see_also": ["r.quantile", "r.stats.quantile", "r.statistics"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.stats.zonal"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.stats.quantile.html", "name": "r.stats.quantile", "definition": "- Compute category quantiles using two passes.", "keywords": ["raster", "statistics", "percentile", "quantile"], "synopsis": "r.stats.quantile [-rpt] base=name cover=name  [quantiles=integer]   [percentiles=float[,float,...]]   [bins=integer]   [output=name[,name,...]]   [file=name]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Create reclass map with statistics as category labels Do not create output maps; just print statistics Print statistics in table format Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Do not create output maps; just print statistics Print statistics in table format Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Print statistics in table format Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "base", "flag": "base", "dataType": "String", "optional": false, "explanation": "Name of base raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cover", "flag": "cover", "dataType": "String", "optional": false, "explanation": "Name of cover raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "quantiles", "flag": "quantiles", "dataType": "String", "optional": true, "explanation": "Number of quantiles", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "percentiles", "flag": "percentiles", "dataType": "String", "optional": true, "explanation": "List of percentiles", "defaultValue": "50", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bins", "flag": "bins", "dataType": "String", "optional": true, "explanation": "Number of bins to use", "defaultValue": "1000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Resultant raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": ":", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.stats.quantile  is a tool to analyse exploratory statistics of a\n floating-point \"cover layer\" according to how it intersects with objects\n in a \"base layer\". It provides quantile calculations as selected\n \"zonal statistics\".\n  NOTES \n  r.stats.quantile  is intended to be a partial replacement for\n  r.statistics , with support\n for floating-point cover maps. It provides quantile calculations,\n which are absent from\n  r.stats.zonal .\n  EXAMPLE \n In this example, the raster polygon map  zipcodes  in the North \n Carolina sample dataset is used to calculate quantile raster statistics using\n the  elevation  raster map: \n g.region raster=zipcodes -p\n # print quantiles\n r.stats.quantile base=zipcodes cover=elevation quantiles=3 -p\n 27511:0:33.333333:134.717392\n 27511:1:66.666667:143.985723\n 27513:0:33.333333:140.669993\n 27513:1:66.666667:146.279449\n 27518:0:33.333333:115.140101\n 27518:1:66.666667:129.893723\n [...]\n # write out percentile raster maps\n r.stats.quantile base=zipcodes cover=elevation percentiles=25,50,75 \n    output=zipcodes_elev_q25,zipcodes_elev_q50,zipcodes_elev_q75\n ", "notes": "", "see_also": ["r.quantile", "r.stats.zonal", "r.statistics"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.stats.quantile"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.stats.html", "name": "r.stats", "definition": "- Generates area statistics for raster map.", "keywords": ["raster", "statistics"], "synopsis": "r.stats [-acpl1gxArnNCi] input=name[,name,...]  [output=name]   [separator=character]   [null_value=string]   [nsteps=integer]   [sort=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Print area totals in square meters Print cell counts (sortable) Print approximate (total percent may not be 100%) percents Print category labels One cell (range) per line Print grid coordinates (east and north) Print x and y (column and row) Print averaged values instead of intervals (floating-point maps only) Print raw indexes of floating-point ranges (floating-point maps only) Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Print cell counts (sortable) Print approximate (total percent may not be 100%) percents Print category labels One cell (range) per line Print grid coordinates (east and north) Print x and y (column and row) Print averaged values instead of intervals (floating-point maps only) Print raw indexes of floating-point ranges (floating-point maps only) Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print approximate (total percent may not be 100%) percents Print category labels One cell (range) per line Print grid coordinates (east and north) Print x and y (column and row) Print averaged values instead of intervals (floating-point maps only) Print raw indexes of floating-point ranges (floating-point maps only) Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Print category labels One cell (range) per line Print grid coordinates (east and north) Print x and y (column and row) Print averaged values instead of intervals (floating-point maps only) Print raw indexes of floating-point ranges (floating-point maps only) Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "1", "flag": "-1", "explanation": "One cell (range) per line Print grid coordinates (east and north) Print x and y (column and row) Print averaged values instead of intervals (floating-point maps only) Print raw indexes of floating-point ranges (floating-point maps only) Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print grid coordinates (east and north) Print x and y (column and row) Print averaged values instead of intervals (floating-point maps only) Print raw indexes of floating-point ranges (floating-point maps only) Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "x", "flag": "-x", "explanation": "Print x and y (column and row) Print averaged values instead of intervals (floating-point maps only) Print raw indexes of floating-point ranges (floating-point maps only) Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "A", "flag": "-A", "explanation": "Print averaged values instead of intervals (floating-point maps only) Print raw indexes of floating-point ranges (floating-point maps only) Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Print raw indexes of floating-point ranges (floating-point maps only) Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "N", "flag": "-N", "explanation": "Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "C", "flag": "-C", "explanation": "Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of raster map(s) to report on", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "space", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nsteps", "flag": "nsteps", "dataType": "String", "optional": true, "explanation": "Number of floating-point subranges to collect stats from", "defaultValue": "255", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sort", "flag": "sort", "dataType": "String", "optional": true, "explanation": "Sort output statistics by cell counts", "defaultValue": null, "alternatives": ["asc", "desc"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.stats  calculates the area present in each of the categories\n or floating-point intervals of user-selected  input  raster map. Area\n statistics are given in units of square meters and/or cell\n counts. This analysis uses the current geographic region\n ( g.region ) and mask settings\n ( r.mask ). The output statistics can\n be saved to a  output  file.\n Area statistics is printed in square meters for each category\n when  -a  is given. Similarly if  -c  flag is chosen, areas\n will be stated also in number of cells.\n ", "notes": "\n If a single raster map is specified, a list of categories will be\n printed. If multiple raster maps are specified, a cross-tabulation\n table for each combination of categories in the raster maps will be\n printed.\n For example, if one raster map was specified, the output would look like:\n 1 1350000.00\n 2 4940000.00\n 3 8870000.00\n If three raster maps were specified, the output would look like:\n 0 0 0 8027500.00\n 0 1 0 1152500.00\n 1 0 0 164227500.00\n 1 0 1 2177500.00\n 1 1 0 140092500.00\n 1 1 1 3355000.00\n 2 0 0 31277500.00\n 2 0 1 2490000.00\n 2 1 0 24207500.00\n 2 1 1 1752500.00\n 3 0 0 17140000.00\n 3 1 0 11270000.00\n 3 1 1 2500.00\n Within each grouping, the first field represents the category value of\n first raster map, the second represents the category values associated\n with second raster map, the third represents category values for third\n raster map, and the last field gives the area in square meters for the\n particular combination of these three raster maps' categories. For\n example, above, combination 3,1,1 covered 2500 square meters. Fields\n are separated by the  separator  option.\n The output from  r.stats  is sorted by category or category\n intervals (for floating-point raster maps).\n Note that the user has only the option of printing out cell statistics\n in terms of cell counts and/or area totals. Users wishing to use\n different units than are available here should\n use  r.report .\n  EXAMPLES \n Report area for each category in the single raster map:\n r.stats -a in=geology_30m nv=no-data sep=tab\n 217     71960000.000000\n 262     19760000.000000\n 270     67760000.000000\n 405     25120000.000000\n 583     2520000.000000\n 720     480000.000000\n 766     840000.000000\n 862     6560000.000000\n 910     4360000.000000\n 921     1200000.000000\n 946     360000.000000\n 948     80000.000000\n no-data 33375200000.000004\n Report sorted number of cells for each category in the single raster\n map (suppress NULL data):\n r.stats -cn in=geology_30m sort=desc\n 217 1799\n 270 1694\n 405 628\n 262 494\n 862 164\n 910 109\n 583 63\n 921 30\n 766 21\n 720 12\n 946 9\n 948 2\n Report area, number of cells, and percents (separated by tabs) for\n each category in the multiple raster maps (suppress NULL data):\n r.stats -nacp in=towns,urban sep=tab\n 1       55      23840000.000000 596     11.89%\n 2       55      13680000.000000 342     6.82%\n 3       55      1360000.000000  34      0.68%\n 4       55      16040000.000000 401     8.00%\n 5       55      98240000.000000 2456    48.98%\n 6       55      19760000.000000 494     9.85%\n Report sorted area for each interval of floating-point input raster\n map. Number of intervals are given by  nsteps  option.\n r.stats -an in=elevation nsteps=10 sort=desc sep=tab\n 95.879221-105.954329    36440000.000000\n 85.804114-95.879221     30800000.000000\n 105.954329-116.029436   30080000.000000\n 116.029436-126.104543   27960000.000000\n 126.104543-136.17965    26440000.000000\n 136.17965-146.254757    20880000.000000\n 75.729007-85.804114     15880000.000000\n 65.6539-75.729007       6040000.000000\n 146.254757-156.329865   5720000.000000\n 55.578793-65.6539       760000.000000\n ", "see_also": ["g.region", "r.report", "r.coin", "r.describe", "r.stats.quantile", "r.stats.zonal", "r.statistics", "r.univar"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.stats"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.statistics.html", "name": "r.statistics", "definition": "- Calculates category or object oriented statistics.", "keywords": ["raster", "statistics", "zonal statistics"], "synopsis": "r.statistics [-c] base=name cover=name method=string output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Cover values extracted from the category labels of the cover map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "base", "flag": "base", "dataType": "String", "optional": false, "explanation": "Name of base raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cover", "flag": "cover", "dataType": "String", "optional": false, "explanation": "Name of cover raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Method of object-based statistic", "defaultValue": null, "alternatives": ["diversity", "average", "mode", "median", "avedev", "stddev", "variance", "skewness", "kurtosis", "min", "max", "sum"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.statistics  is a tool to analyse exploratory statistics of a categorical\n \"cover layer\" according to how it intersects with objects in a \"base layer\".  A\n variety of standard statistical measures are possible (called \"zonal statistics\"\n in some GIS). \n All cells in the base layer are considered one object for the analysis.  For \n some applications, one will first want to prepare the input data so that\n all areas of contiguous cell category values in the base layer are uniquely\n identified, which can be done with  r.clump .\n The available methods are the following:\n  average deviation \n  average \n  diversity \n  kurtosis \n  maximum \n  median \n  minimum \n  mode \n  skewness \n  standard deviation \n  sum \n  variance \n The calculations will be performed on each area of data of the\n cover layers which fall within each unique value, or category, of the base layer.\n  Setting the  -c  flag the category labels of the covering raster\n layer will be used.  This is nice to avoid the GRASS limitation to integer\n in raster maps because using category values floating point numbers can be\n stored.\n  All calculations create an output layer.  The output \n layer is a reclassified version of the base layer with identical\n category values, but modified category labels - the results of the calculations\n are stored in the category labels of the output layer.\n ", "notes": "\n For floating-point cover map support, see the alternative\n  r.stats.zonal .\n For quantile calculations with support for floating-point cover maps, see the\n alternative  r.stats.quantile .\n  EXAMPLES \n Calculation of average elevation of each field in the Spearfish region:\n r.statistics base=fields cover=elevation.dem out=elevstats method=average\n r.category elevstats\n r.mapcalc \"fieldelev = @elevstats\"\n r.univar fieldelev\n ", "see_also": ["r.category", "r.clump", "r.mode", "r.mapcalc", "r.neighbors", "r.stats.quantile", "r.stats.zonal", "r.univar"], "authors": ["Martin Schroeder, Geographisches Institut Heidelberg, Germany"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.statistics"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.spreadpath.html", "name": "r.spreadpath", "definition": "- Recursively traces the least cost path backwards to cells from which the cumulative cost was determined.", "keywords": ["raster", "fire", "cumulative costs"], "synopsis": "r.spreadpath x_input=name y_input=name  [coordinates=east,north[,east,north,...]]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "x_input", "flag": "x_input", "dataType": "String", "optional": false, "explanation": "Name of raster map containing back-path easting information", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y_input", "flag": "y_input", "dataType": "String", "optional": false, "explanation": "Name of raster map containing back-path northing information", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "The map E and N grid coordinates of starting points", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.spreadpath  is part of the wildfire simulation toolset. Preparational\n steps for the fire simulation are the calculation of the rate of spread (ROS)\n with  r.ros , and the creating of spread map with  r.spread .\n Eventually, the fire path(s) based on starting point(s) are calculated\n with  r.spreadpath .\n  r.spreadpath  recursively traces the least cost path backwards to\n the origin, given backlink information input map layers and target locations\n from where paths are to be traced. The backlink information map layers\n record each cell's backlink UTM northing (the y_input) and easting (the\n x_input) coordinates from which the cell's cumulative cost was determined.\n The backlink inputs can be generated from another GRASS raster program\n  r.spread . One of the major applications of  r.spreadpath \n along with  r.spread  is to accurately find the least cost corridors\n and/or paths on a raster setting. More information on  r.spread  and\n  r.spreadpath  can be found in Xu (1994).\n  Parameters: \n  x_input= name \n  Name of input raster map layer containing backlink UTM easting\n coordinates.\n  y_input= name \n  Name of input raster map layer containing backlink UTM northing coordinates.\n  coordinates = x,y[,x,y,x,y, ...] \n  Each x,y coordinate pair gives the easting and northing \n (respectively) geographic coordinates of a target point from which to \n backwards trace the least cost path. As many points as desired can be \n entered by the user.\n  output= name \n  Name of raster map layer to contain output. Also can be used as the \n map layer of the input target points. If so used, the input target \n point map will be overwritten by the output.\n  REFERENCES \n  Xu, Jianping, 1994, Simulating the spread of wildfires using a\n geographic information system and remote sensing, Ph. D. Dissertation,\n Rutgers University, New Brunswick, New Jersey\n ( ref ). \n ", "notes": "", "see_also": ["r.spread", "r.ros"], "authors": ["Jianping Xu and Richard G. Lathrop, Jr., Center for Remote Sensing and Spatial Analysis, Rutgers University."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.spreadpath"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.spread.html", "name": "r.spread", "definition": "- Simulates elliptically anisotropic spread.", "keywords": ["raster", "fire", "spread", "hazard", "model"], "synopsis": "r.spread [-si] base_ros=string max_ros=string direction_ros=string start=string  [spotting_distance=string]   [wind_speed=string]   [fuel_moisture=string]   [least_size=odd int]   [comp_dens=decimal]   [init_time=int (>= 0)]   [lag=int (>= 0)]   [backdrop=string]  output=string  [x_output=string]   [y_output=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Consider spotting effect (for wildfires) Use start raster map values in output spread time raster map Designed to be used with output of previous run of r.spread when computing spread iteratively. The values in start raster map are considered as time. Allowed values in raster map are from zero to the value of init_time option. If not enabled, init_time is used in the area of start raster map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Use start raster map values in output spread time raster map Designed to be used with output of previous run of r.spread when computing spread iteratively. The values in start raster map are considered as time. Allowed values in raster map are from zero to the value of init_time option. If not enabled, init_time is used in the area of start raster map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "base_ros", "flag": "base_ros", "dataType": "String", "optional": false, "explanation": "Raster map containing base ROS (cm/min)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max_ros", "flag": "max_ros", "dataType": "String", "optional": false, "explanation": "Raster map containing maximal ROS (cm/min)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "direction_ros", "flag": "direction_ros", "dataType": "String", "optional": false, "explanation": "Raster map containing directions of maximal ROS (degree)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start", "flag": "start", "dataType": "String", "optional": false, "explanation": "Raster map containing starting sources", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "spotting_distance", "flag": "spotting_distance", "dataType": "String", "optional": true, "explanation": "Raster map containing maximal spotting distance (m, required with -s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "wind_speed", "flag": "wind_speed", "dataType": "String", "optional": true, "explanation": "Raster map containing midflame wind speed (ft/min, required with -s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fuel_moisture", "flag": "fuel_moisture", "dataType": "String", "optional": true, "explanation": "Raster map containing fine fuel moisture of the cell receiving a spotting firebrand (%, required with -s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "least_size", "flag": "least_size", "dataType": "String", "optional": true, "explanation": "Basic sampling window size needed to meet certain accuracy (3)", "defaultValue": null, "alternatives": ["3", "5", "7", "9", "11", "13", "15"], "isInputFile": false, "isOutputFile": false}, {"parameter": "comp_dens", "flag": "comp_dens", "dataType": "String", "optional": true, "explanation": "Sampling density for additional computing (range: 0.0 - 1.0 (0.5))", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "init_time", "flag": "init_time", "dataType": "String", "optional": true, "explanation": "Initial time for current simulation (0) (min)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lag", "flag": "lag", "dataType": "String", "optional": true, "explanation": "Simulating time duration LAG (fill the region) (min)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "backdrop", "flag": "backdrop", "dataType": "String", "optional": true, "explanation": "Name of raster map as a display backdrop", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Raster map to contain output spread time (min)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "x_output", "flag": "x_output", "dataType": "String", "optional": true, "explanation": "Name of raster map to contain X back coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y_output", "flag": "y_output", "dataType": "String", "optional": true, "explanation": "Name of raster map to contain Y back coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.spread  is part of the wildfire simulation toolset. Preparational\n steps for the fire simulation are the calculation of the rate of spread (ROS)\n with  r.ros , and the creating of spread map with  r.spread .\n Eventually, the fire path(s) based on starting point(s) are calculated\n with  r.spreadpath .\n Spread phenomena usually show uneven movement over space. Such unevenness\n is due to two reasons:\n  the uneven conditions from location to location, which can be called\n  spatial heterogeneity , and\n  the uneven conditions in different directions, which can be called\n  anisotropy .\n  The anisotropy of spread occurs when any of the determining factors\n have directional components. For example, wind and topography cause anisotropic\n spread of wildfires.\n  One of the simplest spatial heterogeneous and anisotropic spread\n is elliptical spread, in which, each local spread shape can be thought\n as an ellipse. In a raster setting, cell centers are foci of the spread\n ellipses, and the spread phenomenon moves fastest toward apogees and slowest\n to perigees. The sizes and shapes of spread ellipses may vary cell by cell.\n So the overall spread shape is commonly not an ellipse.\n  r.spread simulates elliptically anisotropic spread phenomena,\n given three raster map layers about ROS (base ROS, maximum ROS and direction\n of the maximum ROS) plus a raster map layer showing the starting sources.\n These ROS layers define unique ellipses for all cell locations in the current\n computational region as if each cell center was a potential spread origin.\n For some wildfire spread, these ROS layers can be generated by another\n GRASS raster program r.ros. The actual locations reached by a spread event\n are constrained by the actual spread origins and the elapsed spread time.\n  r.spread optionally produces raster maps to contain backlink\n UTM coordinates for each raster cell of the spread time map. The spread\n paths can be accurately traced based on the backlink information by\n  r.spreadpath  module.\n  Part of the spotting function in r.spread is based on Chase (1984)\n and Rothermel (1983). More information on  r.spread ,\n  r.ros  and\n  r.spreadpath  can be found in\n Xu (1994).\n  Options  spot_dist ,  w_speed  and  f_mois  must all\n be given if the  -s  (spotting) flag is used.\n  EXAMPLE \n Assume we have inputs, the following simulates a spotting- involved wildfire\n and generates three raster maps to contain spread\n time, backlink information in UTM northing and easting coordinates:\n r.spread -s max=my_ros.max dir=my_ros.maxdir base=my_ros.base \n      start=fire_origin spot_dist=my_ros.spotdist w_speed=wind_speed \n      f_mois=1hour_moisture output=my_spread \n      x_output=my_spread.x y_output=my_spread.y\n ", "notes": "\n 1.  r.spread  is a specific implementation of the shortest path\n algorithm.  r.cost  module served\n as the starting point for the development of  r.spread .\n One of the major differences between the two programs is that\n  r.cost  only simulates\n  isotropic  spread while  r.spread  can simulate\n  elliptically anisotropic  spread, including isotropic spread\n as a special case.\n  2. Before running r.spread, the user should prepare the ROS (base,\n max and direction) maps using appropriate models. For some wildfire spread,\n the  r.ros  module based on\n Rothermel's fire equation does such work.\n The combination of the two forms a simulation of wildfire spread.\n  3. The relationship of the start map and ROS maps should be logically\n correct, i.e. a starting source (a positive value in the start map) should\n not be located in a spread  barrier  (zero value in the ROS maps).\n Otherwise the program refuses to run.\n  4.  r.spread  uses the current computational region settings. The output\n map layer will not go outside the boundaries set in the region, and will\n not be influenced by starting sources outside. So any change of the current\n region may influence the output. The recommendation is to use slightly\n larger region than needed.\n Refer to  g.region  to set an appropriate\n computational region.\n  5. The user should be sure that the inputs to  r.spread  are\n in proper units.\n  6.  r.spread  is a computationally intensive program. The user may\n need to choose appropriate size of the computational region and resolution.\n  7. A low and medium (i.e. <= 0.5) sampling density can improve\n accuracy for elliptical simulation significantly, without adding significantly\n extra running time. Further increasing the sample density will not gain\n much accuracy while requiring greatly additional running time.\n  REFERENCES \n  Chase, Carolyn, H., 1984, Spotting distance from wind-driven surface fires\n -- extensions of equations for pocket calculators, US Forest Service, Res.\n Note INT-346, Ogden, Utah. \n  Rothermel, R. C., 1983, How to predict the spread and intensity\n of forest and range fires. US Forest Service, Gen. Tech. Rep. INT-143.\n Ogden, Utah. \n  Xu, Jianping, 1994, Simulating the spread of wildfires using a\n geographic information system and remote sensing, Ph. D. Dissertation,\n Rutgers University, New Brunswick, New Jersey\n ( ref ). \n ", "see_also": ["r.cost", "r.mask", "r.ros", "r.spreadpath"], "authors": ["Jianping Xu and Richard G. Lathrop, Jr., Center for Remote Sensing and Spatial Analysis, Rutgers University."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.spread"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.solute.transport.html", "name": "r.solute.transport", "definition": "- Numerical calculation program for transient, confined and unconfined solute transport in two dimensions", "keywords": ["raster", "hydrology", "solute transport"], "synopsis": "r.solute.transport [-fc] c=name phead=name hc_x=name hc_y=name status=name diff_x=name diff_y=name  [q=name]   [cin=name]  cs=name rd=name nf=name top=name bottom=name output=name  [vx=name]   [vy=name]  dtime=float  [maxit=integer]   [error=float]   [solver=name]   [relax=float]   [al=float]   [at=float]   [loops=float]   [stab=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Use a full filled quadratic linear equation system, default is a sparse linear equation system. Use the Courant-Friedrichs-Lewy criteria for time step calculation Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Use the Courant-Friedrichs-Lewy criteria for time step calculation Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "c", "flag": "c", "dataType": "String", "optional": false, "explanation": "The initial concentration in [kg/m^3]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "phead", "flag": "phead", "dataType": "String", "optional": false, "explanation": "The piezometric head in [m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "hc_x", "flag": "hc_x", "dataType": "String", "optional": false, "explanation": "The x-part of the hydraulic conductivity tensor in [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "hc_y", "flag": "hc_y", "dataType": "String", "optional": false, "explanation": "The y-part of the hydraulic conductivity tensor in [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "status", "flag": "status", "dataType": "String", "optional": false, "explanation": "The status for each cell, = 0 - inactive cell, 1 - active cell, 2 - dirichlet- and 3 - transfer boundary condition", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "diff_x", "flag": "diff_x", "dataType": "String", "optional": false, "explanation": "The x-part of the diffusion tensor in [m^2/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "diff_y", "flag": "diff_y", "dataType": "String", "optional": false, "explanation": "The y-part of the diffusion tensor in [m^2/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "q", "flag": "q", "dataType": "String", "optional": true, "explanation": "Groundwater sources and sinks in [m^3/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cin", "flag": "cin", "dataType": "String", "optional": true, "explanation": "Concentration sources and sinks bounded to a water source or sink in [kg/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cs", "flag": "cs", "dataType": "String", "optional": false, "explanation": "Concentration of inner sources and inner sinks in [kg/s] (i.e. a chemical reaction)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rd", "flag": "rd", "dataType": "String", "optional": false, "explanation": "Retardation factor [-]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nf", "flag": "nf", "dataType": "String", "optional": false, "explanation": "Effective porosity [-]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "top", "flag": "top", "dataType": "String", "optional": false, "explanation": "Top surface of the aquifer in [m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bottom", "flag": "bottom", "dataType": "String", "optional": false, "explanation": "Bottom surface of the aquifer in [m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "The resulting concentration of the numerical solute transport calculation will be written to this map. [kg/m^3]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "vx", "flag": "vx", "dataType": "String", "optional": true, "explanation": "Calculate and store the groundwater filter velocity vector part in x direction [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vy", "flag": "vy", "dataType": "String", "optional": true, "explanation": "Calculate and store the groundwater filter velocity vector part in y direction [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dtime", "flag": "dtime", "dataType": "String", "optional": false, "explanation": "The calculation time in seconds", "defaultValue": "86400", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxit", "flag": "maxit", "dataType": "String", "optional": true, "explanation": "Maximum number of iteration used to solve the linear equation system", "defaultValue": "10000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "error", "flag": "error", "dataType": "String", "optional": true, "explanation": "Error break criteria for iterative solver", "defaultValue": "0.000001", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "solver", "flag": "solver", "dataType": "String", "optional": true, "explanation": "The type of solver which should solve the linear equation system", "defaultValue": "bicgstab", "alternatives": ["gauss", "lu", "jacobi", "sor", "bicgstab"], "isInputFile": false, "isOutputFile": false}, {"parameter": "relax", "flag": "relax", "dataType": "String", "optional": true, "explanation": "The relaxation parameter used by the jacobi and sor solver for speedup or stabilizing", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "al", "flag": "al", "dataType": "String", "optional": true, "explanation": "The longditudinal dispersivity length. [m]", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "at", "flag": "at", "dataType": "String", "optional": true, "explanation": "The transversal dispersivity length. [m]", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "loops", "flag": "loops", "dataType": "String", "optional": true, "explanation": "Use this number of time loops if the CFL flag is off. The timestep will become dt/loops.", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stab", "flag": "stab", "dataType": "String", "optional": true, "explanation": "Set the flow stabilizing scheme (full or exponential upwinding).", "defaultValue": "full", "alternatives": ["full", "exp"], "isInputFile": false, "isOutputFile": false}], "description": "\n This numerical program calculates numerical implicit transient and steady state\n solute transport in porous media in the saturated zone of an aquifer. The computation is based on\n raster maps and the current region settings. All initial- and boundary-conditions must be provided as\n raster maps. The unit in the location must be meters.\n  This module is sensitive to mask settings. All cells which are outside the mask\n are ignored and handled as no flow boundaries.\n This module calculates the concentration of the solution and optional the\n velocity field, based on the hydraulic conductivity, \n the effective porosity and the initial piecometric heads. \n The vector components can be visualized with paraview if they are exported\n with r.out.vtk.\n Use  r.gwflow  to compute the piezometric heights\n of the aquifer. The piezometric heights and the hydraulic conductivity\n are used to compute the flow direction and the mean velocity of the groundwater.\n This is the base of the solute transport computation.\n The solute transport will always be calculated transient. \n For stady state computation set the timestep\n to a large number (billions of seconds).\n To reduce the numerical dispersion, which is a consequence of the convection term and\n the finite volume discretization, you can use small time steps and choose between full\n and exponential upwinding.\n ", "notes": "\n The solute transport calculation is based on a diffusion/convection partial differential equation and\n a numerical implicit finite volume discretization. Specific for this kind of differential\n equation is the combination of a diffusion/dispersion term and a convection term.\n The discretization results in an unsymmetric linear equation system in form of  Ax = b ,\n which must be solved. The solute transport partial\n differential equation is of the following form:\n  (dc/dt)*R = div ( D grad c - uc) + cs -q/nf(c - c_in)\n  c -- the concentration [kg/m^3] \n  u -- vector of mean groundwater flow velocity \n  dt -- the time step for transient calculation in seconds [s] \n  R -- the linear retardation coefficient [-] \n  D -- the diffusion and dispersion tensor [m^2/s] \n  cs -- inner concentration sources/sinks [kg/m^3] \n  c_in -- the solute concentration of influent water [kg/m^3] \n  q -- inner well sources/sinks [m^3/s] \n  nf -- the effective porosity [-]  \n Three different boundary conditions are implemented,\n the Dirichlet, Transmission and Neumann conditions.\n The calculation and boundary status of single cells can be set with the status map.\n The following states are supportet:\n  0 == inactive - the cell with status 0 will not be calculated, active cells will have a no flow boundary to an inactive cell \n  1 == active - this cell is used for sloute transport calculation, inner sources can be defined for those cells \n  2 == Dirichlet - cells of this type will have a fixed concentration value which do not change over time  \n  3 == Transmission - cells of this type should be placed on out-flow boundaries to assure the flow of the solute stream out  \n Note that all required raster maps are read into main memory. Additionally the\n linear equation system will be allocated, so the memory consumption of this\n module rapidely grow with the size of the input maps.\n The resulting linear equation system  Ax = b  can be solved with several solvers.\n Several iterative solvers with unsymmetric sparse and quadratic matrices support are implemented.\n The jacobi method, the Gauss-Seidel method and the biconjugate gradients-stabilized (bicgstab) method. \n Additionally a direct Gauss solver and LU solver are available. Those direct solvers\n only work with quadratic matrices, so be careful using them with large maps \n (maps of size 10.000 cells will need more than one gigabyte of ram).\n Always prefer a sparse matrix solver.\n  EXAMPLE \n Use this small python script to create a working\n groundwater flow / solute transport area and data. \n Make sure you are not in a lat/lon projection.\n #!/usr/bin/env python\n # This is an example script how groundwater flow and solute transport are\n # computed within grass\n import sys\n import os\n import grass.script as grass\n # Overwrite existing maps\n grass.run_command(\"g.gisenv\", set=\"OVERWRITE=1\")\n grass.message(_(\"Set the region\"))\n # The area is 200m x 100m with a cell size of 1m x 1m\n grass.run_command(\"g.region\", res=1, res3=1, t=10, b=0, n=100, s=0, w=0, e=200)\n grass.run_command(\"r.mapcalc\", expression=\"phead = if(col() == 1 , 50, 40)\")\n grass.run_command(\"r.mapcalc\", expression=\"phead = if(col() ==200  , 45 + row()/40, phead)\")\n grass.run_command(\"r.mapcalc\", expression=\"status = if(col() == 1 || col() == 200 , 2, 1)\")\n grass.run_command(\"r.mapcalc\", expression=\"well = if((row() == 50 && col() == 175) || (row() == 10 && col() == 135) , -0.001, 0)\")\n grass.run_command(\"r.mapcalc\", expression=\"hydcond = 0.00005\")\n grass.run_command(\"r.mapcalc\", expression=\"recharge = 0\")\n grass.run_command(\"r.mapcalc\", expression=\"top_conf = 20\")\n grass.run_command(\"r.mapcalc\", expression=\"bottom = 0\")\n grass.run_command(\"r.mapcalc\", expression=\"poros = 0.17\")\n grass.run_command(\"r.mapcalc\", expression=\"syield = 0.0001\")\n grass.run_command(\"r.mapcalc\", expression=\"null = 0.0\")\n grass.message(_(\"Compute a steady state groundwater flow\"))\n grass.run_command(\"r.gwflow\", solver=\"cg\", top=\"top_conf\", bottom=\"bottom\", phead=\"phead\",\n    status=\"status\", hc_x=\"hydcond\", hc_y=\"hydcond\", q=\"well\", s=\"syield\",\n    recharge=\"recharge\", output=\"gwresult_conf\", dt=8640000000000, type=\"confined\")\n grass.message(_(\"generate the transport data\"))\n grass.run_command(\"r.mapcalc\", expression=\"c = if(col() == 15 && row() == 75 , 500.0, 0.0)\")\n grass.run_command(\"r.mapcalc\", expression=\"cs = if(col() == 15 && row() == 75 , 0.0, 0.0)\")\n grass.run_command(\"r.mapcalc\", expression=\"tstatus = if(col() == 1 || col() == 200 , 3, 1)\")\n grass.run_command(\"r.mapcalc\", expression=\"diff = 0.0000001\")\n grass.run_command(\"r.mapcalc\", expression=\"R = 1.0\")\n # Compute the initial state\n grass.run_command(\"r.solute.transport\", solver=\"bicgstab\", top=\"top_conf\",\n    bottom=\"bottom\", phead=\"gwresult_conf\", status=\"tstatus\", hc_x=\"hydcond\", hc_y=\"hydcond\",\n    rd=\"R\", cs=\"cs\", q=\"well\", nf=\"poros\", output=\"stresult_conf_0\", dt=3600, diff_x=\"diff\",\n    diff_y=\"diff\", c=\"c\", al=0.1, at=0.01)\n # Compute the solute transport for 300 days in 10 day steps\n for dt in range(30):\n     grass.run_command(\"r.solute.transport\", solver=\"bicgstab\", top=\"top_conf\",\n      bottom=\"bottom\", phead=\"gwresult_conf\", status=\"tstatus\", hc_x=\"hydcond\", hc_y=\"hydcond\",\n      rd=\"R\", cs=\"cs\", q=\"well\", nf=\"poros\", output=\"stresult_conf_\" + str(dt + 1), dt=864000, diff_x=\"diff\",\n      diff_y=\"diff\", c=\"stresult_conf_\" + str(dt), al=0.1, at=0.01)\n ", "see_also": ["r.gwflow", "r3.gwflow", "r.out.vtk"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.solute.transport"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.slope.aspect.html", "name": "r.slope.aspect", "definition": "- Generates raster maps of slope, aspect, curvatures and partial derivatives from an elevation raster map.", "keywords": ["raster", "terrain", "aspect", "slope", "curvature"], "synopsis": "r.slope.aspect [-an] elevation=name  [slope=name]   [aspect=name]   [format=string]   [precision=string]   [pcurvature=name]   [tcurvature=name]   [dx=name]   [dy=name]   [dxx=name]   [dyy=name]   [dxy=name]   [zscale=float]   [min_slope=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Do not align the current region to the raster elevation map Create aspect as degrees clockwise from North (azimuth), with flat = -9999 Default: degrees counter-clockwise from East, with flat = 0 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Create aspect as degrees clockwise from North (azimuth), with flat = -9999 Default: degrees counter-clockwise from East, with flat = 0 Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "slope", "flag": "slope", "dataType": "String", "optional": true, "explanation": "Name for output slope raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "aspect", "flag": "aspect", "dataType": "String", "optional": true, "explanation": "Name for output aspect raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Format for reporting the slope", "defaultValue": "degrees", "alternatives": ["degrees", "percent"], "isInputFile": false, "isOutputFile": false}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Type of output aspect and slope maps", "defaultValue": "FCELL", "alternatives": ["CELL", "FCELL", "DCELL"], "isInputFile": false, "isOutputFile": false}, {"parameter": "pcurvature", "flag": "pcurvature", "dataType": "String", "optional": true, "explanation": "Name for output profile curvature raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "tcurvature", "flag": "tcurvature", "dataType": "String", "optional": true, "explanation": "Name for output tangential curvature raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "dx", "flag": "dx", "dataType": "String", "optional": true, "explanation": "Name for output first order partial derivative dx (E-W slope) raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "dy", "flag": "dy", "dataType": "String", "optional": true, "explanation": "Name for output first order partial derivative dy (N-S slope) raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "dxx", "flag": "dxx", "dataType": "String", "optional": true, "explanation": "Name for output second order partial derivative dxx raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "dyy", "flag": "dyy", "dataType": "String", "optional": true, "explanation": "Name for output second order partial derivative dyy raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "dxy", "flag": "dxy", "dataType": "String", "optional": true, "explanation": "Name for output second order partial derivative dxy raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Multiplicative factor to convert elevation units to horizontal units", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "min_slope", "flag": "min_slope", "dataType": "String", "optional": true, "explanation": "Minimum slope value (in percent) for which aspect is computed", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.slope.aspect  generates raster maps of slope, aspect, curvatures and\n first and second order partial derivatives from a raster map of true\n elevation values. The user must specify the input  elevation  raster map\n and at least one output raster maps. The user can also specify the\n  format  for slope (degrees, percent; default=degrees), and the \n  zscale : multiplicative factor to convert elevation units to horizontal units;\n (default 1.0).\n The  elevation  input raster map specified by the user must contain true\n elevation values,  not  rescaled or categorized data. If the elevation\n values are in other units than in the horizontal units,\n they must be converted to horizontal units using the parameter  zscale .\n  In GRASS GIS 7, vertical units are not assumed to be meters any more.\n For example, if both your vertical and horizontal units are feet,\n parameter  zscale  must not be used .\n The  aspect  output raster map indicates the direction that slopes \n are facing counterclockwise from East: 90 degrees is North, 180 is \n West, 270 is South, 360 is East. Zero aspect indicates flat areas with \n zero slope. Category and color table files are also generated for the \n aspect raster map.   Note: These values can be transformed to \n azimuth values (90 is East, 180 is South, 270 is West, 360 is North) \n using  r.mapcalc :\n # convert angles from CCW from East to CW from North\n # modulus (%) can not be used with floating point aspect values\n r.mapcalc \"azimuth_aspect = if(ccw_aspect == 0, 0, \n                              if(ccw_aspect < 90, 90 - ccw_aspect, \n                              450 - ccw_aspect)))\"\n Alternatively, the  -n  flag can be used to produce aspect as \n degrees CW from North. Aspect for flat areas is then set to -9999 \n (default: 0).\n The aspect for slope equal to zero (flat areas) is set to zero (-9999 \n with  -n  flag). Thus, most cells with a very small slope end up \n having category 0, 45, ..., 360 in  aspect  output. It is possible \n to reduce the bias in these directions by filtering out the aspect in \n areas where the terrain is almost flat. A option  min_slope  can \n be used to specify the minimum slope for which aspect is computed. For \n all cells with slope\u00a0<\u00a0 min_slope , both slope and \n aspect are set to zero.\n    \n The  slope  output raster map contains slope values, stated in degrees of\n inclination from the horizontal if  format =degrees option (the default)\n is chosen, and in percent rise if  format =percent option is chosen.\n Category and color table files are generated.\n Profile and tangential curvatures are the curvatures in the direction of\n steepest slope and in the direction of the contour tangent respectively. The\n curvatures are expressed as 1/metres, e.g. a curvature of 0.05 corresponds to a\n radius of curvature of 20m. Convex form values are positive and concave form values\n are negative.\n   \n    \n    \n      \n          Example DEM\n      \n    \n    \n    \n    \n   \n   \n    \n    \n      \n          Slope (degree) from example DEM\n      \n    \n    \n    \n    \n      \n          Aspect (degree) from example DEM\n      \n    \n    \n   \n   \n    \n    \n      \n          Tangential curvature (m -1 ) from example DEM\n      \n    \n    \n    \n    \n      \n          Profile curvature (m -1 ) from example DEM\n      \n    \n    \n    \n    \n   \n  For some applications, the user will wish to use a reclassified raster map\n of slope that groups slope values into ranges of slope. This can be done using\n  r.reclass . An example of a useful\n reclassification is given below:\n            category      range   category labels\n                      (in degrees)    (in percent)\n              1         0-  1             0-  2%\n              2         2-  3             3-  5%\n              3         4-  5             6- 10%\n              4         6-  8            11- 15%\n              5         9- 11            16- 20%\n              6        12- 14            21- 25%\n              7        15- 90            26% and higher\n      The following color table works well with the above\n      reclassification.\n           category   red   green   blue\n              0       179    179     179\n              1         0    102       0\n              2         0    153       0\n              3       128    153       0\n              4       204    179       0\n              5       128     51      51\n              6       255      0       0\n              7         0      0       0 \n ", "notes": "\n To ensure that the raster elevation map is not inappropriately resampled,\n the settings for the current region are modified slightly (for the execution\n of the program only): the resolution is set to match the resolution of\n the elevation raster map and the edges of the region (i.e. the north, south, east\n and west) are shifted, if necessary, to line up along edges of the nearest\n cells in the elevation map. If the user really wants the raster elevation map\n resampled to the current region resolution, the  -a  flag should be specified.\n The current mask is ignored.\n The algorithm used to determine slope and aspect uses a 3x3 \n neighborhood around each cell in the raster elevation map. Thus, it is \n not possible to determine slope and aspect for the cells adjacent to \n the edges and NULL cells in the elevation map layer. These cells are \n set to nodata in both the slope and aspect raster maps.\n Horn's formula is used to find the first order derivatives in x and y directions.\n Only when using integer elevation models, the aspect is biased in 0,\n 45, 90, 180, 225, 270, 315, and 360 directions; i.e., the distribution\n of aspect categories is very uneven, with peaks at 0, 45,..., 360 categories.\n When working with floating point elevation models, no such aspect bias occurs.\n  EXAMPLES \n  Calculation of slope, aspect, profile and tangential curvature \n In this example a slope, aspect, profile and tangential curvature map\n are computed from an elevation raster map (North Carolina sample\n dataset):\n g.region raster=elevation\n r.slope.aspect elevation=elevation slope=slope aspect=aspect pcurvature=pcurv tcurvature=tcurv\n # set nice color tables for output raster maps\n r.colors -n map=slope color=sepia\n r.colors map=aspect color=aspectcolr\n r.colors map=pcurv color=curvature\n r.colors map=tcurv color=curvature\n    \n    \n    \n    \n    \n Figure: Slope, aspect, profile and tangential curvature raster map (North Carolina dataset)\n  Classification of major aspect directions in compass orientation \n In the following example (based on the North Carolina sample dataset)\n we first generate the standard aspect map (oriented CCW from East), then\n convert it to compass orientation, and finally classify four major aspect\n directions (N, E, S, W):\n g.region raster=elevation -p\n # generate integer aspect map with degrees CCW from East\n r.slope.aspect elevation=elevation aspect=myaspect precision=CELL\n # generate compass orientation and classify four major directions (N, E, S, W)\n r.mapcalc \"aspect_4_directions = eval( \\\n     compass=(450 - myaspect ) % 360, \\\n       if(compass >=0. && compass < 45., 1)  \\\n     + if(compass >=45. && compass < 135., 2) \\\n     + if(compass >=135. && compass < 225., 3) \\\n     + if(compass >=225. && compass < 315., 4) \\\n     + if(compass >=315., 1) \\\n  )\"\n # assign text labels\n r.category aspect_4_directions separator=comma rules=- << EOF\n 1,north\n 2,east\n 3,south\n 4,west\n EOF\n # assign color table\n r.colors aspect_4_directions rules=- << EOF\n 1 253,184,99\n 2 178,171,210\n 3 230,97,1\n 4 94,60,153\n EOF\n Aspect map classified to four major compass directions (zoomed subset shown)\n  REFERENCES \n   Horn, B. K. P. (1981).  Hill Shading and the Reflectance Map , Proceedings\n of the IEEE, 69(1):14-47.\n   Mitasova, H. (1985).  Cartographic aspects of computer surface modeling. PhD thesis. \n Slovak Technical University , Bratislava\n   Hofierka, J., Mitasova, H., Neteler, M., 2009.  Geomorphometry in GRASS GIS. \n In: Hengl, T. and Reuter, H.I. (Eds),  Geomorphometry: Concepts, Software, Applications.  \n Developments in Soil Science, vol. 33, Elsevier, 387-410 pp,\n  http://www.geomorphometry.org \n ", "see_also": ["r.mapcalc", "r.neighbors", "r.reclass", "r.rescale"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.slope.aspect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.sim.water.html", "name": "r.sim.water", "definition": "- Overland flow hydrologic simulation using path sampling method (SIMWE).", "keywords": ["raster", "hydrology", "soil", "flow", "overland flow", "model"], "synopsis": "r.sim.water [-ts] elevation=name dx=name dy=name  [rain=name]   [rain_value=float]   [infil=name]   [infil_value=float]   [man=name]   [man_value=float]   [flow_control=name]   [observation=name]   [depth=name]   [discharge=name]   [error=name]   [walkers_output=name]   [logfile=name]   [nwalkers=integer]   [niterations=integer]   [output_step=integer]   [diffusion_coeff=float]   [hmax=float]   [halpha=float]   [hbeta=float]   [random_seed=integer]   [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Time-series output Generate random seed Automatically generates random seed for random number generator (use when you don't want to provide the seed option) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Generate random seed Automatically generates random seed for random number generator (use when you don't want to provide the seed option) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "dx", "flag": "dx", "dataType": "String", "optional": false, "explanation": "Name of x-derivatives raster map [m/m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dy", "flag": "dy", "dataType": "String", "optional": false, "explanation": "Name of y-derivatives raster map [m/m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rain", "flag": "rain", "dataType": "String", "optional": true, "explanation": "Name of rainfall excess rate (rain-infilt) raster map [mm/hr]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rain_value", "flag": "rain_value", "dataType": "String", "optional": true, "explanation": "Rainfall excess rate unique value [mm/hr]", "defaultValue": "50", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "infil", "flag": "infil", "dataType": "String", "optional": true, "explanation": "Name of runoff infiltration rate raster map [mm/hr]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "infil_value", "flag": "infil_value", "dataType": "String", "optional": true, "explanation": "Runoff infiltration rate unique value [mm/hr]", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "man", "flag": "man", "dataType": "String", "optional": true, "explanation": "Name of Manning's n raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "man_value", "flag": "man_value", "dataType": "String", "optional": true, "explanation": "Manning's n unique value", "defaultValue": "0.1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "flow_control", "flag": "flow_control", "dataType": "String", "optional": true, "explanation": "Name of flow controls raster map (permeability ratio 0-1)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "observation", "flag": "observation", "dataType": "String", "optional": true, "explanation": "Name of sampling locations vector points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "depth", "flag": "depth", "dataType": "String", "optional": true, "explanation": "Name for output water depth raster map [m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "discharge", "flag": "discharge", "dataType": "String", "optional": true, "explanation": "Name for output water discharge raster map [m3/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "error", "flag": "error", "dataType": "String", "optional": true, "explanation": "Name for output simulation error raster map [m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "walkers_output", "flag": "walkers_output", "dataType": "String", "optional": true, "explanation": "Base name of the output walkers vector points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "logfile", "flag": "logfile", "dataType": "String", "optional": true, "explanation": "Name for sampling points output text file. For each observation vector point the time series of sediment transport is stored.", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nwalkers", "flag": "nwalkers", "dataType": "String", "optional": true, "explanation": "Number of walkers, default is twice the number of cells", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "niterations", "flag": "niterations", "dataType": "String", "optional": true, "explanation": "Time used for iterations [minutes]", "defaultValue": "10", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output_step", "flag": "output_step", "dataType": "String", "optional": true, "explanation": "Time interval for creating output maps [minutes]", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "diffusion_coeff", "flag": "diffusion_coeff", "dataType": "String", "optional": true, "explanation": "Water diffusion constant", "defaultValue": "0.8", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "hmax", "flag": "hmax", "dataType": "String", "optional": true, "explanation": "Threshold water depth [m]", "defaultValue": "0.3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "halpha", "flag": "halpha", "dataType": "String", "optional": true, "explanation": "Diffusion increase constant", "defaultValue": "4.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "hbeta", "flag": "hbeta", "dataType": "String", "optional": true, "explanation": "Weighting factor for water flow velocity vector", "defaultValue": "0.5", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "random_seed", "flag": "random_seed", "dataType": "String", "optional": true, "explanation": "Seed for random number generator", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of threads which will be used for parallel compute", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.sim.water  is a landscape scale simulation model \n of overland flow designed for spatially variable terrain, soil, cover \n and rainfall excess conditions. A 2D shallow water flow is described by \n the bivariate form of Saint Venant equations. The numerical solution is based\n on the concept of duality between the field and particle representation of\n the modeled quantity. Green's function Monte Carlo method, used to solve the equation,\n provides robustness necessary for spatially variable conditions and high\n resolutions (Mitas and Mitasova 1998). The key inputs of the model include\n elevation ( elevation  raster map), flow gradient vector given by\n first-order partial derivatives of elevation field ( dx  and  dy \n raster maps), rainfall excess rate ( rain  raster map or  rain_value  single\n value) and a surface roughness coefficient given by Manning's n \n ( man  raster map or  man_value  single value). Partial\n derivatives raster maps can be computed along with interpolation of a DEM using\n the -d option in  v.surf.rst  module. If elevation raster \n map is already provided, partial derivatives can be computed using\n  r.slope.aspect  module. Partial derivatives are used\n to determine the direction and magnitude of water flow velocity. To include a \n predefined direction of flow, map algebra can be used to replace terrain-derived\n partial derivatives with pre-defined partial derivatives in selected grid cells such \n as man-made channels, ditches or culverts. Equations (2) and (3) from \n  this report \n can be used to compute partial derivates of the predefined flow using its direction given\n by aspect and slope.\n The module automatically converts horizontal distances from feet to metric system using\n database/projection information. Rainfall excess is defined as rainfall intensity\n - infiltration rate and should be provided in [mm/hr].\n Rainfall intensities are usually available from meteorological stations. \n Infiltration rate depends on soil properties and land cover. It varies in space and time.\n For saturated soil and steady-state water flow it can be estimated using\n saturated hydraulic conductivity rates based on field measurements or using\n reference values which can be found in literature.\n Optionally, user can provide an overland flow infiltration rate map \n  infil  or a single value  infil_value  in [mm/hr] that control the rate of\n infiltration for the already flowing water, effectively reducing the flow depth and \n discharge.\n Overland flow can be further controlled by permeable check dams or similar type of structures,\n the user can provide a map of these structures and their permeability ratio\n in the map  flow_control  that defines the probability of particles to pass\n through the structure (the values will be 0-1).\n Output includes a water depth raster map  depth  in [m], and a water discharge \n raster map  discharge  in [m3/s]. Error of the numerical solution can be analyzed using \n the  error  raster map (the resulting water depth is an average, and err is its RMSE).\n The output vector points map  output_walkers  can be used to analyze and visualize \n spatial distribution of walkers at different simulation times (note that \n the resulting water depth is based on the density of these walkers). \n The spatial distribution of numerical error associated with path sampling solution can be\n analysed using the output error raster file [m]. This error is a function of the number\n of particles used in the simulation and can be reduced by increasing the number of walkers\n given by parameter  nwalkers .\n Duration of simulation is controlled by the  niterations  parameter. The default value \n is 10 minutes, reaching the steady-state may require much longer time, \n depending on the time step, complexity of terrain, land cover and size of the area. \n Output walker, water depth and discharge maps can be saved during simulation using \n the time series flag  -t  and  output_step  parameter \n defining the time step in minutes for writing output files. \n Files are saved with a suffix representing time since the start of simulation in minutes \n (e.g. wdepth.05, wdepth.10).\n Monitoring of water depth at specific points is supported. A vector map with observation points and\n a path to a logfile must be provided. For each point in the vector map which is located in\n the computational region the water depth is logged each time step in the logfile. The logfile is\n organized as a table. A single header identifies the category number of the logged vector points.\n In case of invalid water depth data the value -1 is used.\n Overland flow is routed based on partial derivatives of elevation\n field or other landscape features influencing water flow. Simulation\n equations include a diffusion term ( diffusion_coeff  parameter) which enables \n water flow to overcome elevation depressions or obstacles when water depth exceeds \n a threshold water depth value ( hmax) , given in [m]. When it is reached, \n diffusion term increases as given by  halpha  and advection term \n (direction of flow) is given as \"prevailing\" direction of flow computed\n as average of flow directions from the previous  hbeta  number of grid cells.\n ", "notes": "\n A 2D shallow water flow is described by the bivariate form of Saint\n Venant equations (e.g., Julien et al., 1995). The continuity of water\n flow relation is coupled with the momentum conservation equation and\n for a shallow water overland flow, the hydraulic radius is approximated\n by the normal flow depth. The system of equations is closed using the\n Manning's relation. Model assumes that the flow is close to the kinematic\n wave approximation, but we include a diffusion-like term to incorporate the\n impact of diffusive wave effects. Such an incorporation of diffusion\n in the water flow simulation is not new and a similar term has been obtained\n in derivations of diffusion-advection equations for overland flow, e.g.,\n by Lettenmeier and Wood, (1992). In our reformulation, we simplify the\n diffusion coefficient to a constant and we use a modified diffusion term.\n The diffusion constant which we have used is rather small (approximately\n one order of magnitude smaller than the reciprocal Manning's coefficient)\n and therefore the resulting flow is close to the kinematic regime. However,\n the diffusion term improves the kinematic solution, by overcoming small\n shallow pits common in digital elevation models (DEM) and by smoothing out\n the flow over slope discontinuities or abrupt changes in Manning's coefficient\n (e.g., due to a road, or other anthropogenic changes in elevations or cover).\n  Green's function stochastic method of solution. \n The Saint Venant equations are solved by a stochastic method called Monte Carlo\n (very similar to Monte Carlo methods in computational fluid dynamics or to\n quantum Monte Carlo approaches for solving the Schrodinger equation (Schmidt\n and Ceperley, 1992, Hammond et al., 1994; Mitas, 1996)). It is assumed\n that these equations are a representation of stochastic processes with\n diffusion and drift components (Fokker-Planck equations).\n The Monte Carlo technique has several unique advantages which are\n becoming even more important due to new developments in computer technology. \n Perhaps one of the most significant Monte Carlo properties is robustness \n which enables us to solve the equations for complex cases, such as discontinuities\n in the coefficients of differential operators (in our case, abrupt slope\n or cover changes, etc). Also, rough solutions can be estimated rather\n quickly, which allows us to carry out preliminary quantitative studies\n or to rapidly extract qualitative trends by parameter scans. In addition,\n the stochastic methods are tailored to the new generation of computers\n as they provide scalability from a single workstation to large parallel\n machines due to the independence of sampling points. Therefore, the methods\n are useful both for everyday exploratory work using a desktop computer and\n for large, cutting-edge applications using high performance computing.\n  EXAMPLE \n Spearfish region:\n g.region raster=elevation.10m -p\n r.slope.aspect elevation=elevation.10m dx=elev_dx dy=elev_dy\n # synthetic maps\n r.mapcalc \"rain    = if(elevation.10m, 5.0, null())\"\n r.mapcalc \"manning = if(elevation.10m, 0.05, null())\"\n r.mapcalc \"infilt  = if(elevation.10m, 0.0, null())\"\n # simulate\n r.sim.water elevation=elevation.10m dx=elev_dx dy=elev_dy rain=rain man=manning infil=infilt nwalkers=5000000 depth=depth\n  \n  Figure: Water depth map in the Spearfish (SD) area \n  ERROR MESSAGES \n If the module fails with\n ERROR: nwalk (7000001) > maxw (7000000)!\n then a lower  nwalkers  parameter value has to be selected.\n  REFERENCES \n   Mitasova, H., Thaxton, C., Hofierka, J., McLaughlin, R., Moore, A., Mitas L., 2004,\n Path sampling method for modeling overland water flow, sediment transport \n and short term terrain evolution in Open Source GIS.   \n In: C.T. Miller, M.W. Farthing, V.G. Gray, G.F. Pinder eds., \n Proceedings of the XVth International Conference on Computational Methods in Water \n Resources (CMWR XV), June 13-17 2004, Chapel Hill, NC, USA, Elsevier, pp. 1479-1490.\n   Mitasova H, Mitas, L., 2000,\n  Modeling spatial\n processes in multiscale framework: exploring duality between particles and fields, \n plenary talk at GIScience2000 conference, Savannah, GA. \n   Mitas, L., and Mitasova, H., 1998, Distributed soil erosion simulation \n for effective erosion prevention. Water Resources Research, 34(3), 505-516.\n   Mitasova, H., Mitas, L., 2001,\n Multiscale soil erosion simulations for land use management, \n In: Landscape erosion and landscape evolution modeling, Harmon R. and Doe W. eds., \n Kluwer Academic/Plenum Publishers, pp. 321-347.\n   Hofierka, J, Mitasova, H., Mitas, L., 2002. GRASS and modeling landscape processes\n using duality between particles and fields. Proceedings of the Open source GIS - \n GRASS users conference 2002 - Trento, Italy, 11-13 September 2002.\n  PDF \n   Hofierka, J., Knutova, M., 2015,\n Simulating aspects of a flash flood using the Monte Carlo method and\n GRASS GIS: a case study of the Mal\u00c3\u00a1 Svinka Basin (Slovakia),\n Open Geosciences. Volume 7, Issue 1, ISSN (Online) 2391-5447, DOI:\n  10.1515/geo-2015-0013 ,\n April 2015\n   Neteler, M. and Mitasova, H., 2008,\n  Open Source GIS: A GRASS GIS Approach. Third Edition. \n The International Series in Engineering and Computer Science: Volume 773. Springer New York Inc, p. 406.\n ", "see_also": ["v.surf.rst", "r.slope.aspect", "r.sim.sediment"], "authors": ["Helena Mitasova, Lubos Mitas"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.sim/r.sim.water"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.sim.sediment.html", "name": "r.sim.sediment", "definition": "- Sediment transport and erosion/deposition simulation using path sampling method (SIMWE).", "keywords": ["raster", "hydrology", "soil", "sediment flow", "erosion", "deposition", "model"], "synopsis": "r.sim.sediment [-s] elevation=name water_depth=name dx=name dy=name detachment_coeff=name transport_coeff=name shear_stress=name  [man=name]   [man_value=float]   [observation=name]   [transport_capacity=name]   [tlimit_erosion_deposition=name]   [sediment_concentration=name]   [sediment_flux=name]   [erosion_deposition=name]   [logfile=name]   [walkers_output=name]   [nwalkers=integer]   [niterations=integer]   [output_step=integer]   [diffusion_coeff=float]   [random_seed=integer]   [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Generate random seed Automatically generates random seed for random number generator (use when you don't want to provide the seed option) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "water_depth", "flag": "water_depth", "dataType": "String", "optional": false, "explanation": "Name of water depth raster map [m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dx", "flag": "dx", "dataType": "String", "optional": false, "explanation": "Name of x-derivatives raster map [m/m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dy", "flag": "dy", "dataType": "String", "optional": false, "explanation": "Name of y-derivatives raster map [m/m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "detachment_coeff", "flag": "detachment_coeff", "dataType": "String", "optional": false, "explanation": "Name of detachment capacity coefficient raster map [s/m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "transport_coeff", "flag": "transport_coeff", "dataType": "String", "optional": false, "explanation": "Name of transport capacity coefficient raster map [s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "shear_stress", "flag": "shear_stress", "dataType": "String", "optional": false, "explanation": "Name of critical shear stress raster map [Pa]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "man", "flag": "man", "dataType": "String", "optional": true, "explanation": "Name of Manning's n raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "man_value", "flag": "man_value", "dataType": "String", "optional": true, "explanation": "Manning's n unique value", "defaultValue": "0.1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "observation", "flag": "observation", "dataType": "String", "optional": true, "explanation": "Name of sampling locations vector points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "transport_capacity", "flag": "transport_capacity", "dataType": "String", "optional": true, "explanation": "Name for output transport capacity raster map [kg/ms]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "tlimit_erosion_deposition", "flag": "tlimit_erosion_deposition", "dataType": "String", "optional": true, "explanation": "Name for output transport limited erosion-deposition raster map [kg/m2s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "sediment_concentration", "flag": "sediment_concentration", "dataType": "String", "optional": true, "explanation": "Name for output sediment concentration raster map [particle/m3]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "sediment_flux", "flag": "sediment_flux", "dataType": "String", "optional": true, "explanation": "Name for output sediment flux raster map [kg/ms]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "erosion_deposition", "flag": "erosion_deposition", "dataType": "String", "optional": true, "explanation": "Name for output erosion-deposition raster map [kg/m2s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "logfile", "flag": "logfile", "dataType": "String", "optional": true, "explanation": "Name for sampling points output text file. For each observation vector point the time series of sediment transport is stored.", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "walkers_output", "flag": "walkers_output", "dataType": "String", "optional": true, "explanation": "Base name of the output walkers vector points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nwalkers", "flag": "nwalkers", "dataType": "String", "optional": true, "explanation": "Number of walkers", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "niterations", "flag": "niterations", "dataType": "String", "optional": true, "explanation": "Time used for iterations [minutes]", "defaultValue": "10", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output_step", "flag": "output_step", "dataType": "String", "optional": true, "explanation": "Time interval for creating output maps [minutes]", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "diffusion_coeff", "flag": "diffusion_coeff", "dataType": "String", "optional": true, "explanation": "Water diffusion constant", "defaultValue": "0.8", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "random_seed", "flag": "random_seed", "dataType": "String", "optional": true, "explanation": "Seed for random number generator", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of threads which will be used for parallel compute", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.sim.sediment  is a landscape scale, simulation \n model of soil erosion, sediment transport and deposition caused by flowing \n water designed for spatially variable terrain, soil, cover and  \n rainfall excess conditions. The soil erosion model is based on the theory\n used in the USDA WEPP hillslope erosion model, but it has been generalized\n to 2D flow. The solution is based on the concept of duality between fields and \n particles and the underlying equations are solved by Green's \n function Monte  Carlo method, to provide robustness necessary for \n spatially variable conditions and high resolutions (Mitas and Mitasova \n 1998).  Key inputs of the model include the following raster maps:\n  elevation ( elevation  [m]), flow gradient given by the first-order partial \n derivatives of elevation field (  dx  and  dy ), \n overland flow water depth ( water_depth  [m]), detachment capacity coefficient \n ( detachment_coeff  [s/m]), transport capacity coefficient ( transport_coeff  [s]), \n critical shear stress ( shear_stress  [Pa]) \n and surface  roughness coefficient called Manning's n ( man  raster map). \n Partial derivatives can be computed by  v.surf.rst \n or  r.slope.aspect \n module. The data are automatically converted from feet to metric\n system using database/projection information, so the elevation always should be in meters. \n The water depth file can be computed using  r.sim.water \n module. Other parameters must be determined using field measurements or\n reference literature (see suggested values in Notes and References).  \n Output includes transport capacity raster map  transport_capacity   in [kg/ms],\n transport capacity limited erosion/deposition raster map\n  tlimit_erosion_deposition  [kg/m 2 s]i that are output almost immediately and\n can be viewed while the simulation continues. Sediment flow rate raster map \n  sediment_flux  [kg/ms], and net erosion/deposition raster map [kg/m 2 s]\n can take longer time depending on time step and simulation time. \n Simulation time is controlled by  niterations  [minutes] parameter. \n If the resulting erosion/deposition map is noisy, higher number of walkers,\n given by  nwalkers  should be used. \n ", "notes": "\n ", "see_also": [], "authors": [], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.sim/r.sim.sediment"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.shade.html", "name": "r.shade", "definition": "- Drapes a color raster over an shaded relief or aspect map.", "keywords": ["raster", "elevation", "relief", "hillshade", "visualization"], "synopsis": "r.shade [-c] shade=name color=name output=name  [brighten=integer]   [bgcolor=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Use colors from color tables for NULL values Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "shade", "flag": "shade", "dataType": "String", "optional": false, "explanation": "Name of shaded relief or aspect raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": false, "explanation": "Name of raster to drape over relief raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of shaded raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "brighten", "flag": "brighten", "dataType": "String", "optional": true, "explanation": "Percent to brighten", "defaultValue": "0", "alternatives": ["-99-99"], "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Color to use instead of NULL values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.shade  will drape a color raster map over a shaded relief map.\n In place of shaded relief, any raster map can be used including aspect or slope.\n The color raster map is usually an elevation raster map with colorful color\n table (as opposed to gray scale color table). However, any raster map can be\n used including categorical raster maps.\n The result is a raster map created from elevation and the shade raster.\n Comparing to creating shaded relief as semi-transparent overlay on\n the color raster map, this module gives result with more saturated colors.\n The input for this module can be created for example using\n  r.slope.aspect  or\n  r.relief .\n NULL values are propagated by default, so if any of the two input rasters\n contains NULL cell NULL will be also in the output. If  -c  flag is\n used and cell in  color  raster is NULL, just  shade \n color is used. If cell in  shade  raster is NULL, shading effect\n is not applied and original colors are used. If  bgcolor  option is\n used, NULL value in any input raster will be in the output replaced\n by the given color.\n ", "notes": "\n Refer to the  r.his  help page for more details;\n  r.shade  is a frontend to that module with addition of\n brightness support similar to one provided by\n  d.shade .\n However, note that the brightness is not implemenented in the same way as for\n  d.shade  and the results might\n be different.\n  r.shade  is using method described in  r.his \n manual page.\n  EXAMPLES \n In this example, the  aspect  map in the North Carolina sample\n dataset location is used to hillshade the  elevation  map:\n g.region raster=aspect -p\n r.shade shade=aspect color=elevation output=elevation_aspect_shaded\n d.mon wx0\n d.rast elevation_aspect_shaded\n In this next example, a shaded relief raster map is created\n and used to create a colorized hillshade\n raster map for later use:\n g.region raster=elevation\n r.relief input=elevation output=elevation_shaded_relief\n r.shade shade=elevation_shaded_relief color=elevation \n      output=elevation_relief_shaded\n d.mon wx1\n d.rast elevation_relief_shaded\n Interesting visualizations can be created using different color tables for\n elevation raster map, for example using  haxby  color table.\n  \n Figure: A detail of raster created by applying shading effect of shaded relief\n (hillshade) to elevation raster map from North Carolina dataset elevation map\n ", "see_also": ["r.his", "d.his", "d.shade", "g.pnmcomp", "r.slope.aspect", "r.relief", "d.shade", "r.his"], "authors": ["Hamish Bowman"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.shade"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.series.interp.html", "name": "r.series.interp", "definition": "- Interpolates raster maps located (temporal or spatial) in between input raster maps at specific sampling positions.", "keywords": ["raster", "series", "interpolation"], "synopsis": "r.series.interp  [input=name[,name,...]]   [datapos=float[,float,...]]   [infile=name]   [output=name[,name,...]]   [samplingpos=float[,float,...]]   [outfile=name]   [method=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "datapos", "flag": "datapos", "dataType": "String", "optional": true, "explanation": "Data point position for each input map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "infile", "flag": "infile", "dataType": "String", "optional": true, "explanation": "Input file with one input raster map name and data point position per line, field separator between name and sample point is |", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "samplingpos", "flag": "samplingpos", "dataType": "String", "optional": true, "explanation": "Sampling point position for each output map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "outfile", "flag": "outfile", "dataType": "String", "optional": true, "explanation": "Input file with one output raster map name and sample point position per line, field separator between name and sample point is |", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Interpolation method, currently only linear interpolation is supported", "defaultValue": "linear", "alternatives": ["linear"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.series.interp  \n interpolates new raster maps located temporal or spatial in between existing raster maps. \n The interpolation is performed at specific sampling positions. The sampling position for each output map must be specified,\n as well as the data position of the input maps. \n The following interpolation methods are supported.\n   \n   linear: Linear interpolation. At least two input maps and data positions are required. \n   \n  EXAMPLES \n Interpolate linear three new maps at 3 sampling positions in the interval (0.0;1.0)\n First prepare the input maps:\n g.region s=0 n=80 w=0 e=120 b=0 t=50 res=10 res3=10 -p3\n r.mapcalc expr=\"prec_1 = 100\"\n r.mapcalc expr=\"prec_5 = 500\"\n  Interpolate\n r.series.interp --v input=prec_1,prec_5 datapos=0.0,1.0 \n                    output=prec_2,prec_3,prec_4 samplingpos=0.25,0.5,0.75 \n                    method=linear\n  Interpolate using the file option. \n First prepare the input file:\n echo \"prec_2|0.25\n prec_3|0.5\n prec_4|0.75\" >> outfile.txt\n  Interpolate:\n r.series.interp --v input=prec_1,prec_5 datapos=0.0,1.0 file=outfile.txt method=linear\n The resulting maps will have the values 200, 300 and 400.\n ", "notes": "", "see_also": ["g.region", "r.series", "r.series.accumulate"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.series.interp"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.series.html", "name": "r.series", "definition": "- Makes each output cell value a function of the values assigned to the corresponding cells in the input raster map layers.", "keywords": ["raster", "aggregation", "series"], "synopsis": "r.series [-nz]  [input=name[,name,...]]   [file=name]  output=name[,name,...] method=string[,string,...]  [quantile=float[,float,...]]   [weights=float[,float,...]]   [range=lo,hi]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Propagate NULLs Do not keep files open Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Do not keep files open Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Input file with one raster map name and optional one weight per line, field separator between name and weight is |", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Aggregate operation", "defaultValue": null, "alternatives": ["average", "count", "median", "mode", "minimum", "min_raster", "maximum", "max_raster", "stddev", "range", "sum", "variance", "diversity", "slope", "offset", "detcoeff", "tvalue", "quart1", "quart3", "perc90", "quantile", "skewness", "kurtosis"], "isInputFile": false, "isOutputFile": false}, {"parameter": "quantile", "flag": "quantile", "dataType": "String", "optional": true, "explanation": "Quantile to calculate for method=quantile", "defaultValue": null, "alternatives": ["0.0-1.0"], "isInputFile": false, "isOutputFile": false}, {"parameter": "weights", "flag": "weights", "dataType": "String", "optional": true, "explanation": "Weighting factor for each input map, default value is 1.0 for each input map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "range", "flag": "range", "dataType": "String", "optional": true, "explanation": "Ignore values outside this range", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.series  makes each output cell value a function of the values\n assigned to the corresponding cells in the input raster map layers.\n Following methods are available:\n   \n   average: average value\n   count: count of non-NULL cells\n   median: median value\n   mode: most frequently occurring value\n   minimum: lowest value\n   maximum: highest value\n   range: range of values (max - min)\n   stddev: standard deviation\n   sum: sum of values\n   variance: statistical variance\n   diversity: number of different values\n   slope: linear regression slope\n   offset: linear regression offset\n   detcoeff: linear regression coefficient of determination\n   tvalue: linear regression t-value\n   min_raster: raster map number with the minimum time-series value\n   max_raster: raster map number with the maximum time-series value\n   \n Note that most parameters accept multiple answers, allowing multiple\n aggregates to be computed in a single run, e.g.:\n r.series input=map1,...,mapN \n           output=map.mean,map.stddev \n  \t method=average,stddev\n \t\n or:\n r.series input=map1,...,mapN \n           output=map.p10,map.p50,map.p90 \n           method=quantile,quantile,quantile \n           quantile=0.1,0.5,0.9\n The same number of values must be provided for all options.\n ", "notes": "\n  No-data (NULL) handling \n With  -n  flag, any cell for which any of the corresponding \n input cells are NULL is automatically set to NULL (NULL propagation). \n The aggregate function is not called, so all methods behave this way \n with respect to the  -n  flag.\n Without  -n  flag, the complete list of inputs for each cell \n (including NULLs) is passed to the aggregate function. Individual aggregates can handle data as they choose. Mostly, they just compute \n the aggregate over the non-NULL values, producing a NULL result only if \n all inputs are NULL.\n  Minimum and maximum analysis \n The  min_raster  and  max_raster  methods generate a map \n with the number of the raster map that holds the minimum/maximum value \n of the time-series. The numbering starts at  0  up to  n  \n for the first and the last raster listed in  input= , \n respectively. \n  Range analysis \n If the  range=  option is given, any values which fall outside \n that range will be treated as if they were NULL. The  range  \n parameter can be set to  low,high  thresholds: values outside of \n this range are treated as NULL (i.e., they will be ignored by most \n aggregates, or will cause the result to be NULL if -n is given). The \n  low,high  thresholds are floating point, so use  -inf  \n or  inf  for a single threshold (e.g.,  range=0,inf  to \n ignore negative values, or  range=-inf,-200.4  to ignore values \n above -200.4).\n  Linear regression \n Linear regression (slope, offset, coefficient of determination, \n t-value) assumes equal time intervals. If the data have irregular time \n intervals, NULL raster maps can be inserted into time series to make \n time intervals equal (see example).\n  Quantiles \n  r.series  can calculate arbitrary quantiles.\n  Memory consumption \n Memory usage is not an issue, as  r.series  only needs to hold\n one row from each map at a time.\n  Management of open file limits \n The maximum number of raster maps that can be processed is given by the \n user-specific limit of the operating system. For example, the soft limits \n for users are typically 1024 files. The soft limit can be changed with e.g. \n  ulimit -n 4096  (UNIX-based operating systems) but it cannot be \n higher than the hard limit. If the latter is too low, you can as superuser\n add an entry in:\n /etc/security/limits.conf\n # <domain>      <type>  <item>         <value>\n your_username  hard    nofile          4096\n This will raise the hard limit to 4096 files. Also have a look at the \n overall limit of the operating system\n cat /proc/sys/fs/file-max\n which on modern Linux systems is several 100,000 files.\n For each map a weighting factor can be specified using the \n  weights  option. Using weights can be meaningful when computing \n the sum or average of maps with different temporal extent. The default \n weight is 1.0. The number of weights must be identical to the number \n of input maps and must have the same order. Weights can also be \n specified in the input file.\n Use the  -z  flag to analyze large amounts of raster maps without\n hitting open files limit and the  file  option to avoid hitting\n the size limit of command line arguments.\n Note that the computation using the  file  option is slower\n than with the  input  option.\n For every single row in the output map(s) all input maps are \n opened and closed. The amount of RAM will rise linearly with the number \n of specified input maps. The  input  and  file  options are\n mutually exclusive: the former is a comma separated list of raster map\n names and the latter is a text file with a new line separated list of\n raster map names and optional weights. As separator between the map name\n and the weight the character \"|\" must be used.\n  EXAMPLES \n Using  r.series  with wildcards:\n r.series input=\"`g.list pattern='insitu_data.*' sep=,`\" \n           output=insitu_data.stddev method=stddev\n Note the  g.list  script also supports regular expressions for\n selecting map names.\n Using  r.series  with NULL raster maps (in order to consider a\n \"complete\" time series):\n r.mapcalc \"dummy = null()\"\n r.series in=map2001,map2002,dummy,dummy,map2005,map2006,dummy,map2008 \n           out=res_slope,res_offset,res_coeff meth=slope,offset,detcoeff\n  Example for multiple aggregates to be computed in one run (3 resulting aggregates\n from two input maps):\n r.series in=one,two out=result_avg,res_slope,result_count meth=sum,slope,count\n  Example to use the file option of r.series:\n cat > input.txt << EOF\n map1\n map2\n map3\n EOF\n r.series file=input.txt out=result_sum meth=sum\n Example to use the file option of r.series including weights. The \n weight 0.75 should be assigned to map2. As the other maps do not have \n weights we can leave it out:\n cat > input.txt << EOF\n map1\n map2|0.75\n map3\n EOF\n r.series file=input.txt out=result_sum meth=sum\n Example for counting the number of days above a certain temperature using \n daily average maps ('???' as DOY wildcard):\n # Approach for shell based systems\n r.series input=`g.list rast pattern=\"temp_2003_???_avg\" sep=,` \n           output=temp_2003_days_over_25deg range=25.0,100.0 method=count\n # Approach in two steps (e.g., for Windows systems)\n g.list rast pattern=\"temp_2003_???_avg\" output=mapnames.txt\n r.series file=mapnames.txt \n           output=temp_2003_days_over_25deg range=25.0,100.0 method=count\n ", "see_also": ["g.list", "g.region", "r.quantile", "r.series.accumulate", "r.series.interp", "r.univar"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.series"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.series.accumulate.html", "name": "r.series.accumulate", "definition": "- Makes each output cell value a accumulationfunction of the values assigned to the corresponding cells in the input raster map layers.", "keywords": ["raster", "series", "accumulation"], "synopsis": "r.series.accumulate [-nzf]  [basemap=name]   [input=name[,name,...]]   [file=name]  output=name  [scale=float]   [shift=float]   [lower=name]   [upper=name]   [range=min,max]   [limits=lower,upper]   [method=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Propagate NULLs Do not keep files open Create a FCELL map (floating point single precision) as output Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Do not keep files open Create a FCELL map (floating point single precision) as output Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Create a FCELL map (floating point single precision) as output Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "basemap", "flag": "basemap", "dataType": "String", "optional": true, "explanation": "Existing map to be added to output", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Input file with raster map names, one per line", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Scale factor for input", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "shift", "flag": "shift", "dataType": "String", "optional": true, "explanation": "Shift factor for input", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lower", "flag": "lower", "dataType": "String", "optional": true, "explanation": "The raster map specifying the lower accumulation limit, also called baseline", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "upper", "flag": "upper", "dataType": "String", "optional": true, "explanation": "The raster map specifying the upper accumulation limit, also called cutoff. Only applied to BEDD computation.", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "range", "flag": "range", "dataType": "String", "optional": true, "explanation": "Ignore values outside this range", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "limits", "flag": "limits", "dataType": "String", "optional": true, "explanation": "Use these limits in case lower and/or upper input maps are not defined", "defaultValue": "10,30", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "This method will be applied to compute the accumulative values from the input maps", "defaultValue": "gdd", "alternatives": ["gdd", "bedd", "huglin", "mean"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.series.accumulate  calculates (accumulated) raster value \n using growing degree days (GDDs)/Winkler indices's, Biologically \n Effective Degree Days (BEDD), Huglin heliothermal indices or an average \n approach from several input maps for a given day. Accumulation of e.g. \n degree-days to growing degree days (GDDs) can be done by providing a \n  basemap  with GDDs of the previous day.\n The flag  -a  determines the average computation of the input raster maps. \n In case the flag is not set, the average calculation is:\n  average = (min + max) / 2\n In case the flag was set, the calculation changes to arithmetic mean\n     average = sum(input maps) / (number of input maps)\n  GDD  Growing Degree Days are calculated as\n     gdd = average - lower\n In case the  -a  is set, the Winkler indices are calculated instead\n of GDD, usually accumulated for the period April 1 st  to October \n 31 st  (northern hemisphere) or the period October \n 1 st  to April 30 th  \n (southern hemisphere).\n  BEDDs  Biologically Effective Degree Days are calculated as\n     bedd = average - lower\n with an optional upper  cutoff  applied to the average instead of \n the temperature values.\n The  Huglin heliothermal index  is calculated as\n     huglin = (average + max) / 2 - lower\n usually accumulated for the period April 1 st  to September \n 30 th  (northern hemisphere) or the period September \n 1 st  to April 30 th  (southern hemisphere).\n  Mean  raster values are calculated as\n     mean = average\n For all the formulas  min  is the minimum value,  max \n the maximum value and  average  the average value.\n The  min ,  max  and  average  values\n are automatically calculated from the input maps.\n The  shift  and  scale  values are applied directly to \n the input values. The  lower  and  upper  maps, as well \n as the  range  options are applied to constrain the \n accumulation. In case the  lower  and  upper  maps are \n not provided the  limits  option with default values will be \n applied.\n If an existing map is provided with the  basemap  option, the\n values of this map are added to the output.\n ", "notes": "\n The  scale  and  shift  parameters are used to transform \n input values with\n     new = old * scale + shift\n With the  -n  flag, any cell for which any of the \n corresponding input cells are NULL is automatically set to NULL \n (NULL propagation) and the accumulated value is not calculated.\n Negative results are set to 0 (zero). \n Without the  -n  flag, all non-NULL cells are used for calculation.\n If the  range=  option is given, any values which fall outside \n that range will be treated as if they were NULL. Note that the range is \n applied to the scaled and shifted input data. The  range  \n parameter can be set to  low,high  thresholds: \n values outside of this range are treated as NULL (i.e., they will be \n ignored by most aggregates, or will cause the result to be NULL if -n \n is given). The  low,high  thresholds are floating point, so use \n  -inf  or  inf  for a single threshold (e.g., \n  range=0,inf  to ignore negative values, or \n  range=-inf,-200.4  to ignore values above -200.4).\n The maximum number of raster maps that can be processed is given by the \n user-specific limit of the operating system. For example, the soft limits \n for users are typically 1024 files. The soft limit can be changed with e.g. \n  ulimit -n 4096  (UNIX-based operating systems) but it cannot be \n higher than the hard limit. If the latter is too low, you can as superuser\n add an entry in:\n /etc/security/limits.conf\n # <domain>      <type>  <item>         <value>\n your_username  hard    nofile          4096\n This will raise the hard limit to 4096 files. Also have a look at the \n overall limit of the operating system\n cat /proc/sys/fs/file-max\n which on modern Linux systems is several 100,000 files.\n Use the  -z  flag to analyze large amounts of raster maps without\n hitting open files limit and the  file  option to avoid hitting\n the size limit of command line arguments.\n Note that the computation using the  file  option is slower\n than with the  input  option.\n For every single row in the output map(s) all input maps are \n opened and closed. The amount of RAM will rise linearly with the number \n of specified input maps. The  input  and  file  options are\n mutually exclusive: the former is a comma separated list of raster map\n names and the latter is a text file with a new line separated list of\n raster map names.\n  EXAMPLES \n Example with MODIS Land Surface Temperature, transforming values from \n Kelvin * 50 to degrees Celsius:\n r.series.accumulate in=MOD11A1.Day,MOD11A1.Night,MYD11A1.Day,MYD11A1.Night out=MCD11A1.GDD \n        scale=0.02 shift=-273.15 limits=10,30\n ", "see_also": ["g.list", "g.region", "r.series", "r.series.interp"], "authors": ["Markus Metz and Soeren Gebbert (based on r.series)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.series.accumulate"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.ros.html", "name": "r.ros", "definition": "- Generates rate of spread raster maps.", "keywords": ["raster", "fire", "spread", "rate of spread", "hazard", "model"], "synopsis": "r.ros model=name  [moisture_1h=name]   [moisture_10h=name]   [moisture_100h=name]  moisture_live=name  [velocity=name]   [direction=name]   [slope=name]   [aspect=name]   [elevation=name]  base_ros=name max_ros=name direction_ros=name  [spotting_distance=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "model", "flag": "model", "dataType": "String", "optional": false, "explanation": "Raster map containing fuel models", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "moisture_1h", "flag": "moisture_1h", "dataType": "String", "optional": true, "explanation": "Raster map containing the 1-hour fuel moisture (%)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "moisture_10h", "flag": "moisture_10h", "dataType": "String", "optional": true, "explanation": "Raster map containing the 10-hour fuel moisture (%)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "moisture_100h", "flag": "moisture_100h", "dataType": "String", "optional": true, "explanation": "Raster map containing the 100-hour fuel moisture (%)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "moisture_live", "flag": "moisture_live", "dataType": "String", "optional": false, "explanation": "Raster map containing live fuel moisture (%)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "velocity", "flag": "velocity", "dataType": "String", "optional": true, "explanation": "Raster map containing midflame wind velocities (ft/min)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "direction", "flag": "direction", "dataType": "String", "optional": true, "explanation": "Name of raster map containing wind directions (degree)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "slope", "flag": "slope", "dataType": "String", "optional": true, "explanation": "Name of raster map containing slope (degree)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "aspect", "flag": "aspect", "dataType": "String", "optional": true, "explanation": "Raster map containing aspect (degree, CCW from E)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Raster map containing elevation (m, required for spotting)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "base_ros", "flag": "base_ros", "dataType": "String", "optional": false, "explanation": "Output raster map containing base ROS (cm/min)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max_ros", "flag": "max_ros", "dataType": "String", "optional": false, "explanation": "Output raster map containing maximal ROS (cm/min)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "direction_ros", "flag": "direction_ros", "dataType": "String", "optional": false, "explanation": "Output raster map containing directions of maximal ROS (degree)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "spotting_distance", "flag": "spotting_distance", "dataType": "String", "optional": true, "explanation": "Output raster map containing maximal spotting distance (m)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.ros  is part of the wildfire simulation toolset. Preparational\n steps for the fire simulation are the calculation of the rate of spread (ROS)\n with  r.ros , and the creating of spread map with  r.spread .\n Eventually, the fire path(s) based on starting point(s) are calculated\n with  r.spreadpath .\n  r.ros  is used for fire (wildfire) modeling. The input is fuel model\n and moisture and the outputs are rate of spread (ROS) values.\n The module generates the base ROS value, maximum ROS value,\n direction of the maximum ROS, and optionally the maximum potential spotting distance of wildfire for each raster cell in the current geographic region.\n These three or four raster map layers\n serve as inputs for the  r.spread  module\n which is the next step in fire simulation.\n The  r.ros  module and two related modules\n  r.spread ,\n and  r.spreadpath  can be used\n not only for wildfire modeling but also generally\n to simulate other events where spread of something is involved and\n elliptical spread is appropriate.\n The calculation of the two ROS values for each raster cell is based on the\n Fortran code by Pat Andrews (1983) of the Northern Forest Fire Laboratory,\n USDA Forest Service. The direction of the maximum ROS results from the\n vector addition of the forward ROS in wind direction and that in upslope\n direction. The spotting distance, if required, will be calculated by a\n separate function, spot_dist(), which is based on Lathrop and Xu (in preparation),\n Chase (1984) and Rothermel (1991).  More information\n on  r.ros  and  r.spread  can be found in Xu (1994).\n The  output  parameter is a basename (prefix) for all generated\n raster maps and each map gets a unique suffix:\n    .base  for the base (perpendicular) ROS (cm/minute)\n    .max  for the maximum (forward) ROS (cm/minute),\n    .maxdir  for the direction of the maximum\n     ROS, clockwise from north (degree), and optionally\n    .spotdist  for the maximum potential\n     spotting distance (meters).\n So, if the output parameter is  blackforest_ros ,  r.ros  creates\n  blackforest_ros.base ,  blackforest_ros.max ,\n  blackforest_ros.maxdir ,\n and (optionally)  blackforest_ros.spotdist  raster maps.\n  If only one or two of the options  moisture_1h ,  moisture_10h ,\n and  moisture_100h  are given, the module will assign\n values to the missing option using the formula:\n moisture_100h = moisture_10h + 1 = moisture_1h + 2\n However, at least one of them should be given.\n Options  velocity \n and  direction  must be both given or both omitted.\n If none is given, the module will assume a no-wind\n condition.\n Options  slope  and  aspect  must be also given together.\n If none is given, the module will assume a\n topographically flat condition. Option\n  elevation  must be given if  -s  (spotting) flag is used.\n  EXAMPLES \n Assume we have inputs, the following generates ROSes and spotting distances:\n r.ros -s model=fire_model moisture_1h=1hour_moisture moisture_live=live_moisture \n      velocity=wind_speed direction=wind_direction \n      slope=slope aspect=aspect elevation=elevation output=ros\n ", "notes": "\n    r.ros  is supposed to be run before running\n      r.spread  module.\n     The combination of these two modules forms\n     a simulation of the spread of wildfires.\n    The user should be sure that the inputs to\n      r.ros  are in proper units.\n    The output units for the base and maximum ROSes are in cm/minute\n     rather than ft/minute, which is due to that a possible zero ft/minute base\n     ROS value and a positive integer ft/minute maximum ROS would result in\n     calculation failure in the\n      r.spread  module.\n      \n     As far as the user just use  r.ros  together with\n      r.spread , there is no need to\n     concern about these output units.\n  REFERENCES \n    Albini,  F. A., 1976, Computer-based models of wildland fire behavior:\n     a user's manual, USDA Forest Service, Intermountain Forest and Range Experiment\n     Station, Ogden, Utah. \n    Andrews , P. L., 1986, BEHAVE: fire behavior prediction and fuel\n     modeling system -- BURN subsystem, Part 1, USDA Forest Service, Intermountain\n     Research Station, Gen. Tech. Rep. INT-194, Ogden, Utah. \n    Chase , Carolyn, H., 1984, Spotting distance from wind-driven\n     surface fires -- extensions of equations for pocket calculators, US Forest\n     Service, Res. Note INT-346, Ogden, Utah. \n    Lathrop , Richard G. and Jianping Xu, A geographic information\n     system-based approach for calculating spotting distance. (in preparation) \n    Rothermel , R. E., 1972, A mathematical model for predicting\n     fire spread in wildland fuels, USDA Forest Service, Intermountain Forest\n     and Range Experiment Station, Res. Pap. INT-115, Ogden, Utah. \n    Rothermel , Richard, 1991, Predicting behavior and size of crown\n     fires in the northern Rocky Mountains, US Forest Service, Res. Paper INT-438,\n     Ogden, Utah. \n    Xu , Jianping, 1994, Simulating the spread of wildfires using\n     a geographic information system and remote sensing, Ph. D. Dissertation,\n     Rutgers University, New Brunswick, Jersey\n     ( ref ). \n ", "see_also": ["g.region", "r.slope.aspect", "r.spread", "r.spreadpath"], "authors": [], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.ros"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.rgb.html", "name": "r.rgb", "definition": "- Splits a raster map into red, green and blue maps.", "keywords": ["raster", "RGB", "separate", "split"], "synopsis": "r.rgb input=name  [red=name]   [green=name]   [blue=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "red", "flag": "red", "dataType": "String", "optional": true, "explanation": "Red channel raster map name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "green", "flag": "green", "dataType": "String", "optional": true, "explanation": "Green channel raster map name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "blue", "flag": "blue", "dataType": "String", "optional": true, "explanation": "Blue channel raster map name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.rgb  generates separate red, green and blue maps from a\n raster map and its associated color table (grey255).\n  EXAMPLE \n g.region raster=elevation -p\n r.rgb input=elevation red=elevation.r green=elevation.g blue=elevation.b\n In this case  r.rgb  produces in the current mapset three new\n raster maps - 'elevation.r', 'elevation.g', 'elevation.b'.\n ", "notes": "", "see_also": ["r.composite", "r.blend", "r.colors", "r.mapcalc"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.rgb"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.rescale.html", "name": "r.rescale", "definition": "- Rescales the range of category values in a raster map layer.", "keywords": ["raster", "rescale"], "synopsis": "r.rescale input=name  [from=min,max]  output=name to=min,max  [title=phrase]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "The name of the raster map to be rescaled", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "from", "flag": "from", "dataType": "String", "optional": true, "explanation": "The input data range to be rescaled (default: full range of input map)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "The resulting raster map name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "to", "flag": "to", "dataType": "String", "optional": false, "explanation": "The output data range", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for new raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  r.rescale  program rescales the range of\n category values appearing in a raster map layer. A new\n raster map layer, and an appropriate category file and\n color table based upon the original raster map layer, are\n generated with category labels that reflect the original\n category values that produced each category.  This command\n is useful for producing representations with a reduced\n number of categories from a raster map layer with a large\n range of category values (e.g., elevation).\n  Rescaled  map layers are appropriate for use in\n such GRASS GIS commands as\n  r.stats ,\n  r.report , and \n  r.coin .\n  EXAMPLE \n To rescale an elevation raster map layer with category\n values ranging from 1090 meters to 1800 meters into the\n range 0-255, the following command line could be used\n (without the  from  parameter, the full value range will\n be used):\n r.rescale input=elevation from=1090,1800 output=elevation.255 to=0,255\n ", "notes": "\n Category values that fall beyond the input range will\n become NULL.  This allows the user to select a subset of\n the full category value range for rescaling if desired.\n This also means that the user should know the category\n value range for the input raster map layer.  The user can\n request the  r.rescale  program to determine\n this range, or can obtain it using the\n  r.describe  or  r.info  \n command.  If the category value range is determined using\n  r.rescale , the input raster map layer is examined,\n and the minimum and maximum non-NULL category values are\n selected as the input range.\n ", "see_also": ["r.coin", "r.describe", "r.info", "r.mapcalc", "r.reclass", "r.rescale.eq", "r.report", "r.resample", "r.stats", "r.univar"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.rescale"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.rescale.eq.html", "name": "r.rescale.eq", "definition": "- Rescales histogram equalized the range of category values in a raster map layer.", "keywords": ["raster", "rescale"], "synopsis": "r.rescale.eq input=name  [from=min,max]  output=name to=min,max  [title=phrase]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "The name of the raster map to be rescaled", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "from", "flag": "from", "dataType": "String", "optional": true, "explanation": "The input data range to be rescaled (default: full range of input map)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "The resulting raster map name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "to", "flag": "to", "dataType": "String", "optional": false, "explanation": "The output data range", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for new raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  r.rescale.eq  program rescales the range of\n category values appearing in a raster map layer with equalized histogram. \n A new raster map layer, and an appropriate category file and\n color table based upon the original raster map layer, are\n generated with category labels that reflect the original\n category values that produced each category.  This command\n is useful for producing representations with a reduced\n number of categories from a raster map layer with a large\n range of category values (e.g., elevation).\n  Rescaled  map layers are appropriate for use in\n such GRASS GIS commands as\n  r.stats ,\n  r.report , and \n  r.coin .\n  EXAMPLE \n To rescale an elevation raster map layer with category\n values ranging from 1090 meters to 1800 meters into the\n range 0-255, the following command line could be used\n (without the  from  parameter, the full value range will\n be used):\n r.rescale.eq input=elevation from=1090,1800 output=elevation.255 to=0,255\n ", "notes": "\n Category values that fall beyond the input range will\n become NULL.  This allows the user to select a subset of\n the full category value range for rescaling if desired.\n This also means that the user should know the category\n value range for the input raster map layer.  The user can\n request the  r.rescale.eq  program to determine\n this range, or can obtain it using the\n  r.describe  or\n  r.info \n command.  If the category value range is determined using\n  r.rescale.eq , the input raster map layer is examined,\n and the minimum and maximum non-NULL category values are\n selected as the input range.\n ", "see_also": ["r.coin", "r.describe", "r.info", "r.mapcalc", "r.reclass", "r.rescale", "r.report", "r.resample", "r.stats"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.rescale.eq"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.resample.html", "name": "r.resample", "definition": "- GRASS raster map layer data resampling capability.", "keywords": ["raster", "resample"], "synopsis": "r.resample input=string output=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of an input layer", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of an output layer", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.resample  resamples the data values in a user-specified raster\n input map layer  name  (bounded by the current geographic region\n and masked by the current mask), and produces a new raster output map layer\n  name  containing the results of the resampling.\n The category values in the new raster output map layer will be the same\n as those in the original, except that the resolution and extent of the\n new raster output map layer will match those of the current geographic region\n settings (see  g.region ).\n  r.resample  is intended for resampling of discrete raster data\n (such as land cover, geology or soil type) to a different resolution.\n Continuous data (such as elevation or temperature) usually require reinterpolation\n when changing resolution, see  r.resamp.interp .\n ", "notes": "\n The method by which resampling is conducted is \"nearest neighbor\"\n (see  r.neighbors ).  \n The resulting raster map layer will have the same\n resolution as the resolution of the current geographic region\n (set using  g.region ).\n  The resulting raster map layer may be identical to the original raster\n map layer.  The  r.resample  program will copy the color table\n and history file associated with the original raster map\n layer for the resulting raster map layer and will create a modified\n category file which contains description of only those categories\n which appear in resampled file.\n When the user resamples a GRASS  reclass  file, a true raster map\n is created by  r.resample .\n ", "see_also": ["g.region", "r.mapcalc", "r.mfilter", "r.neighbors", "r.rescale", "r.resamp.interp"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.resample"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.resamp.stats.html", "name": "r.resamp.stats", "definition": "- Resamples raster map layers to a coarser grid using aggregation.", "keywords": ["raster", "resample"], "synopsis": "r.resamp.stats [-nw] input=name output=name  [method=string]   [quantile=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Propagate NULLs Weight according to area (slower) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Weight according to area (slower) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Aggregation method", "defaultValue": "average", "alternatives": ["average", "median", "mode", "minimum", "maximum", "range", "quart1", "quart3", "perc90", "sum", "variance", "stddev", "quantile", "count", "diversity"], "isInputFile": false, "isOutputFile": false}, {"parameter": "quantile", "flag": "quantile", "dataType": "String", "optional": true, "explanation": "Quantile to calculate for method=quantile", "defaultValue": "0.5", "alternatives": ["0.0-1.0"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.resamp.stats  fills a grid cell (raster) matrix with\n aggregated values generated from a set of input layer data points.\n  Without the  -w  switch, the aggregate is computed over all of\n the input cells whose centers lie within the output cell.\n  With the  -w  switch, the aggregate uses the values from all\n input cells which intersect the output cell, weighted according to the\n proportion of the source cell which lies inside the output cell. This\n is slower, but produces a more accurate result.\n ", "notes": "\n  Resampling modules ( r.resample, r.resamp.stats, r.resamp.interp,\n r.resamp.rst ) resample the map to match the current region settings.\n  The notion of weighting doesn't make any sense for the min and max\n aggregates. However, the  -w  flag still has significance in\n that, when multiple destination cells overlap a source cell, the\n source cell is included in the calculation of all of the destination\n cells.\n  EXAMPLE \n  Resample elevation raster map to a lower resolution (from 6m to 20m;\n North Carolina sample dataset):\n g.region raster=el_D782_6m -p\n g.region res=20 -ap\n # from 6m to 20m: weighted resampling -w\n r.resamp.stats -w input=el_D782_6m output=el_D782_20m\n  \n  Resampling of 6m DEM (left) to 20m DEM (right) with weighted resampling (subset) \n ", "see_also": ["g.region", "r.resample", "r.resamp.rst", "r.resamp.filter", "r.resamp.interp", "r.neighbors"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.resamp.stats"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.resamp.rst.html", "name": "r.resamp.rst", "definition": "- Reinterpolates and optionally computes topographic analysis from input raster map to a new raster map (possibly with different resolution) using regularized spline with tension and smoothing.", "keywords": ["raster", "resample"], "synopsis": "r.resamp.rst [-td] input=name ew_res=float ns_res=float  [elevation=name]   [slope=name]   [aspect=name]   [pcurvature=name]   [tcurvature=name]   [mcurvature=name]   [smooth=name]   [maskmap=name]   [overlap=integer]   [zscale=float]   [tension=float]   [theta=float]   [scalex=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Use dnorm independent tension Output partial derivatives instead of topographic parameters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Output partial derivatives instead of topographic parameters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "ew_res", "flag": "ew_res", "dataType": "String", "optional": false, "explanation": "Desired east-west resolution", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ns_res", "flag": "ns_res", "dataType": "String", "optional": false, "explanation": "Desired north-south resolution", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Name for output elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "slope", "flag": "slope", "dataType": "String", "optional": true, "explanation": "Name for output slope map (or fx)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "aspect", "flag": "aspect", "dataType": "String", "optional": true, "explanation": "Name for output aspect map (or fy)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "pcurvature", "flag": "pcurvature", "dataType": "String", "optional": true, "explanation": "Name for output profile curvature map (or fxx)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "tcurvature", "flag": "tcurvature", "dataType": "String", "optional": true, "explanation": "Name for output tangential curvature map (or fyy)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "mcurvature", "flag": "mcurvature", "dataType": "String", "optional": true, "explanation": "Name for output mean curvature map (or fxy)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "smooth", "flag": "smooth", "dataType": "String", "optional": true, "explanation": "Name of input raster map containing smoothing", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "maskmap", "flag": "maskmap", "dataType": "String", "optional": true, "explanation": "Name of input raster map to be used as mask", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "overlap", "flag": "overlap", "dataType": "String", "optional": true, "explanation": "Rows/columns overlap for segmentation", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Multiplier for z-values", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tension", "flag": "tension", "dataType": "String", "optional": true, "explanation": "Spline tension value", "defaultValue": "40.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "theta", "flag": "theta", "dataType": "String", "optional": true, "explanation": "Anisotropy angle (in degrees counterclockwise from East)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "scalex", "flag": "scalex", "dataType": "String", "optional": true, "explanation": "Anisotropy scaling factor", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.resamp.rst  reinterpolates the values a from given raster map (named\n  input ) to a new raster map (named  elev ). \n This module is intended for reinterpolation of continuous data\n to a different resolution rather than for interpolation from scattered data\n (use the  v.surf.*  modules for that purpose).\n The extent of all resulting raster maps is taken from the settings of the\n actual computational region (which may differ from the extent of the input\n raster map). The resolution of the computational region however has to be\n aligned to the resolution of the input map to avoid artefacts.\n Reinterpolation (resampling) is done to higher, same or lower resolution \n specified by the  ew_res  and  ns_res  parameters.\n  All resulting raster maps are created using the settings of the current\n region (which may be different from that of the  input  raster map).\n  Optionally, and simultaneously with interpolation, topographic parameters\n are computed from an input raster map containing z-values of elevation/depth: slope, \n aspect, profile curvature (measured in the direction of steepest\n slope), tangential curvature (measured in the direction of a tangent to\n contour line) and/or mean curvature are computed from and saved as raster maps\n as specified by the options  slope, aspect, pcurv, tcurv, mcurv  respectively.\n  If the  -d  flag is set the program outputs partial derivatives fx, fy, \n fxx, fxy, and fyy instead of slope, aspect and curvatures.\n  For noisy data it is possible to define spatially variable smoothing\n by providing a raster map named by the  smooth  option containing \n smoothing parameters.\n With the smoothing parameter set to zero ( smooth  is not given or\n contains zero data), the resulting surface passes exactly through the data\n points.\n  The user can also define a raster map (named with  maskmap ) which will\n be used as a mask. The interpolation is skipped for cells which have zero\n or NULL value in the mask.\n  Zero values will be assigned to these cells in all output raster maps.\n  The  zmult  parameter allows the user to rescale the z-values which may \n be useful, e.g., for transformation of elevations given in feet to meters,\n so that the proper values of slopes and curvatures can be computed.\n The default value is 1.\n  A regularized spline with tension method is used for the interpolation.\n The  tension  parameter tunes the character of the resulting surface \n from thin plate to membrane. Higher values of tension parameter reduce the \n overshoots that can appear in surfaces with rapid change of gradient. \n  The  -t  flag can be set to use \"dnorm independent tension\".\n  The interpolation is performed for overlapping rectangular segments. \n The user can define the width of overlap (in number of cells) with\n the  overlap  option. The default value is 3.\n ", "notes": "\n  r.resamp.rst  uses regularized spline with tension for interpolation\n (as described in Mitasova and Mitas, 1993). \n  The region is temporarily changed while writing output files with desired \n resolution. Topographic parameters are computed in the same way as in \n the  v.surf.rst  module. (See also Mitasova and Hofierka, 1993)\n  The raster map used with the  smooth  option should contain variable \n smoothing parameters. These can be derived from errors, slope, etc. using\n the  r.mapcalc  module.\n  The program gives warning when significant overshoots appear and higher\n tension should be used. However, with tension set too high the resulting surface\n changes its behavior to a membrane (rubber sheet stretched over the data\n points resulting in a peak or pit in each given point and everywhere else\n the surface goes rapidly to trend). Smoothing can be used to reduce\n the overshoots. When overshoots occur the resulting  elev  file will\n have white color in the locations of overshoots since the color table for\n the output file is the same as colortable for raster input file.\n  The program checks the numerical stability of the algorithm by computation \n of values at given points, and prints the maximum difference found into the \n history file of raster map  elev  (view with  r.info ). \n An increase in tension is suggested if the difference is unacceptable.\n For computations with smoothing set to 0 this difference should be 0.\n With a smoothing parameter greater than zero the surface will not pass through \n the data points exactly, and the higher the parameter the closer the surface \n will be to the trend.\n  The program writes the values of parameters used in computation into\n the comment part of the  elev  map history file. Additionally the \n following values are also written to assist in the evaluation of results \n and choosing of suitable parameters:\n  minimum and maximum z values in the data file (zmin_data, zmax_data) and\n in the interpolated raster map (zmin_int, zmax_int), \n  maximum difference between the given and interpolated z value at a given \n point (errtotal), \n  rescaling parameter used for normalization (dnorm), which influences the\n tension. \n  The program gives a warning when the user wants to interpolate outside\n the region given by the  input  raster map's header data. Zooming into the\n area where the points are is suggested in this case.\n  When a mask is used, the program uses all points in the given region for \n interpolation, including those in the area which is masked out, to ensure \n proper interpolation along the border of the mask. It therefore does not \n mask out the data points; if this is desirable, it must be done outside \n  r.resamp.rst  before processing.\n  EXAMPLE \n Resampling the Spearfish 30m resolution elevation model to 15m:\n # set computation region to original map (30m)\n g.region raster=elevation.dem -p\n # resample to 15m\n r.resamp.rst input=elevation.dem ew_res=15 ns_res=15 elevation=elev15\n # set computation region to resulting map\n g.region raster=elev15 -p\n # verify\n r.univar elev15 -g\n ", "see_also": [], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.resamp.rst"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.resamp.interp.html", "name": "r.resamp.interp", "definition": "- Resamples raster map to a finer grid using interpolation.", "keywords": ["raster", "resample", "interpolation"], "synopsis": "r.resamp.interp input=name output=name  [method=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Sampling interpolation method", "defaultValue": "bilinear", "alternatives": ["nearest", "bilinear", "bicubic", "lanczos"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.resamp.interp  resamples an input raster map by interpolating between\n the neighboring cells via a selectable resampling algorithm. All cells\n present in the neighborhood of the input raster cell must be non-null to\n generate a non-null cell in the output raster map. A choice of four\n interpolation methods is available; each uses the weighted values of a different\n number of adjacent cells in the input map to determine the value of each\n cell in the output map as follows:\n  nearest neighbour (1 cell) \n  bilinear (4 cells) \n  bicubic (16 cells) \n  lanczos (25 cells) \n  This module is intended for reinterpolation of continuous data\n to a different resolution rather than for interpolation from scattered data\n (use the  v.surf.*  modules for that purpose).\n ", "notes": "\n  Resampling modules ( r.resample, r.resamp.stats, r.resamp.interp,\n r.resamp.rst ) resample the map to match the current region settings.\n  Note that for bilinear, bicubic and lanczos interpolation,\n cells of the output raster that cannot be bounded by the appropriate number\n of input cell centers are set to NULL (NULL propagation). This could occur\n due to the input cells being outside the current region, being NULL or MASKed.\n  For longitude-latitude locations, the interpolation algorithm is based on\n degree fractions, not on the absolute distances between cell centers.  Any\n attempt to implement the latter would violate the integrity of the\n interpolation method.\n  EXAMPLE \n Resample elevation raster map to a higher resolution (from 500m to 250m;\n North Carolina sample dataset):\n g.region raster=elev_state_500m -p\n g.region res=250 -ap\n r.resamp.interp input=elev_state_500m output=elev_state_250m \n                  method=bilinear\n Original 500m resolution elevation map\n Resampled (bilinear) 250m resolution elevation map\n ", "see_also": ["g.region", "r.resample", "r.resamp.filter", "r.resamp.rst", "r.resamp.stats"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.resamp.interp"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.resamp.filter.html", "name": "r.resamp.filter", "definition": "- Resamples raster map layers using an analytic kernel.", "keywords": ["raster", "resample", "kernel filter", "filter"], "synopsis": "r.resamp.filter [-n] input=name output=name filter=string[,string,...]  [radius=float[,float,...]]   [x_radius=float[,float,...]]   [y_radius=float[,float,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Propagate NULLs Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "filter", "flag": "filter", "dataType": "String", "optional": false, "explanation": "Filter kernel(s)", "defaultValue": null, "alternatives": ["box", "bartlett", "gauss", "normal", "hermite", "sinc", "lanczos1", "lanczos2", "lanczos3", "hann", "hamming", "blackman"], "isInputFile": false, "isOutputFile": false}, {"parameter": "radius", "flag": "radius", "dataType": "String", "optional": true, "explanation": "Filter radius", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "x_radius", "flag": "x_radius", "dataType": "String", "optional": true, "explanation": "Filter radius (horizontal)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y_radius", "flag": "y_radius", "dataType": "String", "optional": true, "explanation": "Filter radius (vertical)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.resamp.filter  resamples an input raster, filtering the\n input with an analytic kernel. Each output cell is typically calculated\n based upon a small subset of the input cells, not the entire input.\n  r.resamp.filter  performs convolution (i.e. a weighted sum is\n calculated for every raster cell).\n The module maps the input range to the width of the window function, so\n wider windows will be \"sharper\" (have a higher cut-off frequency), e.g.\n lanczos3 will be sharper than lanczos2.\n r.resamp.filter implements FIR (finite impulse response) filtering. All\n of the functions are low-pass filters, as they are symmetric. See\n  Wikipedia: Window function \n for examples of common window functions and their frequency responses.\n A piecewise-continuous function defined by sampled data can be considered\n a mixture (sum) of the underlying signal and quantisation noise. The\n intent of a low pass filter is to discard the quantisation noise while\n retaining the signal.\n The cut-off frequency is normally chosen according to the sampling\n frequency, as the quantisation noise is dominated by the sampling\n frequency and its harmonics. In general, the cut-off frequency is\n inversely proportional to the width of the central \"lobe\" of the window\n function.\n When using  r.resamp.filter  with a specific radius, a specific\n cut-off frequency regardless of the method is chosen. So while lanczos3\n uses 3 times as large a window as lanczos1, the cut-off frequency remains\n the same. Effectively, the radius is \"normalised\".\n All of the kernels specified by the  filter  parameter are\n multiplied together. Typical usage will use either a single kernel or an\n infinite kernel along with a finite window.\n ", "notes": "\n Resampling modules ( r.resample, r.resamp.stats, r.resamp.interp,\n r.resamp.rst, r.resamp.filter ) resample the map to match the\n current region settings.\n When using a kernel which can have negative values (sinc, Lanczos),\n the  -n  flag should be used. Otherwise, extreme values can\n arise due to the total weight being close (or even equal) to zero.\n Kernels with infinite extent (Gauss, normal, sinc, Hann, Hamming,\n Blackman) must be used in conjunction with a finite windowing function\n (box, Bartlett, Hermite, Lanczos).\n The way that Lanczos filters are defined, the number of samples is\n supposed to be proportional to the order (\"a\" parameter), so lanczos3\n should use 3 times as many samples (at the same sampling frequency, i.e.\n cover 3 times as large a time interval) as lanczos1 in order to get a\n similar frequency response (higher-order filters will fall off faster, but\n the frequency at which the fall-off starts should be the same). See \n  Wikipedia: Lanczos-kernel.svg \n for an illustration. If both graphs were drawn on the same axes, they\n would have roughly the same shape, but the a=3 window would have a longer\n tail. By scaling the axes to the same width, the a=3 window has a narrower\n central lobe.\n For longitude-latitude locations, the interpolation algorithm is based on\n degree fractions, not on the absolute distances between cell centers.  Any\n attempt to implement the latter would violate the integrity of the\n interpolation method.\n ", "see_also": ["g.region", "r.mfilter", "r.resample", "r.resamp.interp", "r.resamp.rst", "r.resamp.stats"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.resamp.filter"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.resamp.bspline.html", "name": "r.resamp.bspline", "definition": "- Performs bilinear or bicubic spline interpolation with Tykhonov regularization.", "keywords": ["raster", "surface", "resample", "interpolation"], "synopsis": "r.resamp.bspline [-nc] input=name output=name  [grid=name]   [mask=name]   [ew_step=float]   [ns_step=float]   [method=string]   [lambda=float]   [memory=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Only interpolate null cells in input raster map Find the best Tykhonov regularizing parameter using a \"leave-one-out\" cross validation method Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Find the best Tykhonov regularizing parameter using a \"leave-one-out\" cross validation method Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "grid", "flag": "grid", "dataType": "String", "optional": true, "explanation": "Name for output vector map with interpolation grid", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "mask", "flag": "mask", "dataType": "String", "optional": true, "explanation": "Name of raster map to use for masking", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ew_step", "flag": "ew_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the east-west direction. Default: 1.5 * ewres.", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ns_step", "flag": "ns_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the north-south direction. Default: 1.5 * nsres.", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Spline interpolation algorithm", "defaultValue": "bicubic", "alternatives": ["bilinear", "bicubic"], "isInputFile": false, "isOutputFile": false}, {"parameter": "lambda", "flag": "lambda", "dataType": "String", "optional": true, "explanation": "Tykhonov regularization parameter (affects smoothing)", "defaultValue": "0.01", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used (in MB)", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.resamp.bspline  performs a bilinear/bicubic spline interpolation with\n Tykhonov regularization. The input is a raster surface map, e.g. elevation,\n temperature, precipitation etc. Output is a raster map. Optionally, only\n input NULL cells are interpolated, useful to fill NULL cells, an alternative\n to  r.fillnulls . Using the  -n  flag to only\n interpolate NULL cells will considerably speed up the module.\n The input raster map is read at its native resolution, the output raster\n map will be produced for the current computational region set with\n  g.region . Any MASK will be respected, masked\n values will be treated as NULL cells in both the input and the output map.\n  Spline step values  ew_step  for the east-west direction and\n  ns_step  for the north-south direction should not be smaller than\n the east-west and north-south resolutions of the input map. For a raster\n map without NULL cells, 1 * resolution can be used, but check for\n undershoots and overshoots. For very large areas with missing values\n (NULL cells), larger spline step values may be required, but most of the\n time the defaults (1.5 x resolution) should be fine.\n The Tykhonov regularization parameter ( lambda ) acts to\n smooth the interpolation. With a small  lambda , the\n interpolated surface closely follows observation points; a larger value\n will produce a smoother interpolation. Reasonable values are 0.0001,\n 0.001, 0.005, 0.01, 0.02, 0.05, 0.1 (needs more testing). For seamless\n NULL cell interpolation, a small value is required and default is set to 0.005.\n From a theoretical perspective, the interpolating procedure takes place in two\n parts: the first is an estimate of the linear coefficients of a spline function;\n these are derived from the observation points using a least squares regression; the\n second is the computation of the interpolated surface (or interpolated vector\n points). As used here, the splines are 2D piece-wise non-zero polynomial\n functions calculated within a limited 2D area. The length of each spline step\n is defined by  ew_step  for the east-west direction and\n  ns_step  for the north-south direction. For optimal performance, the\n spline step values should be no less than the east-west and north-south\n resolutions of the input map. Each non-NULL cell observation is modeled as a\n linear function of the non-zero splines in the area around the observation.\n The least squares regression predicts the the coefficients of these linear functions.\n Regularization avoids the need to have one one observation and one coefficient\n for each spline (in order to avoid instability). \n  A cross validation \"leave-one-out\" analysis is available to help to determine\n the optimal  lambda  value that produces an interpolation that\n best fits the original observation data. The more points used for\n cross-validation, the longer the time needed for computation. Empirical testing\n indicates a threshold of a maximum of 100 points is recommended. Note that cross\n validation can run very slowly if more than 100 observations are used. The\n cross-validation output reports  mean  and  rms  of the residuals from\n the true point value and the estimated from the interpolation for a fixed series\n of  lambda  values. No vector nor raster output will be created\n when cross-validation is selected. \n  EXAMPLES \n  Basic interpolation \n r.resamp.bspline input=raster_surface output=interpolated_surface method=bicubic\n A bicubic spline interpolation will be done and a raster map with estimated\n (i.e., interpolated) values will be created. \n  Interpolation of NULL cells and patching \n General procedure:\n # set region to area with NULL cells, align region to input map\n g.region n=north s=south e=east w=west align=input -p\n # interpolate NULL cells\n r.resamp.bspline -n input=input_raster output=interpolated_nulls method=bicubic\n # set region to area with NULL cells, align region to input map\n g.region raster=input -p\n # patch original map and interpolated NULLs\n r.patch input=input_raster,interpolated_nulls output=input_raster_gapfilled\n  Interpolation of NULL cells and patching (NC data) \n In this example, the SRTM elevation map in the\n North Carolina sample dataset location is filtered for outlier\n elevation values; missing pixels are then re-interpolated to obtain\n a complete elevation map:\n g.region raster=elev_srtm_30m -p\n d.mon wx0\n d.histogram elev_srtm_30m\n r.univar -e elev_srtm_30m\n # remove too low elevations (esp. lakes)\n # Threshold: thresh = Q1 - 1.5 * (Q3 - Q1)\n r.mapcalc \"elev_srtm_30m_filt = if(elev_srtm_30m < 50.0, null(), elev_srtm_30m)\"\n # verify\n d.histogram elev_srtm_30m_filt\n d.erase\n d.rast elev_srtm_30m_filt\n r.resamp.bspline -n input=elev_srtm_30m_filt output=elev_srtm_30m_complete \n    method=bicubic\n d.histogram elev_srtm_30m_complete\n d.rast elev_srtm_30m_complete\n  Estimation of  lambda  parameter with a cross validation process \n A random sample of points should be generated first with\n  r.random , and the current region should not\n include more than 100 non-NULL random cells. \n r.resamp.bspline -c input=input_raster \n  REFERENCES \n  Brovelli M. A., Cannata M., and Longoni U.M., 2004, LIDAR Data\n Filtering and DTM Interpolation Within GRASS, Transactions in GIS,\n April 2004, vol. 8, iss. 2, pp. 155-174(20), Blackwell Publishing Ltd \n  Brovelli M. A. and Cannata M., 2004, Digital Terrain model\n reconstruction in urban areas from airborne laser scanning data: the\n method and an example for Pavia (Northern Italy). Computers and\n Geosciences 30, pp.325-331 \n  Brovelli M. A e Longoni U.M., 2003, Software per il filtraggio di\n dati LIDAR, Rivista dell'Agenzia del Territorio, n. 3-2003, pp. 11-22\n (ISSN 1593-2192) \n  Antolin R. and Brovelli M.A., 2007, LiDAR data Filtering with GRASS GIS for the Determination of Digital Terrain Models. Proceedings of Jornadas de SIG Libre,\n Girona, Espa\u00f1a. CD ISBN: 978-84-690-3886-9 \n ", "notes": "", "see_also": ["r.fillnulls", "r.resamp.rst", "r.resamp.interp", "v.surf.bspline", "v.surf.bspline"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.resamp.bspline"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.report.html", "name": "r.report", "definition": "- Reports statistics for raster maps.", "keywords": ["raster", "statistics"], "synopsis": "r.report [-hfenaci] map=name[,name,...]  [units=string[,string,...]]   [output=name]   [null_value=string]   [page_length=integer]   [page_width=integer]   [nsteps=integer]   [sort=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "h", "flag": "-h", "explanation": "Suppress page headers Use formfeeds between pages Scientific format Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Use formfeeds between pages Scientific format Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Scientific format Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Do not report no data value Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Do not report cells where all maps have no data Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Report for cats floating-point ranges (floating-point maps only) Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Read floating-point map as integer (use map's quant rules) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map(s) to report on", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Units to report", "defaultValue": null, "alternatives": ["mi", "me", "k", "a", "h", "c", "p"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file to hold the report", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "page_length", "flag": "page_length", "dataType": "String", "optional": true, "explanation": "Page length", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "page_width", "flag": "page_width", "dataType": "String", "optional": true, "explanation": "Page width", "defaultValue": "79", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nsteps", "flag": "nsteps", "dataType": "String", "optional": true, "explanation": "Number of floating-point subranges to collect stats from", "defaultValue": "255", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sort", "flag": "sort", "dataType": "String", "optional": true, "explanation": "Sort output statistics by cell counts", "defaultValue": null, "alternatives": ["asc", "desc"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.report  allows the user to set up a series of report\n parameters to be applied to a raster map, and creates a report. The\n report will print out to the standard output if  output \n parameter is not given.\n The report itself consists of two parts, a header section and the main\n body of the report.\n The header section of the report identifies the raster map(s) (by map\n name and title), location, mapset, report date, and the region of\n interest. The area of interest is described in two parts: the user's\n current geographic region is presented, and the mask is presented (if\n any is used).\n The main body of the report consists of from one to three tables which\n present the statistics for each category and the totals for each unit\n column. Note that the statistics is always computed in the current\n geographical region.\n When multiple (typically two) raster maps are specified, cross-tabulation\n table for each combination of categories in the raster maps will be computed\n and formatted in a human-readable way (see example).\n ", "notes": "\n Note that, unlike  r.stats ,\n  r.report  allows the user to select the specific units of\n measure in which statistics will be reported. To output\n computer-friendly data suitable for importing into a spreadsheet use\n the  r.stats  module. In\n fact  r.report  is running\n  r.stats  in the background and\n reformatting the results to be more human-friendly.\n  EXAMPLE \n Report sorted areas in square miles and acres for each\n category. No-data are not reported (see  -n  flag).\n r.report -n map=geology_30m units=mi,a sort=desc\n +-----------------------------------------------------------------------------+\n |                         RASTER MAP CATEGORY REPORT                          |\n |LOCATION: nc_spm_08_grass7                           Fri Dec  6 17:00:21 2013|\n |-----------------------------------------------------------------------------|\n |          north: 279073.97546639    east: 798143.31179672                    |\n |REGION    south: 113673.97546639    west: 595143.31179672                    |\n |          res:               200    res:              200                    |\n |-----------------------------------------------------------------------------|\n |MASK: none                                                                   |\n |-----------------------------------------------------------------------------|\n |MAP: South-West Wake county: geology derived from vector map (geology_30m in |\n |-----------------------------------------------------------------------------|\n |                 Category Information                  |    square|          |\n |  #|description                                        |     miles|     acres|\n |-----------------------------------------------------------------------------|\n |217|CZfg . . . . . . . . . . . . . . . . . . . . . . . | 27.783911|17,781.703|\n |270|CZig . . . . . . . . . . . . . . . . . . . . . . . | 26.162282|16,743.861|\n |405|CZbg . . . . . . . . . . . . . . . . . . . . . . . |  9.698886|  6207.287|\n |262|CZlg . . . . . . . . . . . . . . . . . . . . . . . |  7.629379|  4882.802|\n |862|CZam . . . . . . . . . . . . . . . . . . . . . . . |  2.532830|  1621.011|\n |910|CZbg . . . . . . . . . . . . . . . . . . . . . . . |  1.683405|  1077.379|\n |583|CZve . . . . . . . . . . . . . . . . . . . . . . . |  0.972977|   622.706|\n |921|Km . . . . . . . . . . . . . . . . . . . . . . . . |  0.463323|   296.526|\n |766|CZg. . . . . . . . . . . . . . . . . . . . . . . . |  0.324326|   207.569|\n |720|CZam . . . . . . . . . . . . . . . . . . . . . . . |  0.185329|   118.611|\n |946|CZam . . . . . . . . . . . . . . . . . . . . . . . |  0.138997|    88.958|\n |948|CZam . . . . . . . . . . . . . . . . . . . . . . . |  0.030888|    19.768|\n |-----------------------------------------------------------------------------|\n |TOTAL                                                  | 77.606534|49,668.182|\n +-----------------------------------------------------------------------------+\n Report areas for each category of land use for each zipcode (included only part of the table):\n r.report map=zipcodes@PERMANENT,landclass96@PERMANENT units=h,p\n +-----------------------------------------------------------------------------+\n |                         RASTER MAP CATEGORY REPORT                          |\n |LOCATION: nc_spm_08_latest                           Tue Feb 11 10:10:46 2014|\n |-----------------------------------------------------------------------------|\n |          north: 228527.25    east: 644971                                   |\n |REGION    south: 215018.25    west: 629980                                   |\n |          res:        28.5    res:    28.5                                   |\n |-----------------------------------------------------------------------------|\n |MASK: none                                                                   |\n |-----------------------------------------------------------------------------|\n |MAPS: South West Wake: Zipcode areas derived from vector map (zipcodes@PERMAN|\n |        South-West Wake county: Simplified landuse classes (landclass96@PERMA|\n |-----------------------------------------------------------------------------|\n |                   Category Information                    |          |   %  |\n |    #|description                                          |  hectares| cover|\n |-----------------------------------------------------------------------------|\n |27511|CARY                                                 |  1053.813|  5.20|\n |     |-----------------------------------------------------|----------|------|\n |     |1|developed. . . . . . . . . . . . . . . . . . . . . |   197.214| 18.71|\n |     |3|herbaceous . . . . . . . . . . . . . . . . . . . . |    25.017|  2.37|\n |     |4|shrubland. . . . . . . . . . . . . . . . . . . . . |    58.563|  5.56|\n |     |5|forest . . . . . . . . . . . . . . . . . . . . . . |   771.313| 73.19|\n |     |6|water. . . . . . . . . . . . . . . . . . . . . . . |     1.625|  0.15|\n |     |*|no data. . . . . . . . . . . . . . . . . . . . . . |     0.081|  0.01|\n |-----------------------------------------------------------|----------|------|\n |27513|CARY                                                 |   204.525|  1.01|\n |     |-----------------------------------------------------|----------|------|\n |     |1|developed. . . . . . . . . . . . . . . . . . . . . |    32.571| 15.93|\n |     |3|herbaceous . . . . . . . . . . . . . . . . . . . . |     6.011|  2.94|\n |     |4|shrubland. . . . . . . . . . . . . . . . . . . . . |    51.659| 25.26|\n |     |5|forest . . . . . . . . . . . . . . . . . . . . . . |   114.284| 55.88|\n |-----------------------------------------------------------|----------|------|\n ...\n |-----------------------------------------------------------------------------|\n |TOTAL                                                      |22,968.900|100.00|\n +-----------------------------------------------------------------------------+\n ", "see_also": ["r.stats", "g.region", "r.coin", "r.describe", "r.info", "r.univar"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.report"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.relief.html", "name": "r.relief", "definition": "- Creates shaded relief map from an elevation map (DEM).", "keywords": ["raster", "elevation", "relief", "terrain", "hillshade"], "synopsis": "r.relief input=name output=name  [altitude=float]   [azimuth=float]   [zscale=float]   [scale=float]   [units=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output shaded relief map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "altitude", "flag": "altitude", "dataType": "String", "optional": true, "explanation": "Altitude of the sun in degrees above the horizon", "defaultValue": "30", "alternatives": ["0-90"], "isInputFile": false, "isOutputFile": false}, {"parameter": "azimuth", "flag": "azimuth", "dataType": "String", "optional": true, "explanation": "Azimuth of the sun in degrees to the east of north", "defaultValue": "270", "alternatives": ["0-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Factor for exaggerating relief", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Scale factor for converting meters to elevation units", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Elevation units (overrides scale factor)", "defaultValue": null, "alternatives": ["intl", "survey"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.relief  creates a raster shaded relief map based on \n current resolution settings and on sun altitude, azimuth, and \n z-exaggeration values entered by the user. If no output shademap \n name is given, the new shaded relief map is named  <input_map\n >.shade . The map is assigned a grey-scale color table.\n  The parameters controlling the shading are:\n  A raster map layer to provide elevation values for the shaded \n relief map.  Typically, this would be a map layer of elevation; \n however, any raster map layer can be named.\n  The  altitude  of the sun in degrees above the horizon\n (a value between 0 and 90 degrees).\n  The  azimuth  of the sun in degrees to the east of north\n (a value between 0 and 360 degrees; clockwise from north).\n  The scaling parameter, which compensates for a different \n horizontal  scale  than vertical scale. If  scale  is a \n number, then the ewres and nsres are multiplied by that scale to \n calculate the shading. (Default=1.0 for equivalent horizontal and \n vertical scales.)\n  The  zscale  exaggeration factor that changes the apparent relief\n for the shaded relief map.  This can be any positive (or negative) floating\n point value. (Default=1.0)\n  Horizontal distances are calculated in meters, using geodesic \n distances for a latitude-longitude projection. With an elevation map \n measured in feet, the  units  option can be set to automatically \n convert meters to international feet (0.3048 meters = 1 foot) or survey \n feet (1200 / 3937 meters = 1 foot). The  units  parameter overrides \n the  scale  parameter.\n  r.relief  assigns a grey-scale color table to the new \n shaded relief map.\n ", "notes": "\n To visually improve the result of shade maps from low resolution elevation\n models, use  r.resamp.interp  with bilinear or bicubic method to\n resample the DEM at higher resolution.  r.relief  is then\n run on the resampled DEM.\n  EXAMPLES \n  Shaded relief map \n In this example, the aspect map in the North Carolina sample\n dataset location is used to hillshade the elevation map:\n g.region raster=elevation -p\n r.relief input=elevation output=elevation_shade\n  \n  r.relief: shaded elevation map (subset) \n  Colorizing a shaded relief map \n Color can be added later using  r.shade :\n r.shade shade=elevation_shade color=elevation output=elevation_shaded\n  Using the scale factor in Latitude-Longitude \n In Latitude-Longitude locations (or other non-metric locations), the\n  scale  factor has to be used:\n # Latitude-Longitude example\n g.region raster=srtm -p\n r.relief input=srtm output=srtm_shaded scale=111120\n  Exporting shaded relief maps to GeoTIFF \n The data range of shaded relief maps usually does not permit exporting the\n map to GeoTIFF format along with its associated color table due to limitations\n in the GeoTIFF format.\n The most simple way to export it while even reducing the file size is to\n export as palette byte map. This requires a conversion done in  r.mapcalc ,\n using the # operator to convert map category values to their grey scale\n equivalents:\n # using the map created above\n # create new map from map category values\n r.mapcalc \"elevation_shade_byte = #elevation_shade\"\n # verify data range\n r.info elevation_shade_byte\n # assign grey color table\n r.colors elevation_shade_byte color=grey\n # export (optionally: createopt=\"COMPRESS=DEFLATE,BIGTIFF=YES\")\n r.out.gdal input=elevation_shade_byte createopt=\"COMPRESS=DEFLATE\" \n             output=elevation_shade.tif\n # add overview images in GeoTIFF file for faster zooming\n gdaladdo --config GDAL_CACHEMAX 2000 elevation_shade.tif 2 4 8 16\n ", "see_also": [], "authors": ["Jim Westervelt, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.relief"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.regression.multi.html", "name": "r.regression.multi", "definition": "- Calculates multiple linear regression from raster maps.", "keywords": ["raster", "statistics", "regression"], "synopsis": "r.regression.multi [-g] mapx=name[,name,...] mapy=name  [residuals=name]   [estimates=name]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "mapx", "flag": "mapx", "dataType": "String", "optional": false, "explanation": "Map for x coefficient", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapy", "flag": "mapy", "dataType": "String", "optional": false, "explanation": "Map for y coefficient", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "residuals", "flag": "residuals", "dataType": "String", "optional": true, "explanation": "Map to store residuals", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "estimates", "flag": "estimates", "dataType": "String", "optional": true, "explanation": "Map to store estimates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "ASCII file for storing regression coefficients (output to screen if file not specified).", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.regression.multi  calculates a multiple linear regression from\n raster maps, according to the formula\n Y = b0 + sum(bi*Xi) + E\n where\n X = {X1, X2, ..., Xm}\n m = number of explaining variables\n Y = {y1, y2, ..., yn}\n Xi = {xi1, xi2, ..., xin}\n E = {e1, e2, ..., en}\n n = number of observations (cases)\n In R notation:\n Y ~ sum(bi*Xi)\n b0 is the intercept, X0 is set to 1\n  r.regression.multi  is designed for large datasets that can not\n be processed in R. A p value is therefore not provided, because even\n very small, meaningless effects will become significant with a large\n number of cells. Instead it is recommended to judge by the estimator b,\n the amount of variance explained (R squared for a given variable) and\n the gain in AIC (AIC without a given variable minus AIC global must be\n positive) whether the inclusion of a given explaining variable in the\n model is justified.\n  The global model \n The  b  coefficients (b0 is offset), R squared or coefficient of\n determination (Rsq) and F are identical to the ones obtained from\n R-stats's lm() function and R-stats's anova() function. The AIC value\n is identical to the one obtained from R-stats's stepAIC() function\n (in case of backwards stepping, identical to the Start value). The\n AIC value corrected for the number of explaining variables and the BIC\n (Bayesian Information Criterion) value follow the logic of AIC.\n  The explaining variables \n R squared for each explaining variable represents the additional amount\n of explained variance when including this variable compared to when\n excluding this variable, that is, this amount of variance is explained\n by the current explaining variable after taking into consideration all\n the other explaining variables.\n The F score for each explaining variable allows testing if the inclusion\n of this variable significantly increases the explaining power of the\n model, relative to the global model excluding this explaining variable.\n That means that the F value for a given explaining variable is only\n identical to the F value of the R-function  summary.aov  if the\n given explaining variable is the last variable in the R-formula. While\n R successively includes one variable after another in the order\n specified by the formula and at each step calculates the F value\n expressing the gain by including the current variable in addition to the\n previous variables,  r.regression.multi  calculates the F-value\n expressing the gain by including the current variable in addition to all\n other variables, not only the previous variables.\n The AIC value is identical to the one obtained from the R-function\n stepAIC() when excluding this variable from the full model. The AIC\n value corrected for the number of explaining variables and the BIC value\n (Bayesian Information Criterion) value follow the logic of AIC. BIC is\n identical to the R-function stepAIC with k = log(n). AICc is not\n available through the R-function stepAIC.\n  EXAMPLE \n Multiple regression with soil K-factor and elevation, aspect, and slope\n (North Carolina dataset). Output maps are the residuals and estimates:\n g.region raster=soils_Kfactor -p\n r.regression.multi mapx=elevation,aspect,slope mapy=soils_Kfactor \n    residuals=soils_Kfactor.resid estimates=soils_Kfactor.estim\n ", "notes": "", "see_also": ["d.correlate", "r.regression.line", "r.stats"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.regression.multi"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.regression.line.html", "name": "r.regression.line", "definition": "- Calculates linear regression from two raster maps: y = a + b*x.", "keywords": ["raster", "statistics", "regression"], "synopsis": "r.regression.line [-g] mapx=name mapy=name  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "mapx", "flag": "mapx", "dataType": "String", "optional": false, "explanation": "Map for x coefficient", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapy", "flag": "mapy", "dataType": "String", "optional": false, "explanation": "Map for y coefficient", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "ASCII file for storing regression coefficients (output to screen if file not specified).", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.regression.line  calculates a linear regression from two\n raster maps, according to the formula\n y = a + b*x\n where\n x\n y\n represent the input raster maps.\n Optionally, it saves regression coefficients as a ASCII file. \n The result includes the following coefficients:\n offset/intercept (a) and gain/slope (b), correlation coefficient (R),\n number of elements (N), means (medX, medY), standard deviations\n (sdX, sdY), and the F test for testing the significance of the\n regression model as a whole (F).\n ", "notes": "\n The results for offset/intercept (a) and gain/slope (b) are \n identical to that obtained from R-stats's lm() function. \n  EXAMPLE \n Comparison of two DEMs (SRTM and NED, both at 30m resolution),\n provided in the North Carolina sample dataset:\n g.region raster=elev_srtm_30m -p\n r.regression.line mapx=elev_ned_30m mapy=elev_srtm_30m \n  y = a + b*x\n    a (Offset): -1.659279\n    b (Gain): 1.043968\n    R (sumXY - sumX*sumY/N): 0.894038\n    N (Number of elements): 225000\n    F (F-test significance): 896093.366283\n    meanX (Mean of map1): 110.307571\n    sdX (Standard deviation of map1): 20.311998\n    meanY (Mean of map2): 113.498292\n    sdY (Standard deviation of map2): 23.718307\n Using the script style flag AND  eval  to make results\n available in the shell:\n g.region raster=elev_srtm_30m -p\n eval `r.regression.line -g mapx=elev_ned_30m mapy=elev_srtm_30m`\n # print result stored in respective variables\n echo $a\n -1.659279\n echo $b\n 1.043968\n echo $R\n 0.894038\n ", "see_also": ["d.correlate", "r.regression.multi", "r.stats"], "authors": ["Dr. Agustin Lobo - alobo at ija.csic.es"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.regression.line"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.region.html", "name": "r.region", "definition": "- Sets the boundary definitions for a raster map.", "keywords": ["raster", "metadata"], "synopsis": "r.region [-cda] map=name  [region=name]   [raster=name]   [vector=name]   [n=value]   [s=value]   [e=value]   [w=value]   [align=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Set from current region Set from default region Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Set from default region Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Auto-adjustment for lat/lon Attempt to fix small precision errors in resolution and extents Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map to change", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "region", "flag": "region", "dataType": "String", "optional": true, "explanation": "Set region from named region", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Set region to match this raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vector", "flag": "vector", "dataType": "String", "optional": true, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "n", "flag": "n", "dataType": "String", "optional": true, "explanation": "Value for the northern edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "s", "flag": "s", "dataType": "String", "optional": true, "explanation": "Value for the southern edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "e", "flag": "e", "dataType": "String", "optional": true, "explanation": "Value for the eastern edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "w", "flag": "w", "dataType": "String", "optional": true, "explanation": "Value for the western edge", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "align", "flag": "align", "dataType": "String", "optional": true, "explanation": "Raster map to align to", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  r.region  program allows the user to manage the boundaries\n of a raster map. These boundaries can be set by the user directly\n and/or set from a region definition file (stored under the\n  windows  directory in the user's current mapset), a raster\n or vector map, or a 3dview file.\n The  align  parameter sets the current resolution equal to\n that of the named raster map, and align the boundaries to a row and column\n edge in the named map.  Alignment only moves the existing boundaries outward\n to the edges of the next nearest cell in the named raster map -- not to the\n named map's edges.  To perform the latter function, use the\n  raster= name  option.\n ", "notes": "\n After all updates have been applied, the raster map's resolution\n settings are recomputed from the boundaries and the number of rows and\n columns in the raster map.\n  The n= value  may also be specified as a\n function of its current value:  n=n+ value \n increases the current northing, while n=n- value \n decreases it.  This is also true for s= value ,\n e= value , and w= value .\n  EXAMPLES \n Assign absolute coordinates to map:\n r.region map=mymap n=220750 s=220000 w=638300 e=639000\n Shift map (using offset, here by 100 map units in two directions):\n r.region map=mymap n=n+100 e=e+100 w=w+100 s=s+100\n ", "see_also": ["r.support", "g.region", "v.transform"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.region"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.walk.html", "name": "r.walk", "definition": "- Creates a raster map showing the anisotropic cumulative cost of moving between different geographic locations on an input raster map whose cell category values represent cost.", "keywords": ["raster", "cost surface", "cumulative costs", "cost allocation"], "synopsis": "r.walk [-knrib] elevation=name friction=name output=name  [outdir=name]   [start_points=name]   [stop_points=name]   [start_raster=name]   [start_coordinates=east,north[,east,north,...]]   [stop_coordinates=east,north[,east,north,...]]   [max_cost=value]   [null_cost=value]   [memory=value]   [walk_coeff=a,b,c,d]   [lambda=float]   [slope_factor=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "k", "flag": "-k", "explanation": "Use the 'Knight's move'; slower, but more accurate Keep null values in output raster map Start with values in raster map Print info about disk space and memory requirements and exit Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Keep null values in output raster map Start with values in raster map Print info about disk space and memory requirements and exit Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Start with values in raster map Print info about disk space and memory requirements and exit Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Print info about disk space and memory requirements and exit Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Create bitmask encoded directions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "friction", "flag": "friction", "dataType": "String", "optional": false, "explanation": "Name of input raster map containing friction costs", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map to contain walking costs", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "outdir", "flag": "outdir", "dataType": "String", "optional": true, "explanation": "Name for output raster map to contain movement directions", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "start_points", "flag": "start_points", "dataType": "String", "optional": true, "explanation": "Name of starting vector points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stop_points", "flag": "stop_points", "dataType": "String", "optional": true, "explanation": "Name of stopping vector points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_raster", "flag": "start_raster", "dataType": "String", "optional": true, "explanation": "Name of starting raster points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_coordinates", "flag": "start_coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates of starting point(s) (E,N)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stop_coordinates", "flag": "stop_coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates of stopping point(s) (E,N)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max_cost", "flag": "max_cost", "dataType": "String", "optional": true, "explanation": "Maximum cumulative cost", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_cost", "flag": "null_cost", "dataType": "String", "optional": true, "explanation": "Cost assigned to null cells. By default, null cells are excluded", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used in MB", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "walk_coeff", "flag": "walk_coeff", "dataType": "String", "optional": true, "explanation": "Coefficients for walking energy formula parameters a,b,c,d", "defaultValue": "0.72,6.0,1.9998,-1.9998", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lambda", "flag": "lambda", "dataType": "String", "optional": true, "explanation": "Lambda coefficients for combining walking energy and friction cost", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "slope_factor", "flag": "slope_factor", "dataType": "String", "optional": true, "explanation": "Slope factor determines travel energy cost per height step", "defaultValue": "-0.2125", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.walk  computes anisotropic cumulative cost of moving between\n different geographic locations on an input elevation raster map whose\n cell category values represent elevation combined with an input raster\n map layer whose cell values represent friction cost.\n  r.walk  outputs 1) a raster map showing the lowest\n cumulative cost (time) of moving between each cell and the user-specified\n starting points and 2) a second raster map showing the movement \n direction to the next cell on the path back to the start point (see \n  Movement Direction ). It uses an input elevation \n raster map whose cell category values represent elevation, \n combined with a second input raster map whose cell values \n represent friction costs.\n This function is similar to  r.cost ,\n but in addiction to a friction map, it considers an anisotropic travel\n time due to the different walking speed associated with downhill and\n uphill movements.\n ", "notes": "\n The formula from Aitken 1977/Langmuir 1984 (based on Naismith's rule\n for walking times) has been used to estimate the cost parameters of\n specific slope intervals:\n T = a*delta_S + b*delta_H_uphill + c*delta_H_moderate_downhill + d*delta_H_steep_downhill\n where:\n    T  is time of movement in seconds, \n    delta S  is the horizontal distance covered in meters, \n    delta H  is the altitude difference in meters. \n The a, b, c, d  walk_coeff  parameters take in account\n movement speed in the different conditions and are linked to:\n    a: time in seconds it takes to walk for 1 meter a flat surface (1/walking speed) \n    b: additional walking time in seconds, per meter of elevation gain\n       on uphill slopes \n    c: additional walking time in seconds, per meter of elevation loss\n       on moderate downhill slopes (use positive value for decreasing cost) \n    d: additional walking time in seconds, per meter of elevation loss\n       on steep downhill slopes (use negative value for increasing cost) \n It has been proved that moving downhill is favourable up to a specific\n slope value threshold, after that it becomes unfavourable. The default\n slope value threshold ( slope_factor ) is -0.2125, corresponding\n to tan(-12), calibrated on human behaviour (>5 and <12 degrees:\n moderate downhill; >12 degrees: steep downhill). The default values\n for a, b, c, d  walk_coeff  parameters are those proposed by\n Langmuir (0.72, 6.0, 1.9998, -1.9998), based on man walking effort in\n standard conditions.\n  The  friction  cost parameter represents a time penalty in seconds\n of additional walking time to cross 1 meter distance.\n  The  lambda  parameter is a dimensionless scaling factor of the friction cost:\n total cost = movement time cost + lambda * friction costs * delta_S\n For a more accurate result, the \"knight's move\" option can be used\n (although it is more time consuming). In the diagram below, the center\n location (O) represents a grid cell from which cumulative distances\n are calculated. Those neighbours marked with an x are always\n considered for cumulative cost updates. With the \"knight's move\"\n option, the neighbours marked with a K are also considered.\n   K   K \n K x x x K\n   x O x\n K x x x K\n   K   K\n  The minimum cumulative costs are computed using Dijkstra's\n algorithm, that find an optimum solution (for more details see\n  r.cost , that uses the same algorithm).\n  Movement Direction \n The movement direction surface is created to record the sequence of\n movements that created the cost accumulation surface. This movement \n direction surface can be used by  r.path  \n to recover a path from an end point back to the start point. \n The direction of each cell points towards the next cell. \n The directions are recorded as degrees CCW from East:\n        112.5      67.5         i.e. a cell with the value 135 \n 157.5  135   90   45   22.5    means the next cell is to the north-west\n        180   x   360           \n 202.5  225  270  315  337.5\n        247.5     292.5\n Once  r.walk  computes the cumulative cost map as a linear\n combination of friction cost (from friction map) and the altitude and\n distance covered (from the digital elevation model), the associated \n movement direction map can be used by  r.path  \n to find the minimum cost path.\n  r.walk , like most all GRASS raster programs, is also made to \n be run on maps larger that can fit in available computer memory. As the \n algorithm works through the dynamic list of cells it can move almost \n randomly around the entire area.  r.walk  divides the entire \n area into a number of pieces and swaps these pieces in and out of \n memory (to and from disk) as needed. This provides a virtual memory \n approach optimally designed for 2-D raster maps. The amount of memory \n to be used by  r.walk  can be controlled with the  memory  \n option, default is 300 MB. For systems with less memory this value will \n have to be set to a lower value.\n  EXAMPLES \n We compute a map showing how far a lost person could get from the\n point where he or she was last seen\n while taking into account the topography and landcover.\n g.region swwake_30m -p\n # create friction map based on land cover\n r.recode landclass96 out=friction << EOF\n 1:3:0.1:0.1\n 4:5:10.:10.\n 6:6:1000.0:1000.0\n 7:7:0.3:0.3\n EOF\n r.walk -k elevation=elev_ned_30m friction=friction output=walkcost \n      start_coordinates=635576,216485 lambda=0.5 max=10000\n # compute contours on the cost surface to better understand\n # how far the person can get in certain time (1000 is in seconds)\n r.contour walkcost output=walkcost step=1000\n  REFERENCES \n  Aitken, R. 1977. Wilderness areas in Scotland. Unpublished Ph.D. thesis.\n  University of Aberdeen.\n   Steno Fontanari, University of Trento, Italy, Ingegneria per l'Ambiente e\n  il Territorio, 2000-2001.\n  Svilluppo di metodologie GIS per la determinazione dell'accessibilit\u00e0\n  territoriale come supporto alle decisioni nella gestione ambientale.\n  Langmuir, E. 1984. Mountaincraft and leadership. The Scottish\n  Sports Council/MLTB. Cordee, Leicester.\n ", "see_also": ["r.cost", "r.path", "r.in.ascii", "r.mapcalc", "r.out.ascii"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.walk"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.volume.html", "name": "r.volume", "definition": "- Calculates the volume of data \"clumps\".", "keywords": ["raster", "volume", "clumps"], "synopsis": "r.volume [-f] input=name  [clump=name]   [centroids=name]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Generate unformatted report (items separated by colon) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map representing data that will be summed within clumps", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "clump", "flag": "clump", "dataType": "String", "optional": true, "explanation": "Name of input clump raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "centroids", "flag": "centroids", "dataType": "String", "optional": true, "explanation": "Name for output vector points map to contain clump centroids", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file to hold the report", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.volume  is a tool for summing cell values within clumps and\n calculating volumes and centroids of patches or clumps.\n  r.volume  generates a table containing the sum of all cells\n from a  input  raster map sorted by category on a  clump \n raster map, and optionally generates a vector points map of the\n centroids for each clump.  If a clump map is not specified, the\n current MASK is used. The MASK can be defined\n by  r.mask . The sum is multiplied by\n the area of a cell to give the volume occupied by that cell. See below\n for an example of the output table.\n ", "notes": "\n If a clump map is not given and a MASK not set, the program exits with\n an error message.\n  r.volume  works in the current region and respects the current\n MASK.\n  CENTROIDS \n The centroid coordinates are the same as those stored in the vector\n map (if one was requested by  centroids  parameter). They are\n guaranteed to fall on a cell of the appropriate category, thus they\n are not always the true, mathematical centroid. They will always fall\n at a cell center.\n Attribute table linked to the vector map with centroids contains several columns:\n    cat  - category value (integer) \n    volume  - volume value (double precision) \n    average  - average value in the clump (double precision) \n    sum  - sum of cell values in the clump (double precision) \n    count  - number of cells with the category (integer) \n Vector points can be converted directly to a raster map with each\n point a separate category\n using  v.to.rast .\n  APPLICATIONS \n By preprocessing the elevation raster map\n with  r.mapcalc  and using\n suitable masking or clump maps, very interesting applications can be\n done with  r.volume .  Such as, calculating the volume of rock\n in a potential quarry; calculating cut/fill volumes for roads; finding\n water volumes in potential reservoirs. \n  EXAMPLE \n The following report was generated by the command (North Carolina dataset):\n # set computational region\n g.region raster=elevation\n # compute volume\n r.volume input=elevation clump=geology_30m\n Volume report on data from <elevation> using clumps on <geology_30m> raster map\n Category   Average   Data   # Cells        Centroid             Total\n Number     in clump  Total  in clump   Easting     Northing     Volume\n -----------------------------------------------------------------------------\n      217    118.93  86288828  725562   635325.00   221535.00    8628882798.63\n      262    108.97  21650560  198684   638935.00   222495.00    2165056037.02\n      270     92.23  63578874  689373   642405.00   221485.00    6357887443.53\n      405    132.96  33732662  253710   631835.00   224095.00    3373266208.59\n      583    139.35   3011288   21609   630205.00   224665.00     301128821.55\n      720    124.30    599618    4824   634075.00   227995.00      59961816.06\n      766    132.43    936791    7074   631425.00   227845.00      93679120.08\n      862    118.31   7302317   61722   630505.00   218885.00     730231746.74\n      910     94.20   4235816   44964   639215.00   216365.00     423581613.11\n      921    135.22   1693985   12528   630755.00   215445.00     169398523.05\n      945    127.24      1145       9   630015.00   215015.00        114512.03\n      946     89.91    365748    4068   639085.00   215255.00      36574833.85\n      948    129.02    112632     873   630185.00   215115.00      11263181.57\n -----------------------------------------------------------------------------\n                                                 Total Volume = 22351026655.81\n The  Data Total  column is the sum of the elevations for each\n in each of the fields.  The  Total Volume  is the sum\n multiplied by the east-west resolution times the north-south\n resolution. Note that the units on the volume may be difficult if the\n units of cell values on the  input  raster map and the resolution\n units differ.\n ", "see_also": ["r.clump", "r.mask", "r.mapcalc"], "authors": ["Dr. James Hinthorne, Central Washington University GIS Laboratory, December 1988."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.volume"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.viewshed.html", "name": "r.viewshed", "definition": "- Computes the viewshed of a point on an elevation raster map.", "keywords": ["raster", "viewshed", "line of sight", "LOS"], "synopsis": "r.viewshed [-crbe] input=name output=name coordinates=east,north  [observer_elevation=value]   [target_elevation=value]   [max_distance=value]   [refraction_coeff=float]   [memory=value]   [directory=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Consider the curvature of the earth (current ellipsoid) Consider the effect of atmospheric refraction Output format is invisible = 0, visible = 1 Output format is invisible = NULL, else current elev - viewpoint_elev Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Consider the effect of atmospheric refraction Output format is invisible = 0, visible = 1 Output format is invisible = NULL, else current elev - viewpoint_elev Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Output format is invisible = 0, visible = 1 Output format is invisible = NULL, else current elev - viewpoint_elev Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Output format is invisible = NULL, else current elev - viewpoint_elev Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "Coordinates of viewing position", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "observer_elevation", "flag": "observer_elevation", "dataType": "String", "optional": true, "explanation": "Viewing elevation above the ground", "defaultValue": "1.75", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "target_elevation", "flag": "target_elevation", "dataType": "String", "optional": true, "explanation": "Offset for target elevation above the ground", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max_distance", "flag": "max_distance", "dataType": "String", "optional": true, "explanation": "Maximum visibility radius. By default infinity (-1)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "refraction_coeff", "flag": "refraction_coeff", "dataType": "String", "optional": true, "explanation": "Refraction coefficient", "defaultValue": "0.14286", "alternatives": ["0.0-1.0"], "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Amount of memory to use in MB", "defaultValue": "500", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "directory", "flag": "directory", "dataType": "String", "optional": true, "explanation": "Directory to hold temporary files (they can be large)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.viewshed  is a module that computes the viewshed of a\n point on a raster terrain. That is, given an elevation raster, and the\n location of an observer, it generates a raster output map showing\n which cells are visible from the given location. \n The algorithm underlying  r.viewshed  minimizes both the CPU\n operations and the transfer of data between main memory and disk; as a\n result  r.viewshed  runs fast on very large rasters.\n ", "notes": "\n To run  r.viewshed , the user must specify an input elevation\n map name, an output raster map name, and the location of the\n viewpoint.\n  For the time being the viewpoint ( coordinates  parameter) is\n assumed to be located inside the terrain.  The viewpoint location is\n given in map coordinates.\n  The output raster map may have one of three possible formats, based\n on which flags are set.\n By default, if no flag is set, the output is in angle-mode, and\n each point in the output map is marked as NULL if the point is not\n visible or the respective point in the elevation map is NULL.\n Otherwise, a value in [0, 180] representing the vertical angle with\n regard to the viewpoint, in degrees, if the point is visible.\n A value of 0 is directly below the specified viewing position,\n 90 is due horizontal. The angle to the cell containing the viewing\n position is undefined and set to 180. \n If the  -b  flag is set, the output is in boolean-mode, and each point\n in the output map is marked as:\n     0 if the point is no-data/null or not visible\n     1 if the point is visible.\n If the  -e  flag is set, the output is in elevation-mode, and each point\n in the output map is marked as:\n     no-data (null), if the respective point in the elevation map is no-data (null) \n     -1, if the point is not visible\n     the difference in elevation between the point and the viewpoint, if the point is visible.\n If you wish to identify the area of the map which is within the search\n radius but not visible, a combination of  r.buffer  and\n  r.mapcalc  can be used to create\n a negative of the viewshed map.\n By default the elevations are not adjusted for the curvature of the\n earth. The user can turn this on with flag\n  -c .\n By default the observer is assumed to have height 1.75 map units above\n the terrain.  The user can change this using option\n  observer_elevation . The value entered is in the same units as the\n elevation.\n By default the target is assumed to have height of 0 map units above the\n terrain.  The user can change this using option\n  target_elevation  to determine if objects of a given height would be\n visible. The value entered is in the same units as the elevation.\n By default there is no restriction on the maximum distance to which\n the observer can see.  The user can set a maximum distance of\n visibility using option  max_distance .  The value entered is in the\n same units as the cell size of the raster.\n Main memory usage: By default  r.viewshed  assumes it has\n 500MB of main memory, and sets up its internal data structures so that\n it does not require more than this amount of RAM.  The user can set\n the amount of memory used by the program by setting the\n  memory  to the number of MB of memory they would like to\n be used.\n  Memory mode \n The algorithm can run in two modes: in internal memory, which\n means that it keeps all necessary data structures in memory during the\n computation. And in external memory, which means that the data\n structures are external, i.e. on disk.   r.viewshed  decides\n which mode to run in using the amount of main memory specified by the\n user.  The internal mode is (much) faster than the external mode.\n Ideally, the user should specify on the command line the amount of\n physical memory that is free for the program to use. Underestimating\n the memory may result in  r.viewshed  running in external mode\n instead of internal, which is slower. Overestimating the amount of\n free memory may result in  r.viewshed  running in internal mode\n and using virtual memory, which is slower than the external mode.\n  The algorithm \n  r.viewshed  uses the following model for determining\n visibility: The height of a cell is assumed to be variable, and the \n actual height of a point falling into a cell, but not identical the cell \n center, is interpolated. Thus the terrain is viewed as a smooth surface. \n Two points are visible to each other if their line-of-sight does not\n intersect the terrain. The height for an arbitrary point x in the terrain \n is interpolated from the 4 surrounding neighbours. This means that this \n model does a bilinear interpolation of heights.\n This model is suitable for both low and high resolution rasters as well \n as terrain with flat and steep slopes.\n  The core of the algorithm is determining, for each cell, the\n line-of-sight and its intersections with the cells in the terrain. For\n a (square) grid of  n  cells, there can be  O(n\n  1/2 )  cells that intersect the LOS. If we test every\n single such cell for every point in the grid, this adds up to\n  O(n 3/2 )  tests. We can do all these tests faster if\n we re-use information from one point to the next (two grid points that\n are close to each other will be intersected by a lot of the same\n points) and organize the computation differently.\n  More precisely, the algorithm uses a technique called  line\n sweeping : It considers a half-line centered at the viewpoint, and\n rotates it radially around the viewpoint, 360 degrees.  During the\n sweep it keeps track of all the cells that intersect the sweep line at\n that time; These are called the  active  cells. A cell has 3\n associated events: when it is first met by the sweep line and inserted\n into the active structure; when it is last met by the sweep line and\n deleted from the active structure; and when the sweep line passes over\n its centerpoint, at which time its visibility is determined.  To\n determine the visibility of a cell all cells that intersect the\n line-of-sight must be active, so they are in the active structure.\n The algorithm looks at all the active cells that are between the point\n and the viewpoint, and finds the maximum gradient among these.  If the\n cell's gradient is higher, it is marked as visible, whereas if it is\n lower, it is marked as invisible.\n  For a (square) raster of  n  point in total, the standard\n viewshed algorithm uses  O(n sqrt(n))= O(n 3/2 ) \n time, while the sweep-line algorithm uses  O(n lg n)  time.\n This algorithm is efficient in terms of CPU operations and can be also\n made efficient in terms of I/O-operations.  For all details see the\n REFERENCES below.\n    \n        \n        \n    \n    \t\n      The sweep-line. \n      The active cells. \n     \n  EXAMPLES \n Using the North Carolina dataset:  Compute viewshed from a observation \n point (coordinates: 638728.087167, 220609.261501) which is 5 meters \n above ground:\n g.region raster=elev_lid792_1m -p\n r.viewshed input=elev_lid792_1m output=elev_lid792_1m_viewshed coordinates=638728,220609 observer_elevation=5.0\n  Viewshed shown on shaded terrain (observer position in the north-east quadrant with white dot; 5m above ground) \n Using the Spearfish dataset:  calculating the viewpoint from top\n of a mountain:\n g.region raster=elevation.10m\n r.viewshed input=elevation.10m output=viewshed coordinates=598869,4916642 memory=800\n  REFERENCES \n  Computing Visibility on Terrains in External Memory. Herman \n Haverkort, Laura Toma and Yi Zhuang. In  ACM Journal on Experimental \n Algorithmics (JEA)  13 (2009). \n \t \n  Computing\n Visibility on Terrains in External Memory . Herman Haverkort, Laura \n Toma and Yi Zhuang. In the  Proceedings of the 9th Workshop on \n Algorithm Engineering and Experiments / Workshop on Analytic Algorithms \n and Combinatorics (ALENEX/ANALCO 2007) . \n ", "see_also": ["r.mapcalc"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.viewshed"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.usler.html", "name": "r.usler", "definition": "- Computes USLE R factor, Rainfall erosivity index.", "keywords": ["raster", "hydrology", "rainfall", "soil", "erosion"], "synopsis": "r.usler input=name output=name method=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of annual precipitation raster map [mm/year]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output USLE R raster map [MJ.mm/ha.hr.year]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Name of USLE R equation", "defaultValue": "morgan", "alternatives": ["roose", "morgan", "foster", "elswaify"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.usler  calculates USLE R factor for Rainfall erosivity. It\n enables several empirical equations: Roosle (1975), Morgan (1974),\n Foster(1981) and El-Swaify (1985).\n ", "notes": "\n  r.watershed  provides for USLE L, S, LS factors.\n  EXAMPLE \n TBD.\n ", "see_also": ["r.uslek", "r.watershed"], "authors": ["Natialia Medvedeva, SIC-ISDC, Ashgabat, Turkmenistan"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.usler"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.uslek.html", "name": "r.uslek", "definition": "- Computes USLE Soil Erodibility Factor (K).", "keywords": ["raster", "hydrology", "soil", "erosion"], "synopsis": "r.uslek psand=name pclay=name psilt=name pomat=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "psand", "flag": "psand", "dataType": "String", "optional": false, "explanation": "Name of soil sand fraction raster map [0.0-1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "pclay", "flag": "pclay", "dataType": "String", "optional": false, "explanation": "Name of soil clay fraction raster map [0.0-1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "psilt", "flag": "psilt", "dataType": "String", "optional": false, "explanation": "Name of soil silt fraction raster map [0.0-1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "pomat", "flag": "pomat", "dataType": "String", "optional": false, "explanation": "Name of soil organic matter raster map [0.0-1.0]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output USLE K factor raster map [t.ha.hr/ha.MJ.mm]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.uslek  calculates the USLE K factor, that is the Soil Erodibility\n Factor. It takes input of soil texture classes (sand, clay, silt) and\n organic matter, all in range of [0.0-1.0]. The FAO World Soil CD\n documentation was used to produce the conversion system between soil\n textures and soil classes. The soil classes are in number of 12 and\n apparently come from a USDA publication of 1951 (p.209). Once the soil\n classes have been identified (by vector cross-products tests), a general\n conversion table was applied for transforming soil classes into K factor.\n ", "notes": "\n  r.watershed  provides for USLE L, S, LS factors.\n  EXAMPLE \n Calculate the USLE K factor (synthetic values, North Carolina sample dataset):\n # NC data: simulation\n g.region rural_1m -p\n r.mapcalc \"sand  = 0.11\"\n r.mapcalc \"clay  = 0.47\"\n r.mapcalc \"silt  = 0.42\"\n r.mapcalc \"organ = 0.0136\"\n r.uslek psand=sand pclay=clay psilt=silt pomat=organ output=usle_k\n r.univar usle_k\n # Result: uslek = 0.25\n Example with small variations (condition: d_sand + d_clay + d_silt => 1.0)\n # NC data: simulation\n r.mapcalc -s \"sand_r = rand(0.09,0.13)\"\n r.mapcalc -s \"clay_r = rand(0.45,0.49)\"\n r.mapcalc -s \"silt_r = rand(0.40,0.44)\"\n r.mapcalc -s \"organ  = rand(0.01,0.70)\"\n r.mapcalc \"temp_sum = sand_r + clay_r + silt_r\"\n r.mapcalc \"sand = sand_r / temp_sum\"\n r.mapcalc \"clay = clay_r / temp_sum\"\n r.mapcalc \"silt = silt_r / temp_sum\"\n r.mapcalc \"test = sand + clay + silt\"\n r.info -r test\n g.remove -f rast name=sand_r,clay_r,silt_r,temp_sum,test\n r.uslek psand=sand pclay=clay psilt=silt pomat=organ output=usle_k\n r.univar usle_k\n # Result: uslek =  variable values\n ", "see_also": ["r.usler", "r.watershed"], "authors": ["Yann Chemin, SIC-ISDC, Turkmenistan"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.uslek"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.unpack.html", "name": "r.unpack", "definition": "- Imports a GRASS GIS specific raster archive file (packed with r.pack) as a raster map", "keywords": ["raster", "import", "copying"], "synopsis": "r.unpack [-op] input=name.pack  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Print projection information of input pack file and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print projection information of input pack file and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input pack file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map (default: taken from input file internals)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.unpack  allows unpacking raster maps packed by  r.pack .\n ", "notes": "\n Name of the raster map is determined by default from pack file\n internals. Optionally the name can be given by  output  parameter.\n Currently only 2D raster maps are supported.\n  EXAMPLE \n Pack up raster map  aspect  into  aspect.pack  file.\n r.pack input=aspect\n the raster map can be afterwards unpacked by\n r.unpack input=aspect.pack\n ", "see_also": ["r.pack", "r.in.gdal", "v.pack"], "authors": ["Original Bash script written by Hamish Bowman, Otago University, New Zealand as GRASS AddOns"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.unpack"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.univar.html", "name": "r.univar", "definition": "- Calculates univariate statistics from the non-null cells of a raster map.", "keywords": ["raster", "statistics", "univariate statistics", "zonal statistics"], "synopsis": "r.univar [-getr] map=name[,name,...]  [zones=name]   [output=name]   [percentile=float[,float,...]]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print the stats in shell script style Calculate extended statistics Table output format instead of standard output format Use the native resolution and extent of the raster map, instead of the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Calculate extended statistics Table output format instead of standard output format Use the native resolution and extent of the raster map, instead of the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Table output format instead of standard output format Use the native resolution and extent of the raster map, instead of the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Use the native resolution and extent of the raster map, instead of the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zones", "flag": "zones", "dataType": "String", "optional": true, "explanation": "Raster map used for zoning, must be of type CELL", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "percentile", "flag": "percentile", "dataType": "String", "optional": true, "explanation": "Percentile to calculate (requires extended statistics flag)", "defaultValue": "90", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.univar  calculates the univariate statistics of one or several raster\n map(s). This includes the number of cells counted, minimum and maximum cell\n values, range, arithmetic mean, population variance, standard deviation,\n coefficient of variation, and sum. Statistics are calculated separately for every\n category/zone found in the  zones  input map if given.\n If the  -e  extended statistics flag is given the 1st quartile, median,\n 3rd quartile, and given  percentile  are calculated.\n If the  -g  flag is given the results are presented in a format suitable\n for use in a shell script.\n If the  -t  flag is given the results are presented in tabular format\n with the given field separator. The table can immediately be converted to a\n vector attribute table which can then be linked to a vector, e.g. the vector\n that was rasterized to create the  zones  input raster.\n When multiple input maps are given to  r.univar , the overall statistics\n are calculated. This is useful for a time series of the same variable, as well as\n for the case of a segmented/tiled dataset. Allowing multiple raster maps to be\n specified saves the user from using a temporary raster map for the result of \n  r.series  or  r.patch .\n ", "notes": "\n As with most GRASS raster modules,  r.univar  operates on the raster\n array defined by the current region settings, not the original extent and\n resolution of the input map. See  g.region ,\n but also \n the wiki page on the computational region  to understand the impact of the \n region settings on the calculations.\n This module can use large amounts of system memory when the  -e \n extended statistics flag is used with a very large region setting. If the\n region is too large the module should exit gracefully with a memory allocation\n error. Basic statistics can be calculated using any size input region.\n Extended statistics can be calculated using\n  r.stats.quantile .\n Without a  zones  input raster, the  r.quantile  module will\n be significantly more efficient for calculating percentiles with large maps.\n For calculating univariate statistics from a raster map based on vector polygon\n map and uploads statistics to new attribute columns, see\n  v.rast.stats .\n  EXAMPLES \n  Univariate statistics \n In this example, the raster map  elevation  in the North \n Carolina sample dataset is used to calculate univariate statistics: \n g.region raster=elevation -p\n # standard output, along with extended statistics\n r.univar -e elevation percentile=98\n total null and non-null cells: 2025000\n total null cells: 0\n Of the non-null cells:\n ----------------------\n n: 2025000\n minimum: 55.5788\n maximum: 156.33\n range: 100.751\n mean: 110.375\n mean of absolute values: 110.375\n standard deviation: 20.3153\n variance: 412.712\n variation coefficient: 18.4057 %\n sum: 223510266.558102\n 1st quartile: 94.79\n median (even number of cells): 108.88\n 3rd quartile: 126.792\n 98th percentile: 147.727\n # script style output, along with extended statistics\n r.univar -ge elevation percentile=98\n n=2025000\n null_cells=0\n cells=2025000\n min=55.5787925720215\n max=156.329864501953\n range=100.751071929932\n mean=110.375440275606\n mean_of_abs=110.375440275606\n stddev=20.3153233205981\n variance=412.712361620436\n coeff_var=18.4056555243368\n sum=223510266.558102\n first_quartile=94.79\n median=108.88\n third_quartile=126.792\n percentile_98=147.727\n  Zonal statistics \n In this example, the raster polygon map  basins  in the North \n Carolina sample dataset is used to calculate raster statistics for zones\n for  elevation  raster map: \n g.region raster=basins -p\n This will set and print computational region in the format:\n projection: 99 (Lambert Conformal Conic)\n zone:       0\n datum:      nad83\n ellipsoid:  a=6378137 es=0.006694380022900787\n north:      228500\n south:      215000\n west:       630000\n east:       645000\n nsres:      10\n ewres:      10\n rows:       1350\n cols:       1500\n cells:      2025000\n Check basin's IDs using:\n r.category basins\n This will print them in the format:\n 2\t\n 4\t\n 6\t\n 8\t\n 10\t\n 12\t\n 14\t\n 16\t\n 18\t\n 20\t\n 22\t\n 24\t\n 26\t\n 28\t\n 30\t\n Visualization of them underlying elevation map can be created as:\n d.mon wx0\n d.rast map=elevation\n r.colors map=elevation color=grey \n d.rast map=basins\n r.colors map=basins color=bgyr \n d.legend raster=basins use=2,4,6,8,10,12,14,16,18,20,22,24,26,28,30\n d.barscale \n  Figure: Zones (basins, opacity: 60%) with underlying elevation map \n for North Carolina sample dataset. \n Then statistics for elevation can be calculated separately for every\n zone, i.e. basin found in the  zones  parameter:\n r.univar -t map=elevation zones=basins separator=comma \n           output=basin_elev_zonal.csv\n This will print information in the format:\n zone,label,non_null_cells,null_cells,min,max,range,mean,mean_of_abs,\n stddev,variance,coeff_var,sum,sum_abs2,,116975,0,55.5787925720215,\n 133.147018432617,77.5682258605957,92.1196971445722,92.1196971445722,\n 15.1475301152556,229.447668592576,16.4433129773355,10775701.5734863,\n 10775701.57348634,,75480,0,61.7890930175781,110.348838806152,\n 48.5597457885742,83.7808205765268,83.7808205765268,11.6451777476995,\n 135.610164775515,13.8995747088232,6323776.33711624,6323776.33711624\n 6,,1137,0,66.9641571044922,83.2070922851562,16.2429351806641,\n 73.1900814395257,73.1900814395257,4.15733292896409,17.2834170822492,\n 5.68018623179036,83217.1225967407,83217.12259674078,,80506,\n 0,67.4670791625977,147.161514282227, ...\n Comma Separated Values (CSV) file is best viewed through a spreadsheet \n program such as Microsoft Excel, Libre/Open Office Calc or Google Docs:\n  \n  Figure: Raster statistics for zones (basins, North Carolina sample \n dataset) viewed through Libre/Open Office Calc. \n  TODO \n To be implemented  mode, skewness, kurtosis .\n ", "see_also": ["g.region", "r3.univar", "r.mode", "r.quantile", "r.series", "r.stats", "r.stats.quantile", "r.stats.zonal", "r.statistics", "v.rast.stats", "v.univar"], "authors": ["Hamish Bowman, Otago University, New Zealand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.univar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.transect.html", "name": "r.transect", "definition": "- Outputs raster map layer values lying along user defined transect line(s).", "keywords": ["raster", "profile", "transect"], "synopsis": "r.transect [-g] map=name line=east,north,azimuth,distance[,east,north,azimuth,distance,...]  [null_value=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Output easting and northing in first two columns of four column output Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Raster map to be queried", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "line", "flag": "line", "dataType": "String", "optional": false, "explanation": "Transect definition", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This program outputs, in ASCII, the values in a raster map\n which lie along one or more user-defined transect lines.\n The transects are described by their starting coordinates,\n azimuth, and distance. \n The  line  parameter is a definition of (each) transect line,\n specified by the geographic coordinates of its starting point ( easting,\n northing ), the angle and direction of its travel ( azimuth ),\n and its distance ( distance ).\n  The  azimuth  is an angle, in degrees, measured to\n the east of north.  The  distance  is in map units\n (meters for a metered database, like UTM).\n  The  null  parameter can optionally be set to change the character\n string representing null values.\n ", "notes": "\n This program is a front-end to the  \n  r.profile  program.  It simply converts the\n azimuth and distance to an ending coordinate and then runs  \n  r.profile .\n There once were  width=  and  result= raw|median|average \n  options which are not currently implemented.\n ", "see_also": ["r.profile", "wxGUI profile tool"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.transect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.topmodel.html", "name": "r.topmodel", "definition": "- Simulates TOPMODEL which is a physically based hydrologic model.", "keywords": ["raster", "hydrology", "model"], "synopsis": "r.topmodel [-p] parameters=name topidxstats=name input=name output=name  [timestep=integer]   [topidxclass=integer]   [topidx=name]   [ntopidxclasses=integer]   [outtopidxstats=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Preprocess only and stop after generating outtopidxstats Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "parameters", "flag": "parameters", "dataType": "String", "optional": false, "explanation": "Name of input TOPMODEL parameters file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "topidxstats", "flag": "topidxstats", "dataType": "String", "optional": false, "explanation": "Name of input topographic index statistics file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input rainfall and potential evapotranspiration data file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "timestep", "flag": "timestep", "dataType": "String", "optional": true, "explanation": "Time step", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "topidxclass", "flag": "topidxclass", "dataType": "String", "optional": true, "explanation": "Topographic index class", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "topidx", "flag": "topidx", "dataType": "String", "optional": true, "explanation": "Name of input topographic index raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "ntopidxclasses", "flag": "ntopidxclasses", "dataType": "String", "optional": true, "explanation": "Number of topographic index classes", "defaultValue": "30", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "outtopidxstats", "flag": "outtopidxstats", "dataType": "String", "optional": true, "explanation": "Name for output topographic index statistics file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.topmodel  simulates TOPMODEL which is a physically based\n hydrologic model.\n  Parameters description \n  parameters \n This file contains TOPMODEL parameters that describe the study area. Any lines\n starting with a # sign or empty lines are ignored.\n # Subcatchment name\n Subcatchment 1\n ################################################################################\n # A [m^2]: Total subcatchment area\n 3.31697E+07\n ################################################################################\n # qs0 [m/h]: Initial subsurface flow per unit area\n #\t\t\"The first streamflow input is assumed to represent\n #\t\t only the subsurface flow contribution in the watershed.\"\n #\t\t\t\t\t\t\t\t- Liaw (1988)\n 0.000075\n # lnTe [ln(m^2/h)]: Areal average of the soil surface transmissivity\n 4.\n # m [m]: Parameter controlling the decline rate of transmissivity\n # See Beven and Kirkby (1979)\n 0.0125\n # Sr0 [m]: Initial root zone storage deficit\n 0.0025\n # Srmax [m]: Maximum root zone storage deficit\n 0.041\n # td [h]: Unsaturated zone time delay per unit storage deficit if greater than 0\n #  OR\n # -alpha: Effective vertical hydraulic gradient if not greater than 0.\n #\n # For example, -10 means alpha=10.\n 60.\n # vch [m/h]: Main channel routing velocity\n 20000.\n # vr [m/h]: Internal subcatchment routing velocity\n 10000.\n ################################################################################\n # infex: Calculate infiltration excess if not zero (integer)\n 0\n # K0 [m/h]: Surface hydraulic conductivity\n 2.\n # psi [m]: Wetting front suction\n 0.1\n # dtheta: Water content change across the wetting front\n 0.1\n ################################################################################\n # d [m]: Distance from the catchment outlet\n #\t\tThe first value should be the mainstream distance from\n #\t\tthe subcatchment outlet to the catchment outlet.\n # Ad_r:  Cumulative area ratio of subcatchment (0.0 to 1.0)\n #\t\tThe first and last values should be 0 and 1, respectively.\n #   d  Ad_r\n     0   0.0\n  1000   0.2\n  2000   0.4\n  3000   0.6\n  4000   0.8\n  5000   1.0\n  input \n This file contains observed weather data.\n # dt [h]: Time step\n 24\n ################################################################################\n # R [m/dt]:  Rainfall\n # Ep [m/dt]: Potential evapotranspiration\n # R             Ep\n 0.000033        0.000000\n 0.000053        0.011938\n 0.004821        0.000000\n .\n .\n .\n  timestep \n If a time step is specified, output will be generated for the specific time\n step in addition to the summary and total flows at the outlet. This parameter\n can be combined with  topidxclass  to specify a time step and topographic index\n class at the same time. If no  topidxclass  is given, output will be generated\n for all the topographic index classes.\n  toptopidxclass \n If a topographic index class is specified, output will be generated for the\n given topographic index class. This parameter can be combined with  timestep . If\n no  timestep  is given, output will be generated for all the time steps.\n  topidx ,  ntoptopidxclasses ,  outtoptopidxstats \n The  topidx  map can optionally be used for creating a new topographic\n index statistics file. This map has to be already clipped to the catchment\n boundary. The entire range of topographic index values will be divided into\n  ntoptopidxclasses  and the area ratio of each class will be reported in the\n  outtoptopidxstats  file. These three parameters can be omitted unless a new\n  topidxstats  file needs to be created.\n  REFERENCES \n    Beven, K. J., 1984. Infiltration into a class of vertically non-uniform\n   soils. Hydrological Sciences Journal 29 (4), 425-434.\n    Beven, K. J., Kirkby, M. J., 1979. A physically based, variable\n   contributing area model of basin hydrology. Hydrological Sciences Bulletin 24\n   (1), 43-69.\n    Beven K. J., R. Lamb, P. Quinn, R. Romanowicz, and J. Freer, 1995.\n   TOPMODEL, in V.P. Singh (Ed.). Computer Models of Watershed Hydrology. Water\n   Resources Publications.\n    Cho, H., 2000. GIS Hydrological Modeling System by Using Programming\n   Interface of GRASS. Master's Thesis, Department of Civil Engineering,\n   Kyungpook National University, Korea.\n    Liaw, S. C., 1988. Streamflow Simulation Using a Physically Based\n   Hydrologic Model in Humid Forested Watersheds. Dissertation, Colorado State\n   University, CO. p163.\n    Morel-Seytoux, H. J., Khanji, J., 1974. Derivation of an equation of\n   infiltration. Water Resources Research 10 (4), 795-800.\n ", "notes": "", "see_also": ["r.fill.dir", "r.mapcalc", "r.topidx"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.topmodel"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.topidx.html", "name": "r.topidx", "definition": "- Creates a topographic index (wetness index) raster map from an elevation raster map.", "keywords": ["raster", "hydrology", "wetness", "topographic index"], "synopsis": "r.topidx input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output topographic index raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.topidx  creates topographic index (wetness index), ln(a/tan(beta)), map from\n elevation map\n  where\n  a: the area of the hillslope per unit contour length that drains through any point,\n  tan(beta): the local surface topographic slope (delta vertical) / (delta horizontal).\n  Input maps may have NULL values.  For example, if you have a MASK for\n a watershed (basin map from  r.water.outlet ), the\n following command will create a masked elevation map (belev):\n r.mapcalc \"belev = if(isnull(basin), basin, elev)\"\n  r.stats -Anc  prints out averaged statistics for topographic index.\n  EXAMPLE \n Running the command below will generate the topographic index map shown in the figure:\n g.region raster=elevation -p\n r.topidx input=elevation output=topidx_elevation\n  \n  Figure: topographic index map derived from elevation map \n ", "notes": "", "see_also": ["r.topmodel", "r.water.outlet", "r.mapcalc"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.topidx"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.to.vect.html", "name": "r.to.vect", "definition": "- Converts a raster map into a vector map.", "keywords": ["raster", "conversion", "geometry", "vectorization"], "synopsis": "r.to.vect [-svzbt] input=name output=name type=string  [column=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Smooth corners of area features Use raster values as categories instead of unique sequence (CELL only) Write raster values as z coordinate Table is not created. Currently supported only for points. Do not build vector topology Recommended for massive point conversion Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Use raster values as categories instead of unique sequence (CELL only) Write raster values as z coordinate Table is not created. Currently supported only for points. Do not build vector topology Recommended for massive point conversion Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Write raster values as z coordinate Table is not created. Currently supported only for points. Do not build vector topology Recommended for massive point conversion Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build vector topology Recommended for massive point conversion Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": false, "explanation": "Output feature type", "defaultValue": null, "alternatives": ["point", "line", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of attribute column to store value", "defaultValue": "value", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.to.vect  scans the named  input  raster map\n layer, extracts points, lines or area edge features from it, converts data\n to GRASS vector format.\n  Point conversion \n The  r.to.vect  program extracts data from a GRASS raster map \n layer and stores output in a new GRASS  vector  file.  \n  Line conversion \n  r.to.vect  assumes that the  input  map has been thinned\n using  r.thin .\n  r.to.vect  extracts vectors (aka, \"arcs\") from a\n raster map.  These arcs may represent linear features\n (like roads or streams), or may represent area edge\n features (like political boundaries, or soil mapping\n units).  \n  r.thin  and  r.to.vect \n may create excessive nodes at every junction, and may create small spurs\n or \"dangling lines\" during the thinning and vectorization process.\n These excessive nodes and spurs may be removed using\n  v.clean .\n  Area conversion \n  r.to.vect  first traces the perimeter of each unique\n area in the raster map layer and creates vector data to\n represent it.  The cell category values for the raster map\n layer will be used to create attribute information for the\n resultant vector area edge data.\n A true vector tracing of the area edges might appear\n blocky, since the vectors outline the edges of raster data\n that are stored in rectangular cells. To produce a\n better-looking vector map,  r.to.vect  smoothes the\n corners of the vector data as they are being extracted. At\n each change in direction (i.e., each corner), the two\n midpoints of the corner cell (half the cell's height and\n width) are taken, and the line segment connecting them is\n used to outline this corner in the resultant vector map.\n (The cell's cornermost node is ignored.) Because vectors\n are smoothed by this program, the resulting vector map will\n not be \"true\" to the raster map from which it was created.\n The user should check the resolution of the geographic\n region (and the original data) to estimate the possible\n error introduced by smoothing.\n  r.to.vect  extracts only area edges from the named raster \n input file. If the raster map contains other data (i.e., line edges, \n or point data) the output may be wrong.\n  EXAMPLES \n The examples are based on the North Carolina sample dataset:\n  Conversion of raster points to vector points: \n Random sampling of points:\n g.region raster=elevation -p\n # random sampling of points (note that r.random also writes vector points)\n r.random elevation raster_output=elevrand1000 n=1000\n r.to.vect input=elevrand1000 output=elevrand1000 type=point\n # univariate statistics of sample points\n v.univar elevrand1000 column=value type=point\n # compare to univariate statistics on original full raster map\n r.univar elevation\n  Conversion of raster lines to vector lines: \n Vectorization of streams in watershed basins map:\n g.region raster=elevation -p\n r.watershed elev=elevation stream=elev.streams thresh=50000\n r.to.vect -s input=elev.streams output=elev_streams type=line\n # drop \"label\" column which is superfluous in this example\n v.db.dropcolumn map=elev_streams column=label\n v.db.renamecolumn map=elev_streams column=value,basin_id\n # report length per basin ID\n v.report map=elev_streams option=length units=meters sort=asc\n  Conversion of raster polygons to vector polygons: \n Vectorization of simplified landuse class map:\n g.region raster=landclass96 -p\n # we smooth corners of area features\n r.to.vect -s input=landclass96 output=my_landclass96 type=area\n v.colors my_landclass96 color=random\n  KNOWN ISSUES \n For type=line the input raster map MUST be thinned by\n  r.thin ;\n if not,  r.to.vect  may crash.\n ", "notes": "", "see_also": ["g.region", "r.thin", "v.clean"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.to.vect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.to.rast3elev.html", "name": "r.to.rast3elev", "definition": "- Creates a 3D volume map based on 2D elevation and value raster maps.", "keywords": ["raster", "conversion", "raster3d", "voxel"], "synopsis": "r.to.rast3elev [-ulm] input=name[,name,...] elevation=name[,name,...] output=name  [upper=float]   [lower=float]   [tilesize=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "u", "flag": "-u", "explanation": "Use the input map values to fill the upper cells Use the input map values to fill the lower cells Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Use the input map values to fill the lower cells Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "upper", "flag": "upper", "dataType": "String", "optional": true, "explanation": "The value to fill the upper cells, default is null", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lower", "flag": "lower", "dataType": "String", "optional": true, "explanation": "The value to fill the lower cells, default is null", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tilesize", "flag": "tilesize", "dataType": "String", "optional": true, "explanation": "The maximum tile size in kilo bytes. Default is 32KB.", "defaultValue": "32", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n Creates a 3D volume map based on 2D elevation and value raster maps.\n If the 2d and 3d region settings are different,\n the 2d resolution will be adjust to the 3d resolution.\n  \n  How r.to.rast3elev works \n ", "notes": "\n The hight of the 2D elevation maps will be used to verify the position \n within the 3D region. If the cell value of the elevation raster maps is located within the 3D region, the \n cell value of the appropriate 2D input raster maps will be written to the associated 3D cell.\n There are flags and options to fill the upper and lower 3D cells with a specific value, or the\n input raster maps values.\n  Example \n Simple Spearfish sample data set example\n g.region raster=elevation.10m -p\n g.region res=200 res3=200 t=2000 b=0 tbres=20 -p\n # Write the values of raster map soils based on the elevation of elevation.10m\n # to the 3D map volev\n r.to.rast3elev in=soils elev=elevation.10m out=volev\n # Write the values of map soils based on the elevation of elevation.10m\n # to the 3D map volev_l and fill the lower cells with the soils map values\n r.to.rast3elev in=soils elev=elevation.10m out=volev_l -l\n # Write the values of map soils based on the elevation of elevation.10m\n # to the 3D map volev_u and fill the upper cells with the soils map values\n r.to.rast3elev in=soils elev=elevation.10m out=volev_u -u\n # Example with multiple elevation maps.\n ## first we need three support maps\n r.mapcalc expression=\"one = 1\" \n r.mapcalc expression=\"two = 2\" \n r.mapcalc expression=\"three = 3\" \n ## Now we generate the new evelation maps\n r.mapcalc expression=\"elev_mid = elevation.10m - 500\"\n r.mapcalc expression=\"elev_bottom = elevation.10m - 1000\"\n ## Now fill the lower cells below the elevation maps with the values one, two and three\n r.to.rast3elev -l input=one,two,three elevation=elevation.10m,elev_mid,elev_bottom output=threelayer\n ## Export the map for visualization with paraview (http://www.paraview.org)\n ## By default the null value is -9999.99, we adjust it to 0.0 for \n ## better visualization \n r3.out.vtk null=0.0 input=threelayer output=/tmp/threelayer.vtk\n # Start paraview \n paraview --data=/tmp/threelayer.vtk\n # Note: First you need to choose the surface representation style and \n # then color by \"threelayer\" in paraview.\n                                                                             \n ", "see_also": ["r.to.rast3", "r3.cross.rast", "g.region"], "authors": ["Soeren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.to.rast3elev"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.to.rast3.html", "name": "r.to.rast3", "definition": "- Converts 2D raster map slices to one 3D raster volume map.", "keywords": ["raster", "conversion", "voxel"], "synopsis": "r.to.rast3 [-m] input=name[,name,...] output=name  [tilesize=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Use 3D raster mask (if exists) with output map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "2D raster maps which represent the slices", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "tilesize", "flag": "tilesize", "dataType": "String", "optional": true, "explanation": "The maximum tile size in kilo bytes. Default is 32KB.", "defaultValue": "32", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n Converts 2D raster map(s) into one raster3D map. It is important to\n properly set the 3D region settings, especially number or layers and\n depth of layers. If the 2D and 3D region settings are different,\n the 2D resolution will be adjusted to the 3D resolution.\n  \n  How r.to.rast3 works \n ", "notes": "\n Every 2D raster map is copied as one slice to the raster3D map. Slices\n are counted from bottom to the top, so the bottom slice has to be number 1. \n If less number of 2D raster maps are provided than defined depths, the\n last given 2D map is used to fill up the remaining raster3D slices to\n the top.\n  EXAMPLES \n  EXAMPLE 1 \n This example shows how to convert 6 maps into one 3D map with 6 layers.\n # Mapset data in Location slovakia3d\n g.region raster=prec_1,prec_2,prec_3,prec_4,prec_5,prec_6 -p\n g.region b=0 t=600 tbres=100 res3=100 -p3\n r.to.rast3 input=prec_1,prec_2,prec_3,prec_4,prec_5,prec_6 output=new_3dmap\n  EXAMPLE 2 \n This example shows how to convert 3 maps into one 3D map with 6 layers.\n # Mapset data in Location slovakia3d\n g.region b=0 t=600 tbres=100 res3=100 -p3\n r.to.rast3 input=prec_1,prec_2,prec_3 output=new_3dmap\n                                                                             \n ", "see_also": ["g.region", "r3.to.rast", "r.to.rast3elev"], "authors": ["Soeren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.to.rast3"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.timestamp.html", "name": "r.timestamp", "definition": "- Modifies a timestamp for a raster map.", "keywords": ["raster", "metadata", "timestamp", "time"], "synopsis": "r.timestamp map=name  [date=timestamp]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "date", "flag": "date", "dataType": "String", "optional": true, "explanation": "Datetime, datetime1/datetime2, or 'none' to remove", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This command has 2 modes of operation. If no  date  argument is\n supplied, then the current timestamp for the raster map is printed. If\n a date argument is specified, then the timestamp for the raster map is\n set to the specified date(s). See examples below.\n ", "notes": "\n Strings containing spaces should be quoted. For specifying a range of\n time, the two timestamps should be separated by a forward slash. To\n remove the timestamp from a raster map, use  date=none .\n  TIMESTAMP FORMAT \n The timestamp values must use the format as described in the  GRASS\n Datetime Library . The source tree for this library should have a\n description of the format. For convenience, the formats are reproduced\n here:\n  There are two types of datetime values:\n    absolute  and\n    relative .\n Absolute values specify exact dates and/or times. Relative values\n specify a span of time. \n  Absolute \n The general format for absolute values is:\n   day month year [bc] hour:minute:seconds timezone\n \t     day is 1-31\n \t     month is jan,feb,...,dec\n \t     year is 4 digit year\n \t     [bc] if present, indicates dates is BC\n \t     hour is 0-23 (24 hour clock)\n \t     minute is 0-59\n \t     second is 0-59.9999 (fractions of second allowed)\n \t     timezone is +hhmm or -hhmm (eg, -0600)\n Some parts can be missing, for example\n \t     1994 [bc]\n \t     Jan 1994 [bc]\n \t     15 jan 1000 [bc]\n \t     15 jan 1994 [bc] 10 [+0000]\n \t     15 jan 1994 [bc] 10:00 [+0100]\n \t     15 jan 1994 [bc] 10:00:23.34 [-0500]\n  Relative \n There are two types of relative datetime values, year-month and\n day-second. The formats are:\n \t     [-] # years # months\n \t     [-] # days # hours # minutes # seconds\n The words years, months, days, hours, minutes, seconds are literal\n words, and the # are the numeric values. Examples:\n \t     2 years\n \t     5 months\n \t     2 years 5 months\n \t     100 days\n \t     15 hours 25 minutes 35.34 seconds\n \t     100 days 25 minutes\n \t     1000 hours 35.34 seconds\n The following are  illegal  because it mixes year-month and\n day-second (because the number of days in a month or in a year vary):\n \t     3 months 15 days\n \t     3 years 10 days\n  EXAMPLES \n Prints the timestamp for the \"soils\" raster map. If there is no\n timestamp for \"soils\", nothing is printed. If there is a timestamp,\n one or two time strings are printed, depending on if the timestamp for\n the map consists of a single date or two dates (ie start and end\n dates).\n r.timestamp map=soils\n Sets the timestamp for \"soils\" to the single date \"15 sep 1987\".\n r.timestamp map=soils date='15 sep 1987'\n Sets the timestamp for \"soils\" to have the start date \"15 sep 1987\"\n and the end date \"20 feb 1988\".\n r.timestamp map=soils date='15 sep 1987/20 feb 1988'\n Sets the timestamp for \"soils\" to have the start date \"18 feb 2005\n 10:30:00\" and the end date \"20 jul 2007 20:30:00\".\n r.timestamp map=soils date='18 feb 2005 10:30:00/20 jul 2007 20:30:00'\n Removes the timestamp for the \"soils\" raster map.\n r.timestamp map=soils date=none\n  KNOWN ISSUES \n Spaces in the timestamp value are required.\n ", "see_also": ["r.info", "r3.timestamp", "v.timestamp"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.timestamp"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.tileset.html", "name": "r.tileset", "definition": "- Produces tilings of the source projection for use in the destination region and projection.", "keywords": ["raster", "tiling"], "synopsis": "r.tileset [-gw]  [region=string]  sourceproj=string  [sourcescale=string]   [destproj=string]   [destscale=string]   [maxcols=integer]   [maxrows=integer]   [overlap=integer]   [separator=character]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Produces shell script output Produces web map server query string output Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Produces web map server query string output Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "region", "flag": "region", "dataType": "String", "optional": true, "explanation": "Name of region to use instead of current region for bounds and resolution", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sourceproj", "flag": "sourceproj", "dataType": "String", "optional": false, "explanation": "Source projection", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sourcescale", "flag": "sourcescale", "dataType": "String", "optional": true, "explanation": "Conversion factor from units to meters in source projection", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "destproj", "flag": "destproj", "dataType": "String", "optional": true, "explanation": "Destination projection, defaults to this location's projection", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "destscale", "flag": "destscale", "dataType": "String", "optional": true, "explanation": "Conversion factor from units to meters in source projection", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxcols", "flag": "maxcols", "dataType": "String", "optional": true, "explanation": "Maximum number of columns for a tile in the source projection", "defaultValue": "1024", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxrows", "flag": "maxrows", "dataType": "String", "optional": true, "explanation": "Maximum number of rows for a tile in the source projection", "defaultValue": "1024", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "overlap", "flag": "overlap", "dataType": "String", "optional": true, "explanation": "Number of cells tiles should overlap in each direction", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.tileset  generates sets of tiles in another projection that\n cover a region in this projection with adequate resolution. By default\n the current region and its resolution are used, the bounds and\n resolution of another region can be used via the region option.\n ", "notes": "\n  r.tileset  does not make \"optimal\" tilings (as few tiles of\n the largest size less than the maximums). This means that from\n latitude longitude projection to an appropriate projection for a\n region, in the degenerate case, it may create tiles demanding up to\n twice the necessary information. Furthermore, generating a tiling near\n a divergant point of a source projection, such as the poles of a\n cylindrical source projections, results in divergence of the tile set.\n Not generating \"optimal\" tilings may have another consequence; the\n aspect ratio of cells in the destination region will not necessarily\n carry over to the source region and generated tiles may have cells of\n strange aspect ratios. This might be a problem for some map request\n services presenting data in an inappropriate projection or with strict\n constraints on cell aspect ratio.\n  OUTPUT FORMAT \n Each tile is listed on a separate line in the output. The lines are\n formatted as follows:\n 5|125|45|175|80|100\n  This is the default output format. It is the tile's minimum x\n coordinate, minimum y coordinate, maximum x coordinate, maximum y\n coordinate, width in cells, and height in cells separated by the \"|\"\n character. The fields can be separated by a different character by\n changing the fs option.\n w=5;s=125;e=45;n=175;cols=80;rows=100;\n  This is output in a format convinent for setting variables in a shell\n script.\n bbox=5,125,45,175&width=80&height=100\n  This is output in a format convinent for requesting data from some\n http services.\n ", "see_also": [], "authors": ["Cedric Shock"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r.tileset"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.tile.html", "name": "r.tile", "definition": "- Splits a raster map into tiles.", "keywords": ["raster", "tiling"], "synopsis": "r.tile input=name output=string width=integer height=integer  [overlap=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output base name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": false, "explanation": "Width of tiles (columns)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "height", "flag": "height", "dataType": "String", "optional": false, "explanation": "Height of tiles (rows)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "overlap", "flag": "overlap", "dataType": "String", "optional": true, "explanation": "Overlap of tiles", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.tile  retiles an existing raster map with user defined \n x and y tile size.\n ", "notes": "\n  r.tile  generates a separate raster for each tile.\n This is equivalent to running  g.region  along with\n  r.resample  in a double loop.\n The module can be used to split a large raster map into smaller\n tiles, e.g. for further parallelized analysis on a cluster computing\n system.\n The overlap is defined in rows/columns.\n  EXAMPLE \n Retiling example for the North Carolina DEM:\n g.region raster=elevation -p\n # rows:       1350\n # cols:       1500\n # generating 2 x 2 = 4 tiles (width=1500/2, height=rows/2)\n r.tile input=elevation output=elev_tile width=750 height=675\n creates 4 tiles with the prefix  elev_tile  (named:\n elev_tile-000-000, elev_tile-000-001, elev_tile-001-000, ...).\n ", "see_also": ["g.region", "r3.retile"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.tile"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.thin.html", "name": "r.thin", "definition": "- Thins non-null cells that denote linear features in a raster map layer.", "keywords": ["raster", "geometry"], "synopsis": "r.thin input=name output=name  [iterations=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "iterations", "flag": "iterations", "dataType": "String", "optional": true, "explanation": "Maximal number of iterations", "defaultValue": "200", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.thin  scans the named  input  raster map layer and \n thins non-NULL cells that denote linear features into linear features \n having a single cell width. Raster lines often need to be thinned \n (skeletonizing raster features) to a single pixel width before they can \n be transformed to vector data.\n  r.thin  will thin only the non-NULL (no data) raster cells\n of the named  input  raster map layer within the current\n geographic region settings.  The cell width of the thinned\n  output  raster map layer will be equal to the cell\n resolution of the currently set geographic region.  All of\n the thinned linear features will have the width of a single\n cell.\n  r.thin  will create a new  output  raster\n data file containing the thinned linear features.\n  r.thin  assumes that linear features are encoded\n with positive values on a background of NULL's in the\n  input  raster data file, hence it creates a NULL/1\n output map.\n ", "notes": "\n  r.thin  only creates raster map layers. In order to\n create a vector map, the user will need to run \n  r.to.vect \n on the resultant raster map.\n  r.thin  may create small spurs or \"dangling lines\"\n during the thinning process.  These spurs may be removed\n (after creating a vector map layer) by\n  v.clean  ( rmdangle \n tool).\n This code implements the thinning algorithm described in\n \"Analysis of Thinning Algorithms Using Mathematical\n Morphology\" by Ben-Kwei Jang and Ronlad T. Chin in\n  Transactions on Pattern Analysis and Machine\n Intelligence , vol. 12, No. 6, June 1990.  The\n definition Jang and Chin give of the thinning process is\n \"successive removal of outer layers of pixels from an\n object while retaining any pixels whose removal would alter\n the connectivity or shorten the legs of the sceleton.\"\n The sceleton is finally thinned when the thinning process\n converges; i.e., \"no further pixels can be removed without\n altering the connectivity or shortening the sceleton legs\"\n (p. 541).  The authors prove that the thinning process\n described always converges and produces one-pixel thick\n sceletons.  The number of iterations depends on the\n original thickness of the object.  Each iteration peels off\n the outside pixels from the object.  Therefore, if the\n object is <= n pixels thick, the algorithm should\n converge in <= iterations.\n  EXAMPLE \n To vectorize the raster map  streams_derived  in the North \n Carolina sample dataset that represents the stream network derived from \n the 10m resolution DEM by  r.watershed , run:\n g.region raster=elevation -p\n # create flow accumulation map\n r.watershed elevation=elevation accumulation=accum_50K thresh=50000\n # extract streams from flow accumulation map\n r.mapcalc \"streams_from_flow = if(abs(accum_50K) > 1000, 1, null())\"\n # skeletonize map\n r.thin streams_from_flow out=streams_thin\n d.mon wx0\n d.rast streams_from_flow\n d.erase\n d.rast streams_thin\n  \n Raster feature thinning (skeletonizing)\n The resulting map cabe optionally vectorized:\n r.to.vect streams_thin output=streams_thin type=line\n # visualize\n d.rast accum_50K\n d.vect streams_thin color=red width=2\n  \n Vectorized stream network after thinning extracted from flow accumulation map\n ", "see_also": ["g.region", "r.to.vect", "v.clean", "wxGUI vector digitizer", "v.build"], "authors": ["Olga Waupotitsch, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.thin"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.texture.html", "name": "r.texture", "definition": "- Generate images with textural features from a raster map.", "keywords": ["raster", "algebra", "statistics", "texture"], "synopsis": "r.texture [-san] input=name output=basename  [size=value]   [distance=value]   [method=string[,string,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Separate output for each angle (0, 45, 90, 135) Angles are counterclockwise from east: 0 is East to West, 45 is North-East to South-West Calculate all textural measurements Allow NULL cells in a moving window This will also avoid cropping along edges of the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Calculate all textural measurements Allow NULL cells in a moving window This will also avoid cropping along edges of the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Allow NULL cells in a moving window This will also avoid cropping along edges of the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output basename raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "The size of moving window (odd and >= 3)", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": true, "explanation": "The distance between two samples (>= 1)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Textural measurement method", "defaultValue": null, "alternatives": ["asm", "contrast", "corr", "var", "idm", "sa", "sv", "se", "entr", "dv", "de", "moc1", "moc2"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.texture  creates raster maps with textural features from a\n user-specified raster map layer. The module calculates textural features \n based on spatial dependence matrices at 0, 45, 90, and 135 \n degrees.\n In order to take into account the scale of the texture to be measured,\n  r.texture  allows the user to define the  size  of the moving\n window and the  distance  at which to compare pixel grey values.  By\n default the module averages the results over the 4 orientations, but the user\n can also request output of the texture variables in 4 different orientations\n (flag  -s ). Please note that angles are defined in degrees of east and\n they increase counterclockwise, so 0 is East - West, 45 is North-East -\n South-West, 90 is North - South, 135 is North-West - South-East.\n The user can either chose one or several texture measures (see below for their\n description) using the  method  parameter, or can request the creating\n of maps for all available methods with the  -a .\n  r.texture  assumes grey levels ranging from 0 to 255 as input.  The\n input is automatically rescaled to 0 to 255 if the input map range is outside of\n this range.  In order to reduce noise in the input data (thus generally\n reinforcing the textural features), and to speed up processing, it is\n recommended that the user recode the data using equal-probability quantization.\n Quantization rules for  r.recode  can be generated with  r.quantile\n -r  using e.g 16 or 32 quantiles (see example below).\n ", "notes": "\n Texture is a feature of specific land cover classes in satellite imagery.\n It is particularly useful in situations where spectral differences between\n classes are small, but classes are distinguishable by their organisation on the \n ground, often opposing natural to human-made spaces: cultivated fields vs meadows\n or golf courses, palm tree plantations vs natural rain forest, but texture can\n also be a natural phenomen: dune fields, different canopies due to different\n tree species. The usefulness and use of texture is highly dependent on the \n resolution of satellite imagery and on the scale of the human intervention or \n the phenomenon that created the texture (also see the discussion of scale \n dependency below). The user should observe the phenomenon visually in order to\n determine an adequat setting of the  size  parameter.\n The output of  r.texture  can constitute very useful additional variables \n as input for image classification or image segmentation (object recognition). \n It can be used in supervised classification algorithms such as \n  i.maxlik  or  i.smap ,\n or for the identification of objects in  i.segment ,\n and/or for the characterization of these objects and thus, for example, as one \n of the raster inputs of the \n \ti.segment.stats  addon.\n In general, several variables constitute texture: differences in grey level values,\n coarseness as scale of grey level differences, presence or lack of directionality\n and regular patterns. A texture can be characterized by tone (grey level intensity\n properties) and structure (spatial relationships). Since textures are highly scale\n dependent, hierarchical textures may occur.\n  r.texture  uses the common texture model based on the so-called grey \n level co-occurrence matrix as described by Haralick et al (1973). This matrix \n is a two-dimensional histogram of grey levels for a pair of pixels which are \n separated by a fixed spatial relationship. The matrix approximates the joint \n probability distribution of a pair of pixels. Several texture measures are \n directly computed from the grey level co-occurrence matrix. \n The following part offers brief explanations of the Haralick et al texture \n measures (after Jensen 1996).\n  First-order statistics in the spatial domain \n   Sum Average (SA) \n   Entropy (ENT):\n  This measure analyses the randomness. It is high when the values of the\n  moving window have similar values. It is low when the values are close\n  to either 0 or 1 (i.e. when the pixels in the local window are uniform). \n   Difference Entropy (DE) \n   Sum Entropy (SE) \n   Variance (VAR):\n   A measure of gray tone variance within the moving window (second-order\n moment about the mean) \n   Difference Variance (DV) \n   Sum Variance (SV) \n Note that measures \"mean\", \"kurtosis\", \"range\", \"skewness\", and \"standard\n deviation\" are available in  r.neighbors .\n  Second-order statistics in the spatial domain \n The second-order statistics texture model is based on the so-called grey\n level co-occurrence matrices (GLCM; after Haralick 1979).\n   Angular Second Moment (ASM, also called Uniformity):\n  This is a measure of local homogeneity and the opposite of Entropy.\n  High values of ASM occur when the pixels in the moving window are\n  very similar.\n   \n  Note: The square root of the ASM is sometimes used as a texture measure,\n  and is called Energy. \n   Inverse Difference Moment (IDM, also called Homogeneity):\n  This measure relates inversely to the contrast measure. It is a direct measure of the\n  local homogeneity of a digital image. Low values are associated with low homogeneity\n  and vice versa. \n   Contrast (CON):\n  This measure analyses the image contrast (locally gray-level variations) as\n  the linear dependency of grey levels of neighboring pixels (similarity). Typically high,\n  when the scale of local texture is larger than the  distance . \n   Correlation (COR):\n  This measure  analyses the linear dependency of grey levels of neighboring\n  pixels. Typically high, when the scale of local texture is larger than the\n   distance . \n   Information Measures of Correlation (MOC) \n   Maximal Correlation Coefficient (MCC) \n The computational region should be set to the input map with \n  g.region raster=<input map> , or aligned to the input map \n with  g.region align=<input map>  if only a subregion \n should be analyzed.\n Note that the output of  r.texture  will always be smaller than \n the current region as only cells for which there are no null cells and \n for which all cells of the moving window are within the current region \n will contain a value. The output will thus appear cropped at the margins.\n Importantly, the input raster map cannot have more than 255 categories.\n  EXAMPLE \n Calculation of Angular Second Moment of B/W orthophoto (North Carolina data set):\n g.region raster=ortho_2001_t792_1m -p\n # set grey level color table 0% black 100% white\n r.colors ortho_2001_t792_1m color=grey\n # extract grey levels\n r.mapcalc \"ortho_2001_t792_1m.greylevel = ortho_2001_t792_1m\"\n # texture analysis\n r.texture ortho_2001_t792_1m.greylevel prefix=ortho_texture method=asm -s \n # display\n g.region n=221461 s=221094 w=638279 e=638694\n d.shade color=ortho_texture_ASM_0 shade=ortho_2001_t792_1m\n This calculates four maps (requested texture at four orientations):\n ortho_texture_ASM_0, ortho_texture_ASM_45, ortho_texture_ASM_90, ortho_texture_ASM_135.\n Reducing the number of gray levels (equal-probability quantizing):\n g.region -p raster=ortho_2001_t792_1m\n # enter as one line or with \n  r.quantile input=ortho_2001_t792_1m quantiles=16 -r | r.recode \n             input=ortho_2001_t792_1m output=ortho_2001_t792_1m_q16 rules=-\n The recoded raster map can then be used as input for  r.texture  as before.\n Second example: analysis of IDM (homogeneity) on a simple raster with \n North-South line pattern.\n # import raster\n r.in.ascii in=- output=lines << EOF\n north: 9\n south: 0\n east: 9\n west: 0\n rows: 9\n cols: 9\n 0 0 0 1 0 0 0 1 0\n 0 0 0 1 0 0 0 1 0\n 0 0 0 1 0 0 0 1 0\n 0 0 0 1 0 0 0 1 0\n 0 0 0 1 0 0 0 1 0\n 0 0 0 1 0 0 0 1 0\n 0 0 0 1 0 0 0 1 0\n 0 0 0 1 0 0 0 1 0\n 0 0 0 1 0 0 0 1 0\n EOF\n # adjust region to raster\n g.region raster=lines\n # calculate IDM (homogeneity) in all directions\n r.texture -s lines method=idm output=text_lines\n The following image shows the original map, the result in East-West direction\n and the result in North-South direction, showing how texture can depend on\n direction, with texture perfectly homogeneous (value=1) in the North-South \n direction, but quite heterogeneous in East-West direction, except for those \n areas where there are three columns of equal values (as size=3). \n The overlayed grid highlights that the texture measures output maps\n are cropped at the margins.\n \t \n \t IDM textures according to direction \n  KNOWN ISSUES \n The program can run incredibly slow for large raster maps and large \n moving windows ( size  option).\n  REFERENCES \n The algorithm was implemented after Haralick et al., 1973 and 1979.\n The original code was taken by permission from  pgmtexture , part of\n PBMPLUS (Copyright 1991, Jef Poskanser and Texas Agricultural Experiment\n Station, employer for hire of James Darrell McCauley). Manual page \n of  pgmtexture .\n Over the years, the source code of  r.texture  was further improved.\n   \n  Haralick, R.M., K. Shanmugam, and I. Dinstein (1973). Textural features for\n     image classification.  IEEE Transactions on Systems, Man, and\n     Cybernetics , SMC-3(6):610-621. \n  Bouman, C. A., Shapiro, M. (1994). A Multiscale Random Field Model for\n  Bayesian Image Segmentation, IEEE Trans. on Image Processing, vol. 3, no. 2. \n  Jensen, J.R. (1996). Introductory digital image processing. Prentice Hall.\n   ISBN 0-13-205840-5  \n  Haralick, R. (May 1979).  Statistical and structural approaches to texture ,\n    Proceedings of the IEEE, vol. 67, No.5, pp. 786-804 \n  Hall-Beyer, M. (2007).  The GLCM Tutorial Home Page \n   (Grey-Level Co-occurrence Matrix texture measurements). University of Calgary, Canada\n ", "see_also": ["i.maxlik", "i.gensig", "i.smap", "i.gensigset", "i.segment.stats", "i.pca", "r.neighbors", "r.rescale"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.texture"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.terraflow.html", "name": "r.terraflow", "definition": "- Performs flow computation for massive grids.", "keywords": ["raster", "hydrology", "flow", "accumulation", "sink"], "synopsis": "r.terraflow [-s] elevation=name  [filled=name]   [direction=name]   [swatershed=name]   [accumulation=name]   [tci=name]   [d8cut=float]   [memory=integer]   [directory=string]   [stats=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "SFD (D8) flow (default is MFD) SFD: single flow direction, MFD: multiple flow direction Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "filled", "flag": "filled", "dataType": "String", "optional": true, "explanation": "Name for output filled (flooded) elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "direction", "flag": "direction", "dataType": "String", "optional": true, "explanation": "Name for output flow direction raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "swatershed", "flag": "swatershed", "dataType": "String", "optional": true, "explanation": "Name for output sink-watershed raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "accumulation", "flag": "accumulation", "dataType": "String", "optional": true, "explanation": "Name for output flow accumulation raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "tci", "flag": "tci", "dataType": "String", "optional": true, "explanation": "Name for output topographic convergence index (tci) raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "d8cut", "flag": "d8cut", "dataType": "String", "optional": true, "explanation": "Routing using SFD (D8) direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used (in MB)", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "directory", "flag": "directory", "dataType": "String", "optional": true, "explanation": "Directory to hold temporary files (they can be large)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stats", "flag": "stats", "dataType": "String", "optional": true, "explanation": "Name for output file containing runtime statistics", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.terraflow  takes as input a raster digital elevation\n model (DEM) and computes the flow direction raster and the flow\n accumulation raster, as well as the flooded elevation raster,\n sink-watershed raster (partition into watersheds around sinks) and TCI\n (topographic convergence index) raster maps.\n  r.terraflow  computes these rasters using well-known\n approaches, with the difference that its emphasis is on the\n computational complexity of the algorithms, rather than on modeling\n realistic flow.   r.terraflow  emerged from the necessity of\n having scalable software able to process efficiently very large\n terrains.  It is based on theoretically optimal algorithms developed\n in the framework of I/O-efficient algorithms.   r.terraflow \n was designed and optimized especially for massive grids and is able to\n process terrains which were impractical with similar functions\n existing in other GIS systems.\n  Flow directions are computed using either the MFD (Multiple Flow\n Direction) model or the SFD (Single Flow Direction, or D8) model,\n illustrated below. Both methods compute downslope flow directions by\n inspecting the 3-by-3 window around the current cell. The SFD method\n assigns a unique flow direction towards the steepest downslope\n neighbor. The MFD method assigns multiple flow directions towards all\n downslope neighbors.\n   \n    \n    \n   \n   \n    Flow direction to steepest  downslope neighbor (SFD). \n    Flow direction to all  downslope neighbors (MFD). \n   \n  The SFD and the MFD method cannot compute flow directions for\n cells which have the same height as all their neighbors (flat areas)\n or cells which do not have downslope neighbors (one-cell pits).\n    On plateaus (flat areas that spill out)  r.terraflow \n routes flow so that globally the flow goes towards the spill cells of\n the plateaus.\n    On sinks (flat areas that do not spill out, including one-cell\n pits)  r.terraflow  assigns flow by flooding the terrain until\n all the sinks are filled and assigning flow directions on the filled\n terrain.\n  In order to flood the terrain,  r.terraflow  identifies all\n sinks and partitions the terrain into sink-watersheds (a\n sink-watershed contains all the cells that flow into that sink),\n builds a graph representing the adjacency information of the\n sink-watersheds, and uses this sink-watershed graph to merge\n watersheds into each other along their lowest common boundary until\n all watersheds have a flow path outside the terrain. Flooding produces\n a sink-less terrain in which every cell has a downslope flow path\n leading outside the terrain and therefore every cell in the terrain\n can be assigned SFD/MFD flow directions as above.\n  Once flow directions are computed for every cell in the terrain,\n  r.terraflow  computes flow accumulation by routing water using\n the flow directions and keeping track of how much water flows through\n each cell.\n  If flow accumulation of a cell is larger than the value given by the\n  d8cut  option, then\n the flow of this cell is routed to its neighbors using the SFD (D8)\n model. This option affects only the flow accumulation raster and is\n meaningful only for MFD flow (i.e. if the  -s  flag is not used); If\n this option is used for SFD flow it is ignored. The default value of\n  d8cut  is  infinity .\n  r.terraflow  also computes the  tci  raster (topographic convergence\n index, defined as the logarithm of the ratio of flow accumulation and\n local slope).\n  For more details on the algorithms see [1,2,3] below.\n ", "notes": "\n One of the techniques used by  r.terraflow  is the\n space-time trade-off. In particular, in order to avoid searches, which\n are I/O-expensive,  r.terraflow  computes and works with an\n augmented elevation raster in which each cell stores relevant\n information about its 8 neighbors, in total up to 80B per cell.  As a\n result  r.terraflow  works with intermediate temporary files\n that may be up to 80N bytes, where N is the number of cells (rows x\n columns) in the elevation raster (more precisely, 80K bytes, where K\n is the number of valid (not no-data) cells in the input elevation\n raster).\n  All these intermediate temporary files are stored in the path specified\n by the  directory  option. Note:  directory  must contain\n enough free disk space in order to store up to 2 x 80N bytes.\n  The  memory  option can be used to set the maximum amount of main\n memory (RAM) the module will use during processing. In practice its\n  value  should be an underestimate of the amount of available\n (free) main memory on the machine.  r.terraflow  will use at\n all times at most this much memory, and the virtual memory system\n (swap space) will never be used. The default value is 300 MB.\n  The  stats  option defines the name of the file that contains the\n statistics (stats) of the run.\n  r.terraflow  has a limit on the number of rows and columns\n (max 32,767 each).\n  The internal type used by  r.terraflow  to store elevations\n can be defined at compile-time. By default,  r.terraflow  is\n compiled to store elevations internally as floats. Other versions can be\n created by the user if needed.\n  Hints concerning compilation with storage of elevations internally as\n shorts: such a version uses less space (up to 60B per cell, up\n to 60N intermediate file) and therefore is more space and time\n efficient.  r.terraflow  is intended for use with floating\n point raster data (FCELL), and  r.terraflow (short)  with integer\n raster data (CELL) in which the maximum elevation does not exceed the\n value of a short SHRT_MAX=32767 (this is not a constraint for any\n terrain data of the Earth, if elevation is stored in meters).\n Both  r.terraflow  and  r.terraflow (short)  work with\n input elevation rasters which can be either integer, floating point or\n double (CELL, FCELL, DCELL). If the input raster contains a value that\n exceeds the allowed internal range (short for\n  r.terraflow (short) , float for  r.terraflow ), the\n program exits with a warning message. Otherwise, if all values in the\n input elevation raster are in range, they will be converted\n (truncated) to the internal elevation type (short for\n  r.terraflow (short) , float for  r.terraflow ). In this\n case precision may be lost and artificial flat areas may be created.\n For instance, if  r.terraflow (short)  is used with floating\n point raster data (FCELL or DCELL), the values of the elevation will\n be truncated as shorts. This may create artificial flat areas, and the\n output of  r.terraflow (short)  may be less realistic than those\n of  r.terraflow  on floating point raster data.\n The outputs of  r.terraflow (short)  and  r.terraflow  are\n identical for integer raster data (CELL maps).\n  EXAMPLES \n Example for small area in North Carolina sample dataset to calculate flow accumulation:\n g.region raster=elev_lid792_1m\n r.terraflow elevation=elev_lid792_1m accumulation=elev_lid792_1m_accumulation\n  Flow accumulation \n Spearfish sample data set:\n g.region raster=elevation.10m -p\n r.terraflow elev=elevation.10m filled=elevation10m.filled \n      dir=elevation10m.mfdir swatershed=elevation10m.watershed \n      accumulation=elevation10m.accu tci=elevation10m.tci\n g.region raster=elevation.10m -p\n r.terraflow elev=elevation.10m filled=elevation10m.filled \n      dir=elevation10m.mfdir swatershed=elevation10m.watershed \n      accumulation=elevation10m.accu tci=elevation10m.tci d8cut=500 memory=800 \n      stats=elevation10mstats.txt \n  REFERENCES \n     The  TerraFlow  project at Duke University\n    \n        I/O-efficient algorithms for problems on grid-based\n        terrains .  Lars Arge, Laura Toma, and Jeffrey S. Vitter. In\n         Proc. Workshop on Algorithm Engineering and Experimentation ,\n        2000. To appear in  Journal of Experimental Algorithms .\n        \n    \n        Flow computation on massive grids .\n        Lars Arge, Jeffrey S. Chase, Patrick N. Halpin, Laura Toma,\n        Jeffrey S. Vitter, Dean Urban and Rajiv Wickremesinghe. In\n         Proc. ACM Symposium on Advances in Geographic Information\n        Systems , 2001.\n        \n    \n        Flow computation on massive grid terrains .\n        Lars Arge, Jeffrey S. Chase, Patrick N. Halpin, Laura Toma,\n        Jeffrey S. Vitter, Dean Urban and Rajiv Wickremesinghe.\n        In  GeoInformatica, International Journal on\n        Advances of Computer Science for Geographic Information\n        Systems , 7(4):283-313, December 2003.\n ", "see_also": ["r.flow", "r.basins.fill", "r.drain", "r.topidx", "r.topmodel", "r.water.outlet", "r.watershed"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.terraflow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.surf.random.html", "name": "r.surf.random", "definition": "- Produces a raster surface map of uniform random deviates with defined range.", "keywords": ["raster", "surface", "random"], "synopsis": "r.surf.random [-i] output=name  [min=integer]   [max=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Create an integer raster map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "min", "flag": "min", "dataType": "String", "optional": true, "explanation": "Minimum random value", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max", "flag": "max", "dataType": "String", "optional": true, "explanation": "Maximum random value", "defaultValue": "100", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.surf.random  produces a raster map layer of uniform random deviates\n whose range can be expressed by the user. It is essentialy the same as\n  r.surf.gauss , but uses a linear random number generator instead.\n It uses the random number generator drand48() or rand() ,\n depending on the user's platform.\n  Histogram of map generated with r.surf.random \n  EXAMPLE \n g.region -p n=228500 s=215000 w=630000 e=645000 res=10\n r.surf.random out=random min=0 max=100\n # check result\n r.univar random\n ", "notes": "", "see_also": ["r.random.surface", "r.surf.contour", "r.surf.fractal", "r.surf.gauss", "r.surf.idw", "v.surf.rst"], "authors": ["Jo Wood"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.surf.random"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.surf.idw.html", "name": "r.surf.idw", "definition": "- Provides surface interpolation from raster point data by Inverse Distance Squared Weighting.", "keywords": ["raster", "surface", "interpolation", "IDW"], "synopsis": "r.surf.idw [-e] input=name output=name  [npoints=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Output is the interpolation error Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "npoints", "flag": "npoints", "dataType": "String", "optional": true, "explanation": "Number of interpolation points", "defaultValue": "12", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.surf.idw  fills a grid cell (raster) matrix with\n interpolated values generated from input raster\n data points. It uses a numerical approximation technique\n based on distance squared weighting of the values of\n nearest data points. The number of nearest data points used\n to determined the interpolated value of a cell can be\n specified by the user (default: 12 nearest data points).\n If there is a current working mask, it applies to the output \n raster map. Only those cells falling within the mask will be \n assigned interpolated values. The search procedure for the \n selection of nearest neighboring points will consider all \n input data, without regard to the mask. \n The  -e  flag is the error analysis option that interpolates values\n only for those cells of the input raster map which have non-zero values and\n outputs the difference (see  NOTES  below).\n  The  npoints  parameter defines the number of nearest data points used\n to determine the interpolated value of an output raster cell.\n ", "notes": "\n  r.surf.idw  is a surface generation utility which\n uses inverse distance squared weighting (as described in\n  Applied Geostatistics  by E. H. Isaaks and R. M.\n Srivastava, Oxford University Press, 1989) to assign\n interpolated values. The implementation includes a\n customized data structure somewhat akin to a sparse matrix\n which enhances the efficiency with which nearest data\n points are selected.  For latitude/longitude projections,\n distances are calculated from point to point along a\n geodesic.\n Unlike  r.surf.idw2  (addon),\n which processes all input data points in each interpolation cycle,  r.surf.idw \n attempts to minimize the number of input data for which distances must be\n calculated. Execution speed is therefore a function of the search effort,\n and does not increase appreciably with the number of input data points.\n  r.surf.idw  will generally outperform \n  r.surf.idw2  except when the input data\n layer contains few non-zero data, i.e. when the cost of the search exceeds\n the cost of the additional distance calculations performed by \n  r.surf.idw2 . The relative performance\n of these utilities will depend on the comparative speed of boolean, integer\n and floating point operations on a particular platform.\n Worst case search performance by  r.surf.idw  occurs\n when the interpolated cell is located outside of the region\n in which input data are distributed. It therefore behooves\n the user to employ a mask when geographic region boundaries\n include large areas outside the general extent of the input\n data.\n The degree of smoothing produced by the interpolation will\n increase relative to the number of nearest data points\n considered.  The utility may be used with regularly or\n irregularly spaced input data.  However, the output result\n for the former may include unacceptable nonconformities in\n the surface pattern.\n The  -e  flag option provides a standard\n surface-generation error analysis facility. It produces an output raster map\n of the difference of interpolated values minus input values for those cells\n whose input data are non-zero. For each interpolation cycle, the known value\n of the cell under consideration is ignored, and the remaining input values\n are used to interpolate a result. The output raster map may be compared to\n the input raster map to analyze the distribution of interpolation error.\n This procedure may be helpful in choosing the number of nearest neighbors\n considered for surface generation.\n  KNOWN ISSUES \n Module  r.surf.idw  works only for integer (CELL) raster maps.\n ", "see_also": ["r.surf.contour", "r.surf.gauss", "r.surf.fractal", "r.surf.random", "v.surf.idw", "v.surf.rst"], "authors": ["Greg Koerper"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.surf.idw"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.surf.gauss.html", "name": "r.surf.gauss", "definition": "- Generates a raster map using gaussian random number generator.", "keywords": ["raster", "surface", "random"], "synopsis": "r.surf.gauss output=name  [mean=float]   [sigma=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "mean", "flag": "mean", "dataType": "String", "optional": true, "explanation": "Distribution mean", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sigma", "flag": "sigma", "dataType": "String", "optional": true, "explanation": "Standard deviation", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.surf.gauss  produces a raster map of Gaussian deviates whose\n mean and standard deviation can be expressed by the user. It uses a\n Gaussian random number generator. It is essentialy the same\n as  r.surf.random , but uses a\n Gaussian random number generator instead.\n  Histogram of map generated with r.surf.gauss (mean=0, sigma=10) \n  EXAMPLE \n g.region -p n=228500 s=215000 w=630000 e=645000 res=10\n r.surf.gauss out=gauss mean=0 sigma=10\n # check result\n r.univar gauss\n ", "notes": "", "see_also": ["r.surf.contour", "r.surf.fractal", "r.surf.idw", "r.surf.random", "v.surf.rst"], "authors": ["Jo Wood,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.surf.gauss"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.surf.fractal.html", "name": "r.surf.fractal", "definition": "- Creates a fractal surface of a given fractal dimension.", "keywords": ["raster", "surface", "fractal"], "synopsis": "r.surf.fractal output=name  [dimension=float]   [number=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "dimension", "flag": "dimension", "dataType": "String", "optional": true, "explanation": "Fractal dimension of surface (2 < D < 3)", "defaultValue": "2.05", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "number", "flag": "number", "dataType": "String", "optional": true, "explanation": "Number of intermediate images to produce", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.surf.fractal  creates a fractal surface of a given fractal\n dimension. It uses the spectral synthesis method. The module can create\n intermediate layers showing the build up of different spectral coefficients\n (see Saupe, pp.106-107 for an example of this).\n This module generates naturally looking synthetical elevation models\n (DEM).\n ", "notes": "\n This module requires the  FFTW library \n for computing Discrete Fourier Transforms.\n  EXAMPLE \n Generate surface using fractals in selected region, set color table and\n display with shade.\n g.region -p raster=elevation\n r.surf.fractal output=fractals\n r.colors map=fractals color=byr\n r.relief input=fractals output=fractals_shade\n d.mon wx0\n d.shade shade=fractals_shade color=fractals b=50\n Artificial surface created with fractals \n Compare results when using different fractal dimensions:\n # D=2.0005\n g.region -dp\n r.surf.fractal out=dem_d2_0005 dim=2.0005\n r.info -r dem_d2_0005\n r.mapcalc \"dem_d2_0005_final = 1.0 * dem_d2_0005 + abs(min(dem_d2_0005))\"\n r.colors dem_d2_0005_final color=terrain\n r.slope.aspect dem_d2_0005_final aspect=dem_d2_0005_final_as\n # D=2.90\n r.surf.fractal out=dem_d2_90 dim=2.90\n r.info -r dem_d2_90\n r.mapcalc \"dem_d2_90_final = 1.0 * dem_d2_90 + abs(min(dem_d2_90))\"\n r.colors dem_d2_90_final color=terrain\n r.slope.aspect dem_d2_90_final aspect=dem_d2_90_final_as\n  \n Artificial DEMs created with fractals: \n top: fractal dimension d=2.0005 (left: elevation map, right: aspect map) \n top: fractal dimension d=2.90 (left: elevation map, right: aspect map)\n  REFERENCES \n Saupe, D. (1988) Algorithms for random fractals, in Barnsley M., \n  Devaney R., Mandelbrot B., Peitgen, H-O., Saupe D., and Voss R.\n  (1988) The Science of Fractal Images, Ch. 2, pp.71-136. London:\n  Springer-Verlag.\n ", "see_also": ["r.surf.contour", "r.surf.idw", "r.surf.gauss", "r.surf.random", "v.surf.idw", "v.surf.rst"], "authors": ["Jo Wood, Midlands Regional Research Laboratory (ASSIST), University of Leicester"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.surf.fractal"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.surf.contour.html", "name": "r.surf.contour", "definition": "- Generates surface raster map from rasterized contours.", "keywords": ["raster", "surface", "interpolation"], "synopsis": "r.surf.contour input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input raster map containing contours", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.surf.contour  creates a raster elevation map from a rasterized\n contour map.  Elevation values are determined using procedures similar\n to a manual methods.\n To determine the elevation of a point on a contour map, an individual\n might interpolate its value from those of the two nearest contour lines\n (uphill and downhill).\n  r.surf.contour  works in a similar way.  Initially, a vector map of\n the contour lines is made with the elevation of each line as an attribute.\n When the program  v.to.rast \n is run on the vector map, continuous \"lines\" of rasters containing the\n contour line values will be the input for  r.surf.contour . For each\n cell in the input map, either the cell is a contour line cell (which is\n given that value), or a flood fill is generated from that spot until the\n fill comes to two unique values. So the  r.surf.contour  algorithm\n  linearly interpolates  between contour lines. The flood fill\n is not allowed to cross over\n the rasterized contour lines, thus ensuring that an uphill and downhill\n contour value will be the two values chosen.   r.surf.contour \n interpolates from the uphill and downhill values by the true distance.\n  Parameters: \n  input= name  \n  Name of an existing raster map that contains a set of \n initial category values (i.e., some cells contain known elevation\n values (denoting contours) while the rest contain NULL values).\n  output= name  \n  Name to be assigned to new output raster map that represents\n a smooth (e.g., elevation) surface generated from\n the known category values in the input raster map layer.\n  An existing MASK raster map is respected for both reading  input \n and writing  output .\n ", "notes": "\n  r.surf.contour  works well under the following circumstances:\n 1) the contour lines extend to the the edge of the current region,\n 2) the program is run at the same resolution as that of the input map,\n 3) there are no disjointed contour lines,\n and 4) no spot elevation data BETWEEN contour lines exist.  Spot elevations at\n the tops of hills and the bottoms of depressions, on the other hand, improve\n the output greatly.\n Violating these constraints will cause non-intuitive anomalies to appear in\n the output map.  Run    r.slope.aspect \n   on  r.surf.contour  results to locate potential anomalies.\n  The running of  r.surf.contour  is very sensitive to the resolution of\n rasterized vector map.  If multiple contour lines go through the same raster,\n slight anomalies may occur.  The speed of  r.surf.contour  is dependent\n on how far \"apart\" the contour lines are from each other (as measured in\n raster cells).  Since a flood fill algorithm is used, the program's running\n time will grow exponentially with the distance between contour lines.\n  EXAMPLE \n Example to create contour lines from elevation model, then recreating DEM\n from these contour lines along with differences analysis (North Carolina\n sample data set):\n g.region raster=elevation -p\n # get minimum elevation value\n r.univar elevation\n # generate vector contour lines \n r.contour input=elevation output=contours_5m step=5 minlevel=50\n # rasterize contour lines\n v.info -c contours_5m\n v.to.rast input=contours_5m output=contours_5m use=attr attribute_column=level\n # generate DEM from rasterized contour lines\n r.surf.contour input=contours_5m output=elevation_from_cont5m\n # calculate difference map\n r.mapcalc \"diff = elevation - elevation_from_cont5m\"\n r.colors diff color=differences\n # analyze differences statistically\n r.univar diff\n ", "see_also": ["r.mapcalc", "r.slope.aspect", "r.surf.idw", "wxGUI vector digitizer", "v.surf.idw", "v.surf.rst", "v.to.rast"], "authors": ["Chuck Ehlschlaeger, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.surf.contour"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.surf.area.html", "name": "r.surf.area", "definition": "- Prints estimation of surface area for raster map.", "keywords": ["raster", "surface", "statistics", "area estimation"], "synopsis": "r.surf.area map=name  [vscale=float]   [units=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vscale", "flag": "vscale", "dataType": "String", "optional": true, "explanation": "Vertical scale", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Output units", "defaultValue": null, "alternatives": ["miles", "feet", "meters", "kilometers", "acres", "hectares"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.surf.area  calculates area of regular 3D triangulated points\n (centers of cells) in current region by adding areas of triangles.\n Therefore, area of a flat surface will be reported as ( rows + cols\n -1) * (area of cell)  less than area of flat region due to a half\n row and half column missing around the perimeter.\n ", "notes": "\n This calculation is heavily dependent on data resolution (think of it\n as a fractal shoreline problem, the more resolution the more detail,\n the more area, etc). This module uses the  current region\n settings , not the resolution of the raster map. This is especially\n important for surfaces with  NULL  values and highly irregular\n edges. The module does not [currently] attempt to correct for the\n error introduced by this  edge effect .\n  This version actually calculates area twice for each triangle pair,\n keeping a running minimum and maximum area depending on the direction\n of the diagonal used.\n  Reported totals are:\n  \"Plan\" area of  NULL  values within the current GRASS\n region \n  \"Plan\" area within calculation region ( rows-1 * cols-1 *\n cellarea ) \n  Average of the minimum and maximum calculated 3d triangle area\n within this region \n  \"Plan\" area within current computational region ( rows * cols *\n cellarea ) \n  Scaling of calculated area to current region \n   \n  r.surf.area  works best when the surface being evaluated\n extends to the edges of the current region and the cell resolution is\n small. Surfaces which are especially long and thin and have highly\n irregular boundaries will tend to have underestimated surface areas.\n Setting a high cell resolution (small area) will greatly reduce this\n impact, but will cause longer processing times.\n  EXAMPLES \n g.region -p raster=elevation\n r.surf.area map=elevation units=hectares\n Null value area ignored in calculation: 0.000000\n Plan area used in calculation: 20221.510000\n Surface area calculation(low, high, avg):\n         20294.310421 20320.936368 20307.623395\n Current region plan area: 20250.000000\n Estimated region Surface Area: 20336.234719\n ", "see_also": ["g.region", "r.surf.idw", "r.surf.fractal", "r.surf.gauss", "r.volume", "r.slope.aspect", "v.to.rast"], "authors": ["Bill Brown, USACERL December 21, 1994"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.surf.area"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.support.stats.html", "name": "r.support.stats", "definition": "- Update raster map statistics", "keywords": ["raster", "statistics"], "synopsis": "r.support.stats map=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.support.stats  allows the user to update raster map statistics \n information.\n ", "notes": "\n None\n ", "see_also": [], "authors": ["Micharl Shapiro, CERL: Original author"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.support.stats"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.support.html", "name": "r.support", "definition": "- Allows creation and/or modification of raster map layer support files.", "keywords": ["raster", "metadata"], "synopsis": "r.support [-snd] map=name  [title=phrase]   [history=phrase]   [units=string]   [vdatum=string]   [source1=phrase]   [source2=phrase]   [description=phrase]   [raster=string]   [loadhistory=name]   [savehistory=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Update statistics (histogram, range) Create/reset the null file Delete the null file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Create/reset the null file Delete the null file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Delete the null file Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title for resultant raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "history", "flag": "history", "dataType": "String", "optional": true, "explanation": "Text to append to the next line of the map's metadata file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Text to use for map data units", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vdatum", "flag": "vdatum", "dataType": "String", "optional": true, "explanation": "Text to use for map vertical datum", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "source1", "flag": "source1", "dataType": "String", "optional": true, "explanation": "Text to use for data source, line 1", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "source2", "flag": "source2", "dataType": "String", "optional": true, "explanation": "Text to use for data source, line 2", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "description", "flag": "description", "dataType": "String", "optional": true, "explanation": "Text to use for data description or keyword(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Raster map from which to copy category table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "loadhistory", "flag": "loadhistory", "dataType": "String", "optional": true, "explanation": "Text file from which to load history", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "savehistory", "flag": "savehistory", "dataType": "String", "optional": true, "explanation": "Text file in which to save history", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.support  allows the user to create and/or edit raster map support \n information. Editing of raster map color tables, category labels, header, \n history, and title is supported. Category labels can also be copied from\n another raster map.\n  EXAMPLES \n These examples are based on the North Carolina dataset, more specfically the  landuse  raster map.\n Copy the landuse map to the current mapset\n  g.copy raster=landuse,my_landuse\n  Update statistics \n  r.support -s map=my_landuse \n  Update Title \n  r.support map=my_landuse title=\"Landuse copied\"\n  Append to History Metadata \n  r.support map=my_landuse history=\"Copied from PERMANENT mapset\"\n  Update Units Display \n  r.support map=my_landuse units=meter\n ", "notes": "\n If metadata options such as  title  or  history  are given the\n module will run  non-interactively. If only the map name is given\n  r.support  will run interactively within a terminal shell and the\n user with be prompted for input.\n  Freeform metadata information is stored in a \" hist \" file which may be\n appended to by using the  history  option. Currently this is limited to\n 50 lines of text with a maximum line length of 78 characters. Any input\n larger than this will be wrapped to the next line.\n All other metadata strings available as standard options are limited to\n 79 characters.\n ", "see_also": ["r.category", "r.describe", "r.info", "r.null", "r.region", "r.report", "r.timestamp"], "authors": ["Micharl Shapiro, CERL: Original author"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.support"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.sunmask.html", "name": "r.sunmask", "definition": "- Calculates cast shadow areas from sun position and elevation raster map.", "keywords": ["raster", "solar", "sun position", "shadow"], "synopsis": "r.sunmask [-zsg] elevation=name  [output=name]   [altitude=float]   [azimuth=float]   [year=integer]   [month=integer]   [day=integer]   [hour=integer]   [minute=integer]   [second=integer]   [timezone=integer]   [east=value]   [north=value]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Do not ignore zero elevation Calculate sun position only and exit Print the sun position output in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Calculate sun position only and exit Print the sun position output in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print the sun position output in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "altitude", "flag": "altitude", "dataType": "String", "optional": true, "explanation": "Altitude of the sun in degrees above the horizon (A)", "defaultValue": null, "alternatives": ["0-89.999"], "isInputFile": false, "isOutputFile": false}, {"parameter": "azimuth", "flag": "azimuth", "dataType": "String", "optional": true, "explanation": "Azimuth of the sun in degrees from north (A)", "defaultValue": null, "alternatives": ["0-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "year", "flag": "year", "dataType": "String", "optional": true, "explanation": "Year (B)", "defaultValue": null, "alternatives": ["1950-2050"], "isInputFile": false, "isOutputFile": false}, {"parameter": "month", "flag": "month", "dataType": "String", "optional": true, "explanation": "Month (B)", "defaultValue": null, "alternatives": ["0-12"], "isInputFile": false, "isOutputFile": false}, {"parameter": "day", "flag": "day", "dataType": "String", "optional": true, "explanation": "Day (B)", "defaultValue": null, "alternatives": ["0-31"], "isInputFile": false, "isOutputFile": false}, {"parameter": "hour", "flag": "hour", "dataType": "String", "optional": true, "explanation": "Hour (B)", "defaultValue": null, "alternatives": ["0-24"], "isInputFile": false, "isOutputFile": false}, {"parameter": "minute", "flag": "minute", "dataType": "String", "optional": true, "explanation": "Minutes (B)", "defaultValue": null, "alternatives": ["0-60"], "isInputFile": false, "isOutputFile": false}, {"parameter": "second", "flag": "second", "dataType": "String", "optional": true, "explanation": "Seconds (B)", "defaultValue": "0", "alternatives": ["0-60"], "isInputFile": false, "isOutputFile": false}, {"parameter": "timezone", "flag": "timezone", "dataType": "String", "optional": true, "explanation": "Timezone", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "east", "flag": "east", "dataType": "String", "optional": true, "explanation": "Easting coordinate (point of interest)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "north", "flag": "north", "dataType": "String", "optional": true, "explanation": "Northing coordinate (point of interest)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.sunmask  creates an output map layer based on an input elevation\n raster map layer and the sun position. The output map layer contains the\n cast shadow areas arising from sun shine and elevations. The user can define\n the sun position either directly or the module calculates it from given\n location and date/time parameters using the\n  NREL  sun position algorithm. So either\n \"A:\"-parameters to specify the exact known sun position or \"B:-parameters\"\n to specify date/time for sun position calculation by  r.sunmask  itself\n have to be used.\n  The module performs sunset/sunrise checks and refraction correction for sun\n position calculation. Local coordinate systems are internally transformed to\n latitude/longitude for the SOLPOS algorithm. The elevation is not considered\n in the sunset/sunrise calculations.\n ", "notes": "\n  r.sunmask  and daylight savings: Rather than converting the\n local time to GMT, the SOLPOS algorithm uses what is called Local\n Standard Time, which is generally politically defined as an offset\n from GMT.  So the key is the offset from GMT, which the solpos Time\n Zone parameter. If the user specifies clock time (different for\n winter and summer), s/he would have to change the Time Zone\n parameter seasonally in  r.sunmask  (timezone parameter). See also \n  Daylight saving time by region and country .\n Note: In latitude/longitude locations the position coordinates pair\n (east/west) has to be specified in decimal degree (not D:M:S). If\n not specified, the map center's coordinates will be used.\n Also  g.region -l  displays the map center's coordinates in\n latitude/longitude (or  g.region -c  in the actual coordinate\n system).\n Note for module usage with the  -g  flag, when performing calculations\n close to sunset/sunrise:\n  [...]\n  sunangleabovehorizont=0.434240\n  sunrise=07:59:19\n  sunset=16:25:17\n  Time (07:59:02) is before sunrise (07:59:19)!\n  WARNING: Nothing to calculate. Please verify settings.\n  No map calculation requested. Finished.\n In above calculation it appears to be a mistake as\n the program indicates that we are before sunrise while\n the  sun angle above horizon  is already positive.\n The reason is that  sun angle above horizon  is\n calculated with correction for atmosphere refraction while\n  sunrise  and  sunset  are calculated  without \n correction for atmosphere refraction. The output without \n  -g  flag contains related indications.\n  EXAMPLE \n Example for North Carolina sample data set for the calculation\n of sun position angles and more:\n # set the region to a place near Raleigh (NC)\n g.region raster=elev_lid792_1m -p\n # compute only sun position and no output map\n r.sunmask -s elev_lid792_1m year=2012 month=2 \n            day=22 hour=10 minute=30 timezone=-5\n Using map center coordinates: 638650.000000 220375.000000\n Calculating sun position... (using solpos (V. 11 April 2001) from NREL)\n 2012/02/22, daynum: 53, time: 10:30:00 (decimal time: 10.500000)\n long: -78.678856, lat: 35.736160, timezone: -5.000000\n Solar position: sun azimuth: 143.006409, sun angle above horz. (refraction corrected): 36.233879\n Sunrise time (without refraction): 06:58:11\n Sunset time  (without refraction): 17:58:47\n # with -g flag, useful for eval() shell function\n r.sunmask -s -g elev_lid792_1m  year=2012 month=2 \n            day=22 hour=10 minute=30 timezone=-5\n Using map center coordinates: 638650.000000 220375.000000\n Calculating sun position... (using solpos (V. 11 April 2001) from NREL)\n date=2012/02/22\n daynum=53\n time=10:30:00\n decimaltime=10.500000\n longitudine=-78.678856\n latitude=35.736160\n timezone=-5.000000\n sunazimuth=143.006409\n sunangleabovehorizon=36.233879\n sunrise=06:58:11\n sunset=17:58:47\n  Acknowledgements \n Acknowledgements: National Renewable Energy Laboratory for their\n  SOLPOS 2.0  sun position\n algorithm.\n ", "see_also": ["g.region", "r.sun", "r.sunhours", "r.slope.aspect"], "authors": ["Janne Soimasuo, Finland 1994"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.sunmask"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.sunhours.html", "name": "r.sunhours", "definition": "- Calculates solar elevation, solar azimuth, and sun hours.", "keywords": ["raster", "solar", "sun energy", "sun position"], "synopsis": "r.sunhours [-ts]  [elevation=name]   [azimuth=name]   [sunhour=name]  year=integer  [month=integer]  day=integer  [hour=integer]   [minute=integer]   [second=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Time is local sidereal time, not Greenwich standard time Do not use SOLPOS algorithm of NREL Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Do not use SOLPOS algorithm of NREL Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Output raster map with solar elevation angle", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "azimuth", "flag": "azimuth", "dataType": "String", "optional": true, "explanation": "Output raster map with solar azimuth angle", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sunhour", "flag": "sunhour", "dataType": "String", "optional": true, "explanation": "Output raster map with sunshine hours", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "year", "flag": "year", "dataType": "String", "optional": false, "explanation": "Year", "defaultValue": null, "alternatives": ["1950-2050"], "isInputFile": false, "isOutputFile": false}, {"parameter": "month", "flag": "month", "dataType": "String", "optional": true, "explanation": "Month", "defaultValue": null, "alternatives": ["1-12"], "isInputFile": false, "isOutputFile": false}, {"parameter": "day", "flag": "day", "dataType": "String", "optional": false, "explanation": "Day", "defaultValue": null, "alternatives": ["1-366"], "isInputFile": false, "isOutputFile": false}, {"parameter": "hour", "flag": "hour", "dataType": "String", "optional": true, "explanation": "Hour", "defaultValue": "12", "alternatives": ["0-24"], "isInputFile": false, "isOutputFile": false}, {"parameter": "minute", "flag": "minute", "dataType": "String", "optional": true, "explanation": "Minutes", "defaultValue": "0", "alternatives": ["0-60"], "isInputFile": false, "isOutputFile": false}, {"parameter": "second", "flag": "second", "dataType": "String", "optional": true, "explanation": "Seconds", "defaultValue": "0", "alternatives": ["0-60"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r.sunhours  calculates sun elevation and sun azimuth angles for\n the given time of day and each grid cell in the current region. \n Additionally, the photoperiod (sunshine hours on flat terrain) can be\n calculated.\n Sun elevation, height, height angle, or solar altitude angle is the\n angle in degrees between the horizon and a line that points from the\n site towards the centre of the sun.\n The sun azimuth angle is here defined as the azimuth angle in degrees\n of the sun from due north in a clockwise direction.\n The time used here is defined such that 12:00 (high noon) is the time\n when the sun has reached its highest point in the sky at the current site,\n unless the  -t  flag is used in which case time is interpreted as \n Greenwich standard time.\n If a  sunhour  output map is specified, the module calculates \n sunshine hours for the given day. This option requires both Greenwhich \n standard time and the use of the SOLPOS algorithm by NREL.\n  NOTESS \n To consider also cast shadow effects of the terrain,  r.sun  is\n to be used.\n  EXAMPLES \n  Calculating a sun elevation angle map \n Calculate the sun elevation angle map for 2010-10-11 at 14:00h solar time:\n # set computational region to North Carolina state extent\n g.region n=318500 s=-16000 w=124000 e=963000 res=500 -p\n r.sunhours elevation=sun_elev year=2010 month=10 day=11 hour=14 minute=00\n # visualize\n d.mon wx0\n d.rast sun_elev \n d.vect nc_state type=boundary\n d.legend sun_elev -s \n  \n  Sun angle map (in degree) of North Carolina for the 2010-10-11 at 14:00h solar time \n  Calculate map of photoperiod (insolation time) \n Calculate photoperiod of day-of-year 001 (1st January) of 2012 for\n the current computational region, ignoring cast shadow effects of the\n terrain:\n g.region -p\n r.sunhours sunhour=photoperiod_doy_001 year=2012 day=1\n  Acknowledgements \n Acknowledgements: National Renewable Energy Laboratory for their\n  SOLPOS 2.0  sun position\n algorithm.\n ", "notes": "", "see_also": ["g.region", "r.sun", "r.sunmask"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.sunhours"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.sun.html", "name": "r.sun", "definition": "- Solar irradiance and irradiation model.", "keywords": ["raster", "solar", "sun energy", "shadow"], "synopsis": "r.sun [-pm] elevation=string  [aspect=string]   [aspect_value=float]   [slope=string]   [slope_value=float]   [linke=string]   [linke_value=float]   [albedo=string]   [albedo_value=float]   [lat=string]   [long=string]   [coeff_bh=string]   [coeff_dh=string]   [horizon_basename=basename]   [horizon_step=float]   [incidout=string]   [beam_rad=string]   [diff_rad=string]   [refl_rad=string]   [glob_rad=string]   [insol_time=string]  day=integer  [step=float]   [declination=float]   [time=float]   [nprocs=integer]   [distance_step=float]   [npartitions=integer]   [civil_time=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Do not incorporate the shadowing effect of terrain Use the low-memory version of the program Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Use the low-memory version of the program Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of the input elevation raster map [meters]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "aspect", "flag": "aspect", "dataType": "String", "optional": true, "explanation": "Name of the input aspect map (terrain aspect or azimuth of the solar panel) [decimal degrees]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "aspect_value", "flag": "aspect_value", "dataType": "String", "optional": true, "explanation": "A single value of the orientation (aspect), 270 is south", "defaultValue": "270", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "slope", "flag": "slope", "dataType": "String", "optional": true, "explanation": "Name of the input slope raster map (terrain slope or solar panel inclination) [decimal degrees]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "slope_value", "flag": "slope_value", "dataType": "String", "optional": true, "explanation": "A single value of inclination (slope)", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "linke", "flag": "linke", "dataType": "String", "optional": true, "explanation": "Name of the Linke atmospheric turbidity coefficient input raster map [-]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "linke_value", "flag": "linke_value", "dataType": "String", "optional": true, "explanation": "A single value of the Linke atmospheric turbidity coefficient [-]", "defaultValue": "3.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "albedo", "flag": "albedo", "dataType": "String", "optional": true, "explanation": "Name of the ground albedo coefficient input raster map [-]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "albedo_value", "flag": "albedo_value", "dataType": "String", "optional": true, "explanation": "A single value of the ground albedo coefficient [-]", "defaultValue": "0.2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lat", "flag": "lat", "dataType": "String", "optional": true, "explanation": "Name of input raster map containing latitudes [decimal degrees]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "long", "flag": "long", "dataType": "String", "optional": true, "explanation": "Name of input raster map containing longitudes [decimal degrees]", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "coeff_bh", "flag": "coeff_bh", "dataType": "String", "optional": true, "explanation": "Name of real-sky beam radiation coefficient (thick cloud) input raster map [0-1]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "coeff_dh", "flag": "coeff_dh", "dataType": "String", "optional": true, "explanation": "Name of real-sky diffuse radiation coefficient (haze) input raster map [0-1]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "horizon_basename", "flag": "horizon_basename", "dataType": "String", "optional": true, "explanation": "The horizon information input map basename", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "horizon_step", "flag": "horizon_step", "dataType": "String", "optional": true, "explanation": "Angle step size for multidirectional horizon [degrees]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "incidout", "flag": "incidout", "dataType": "String", "optional": true, "explanation": "Output incidence angle raster map (mode 1 only)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "beam_rad", "flag": "beam_rad", "dataType": "String", "optional": true, "explanation": "Output beam irradiance [W.m-2] (mode 1) or irradiation raster map [Wh.m-2.day-1] (mode 2)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "diff_rad", "flag": "diff_rad", "dataType": "String", "optional": true, "explanation": "Output diffuse irradiance [W.m-2] (mode 1) or irradiation raster map [Wh.m-2.day-1] (mode 2)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "refl_rad", "flag": "refl_rad", "dataType": "String", "optional": true, "explanation": "Output ground reflected irradiance [W.m-2] (mode 1) or irradiation raster map [Wh.m-2.day-1] (mode 2)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "glob_rad", "flag": "glob_rad", "dataType": "String", "optional": true, "explanation": "Output global (total) irradiance/irradiation [W.m-2] (mode 1) or irradiance/irradiation raster map [Wh.m-2.day-1] (mode 2)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "insol_time", "flag": "insol_time", "dataType": "String", "optional": true, "explanation": "Output insolation time raster map [h] (mode 2 only)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "day", "flag": "day", "dataType": "String", "optional": false, "explanation": "No. of day of the year (1-365)", "defaultValue": null, "alternatives": ["1-365"], "isInputFile": false, "isOutputFile": false}, {"parameter": "step", "flag": "step", "dataType": "String", "optional": true, "explanation": "Time step when computing all-day radiation sums [decimal hours]", "defaultValue": "0.5", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "declination", "flag": "declination", "dataType": "String", "optional": true, "explanation": "Declination value (overriding the internally computed value) [radians]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "time", "flag": "time", "dataType": "String", "optional": true, "explanation": "Local (solar) time (to be set for mode 1 only) [decimal hours]", "defaultValue": null, "alternatives": ["0-24"], "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of threads which will be used for parallel computing", "defaultValue": "1", "alternatives": ["1-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "distance_step", "flag": "distance_step", "dataType": "String", "optional": true, "explanation": "Sampling distance step coefficient (0.5-1.5)", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "npartitions", "flag": "npartitions", "dataType": "String", "optional": true, "explanation": "Read the input files in this number of chunks", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "civil_time", "flag": "civil_time", "dataType": "String", "optional": true, "explanation": "Civil time zone value, if none, the time will be local solar time", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.sun  computes beam (direct), diffuse and ground reflected solar\n irradiation raster maps for given day, latitude, surface and atmospheric\n conditions. Solar parameters (e.g. time of sunrise and sunset, declination,\n extraterrestrial irradiance, daylight length) are stored in the resultant maps'\n history files. Alternatively, the local time can be specified to compute solar\n incidence angle and/or irradiance raster maps. The shadowing effect of the\n topography is incorporated by default. This can be done either internally by\n calculatoion of the shadowing effect directly from the digital elevation model\n or by specifying raster maps of the horizon height which is much faster. These\n horizon raster maps can be calculated using  r.horizon .\n  For latitude-longitude coordinates it requires that the elevation map is in meters.\n The rules are:\n   lat/lon coordinates: elevation in meters;\n   Other coordinates: elevation in the same unit as the easting-northing coordinates.\n The solar geometry of the model is based on the works of Krcho (1990), later\n improved by Jenco (1992). The equations describing Sun -- Earth position as\n well as an interaction of the solar radiation with atmosphere were originally \n based on the formulas suggested by Kitler and Mikler (1986). This component \n was considerably updated by the results and suggestions of the working group\n co-ordinated by Scharmer and Greif (2000) (this algorithm might be replaced\n by SOLPOS algorithm-library included in GRASS within  \n r.sunmask \n  command). The model computes all three components of global radiation (beam, \n diffuse and reflected) for the clear sky conditions, i.e. not taking into \n consideration the spatial and temporal variation of clouds. The extent and\n spatial resolution of the modelled area, as well as integration over time,\n are limited only by the memory and data storage resources. The model is built\n to fulfil user needs in various fields of science (hydrology, climatology,\n ecology and environmental sciences, photovoltaics, engineering, etc.) for\n continental, regional up to the landscape scales. \n  The model considers a shadowing effect of the local topography unless switched\n off with the  -p  flag.\n  r.sun  works in two modes: In the first mode it calculates for the set \n local time a solar incidence angle [degrees] and solar irradiance values [W.m-2].\n In the second mode daily sums of solar radiation [Wh.m-2.day-1] are computed\n within a set day. By a scripting the two modes can be used separately or\n in a combination to provide estimates for any desired time interval. The\n model accounts for sky obstruction by local relief features. Several solar\n parameters are saved in the resultant maps' history files, which may be viewed\n with the  r.info  command.\n The solar incidence angle raster map  incidout  is computed specifying \n elevation raster map  elevation , aspect raster map  aspect , slope \n steepness raster map  slope,  given the day  day  and local time\n  time . There is no need to define latitude for locations with known\n and defined projection/coordinate system (check it with the  \n g.proj \n  command). If you have undefined projection, (x,y) system, etc. then the latitude\n can be defined explicitly for large areas by input raster map  lat_in \n  with interpolated latitude values. All input raster maps must\n be floating point (FCELL) raster maps. Null data in maps are excluded from\n the computation (and also speeding-up the computation), so each output raster\n map will contain null data in cells according to all input raster maps. The\n user can use  r.null \n  command to create/reset null file for your input raster maps.  \n The specified day  day  is the number of the day of the general year\n where January 1 is day no.1 and December 31 is 365. Time  time  must\n be a local (solar) time (i.e. NOT a zone time, e.g. GMT, CET) in decimal system,\n e.g. 7.5 (= 7h 30m A.M.), 16.1 = 4h 6m P.M.. \n The solar  declination  parameter is an option to override\n the value computed by the internal routine for the day of the year. The value\n of geographical latitude can be set as a constant for the whole computed\n region or, as an option, a grid representing spatially distributed values\n over a large region. The geographical latitude must be also in decimal system\n with positive values for northern hemisphere and negative for southern one.\n In similar principle the Linke turbidity factor ( linke ,  lin \n ) and ground albedo ( albedo ,  alb ) can be set. \n  Besides clear-sky radiations, the user can compute a real-sky radiation (beam,\n diffuse) using  coeff_bh  and  coeff_dh  input raster maps defining\n the fraction of the respective clear-sky radiations reduced by atmospheric\n factors (e.g. cloudiness). The value is between 0-1. Usually these\n coefficients can be obtained from a long-terms meteorological measurements\n provided as raster maps with spatial distribution of these coefficients separately\n for beam and diffuse radiation (see Suri and Hofierka, 2004, section 3.2).\n The solar irradiation or irradiance raster maps  beam_rad ,  diff_rad ,\n  refl_rad  are computed for a given day  day,  latitude  lat_in ,\n elevation  elevation , slope  slope  and aspect  aspect  raster maps.\n For convenience, the output raster given as  glob_rad \n will output the sum of the three radiation components. The program uses \n the Linke atmosphere turbidity factor and ground albedo coefficient. \n A default, single value of Linke factor is  lin =3.0 and \n is near the annual average for rural-city areas. The Linke\n factor for an absolutely clear atmosphere is  lin =1.0. See notes below\n to learn more about this factor. The incidence solar angle is the angle between\n horizon and solar beam vector. \n The solar radiation maps for a given day are computed by integrating the\n relevant irradiance between sunrise and sunset times for that day. The\n user can set a finer or coarser time step used for all-day radiation\n calculations with the  step  option. The default value of  step  is\n 0.5 hour. Larger steps (e.g. 1.0-2.0) can speed-up calculations but produce\n less reliable (and more jagged) results. As the sun moves through approx.\n 15\u00b0 of the sky in an hour, the default  step  of half an hour will\n produce 7.5\u00b0 steps in the data. For relatively smooth output with the\n sun placed for every degree of movement in the sky you should set the\n  step  to 4 minutes or less.  step =0.05  is equivalent\n to every 3 minutes. Of course setting the time step to be very fine\n proportionally increases the module's running time.\n  The output units are in Wh per squared meter per given\n day [Wh/(m*m)/day]. The incidence angle and irradiance/irradiation maps are\n computed with the shadowing influence of relief by default. It is also possible\n for them to be computed without this influence using the planar flag ( -p ).\n In mountainous areas this can lead to very different results! The user should be\n aware that taking into account the shadowing effect of relief can slow\n down the speed of computation, especially when the sun altitude is low.\n When considering the shadowing effect, speed and precision of computation\n can be controlled by the  distance_step  parameter, which defines the sampling density\n at which the visibility of a grid cell is computed in the direction of a\n path of the solar flow. It also defines the method by which the obstacle's\n altitude is computed. When choosing a  distance_step  less than 1.0 (i.e. sampling\n points will be computed at  distance_step  * cellsize distance),  r.sun  takes\n the altitude from the nearest grid point. Values above 1.0 will use the maximum\n altitude value found in the nearest 4 surrounding grid points. The default\n value  distance_step =1.0 should give reasonable results for most cases (e.g.\n on DEM). The  distance_step  value defines a multiplying coefficient for sampling\n distance. This basic sampling distance equals to the arithmetic average of\n both cell sizes. The reasonable values are in the range 0.5-1.5.  The values\n below 0.5 will decrease and values above 1.0 will increase the computing\n speed. Values greater than 2.0 may produce estimates with lower accuracy\n in highly dissected relief. The fully shadowed areas are written to the output\n maps as zero values. Areas with NULL data are considered as no barrier with\n shadowing effect.\n The maps' history files are generated containing the following listed \n parameters used in the computation:  \n - Solar constant 1367 W.m-2  \n - Extraterrestrial irradiance on a plane perpendicular to the solar beam [W.m-2]  \n - Day of the year  \n - Declination [radians]  \n - Decimal hour (Alternative 1 only)  \n - Sunrise and sunset (min-max) over a horizontal plane  \n - Daylight lengths  \n - Geographical latitude (min-max)  \n - Linke turbidity factor (min-max)  \n - Ground albedo (min-max) \n  The user can use a nice shellcript with variable\n day to compute radiation for some time interval within the year (e.g. vegetation\n or winter period). Elevation, aspect and slope input values should not be\n reclassified into coarser categories. This could lead to incorrect results. \n   OPTIONS \n  Currently, there are two modes of r.sun.\n In the first mode it calculates solar incidence angle and solar irradiance\n raster maps using the set local time. In the second mode daily sums of solar\n irradiation [Wh.m-2.day-1] are computed for a specified day.\n ", "notes": "\n Solar energy is an important input parameter in different models concerning \n energy industry, landscape, vegetation, evapotranspiration, snowmelt or remote\n sensing. Solar rays incidence angle maps can be effectively used in radiometric\n and topographic corrections in mountainous and hilly terrain where very accurate\n investigations should be performed. \n The clear-sky solar radiation model applied in the r.sun is based on the\n work undertaken for development of European Solar Radiation Atlas (Scharmer \n and Greif 2000, Page et al. 2001, Rigollier 2001). The clear sky model estimates\n the global radiation from the sum of its beam, diffuse and reflected components.\n The main difference between solar radiation models for inclined surfaces\n in Europe is the treatment of the diffuse component. In the European climate\n this component is often the largest source of estimation error. Taking into\n consideration the existing models and their limitation the European Solar\n Radiation Atlas team selected the Muneer (1990) model as it has a sound theoretical\n basis and thus more potential for later improvement. \n Details of underlying equations used in this program can be found in the\n reference literature cited below or book published by Neteler and Mitasova: \n Open Source GIS: A GRASS GIS Approach (published in Kluwer Academic Publishers \n in 2002). \n Average monthly values of the Linke turbidity coefficient for a mild climate\n in the northern hemisphere (see reference literature for your study area):\n  Month Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec annual \n  mountains 1.5 1.6 1.8 1.9 2.0 2.3 2.3 2.3 2.1 1.8 1.6 1.5 1.90 \n  rural 2.1 2.2 2.5 2.9 3.2 3.4 3.5 3.3 2.9 2.6 2.3 2.2 2.75 \n  city 3.1 3.2 3.5 4.0 4.2 4.3 4.4 4.3 4.0 3.6 3.3 3.1 3.75 \n  industrial 4.1 4.3 4.7 5.3 5.5 5.7 5.8 5.7 5.3 4.9 4.5 4.2 5.00 \n  Planned improvements include the use of the SOLPOS algorithm for solar \n geometry calculations and internal computation of aspect and slope.\n  Solar time \n By default r.sun calculates times as true solar time, whereby solar noon is\n always exactly 12 o'clock everywhere in the current region. Depending on where \n the zone of interest is located in the related time zone, this may cause\n differences of up to an hour, in some cases (like Western Spain) even more.\n On top of this, the offset varies during the year according to the Equation\n of Time.\n To overcome this problem, the user can use the option  civil_time=<timezone_offset> \n in r.sun to make it use real-world (wall clock) time. For example, for Central \n Europe the timezone offset is +1, +2 when daylight saving time is in effect.\n  Extraction of shadow maps \n A map of shadows can be extracted from the solar incidence angle map\n (incidout). Areas with NULL values are shadowed. This will not work\n if the  -p  flag has been used.\n  Large maps and out of memory problems \n With a large number or columns and rows,  r.sun  can consume\n significant amount of memory. While output raster maps are not\n partitionable, the input raster maps are using the  npartitions \n parameter.\n In case of out of memory error ( ERROR: G_malloc: out of memory ), the\n  npartitions  parameter can be used to run a segmented calculation\n which consumes less memory during the computations.\n The amount of memory by  r.sun  is estimated as follows:\n # without input raster map partitioning:\n #  memory requirements: 4 bytes per raster cell\n #  rows,cols: rows and columns of current region (find out with g.region)\n #  IR: number of input raster maps without horizon maps\n #  OR: number of output raster maps\n memory_bytes = rows*cols*(IR*4 + horizon_steps + OR*4)\n # with input raster map partitioning:\n memory_bytes = rows*cols*((IR*4+horizon_steps)/npartitions  + OR*4)\n  EXAMPLES \n North Carolina example (considering also cast shadows):\n g.region raster=elevation -p\n # calculate horizon angles (to speed up the subsequent r.sun calculation)\n r.horizon elevation=elevation step=30 bufferzone=200 output=horangle \n      maxdistance=5000\n # slope + aspect\n r.slope.aspect elevation=elevation aspect=aspect.dem slope=slope.dem\n # calculate global radiation for day 180 at 2p.m., using r.horizon output\n r.sun elevation=elevation horizon_basename=horangle horizon_step=30 \n        aspect=aspect.dem slope=slope.dem glob_rad=global_rad day=180 time=14\n # result: output global (total) irradiance/irradiation [W.m-2] for given day/time\n r.univar global_rad\n Calculation of the integrated daily irradiation for a region in North-Carolina\n for a given day of the year at 30m resolution. Here day 172 (i.e., 21 June\n in non-leap years):\n g.region raster=elev_ned_30m -p\n # considering cast shadows\n r.sun elevation=elev_ned_30m linke_value=2.5 albedo_value=0.2 day=172 \n        beam_rad=b172 diff_rad=d172 \n        refl_rad=r172 insol_time=it172\n d.mon wx0\n # show irradiation raster map [Wh.m-2.day-1]\n d.rast.leg b172\n # show insolation time raster map [h]\n d.rast.leg it172\n We can compute the day of year from a specific date in Python:\n >>> import datetime\n >>> datetime.datetime(2014, 6, 21).timetuple().tm_yday\n 172\n ", "see_also": ["r.horizon", "r.slope.aspect", "r.sunhours", "r.sunmask", "g.proj", "r.null", "v.surf.rst"], "authors": ["Jaroslav Hofierka, GeoModel, s.r.o. Bratislava, Slovakia"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.sun"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.stream.extract.html", "name": "r.stream.extract", "definition": "- Performs stream network extraction.", "keywords": ["raster", "hydrology", "stream network"], "synopsis": "r.stream.extract elevation=name  [accumulation=name]   [depression=name]  threshold=float  [d8cut=float]   [mexp=float]   [stream_length=integer]   [memory=integer]   [stream_raster=name]   [stream_vector=name]   [direction=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "accumulation", "flag": "accumulation", "dataType": "String", "optional": true, "explanation": "Name of input accumulation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "depression", "flag": "depression", "dataType": "String", "optional": true, "explanation": "Name of input raster map with real depressions", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": false, "explanation": "Minimum flow accumulation for streams", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "d8cut", "flag": "d8cut", "dataType": "String", "optional": true, "explanation": "Use SFD above this threshold", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mexp", "flag": "mexp", "dataType": "String", "optional": true, "explanation": "Montgomery exponent for slope, disabled with 0", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stream_length", "flag": "stream_length", "dataType": "String", "optional": true, "explanation": "Delete stream segments shorter than stream_length cells", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used (in MB)", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stream_raster", "flag": "stream_raster", "dataType": "String", "optional": true, "explanation": "Name for output raster map with unique stream ids", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "stream_vector", "flag": "stream_vector", "dataType": "String", "optional": true, "explanation": "Name for output vector map with unique stream ids", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "direction", "flag": "direction", "dataType": "String", "optional": true, "explanation": "Name for output raster map with flow direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  r.stream.extract  extracts streams in both raster and vector\n format from a required input  elevation  map and optional input\n  accumulation  map.\n ", "notes": "\n NULL (nodata) cells in the input  elevation  map are ignored,\n zero and negative values are valid elevation data. Gaps in the\n elevation map that are located within the area of interest must be\n filled beforehand, e.g. with\n  r.fillnulls , to avoid distortions.\n All non-NULL and non-zero cells of  depression  map will be\n regarded as real depressions. Streams will not be routed out of\n depressions. If an area is marked as depression but the elevation\n model has no depression at this location, streams will not stop\n there. If a flow accumulation map and a map with real depressions are\n provided, the flow accumulation map must match the depression map such\n that flow is not distributed out of the indicated depressions. It is\n recommended to use internally computed flow accumulation if a\n depression map is provided.\n Option  threshold  defines the minimum (optionally modified) flow\n accumulation value that will initiate a new stream. If Montgomery's\n method for channel initiation is used, the cell value of the\n accumulation input map is multiplied by  (tan(local\n slope)) mexp  and then compared\n to  threshold . If  mexp  is given than the method of\n Montgomery and Foufoula-Georgiou (1993) to initiate a stream with this\n value. The cell value of the accumulation input map is multiplied\n by  (tan(local slope)) mexp  and then compared\n to  threshold . If threshold is reached or exceeded, a new stream\n is initiated. The default value 0 disables Montgomery. Montgomery and\n Foufoula-Georgiou (1993) generally recommend to use 2.0 as\n exponent.  mexp  values closer to 0 will produce streams more\n similar to streams extracted with Montgomery disabled.\n Larger  mexp  values decrease the number of streams in flat areas\n and increase the number of streams in steep areas. If  weight  is\n given, the weight is applied first.\n Option  d8cut  defines minimum amount of overland flow\n (accumulation) when SFD (D8) will be used instead of MFD (FD8) to\n calculate flow accumulation. Only applies if no accumulation map is\n provided. Setting to 0 disables MFD completely.\n Option  stream_length  defines minimum stream length in number of\n cells for first-order (head/spring) stream segments. All first-order\n stream segments shorter than  stream_length  will be deleted.\n Output  direction  raster map contains flow direction for all\n non-NULL cells in input elevation. Flow direction is of D8 type with a\n range of 1 to 8.  Multiplying values with 45 gives degrees CCW from\n East. Flow direction was adjusted during thinning, taking shortcuts\n and skipping cells that were eliminated by the thinning procedure.\n  Stream extraction \n If no  accumulation  input map is provided, flow accumulation is\n determined with a hydrological analysis similar to\n  r.watershed . The algorithm is\n MFD (FD8) after Holmgren 1994, as for\n  r.watershed . The  threshold \n option determines the number of streams and detail of stream networks.\n Whenever flow accumulation reaches  threshold , a new stream is\n started and traced downstream to its outlet point. As for\n  r.watershed , flow accumulation is\n calculated as the number of cells draining through a cell.\n If  accumulation  is given than the accumulation values of the\n provided  accumulation  map are used and not calculated from the\n input  elevation  map. In this case the  elevation  map must\n be exactly the same map used to calculate\n  accumulation . If  accumulation  was calculated with\n  r.terraflow , the filled\n elevation output\n of  r.terraflow  must be\n used. Further on, the current region should be aligned to\n the  accumulation  map. Flow direction is first calculated\n from  elevation  and then adjusted to\n  accumulation . It is not necessary to provide  accumulation \n as the number of cells, it can also be the optionally adjusted or\n weighed total contributing area in square meters or any other unit. \n When an original flow accumulation map is adjusted or weighed, the \n adjustment or weighing should not convert valid accumulation values to \n NULL (nodata) values.\n In case of getting the error message\n  ERROR: Accumulation raster map is NULL but elevation map is not NULL \n the computational region must be carefully adjusted to exclude NULL pixels\n in the accumulation raster map prior to stream extraction.\n  Weighed flow accumulation \n Flow accumulation can be calculated first, e.g. with\n  r.watershed , and then modified before\n using it as input for  r.stream.extract . In its general form, a\n weighed accumulation map is generated by first creating a weighing map\n and then multiplying the accumulation map with the weighing map using\n  r.mapcalc . It is highly recommended to\n evaluate the weighed flow accumulation map first, before using it as\n input for  r.stream.extract .\n This allows e.g. to decrease the number of streams in dry areas and\n increase the number of streams in wet areas by setting  weight \n to smaller than 1 in dry areas and larger than 1 in wet areas.\n Another possibility is to restrict channel initiation to valleys\n determined from terrain morphology. Valleys can be determined with\n  r.param.scale   method=crosc \n (cross-sectional or tangential curvature). Curvature values < 0\n indicate concave features, i.e. valleys. The size of the processing\n window determines whether narrow or broad valleys will be identified\n (See example below).\n  Defining a region of interest \n The stream extraction procedure can be restricted to a certain region of \n interest, e.g. a subbasin, by setting the computational region with \n  g.region  and/or creating a MASK. Such region of interest should \n be a complete catchment area, complete in the sense that the complete \n area upstream of an outlet point is included and buffered with at least \n one cell.\n  Stream output \n The output raster and vector contains stream segments with unique\n IDs. Note that these IDs are different from the IDs assigned\n by  r.watershed . The vector\n output also contains points at the location of the start of a stream\n segment, at confluences and at stream network outlet locations.\n Output  stream_raster  raster map stores extracted streams. Cell\n values encode a unique ID for each stream segment.\n Output  stream_vector  vector map stores extracted stream segments\n and points. Points are written at the start location of each stream\n segment and at the outlet of a stream network. In layer 1, categories\n are unique IDs, identical to the cell value of the raster output. The\n attribute table for layer 1 holds information about the type of stream \n segment: start segment, or intermediate segment with tributaries, and \n about the stream network this stream or node belongs to. Columns are \n  cat int,stream_type varchar(),type_code int,network int . The \n network attribute is the network ID of the stream/node. The encoding \n for type_code is 0 = start, 1 = intermediate. In layer 2, categories \n are identical to type_code in layer 1 with additional category 2 = \n outlet for outlet points. Points with category 1 = intermediate in \n layer 2 are at the location of confluences.\n  EXAMPLE \n This example is based on the elevation map \"elev_ned_30m\" in the\n North Carolina sample dataset and uses valleys determined with\n  r.param.scale  to weigh an accumulation\n map produced with  r.watershed .\n # set region\n g.region -p raster=elev_ned_30m@PERMANENT\n # calculate flow accumulation\n r.watershed ele=elev_ned_30m@PERMANENT acc=elev_ned_30m.acc\n # curvature to get narrow valleys\n r.param.scale input=elev_ned_30m@PERMANENT output=tangential_curv_5 size=5 method=crosc\n # curvature to get a bit broader valleys\n r.param.scale input=elev_ned_30m@PERMANENT output=tangential_curv_7 size=7 method=crosc\n # curvature to get broad valleys\n r.param.scale input=elev_ned_30m@PERMANENT output=tangential_curv_11 size=11 method=crosc\n # create weight map\n r.mapcalc \"weight = if(tangential_curv_5 < 0, -100 * tangential_curv_5, \n                      if(tangential_curv_7 < 0, -100 * tangential_curv_7, \n                      if(tangential_curv_11 < 0, -100 * tangential_curv_11, 0.000001)))\"\n # weigh accumulation map\n r.mapcalc expr=\"elev_ned_30m.acc.weighed = elev_ned_30m.acc * weight\"\n # copy color table from original accumulation map\n r.colors map=elev_ned_30m.acc.weighed raster=elev_ned_30m.acc\n  \n Weight map (spatial subset with lake in the southern half)\n Original flow accumulation map (spatial subset with lake in the southern half)\n Weighed flow accumulation map (spatial subset with lake in the southern half)\n Display both the original and the weighed accumulation map.\n Compare them and proceed if the weighed accumulation map makes sense.\n # extract streams using the original accumulation map\n r.stream.extract elevation=elev_ned_30m@PERMANENT \n                   accumulation=elev_ned_30m.acc \n                   threshold=1000 \n                   stream_rast=elev_ned_30m.streams.noweight\n # extract streams from weighed map\n # note that the weighed map is a bit smaller than the original map\n r.stream.extract elevation=elev_ned_30m@PERMANENT \n                   accumulation=elev_ned_30m.acc.weighed \n                   threshold=1000 \n                   stream_rast=elev_ned_30m.streams\n Now display both stream maps and decide which one is more realistic.\n  \n Extracted streams from original flow accumulation map\n Extracted streams from weighed flow accumulation map\n  REFERENCES \n  Ehlschlaeger, C. (1989).  Using the A T  Search\n Algorithm to Develop Hydrologic Models from Digital Elevation\n Data ,\n  Proceedings of International Geographic Information Systems (IGIS)\n Symposium '89 , pp 275-281 (Baltimore, MD, 18-19 March\n 1989). URL:  \n http://faculty.wiu.edu/CR-Ehlschlaeger2/older/IGIS/paper.html \n  Holmgren, P. (1994).  Multiple flow direction algorithms for\n runoff modelling in grid based elevation models: An empirical\n evaluation. \n  Hydrological Processes  Vol 8(4), pp 327-334. DOI:  10.1002/hyp.3360080405 \n  Montgomery, D.R., Foufoula-Georgiou, E. (1993).  Channel network source\n representation using digital elevation models. \n  Water Resources Research  Vol 29(12), pp 3925-3934. \n ", "see_also": ["r.mapcalc", "r.param.scale", "r.stream.channel", "r.stream.distance", "r.stream.order", "r.stream.segment", "r.stream.slope", "r.stream.snap", "r.stream.stats", "r.terraflow", "r.thin", "r.to.vect", "r.watershed"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.stream.extract"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.to.rast.html", "name": "r3.to.rast", "definition": "- Converts 3D raster maps to 2D raster maps", "keywords": ["raster3d", "conversion", "raster", "voxel"], "synopsis": "r3.to.rast [-mr] input=string output=string  [type=string]   [multiply=float]   [add=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Use 3D raster mask (if exists) with input map Use the same resolution as the input 3D raster map for the 2D output maps, independent of the current region settings Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Use the same resolution as the input 3D raster map for the 2D output maps, independent of the current region settings Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "3D raster map(s) to be converted to 2D raster slices", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Basename for resultant raster slice maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of raster map to be created", "defaultValue": null, "alternatives": ["CELL", "FCELL", "DCELL"], "isInputFile": false, "isOutputFile": false}, {"parameter": "multiply", "flag": "multiply", "dataType": "String", "optional": true, "explanation": "Value to multiply the raster values with", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "add", "flag": "add", "dataType": "String", "optional": true, "explanation": "Value to add to the raster values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n Converts one 3D raster map into several 2D raster maps (depends on depths). \n If the 2D and 3D region settings are different, the 3D resolution will be \n adjusted to the 2D resolution (the depths are not touched).\n The user can force  r3.to.rast  to use the 2D resolution of the input \n 3D raster map for the output maps, independently from the current region settings.\n  \n  How r3.to.rast works \n  Map type conversions \n Type of resulting 2D raster maps is determined by the type of the\n input 3D raster, i.e. 3D raster of type DCELL (double) will result in\n DCELL 2D rasters. A specific type for 2D rasters can be requested using\n the  type  option.\n The  type  option is especially advantageous when the 3D raster\n map stores categories (which need to be stored as floating point numbers)\n and the 2D raster map should be also categorical, i.e. use integers.\n The type is set to  CELL  in this case. \n  Modifying the values \n The values in the 3D raster map can be modified prior to storing in\n the 2D raster map. The values can be scaled using the option  multiply \n and a constant value can be added using the option  add .\n The new value is computed using the following equation:\n y = ax + b\n where  x  is the original value,  a  is the value of\n  multiply  option,  b  is the value of  add  option,\n and  y  is the new value. When  multiply  is not provided,\n the value of  a  is 1. When  add  is not provided, the value\n of  b  is 0.\n ", "notes": "\n Every slice of the 3D raster map is copied to one 2D raster map. The maps\n are named like  output _slicenumber . Slices are counted from bottom\n to the top, so the bottom slice has number 1. \n The number of slices is equal to the number of depths.\n To round floating point values to integers when using  type=CELL ,\n the  add  option should be set to 0.5.\n ", "see_also": ["r3.cross.rast", "r3.out.vtk", "r3.out.ascii", "g.region"], "authors": ["S\u00f6ren Gebbert Vaclav Petras,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.to.rast"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.timestamp.html", "name": "r3.timestamp", "definition": "- Modifies a timestamp for a 3D raster map.", "keywords": ["raster3d", "metadata", "timestamp", "time", "voxel"], "synopsis": "r3.timestamp map=name  [date=timestamp]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "date", "flag": "date", "dataType": "String", "optional": true, "explanation": "Datetime, datetime1/datetime2, or none", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This command has 2 modes of operation. If no  date  argument is\n supplied, then the current timestamp for the 3D raster map is\n printed. If a date argument is specified, then the timestamp for the\n 3D raster map is set to the specified date(s). See examples below.\n See  TIMESTAMP FORMAT \n description for details.\n ", "notes": "\n Strings containing spaces should be quoted. For specifying a range of\n time, the two timestamps should be separated by a forward slash. To\n remove the timestamp from a 3D raster map, use  date=none .\n  EXAMPLES \n Prints the timestamp for the \"soils\" 3D raster map. If there is no\n timestamp for soils, nothing is printed. If there is a timestamp, one\n or two lines are printed, depending on if the timestamp for the map\n consists of a single date or two dates (ie start and end dates).\n r3.timestamp map=soils\n Sets the timestamp for \"soils\" to the single date \"15 sep 1987\".\n r3.timestamp map=soils date='15 sep 1987'\n Sets the timestamp for \"soils\" to have the start date \"15 sep 1987\"\n and the end date \"20 feb 1988\".\n r3.timestamp map=soils date='15 sep 1987/20 feb 1988'\n Sets the timestamp for \"soils\" to have the start date \"18 feb 2005\n 10:30:00\" and the end date \"20 jul 2007 20:30:00\".\n r3.timestamp map=soils date='18 feb 2005 10:30:00/20 jul 2007 20:30:00'\n Removes the timestamp for the \"soils\" 3D raster map.\n r3.timestamp map=soils date=none\n   \n  KNOWN ISSUES \n Spaces in the timestamp value are required.\n ", "see_also": ["r3.info", "r.timestamp", "v.timestamp"], "authors": ["Michael Pelizzari"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.timestamp"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.support.html", "name": "r3.support", "definition": "- Allows creation and/or modification of 3D raster map layer support files.", "keywords": ["raster3d", "metadata", "voxel"], "synopsis": "r3.support [-s] map=name  [title=phrase]   [history=phrase]   [unit=string]   [vunit=string]   [source1=phrase]   [source2=phrase]   [description=phrase]   [raster=string]   [loadhistory=name]   [savehistory=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Update range Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Text to use for map title", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "history", "flag": "history", "dataType": "String", "optional": true, "explanation": "Text to append to the next line of the map's metadata file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "unit", "flag": "unit", "dataType": "String", "optional": true, "explanation": "The map data unit", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vunit", "flag": "vunit", "dataType": "String", "optional": true, "explanation": "The vertical unit of the map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "source1", "flag": "source1", "dataType": "String", "optional": true, "explanation": "Text to use for data source, line 1", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "source2", "flag": "source2", "dataType": "String", "optional": true, "explanation": "Text to use for data source, line 2", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "description", "flag": "description", "dataType": "String", "optional": true, "explanation": "Text to use for data description or keyword(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Raster map from which to copy category table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "loadhistory", "flag": "loadhistory", "dataType": "String", "optional": true, "explanation": "Text file from which to load history", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "savehistory", "flag": "savehistory", "dataType": "String", "optional": true, "explanation": "Text file in which to save history", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.support  allows the user to create and/or edit raster3d map support \n information. Editing of raster3d map units, history, description and title is supported. \n ", "notes": "\n Freeform metadata information is stored in a \" hist \" file which may be\n appended to by using the  history  option. Currently this is limited to\n text with a maximum line length of 78 characters. Any input\n larger than this will be wrapped to the next line.\n All other metadata strings available as standard options are limited to\n 79 characters.\n ", "see_also": ["r.info", "r.timestamp"], "authors": ["Soeren Gebbert, vTI/AK, soerengebbert gmooglemail.com"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.support"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.stats.html", "name": "r3.stats", "definition": "- Generates volume statistics for 3D raster maps.", "keywords": ["raster3d", "statistics", "voxel", "volume"], "synopsis": "r3.stats [-ec] input=name  [nsteps=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Calculate statistics based on equal value groups Only print cell counts Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Only print cell counts Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "nsteps", "flag": "nsteps", "dataType": "String", "optional": true, "explanation": "Number of subranges to collect stats from", "defaultValue": "20", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.stats  calculates volume statistics for 3D raster maps.\n Volumes are created on base of value subranges or groups of equal values.\n The default number of subranges is 20 and can vary from 1 to infinite. \n Larger number of subranges will result in larger memory consumption.\n The volumes are calculated in qubic meters. Null values are marked with \"*\".\n If the flag  -e  is set, the number of subranges will be ignored.\n ", "notes": "\n As with most GRASS 3D raster map modules,  r3.stats  operates on the cell\n array defined by the current 3D region settings, not the original extent and\n resolution of the input map. See  g.region .\n  The region setting will not effect the memory consumption of this module.\n The number of subranges in case of value range calculation or the number of \n equal value groups effect the memory consumption and the calculation time.\n The user can expect a huge time consumption to calculate the equal value\n groups (flag  -e ) if large region settings occur for maps which\n have many equal value groups (> 100000).\n  EXAMPLES \n  Lausanne FOSS4G 2006 3D demo dataset example \n The 3D raster map  geology  has three values. Each value represents \n a specific geological layer, clay = 1, sand = 2 and bedrock = 3. To calculate\n the volume of each geological layer, we can use the flag  -e  to group\n equal values into single volumes. \n  r3.stats geology -e  will produce the following output:\n   num   |        value       |     volume    |   perc  |    count\n       1             1.000000   300822000.000   50.13700        50137\n       2             2.000000   101400000.000   16.90000        16900\n       3             3.000000   197778000.000   32.96300        32963\n       4                    *           0.000   0.00000            0\n Number of groups with equal values: 3\n Sum of non Null cells:\n         Volume = 600000000.000\n         Percentage = 100.000\n         Count = 100000\n Sum of all cells:\n         Volume = 600000000.000\n         Percentage = 100.000\n         Count = 100000\n  Generic example \n #create a small 3D region\n g.region n=1000 s=0 e=2000 w=0 t=300 b=0 res3=100\n #create a raster3D map with row() and null values\n r3.mapcalc \"volmap = if(row() == 5, null(), row())\"\n #run r3.stats with a subrange of 10\n r3.stats input=volmap nsteps=10\n #the result should look like this\n  num   | minimum <= value   | value < maximum    |     volume    |   perc  | cell count\n       1          1.000000000          1.900000000    60000000.000   10.00000           60\n       2          1.900000000          2.800000000    60000000.000   10.00000           60\n       3          2.800000000          3.700000000    60000000.000   10.00000           60\n       4          3.700000000          4.600000000    60000000.000   10.00000           60\n       5          4.600000000          5.500000000           0.000   0.00000            0\n       6          5.500000000          6.400000000    60000000.000   10.00000           60\n       7          6.400000000          7.300000000    60000000.000   10.00000           60\n       8          7.300000000          8.200000000    60000000.000   10.00000           60\n       9          8.200000000          9.100000000    60000000.000   10.00000           60\n      10          9.100000000         10.000000001    60000000.000   10.00000           60\n      11                    *                    *    60000000.000   10.00000           60\n Sum of non Null cells:\n         Volume = 540000000.000\n         Percentage =  90.000\n         Cell count = 540\n Sum of all cells:\n         Volume = 600000000.000\n         Percentage = 100.000\n         Cell count = 600\n ", "see_also": ["g.region", "r3.univar", "r.stats", "r.statistics", "v.univar"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.stats"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.retile.html", "name": "r3.retile", "definition": "- Retiles an existing 3D raster map with user defined x, y and z tile size.", "keywords": ["raster3d", "tiling", "voxel"], "synopsis": "r3.retile [-c] input=name output=name  [tiledimension=XxYxZ]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Disable tile caching Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the retiled 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "tiledimension", "flag": "tiledimension", "dataType": "String", "optional": true, "explanation": "The dimensions of the tiles used in the output raster3d map (XxYxZ or default: 16x16x8)", "defaultValue": "default", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.retile  writes a copy of an existing 3D raster map with\n a user defined number of tiles in x, y and z direction. \n The precision and the type of the original 3D raster map are used for\n the new retiled 3D raster map. \n ", "notes": "", "see_also": ["r3.cross.rast", "r3.out.ascii", "g.region", "r.tile"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.retile"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.out.vtk.html", "name": "r3.out.vtk", "definition": "- Converts 3D raster maps into the VTK-ASCII format.", "keywords": ["raster3d", "export", "voxel", "VTK"], "synopsis": "r3.out.vtk [-psmocl]  [input=name[,name,...]]   [output=name]   [null=float]   [top=string]   [bottom=string]   [rgbmaps=name[,name,...]]   [vectormaps=name[,name,...]]   [zscale=float]   [precision=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Create VTK pointdata instead of VTK celldata (celldata is default) Create 3D elevation output with a top and a bottom surface, both raster maps are required. Use 3D raster mask (if exists) with input maps Scale factor affects the origin Correct the coordinates to match the VTK-OpenGL precision Do not convert the top-bottom resolution in case of lat long projection to meters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Create 3D elevation output with a top and a bottom surface, both raster maps are required. Use 3D raster mask (if exists) with input maps Scale factor affects the origin Correct the coordinates to match the VTK-OpenGL precision Do not convert the top-bottom resolution in case of lat long projection to meters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Use 3D raster mask (if exists) with input maps Scale factor affects the origin Correct the coordinates to match the VTK-OpenGL precision Do not convert the top-bottom resolution in case of lat long projection to meters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Scale factor affects the origin Correct the coordinates to match the VTK-OpenGL precision Do not convert the top-bottom resolution in case of lat long projection to meters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Correct the coordinates to match the VTK-OpenGL precision Do not convert the top-bottom resolution in case of lat long projection to meters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Do not convert the top-bottom resolution in case of lat long projection to meters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "3D raster map(s) to be converted to VTK-ASCII data format", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for VTK-ASCII output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "Float value to represent no data cell/points", "defaultValue": "-99999.99", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "top", "flag": "top", "dataType": "String", "optional": true, "explanation": "Top surface 2D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bottom", "flag": "bottom", "dataType": "String", "optional": true, "explanation": "Bottom surface 2D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rgbmaps", "flag": "rgbmaps", "dataType": "String", "optional": true, "explanation": "Three (R,G,B) 3D raster maps to create RGB values [redmap,greenmap,bluemap]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vectormaps", "flag": "vectormaps", "dataType": "String", "optional": true, "explanation": "Three (x,y,z) 3D raster maps to create vector values [xmap,ymap,zmap]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Scale factor for elevation", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Number of significant digits (floating point only)", "defaultValue": "12", "alternatives": ["0-20"], "isInputFile": false, "isOutputFile": false}], "description": "\n The module  r3.out.vtk  outputs 3D raster maps into VTK-ASCII format.\n Maps are valid 3D raster maps in the current mapset search path. The\n  output  parameter is the name of a VTK-ASCII file which will be\n written in the current working directory. If  output  is not\n specified then standard output (stdout) is used. The module is sensitive\n to region settings (set with  g.region ).\n ", "notes": "\n This module generates  structured points  with  celldata  \n (default) or  pointdata . If top and bottom surfaces are requested\n an  unstructured grid  with  celldata  or a  structured grid \n with  pointdata  is generated.\n This data is put in a simple VTK-ASCII file. Neither XML nor \n binary output are supported. It is possible to choose more then one 3D raster\n map\n to be written in the VTK-ASCII file. Each  celldata  is named as the\n 3D raster map it represents. The user can visualize this file with the \n  VTK Toolkit , \n  ParaView  and \n  MayaVi  which are based on\n VTK. In case of 3D raster map with partially no data, the threshold filter in\n ParaView can be used to visualize the valid data. Just filter all data which is\n greater/lesser than the chosen null value in the VTK-ASCII file.\n  The top and bottom region values are expected in meters. \n If a Latitude-Longitude (LL) coordinates are used, the elevation value for each\n voxel will be converted into degrees.\n  The  input ,  rgbmaps  and  vectormaps  parameters are\n optional, so only the geometry can be exported.\n  If the user defines  top  and  bottom  and the 2D and 3D region\n values differ, the 2D resolution will be adjusted to the 3D resolution. The\n elevation maps are expected in meters. If Lat/Long coordinates are used, the\n elevation will automatically converted into degree.\n If the surface and bottom maps are in a different unit than meters, use the\n scale parameter to convert them into meters.\n  The RGB voxel data can be created from 2D raster maps (Landsat TM images) \n with  r.to.rast3 . The values of the RGB maps\n must be within 0 and 255. If not, the values are automatically set\n to 0 and warnings will be printed to stderr.\n  The vector data is created from three 3D raster maps. Each map represents a vector component.\n So x, y and z components are required in this order. This data can be visualized with Glyph3d or \n StreamTracer filters within Paraview.\n  If the  -c  flag is used and the data should be visualised together with\n other data exported via  *.out.vtk  modules, be sure the  -c  flag\n was also set in these modules. But this will only work with data from the SAME\n location (the reference point for the coordinates transformation is based on the\n center point of the default region).\n  Difference between point- and celldata \n  r3.out.vtk  can export 3D raster maps with different representations.\n    pointdata  -- the cells/values are represented by the center of the\n cell. Instead of cells, points are created. Each point can hold different\n values, but the user can only visualize one value at a time. \n    celldata  The cells are created with the same hight, width and depth\n as in GRASS. Each cell can hold different values, but the user can only\n visualize one value at a time. \n  EXAMPLE \n  Simple Spearfish example \n g.region -d\n g.region res=150 res3=150 t=80 b=0 tbres=10\n r.mapcalc \"bottom = 1800. - elevation.10m\"\n # synthetic data, could be geological structures:\n r3.mapcalc \"map3d = row()+col()+depth()\"\n #export of volume to VTK:\n r3.out.vtk -s input=map3d top=elevation.10m bottom=bottom output=/tmp/out.vtk\n # visualize in paraview or other VTK viewer:\n paraview --data=/tmp/out.vtk\n  Spearfish example with RGB data \n #set the region\n g.region -d\n g.region n=4926970 s=4914857 w=591583 e=607793 res=50 res3=50 t=80 b=0 tbres=10\n #create a bottom surface\n r.mapcalc \"bottom = 1800. - elevation.10m\"\n # synthetic data, could be geological structures:\n r3.mapcalc \"map3d = row()+col()+depth()\"\n #get some satellite images with r.in.onearth\n r.in.onearth -l output=Sat tmband=Red\n r.in.onearth -l output=Sat tmband=IR1\n r.in.onearth -l output=Sat tmband=IR2\n #Convert the 2D maps to 3D raster maps with r.to.rast3\n r.to.rast3 input=SatLandsatTM_Red output=SatLandsatTM_Red\n r.to.rast3 input=SatLandsatTM_IR1 output=SatLandsatTM_IR1\n r.to.rast3 input=SatLandsatTM_IR2 output=SatLandsatTM_IR2\n #export of volume to VTK:\n r3.out.vtk -s rgbmaps=SatLandsatTM_IR1,SatLandsatTM_IR2,SatLandsatTM_Red\n input=map3d top=elevation.10m bottom=bottom output=/tmp/out.vtk\n # visualize in paraview or other VTK viewer:\n paraview --data=/tmp/out.vtk \n  Spearfish example with vector data \n # set the region\n g.region -d\n g.region n=4926970 s=4914857 w=591583 e=607793 res=50 res3=50 t=80 b=0 tbres=10\n # create a bottom surface\n r.mapcalc \"bottom = 1800. - elevation.10m\"\n # synthetic data, could be geological structures:\n r3.mapcalc \"map3d = row()+col()+depth()\"\n # synthetic vector data, could be groundwater stream vectors\n r3.mapcalc \"x_part = sin(row())\"\n r3.mapcalc \"y_part = cos(col())\"\n r3.mapcalc \"z_part = sin(depth())\"\n # export the stuff data to VTK:\n r3.out.vtk -s vectormaps=x_part,y_part,z_part input=map3d top=elevation.10m\n bottom=bottom output=/tmp/out.vtk\n # visualize in paraview or other VTK viewer:\n paraview --data=/tmp/out.vtk \n # Now use the Glyph and Stream-Trace Filter to get nice vectors and streamlines\n  Slovakia3d example \n #reduce resolution:\n g.region -dp3 res=1000 res3=1000\n r.mapcalc \"bottom = 100\"\n #export of volume to VTK:\n r3.out.vtk -s in=precip3d.500z50 top=dem500 bottom=bottom\n out=/tmp/slovakia3d.vtk\n # visualize in paraview or other VTK viewer:\n paraview --data=/tmp/slovakia3d.vtk\n # set Display style to 'surface#\n # set Actor Control z to 10\n ", "see_also": ["r.out.vtk", "r3.out.ascii", "g.region"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.out.vtk"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.out.v5d.html", "name": "r3.out.v5d", "definition": "- Exports GRASS 3D raster map to 3-dimensional Vis5D file.", "keywords": ["raster3d", "export", "voxel"], "synopsis": "r3.out.v5d [-m] input=string output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Use map coordinates instead of xyz coordinates Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "3D raster map to be converted to Vis5D (V5D) file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for V5D output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n Exports 3D raster maps to V5D format. The  map  parameter is a valid \n 3D raster map in the current mapset search path. The  output \n parameter is the name  of a V5D file which will be written in the current\n working directory. \n  Vis5D  is a system\n for interactive visualization of large 5D gridded data sets such as those\n produced by numerical weather models. The user can make isosurfaces, contour\n line slices, colored slices, volume renderings, etc. of data in a 3D raster map,\n then rotate and animate the images in real time. There's also a feature\n for wind trajectory tracing, a way to make text anotations for publications,\n support for interactive data analysis, etc.\n ", "notes": "", "see_also": ["r3.in.v5d", "r3.out.vtk"], "authors": ["Jaro Hofierka, GeoModel s.r.o., Slovakia"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.out.v5d"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.out.netcdf.html", "name": "r3.out.netcdf", "definition": "- Export a 3D raster map as netCDF file.", "keywords": ["raster3d", "export", "netCDF", "voxel"], "synopsis": "r3.out.netcdf [-pm] input=name output=name  [null=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Export projection information as wkt and proj4 parameter Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for netCDF output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "The value to be used for null values, default is the netCDF standard", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The module  r3.out.netcdf  exports a 3D raster map as netCDF file.\n Maps are valid 3D raster maps in the current mapset search path. The\n  output  parameter is the name of a netCDF file that will be\n written in the current working directory. The module is sensitive\n to mapset region settings (set with  g.region ) and the vertical unit settings\n of the 3D raster map. The vertical unit can be set with  r3.support .\n ", "notes": "\n The resulting netCDF file will have time as third dimension in case a temporal \n vertical unit is specified for the input map, otherwise the third dimension is assumed as spatial.\n If the 3D raster map has a time stamp with absolute time, the start time will be \n used as starting point for the netCDF time series. If the absolute time stamp is missing\n the date \"Jan. 01. 1900 00:00:00\" will be used as default. In case of relative time stamp no start time\n is set in the netCDF file. The number of depths of the 3D raster map are the number of time slices\n in the netCDF file. You can use  t.rast.to.rast3  to convert a \n space time raster dataset into a 3D raster map representing a space time voxel \n cube, then export the raster time series as netCDF file.\n Spatial coordinates are exported as cell centered coordinates. The projection can be optionally stored\n in the metadata as  crs  attributes . \n The netCDF projection metadata storage follows the spatial_ref GDAL/netCDF suggestion\n  here  \n and the netCDF CF 1.6 convention \n  here   \n using WKT projection information. Additional a PROJ.4 string is\n stored in the  crs  attribute section. \n The export of projection parameters is suppressed when the XY-projection is set. \n The range of the 3D raster map is set in the netCDF output file. Optionally a the netCDF missing value and \n _FillValue can be set using the  null  option. As default the netCDF floating point _FillValues are used\n to fill empty cell.\n The netCDF library must be installed on the system and activated at configuration time to compile this module.\n  Examples \n g.region s=-90 n=90 w=-180 e=180 b=0 t=5 res=10 res3=10 tbres=1 -p3\n #####################################################################\n # We create a simple volume map with floating point values\n #####################################################################\n r3.mapcalc --o expr=\"volume_float = float(col() + row() + depth())\"\n r3.info volume_float\n  +----------------------------------------------------------------------------+\n  | Layer:    volume_float                   Date: Thu Jun 14 08:40:56 2012    |\n  | Mapset:   PERMANENT                      Login of Creator: soeren          |\n  | Location: TestLL                                                           |\n  | DataBase: /1/soeren/grassdata                                              |\n  | Title:    volume_float                                                     |\n  | Units:    none                                                             |\n  | Vertical unit: units                                                       |\n  | Timestamp: none                                                            |\n  |----------------------------------------------------------------------------|\n  |                                                                            |\n  |   Type of Map:  3d cell              Number of Categories: 0               |\n  |   Data Type:    FCELL                                                      |\n  |   Rows:         18                                                         |\n  |   Columns:      36                                                         |\n  |   Depths:       5                                                          |\n  |   Total Cells:  3240                                                       |\n  |   Total size:           10114 Bytes                                        |\n  |   Number of tiles:      1                                                  |\n  |   Mean tile size:       10114 Bytes                                        |\n  |   Tile size in memory:  12960 Bytes                                        |\n  |   Number of tiles in x, y and  z:   1, 1, 1                                |\n  |   Dimension of a tile in x, y, z:   36, 18, 5                              |\n  |                                                                            |\n  |        Projection: Latitude-Longitude (zone 0)                             |\n  |            N:        90N    S:        90S   Res:    10                     |\n  |            E:       180E    W:       180W   Res:    10                     |\n  |            T:          5    B:          0   Res:     1                     |\n  |   Range of data:   min =          3 max =         59                       |\n  |                                                                            |\n  |   Data Source:                                                             |\n  |                                                                            |\n  |                                                                            |\n  |                                                                            |\n  |   Data Description:                                                        |\n  |    generated by r3.mapcalc                                                 |\n  |                                                                            |\n  |   Comments:                                                                |\n  |    r3.mapcalc expression=\"volume_float = float(col() + row() + depth())\"   |\n  |                                                                            |\n  +----------------------------------------------------------------------------+\n #####################################################################\n # We use the netCDF ncdump tool to have a look at the header \n # and coordinates of the exported netCDF file\n #####################################################################\n r3.out.netcdf --o input=volume_float output=test_float.nc\n ncdump -c test_float.nc\n netcdf test_float {\n dimensions:\n         longitude = 36 ;\n         latitude = 18 ;\n         z = 5 ;\n variables:\n         float longitude(longitude) ;\n                 longitude:units = \"degrees_east\" ;\n                 longitude:long_name = \"Longitude values\" ;\n                 longitude:standard_name = \"longitude\" ;\n                 longitude:axis = \"X\" ;\n         float latitude(latitude) ;\n                 latitude:units = \"degrees_north\" ;\n                 latitude:long_name = \"Latitude values\" ;\n                 latitude:standard_name = \"latitude\" ;\n                 latitude:axis = \"Y\" ;\n         float z(z) ;\n                 z:units = \"meter\" ;\n                 z:long_name = \"z coordinate of projection\" ;\n                 z:standard_name = \"projection_z_coordinate\" ;\n                 z:positive = \"up\" ;\n                 z:axis = \"Z\" ;\n         float volume_float(z, latitude, longitude) ;\n                 volume_float:valid_min = 3.f ;\n                 volume_float:valid_max = 59.f ;\n // global attributes:\n                 :Conventions = \"CF-1.5\" ;\n                 :history = \"GRASS GIS 7 netCDF export of r3.out.netcdf\" ;\n data:\n  longitude = -175, -165, -155, -145, -135, -125, -115, -105, -95, -85, -75, \n     -65, -55, -45, -35, -25, -15, -5, 5, 15, 25, 35, 45, 55, 65, 75, 85, 95, \n     105, 115, 125, 135, 145, 155, 165, 175 ;\n  latitude = 85, 75, 65, 55, 45, 35, 25, 15, 5, -5, -15, -25, -35, -45, -55, \n     -65, -75, -85 ;\n  z = 0.5, 1.5, 2.5, 3.5, 4.5 ;\n }\n #####################################################################\n # Exporting the projection specific settings and a null value\n #####################################################################\n r3.out.netcdf --o -p null=-1 input=volume_float output=test_float.nc\n ncdump -c test_float.nc \n netcdf test_float {\n dimensions:\n         longitude = 36 ;\n         latitude = 18 ;\n         z = 5 ;\n variables:\n         char crs ;\n                 crs:crs_wkt = \"GEOGCS[\\\"wgs84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS_1984\\\",6378137,298.257223563]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433]]\" ;\n                 crs:spatial_ref = \"GEOGCS[\\\"wgs84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS_1984\\\",6378137,298.257223563]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433]]\" ;\n                 crs:crs_proj4 = \" +proj=longlat +no_defs +a=6378137 +rf=298.257223563 +towgs84=0.000,0.000,0.000\" ;\n         float longitude(longitude) ;\n                 longitude:units = \"degrees_east\" ;\n                 longitude:long_name = \"Longitude values\" ;\n                 longitude:standard_name = \"longitude\" ;\n                 longitude:axis = \"X\" ;\n         float latitude(latitude) ;\n                 latitude:units = \"degrees_north\" ;\n                 latitude:long_name = \"Latitude values\" ;\n                 latitude:standard_name = \"latitude\" ;\n                 latitude:axis = \"Y\" ;\n         float z(z) ;\n                 z:units = \"meter\" ;\n                 z:long_name = \"z coordinate of projection\" ;\n                 z:standard_name = \"projection_z_coordinate\" ;\n                 z:positive = \"up\" ;\n                 z:axis = \"Z\" ;\n         float volume_float(z, latitude, longitude) ;\n                 volume_float:valid_min = 3.f ;\n                 volume_float:valid_max = 59.f ;\n                 volume_float:missing_value = -1.f ;\n                 volume_float:_FillValue = -1.f ;\n                 volume_float:grid_mapping = \"crs\" ;\n // global attributes:\n                 :Conventions = \"CF-1.5\" ;\n                 :history = \"GRASS GIS 7 netCDF export of r3.out.netcdf\" ;\n data:\n  longitude = -175, -165, -155, -145, -135, -125, -115, -105, -95, -85, -75, \n     -65, -55, -45, -35, -25, -15, -5, 5, 15, 25, 35, 45, 55, 65, 75, 85, 95, \n     105, 115, 125, 135, 145, 155, 165, 175 ;\n  latitude = 85, 75, 65, 55, 45, 35, 25, 15, 5, -5, -15, -25, -35, -45, -55, \n     -65, -75, -85 ;\n  z = 0.5, 1.5, 2.5, 3.5, 4.5 ;\n }\n #####################################################################\n # Assigning time as vertical unit and setting an absolute time stamp\n #####################################################################\n r3.timestamp map=volume_float date='1 Jan 2001/5 Jan 2001'\n r3.support map=volume_float vunit=\"days\"\n r3.out.netcdf --o -p null=-1 input=volume_float output=test_float.nc\n ncdump -c test_float.nc \n netcdf test_float {\n dimensions:\n         longitude = 36 ;\n         latitude = 18 ;\n         time = 5 ;\n variables:\n         char crs ;\n                 crs:crs_wkt = \"GEOGCS[\\\"wgs84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS_1984\\\",6378137,298.257223563]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433]]\" ;\n                 crs:spatial_ref = \"GEOGCS[\\\"wgs84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS_1984\\\",6378137,298.257223563]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433]]\" ;\n                 crs:crs_proj4 = \" +proj=longlat +no_defs +a=6378137 +rf=298.257223563 +towgs84=0.000,0.000,0.000\" ;\n         float longitude(longitude) ;\n                 longitude:units = \"degrees_east\" ;\n                 longitude:long_name = \"Longitude values\" ;\n                 longitude:standard_name = \"longitude\" ;\n                 longitude:axis = \"X\" ;\n         float latitude(latitude) ;\n                 latitude:units = \"degrees_north\" ;\n                 latitude:long_name = \"Latitude values\" ;\n                 latitude:standard_name = \"latitude\" ;\n                 latitude:axis = \"Y\" ;\n         int time(time) ;\n                 time:units = \"days since 2001-01-01 00:00:00\" ;\n                 time:long_name = \"Time in days\" ;\n                 time:calendar = \"gregorian\" ;\n                 time:positive = \"up\" ;\n                 time:axis = \"T\" ;\n         float volume_float(time, latitude, longitude) ;\n                 volume_float:valid_min = 3.f ;\n                 volume_float:valid_max = 59.f ;\n                 volume_float:missing_value = -1.f ;\n                 volume_float:_FillValue = -1.f ;\n                 volume_float:grid_mapping = \"crs\" ;\n // global attributes:\n                 :Conventions = \"CF-1.5\" ;\n                 :history = \"GRASS GIS 7 netCDF export of r3.out.netcdf\" ;\n data:\n  longitude = -175, -165, -155, -145, -135, -125, -115, -105, -95, -85, -75, \n     -65, -55, -45, -35, -25, -15, -5, 5, 15, 25, 35, 45, 55, 65, 75, 85, 95, \n     105, 115, 125, 135, 145, 155, 165, 175 ;\n  latitude = 85, 75, 65, 55, 45, 35, 25, 15, 5, -5, -15, -25, -35, -45, -55, \n     -65, -75, -85 ;\n  time = 0, 1, 2, 3, 4 ;\n }\n \t\n ", "see_also": ["t.rast.to.rast3", "r3.in.ascii", "g.region"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.out.netcdf"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.out.bin.html", "name": "r3.out.bin", "definition": "- Exports a GRASS 3D raster map to a binary array.", "keywords": ["raster3d", "export", "voxel"], "synopsis": "r3.out.bin [-rdi] input=name output=name  [null=float]  bytes=integer  [order=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Switch the row order in output from north->south to south->north Switch the depth order in output from bottom->top to top->bottom Write data as integer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Switch the depth order in output from bottom->top to top->bottom Write data as integer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Write data as integer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "Value to write out for null", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bytes", "flag": "bytes", "dataType": "String", "optional": false, "explanation": "Number of bytes per cell in binary file", "defaultValue": null, "alternatives": ["1", "2", "4", "8"], "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Output byte order", "defaultValue": "native", "alternatives": ["big", "little", "native", "swap"], "isInputFile": false, "isOutputFile": false}], "description": "\n The  r3.out.bin  program exports a GRASS 3D raster map to a binary array\n file. Optionally, output can be send to standard output (stdout) for direct\n input (pipe) into other applications. Data is exported according to the\n original GRASS 3D raster type (float, double).\n ", "notes": "\n The write order of the rows (north->south to south->north) and\n the write order of the depths (bottom->top to top->bottom) can be switched.\n The region parameters are printed to stderr when setting the verbose flag.\n Export of little and big endian byte order is supported.\n Have a look at  r3.out.ascii  manual page that\n describes the internal layout of the 3D raster maps and the supported\n row and depth switch options.\n  Examples \n Have a look at the examples in  r3.in.bin .\n ", "see_also": ["r3.in.bin", "r3.out.bin", "r3.in.ascii"], "authors": ["S\u00f6ren Gebbert, based on r.out.bin from Bob Covill and Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.out.bin"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.out.ascii.html", "name": "r3.out.ascii", "definition": "- Converts a 3D raster map layer into a ASCII text file.", "keywords": ["raster3d", "export", "voxel", "conversion", "ASCII"], "synopsis": "r3.out.ascii [-hrdcm] input=string  [output=name]   [precision=integer]   [null_value=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "h", "flag": "-h", "explanation": "Suppress printing of header information Switch the row order in output from north->south to south->north Switch the depth order in output from bottom->top to top->bottom Print grass6 compatible format. Flags -d and -r are ignored. Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Switch the row order in output from north->south to south->north Switch the depth order in output from bottom->top to top->bottom Print grass6 compatible format. Flags -d and -r are ignored. Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Switch the depth order in output from bottom->top to top->bottom Print grass6 compatible format. Flags -d and -r are ignored. Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Print grass6 compatible format. Flags -d and -r are ignored. Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "3D raster map to be converted to ASCII", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for ASCII output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Number of decimal places for floats", "defaultValue": "8", "alternatives": ["0-20"], "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.out.ascii  exports a 3D raster map in ASCII format. The  input  parameter is\n a valid 3D raster map in the current mapset search path. The  output  \n parameter is the name of an ASCII file which will be written in the \n current working directory.\n  If  output  is not specified then standard output (stdout) is used.\n The  -h  flag may be used to suppress header information. The\n module is sensitive to region settings (set with  g.region ).\n  The  -c  flag will create GRASS 6  r3.in.ascii  compatible\n output.\n ", "notes": "\n The default format of the exported ASCII file is equivalent to that required\n by  r3.in.ascii . In particular, files output by\n  r3.out.ascii  with header information may be converted back to\n 3D raster maps with  r3.in.ascii .\n The format of the ASCII file is:\n version:  \"grass7\" \n order:    \"nsbt\" or \"nstb\" or \"snbt\" or \"sntb\" \n north:    floating point \n south:    floating point \n east:     floating point \n west:     floating point \n top:      floating point \n bottom:   floating point \n rows:     integer \n cols:     integer \n levels:   integer \n The  version  and  order  options have been introduced in GRASS 7 in June 2011.\n The  order  option describes the order of rows and depths in the output. \n It is possible to create output of different row order using the  -r  flag \n and output of different depths order using the   -d  flag. The default order is:\n west -> east for columns\n north -> south for rows\n bottom -> top for depths\n This header is followed by the cell values in  floating point  format \n organized in rows with constant  col  and  level  coordinate.\n The rows are organized by constant  level  coordinate. Individual cell\n values are separated by  space  or  CR .\n Cell values are exported as a series of horizontal slices in row-major\n order. The data starts with the upper left corner (NW) at the bottom of the data set.\n The values at the following coordinates are exported:\n (x, y + rows,     z) (x + 1, y + rows,     z) ... (x + cols, y + rows,     z)\n (x, y + rows,     z) (x + 1, y + rows - 1, z) ... (x + cols, y + rows - 1, z)\n           .                     .                                .\n           .                     .                                .\n           .                     .                                .\n (x, y,   z + depths) (x + 1, y,   z + depths) ... (x + cols, y,   z + depths)\n This order is compatible with the  r.in.ascii  row -> column ordering.\n Supported orders are:\n  nsbt : north -> south and bottom -> top ordering which is the default (no flags) \n  snbt : south -> north and bottom -> top ordering using  -r  flag \n  nstb : north -> south and top -> bottom ordering using  -d  flag \n  sntb : south -> north and top -> bottom ordering using  -rd  flag \n The internal storage scheme of 3D raster maps is visualized in the following picture:\n  \n  The coordinate system and tile layout of a voxel map in GRASS \n  \n One level maps can be imported with  r.in.ascii  (2D raster) using\n the default  nsbt  order and removing the header lines \"version\",\n \"order\", \"top\", \"bottom\" and \"levels\".\n  Example \n We define a small region with 4 columns, 3 rows and 2 depths (4x3x2) and export\n it using different ordering definitions: \n g.region res3=1 t=2 b=0 w=0 e=4 s=0 n=3\n r3.mapcalc \"simple_example = row() + col() + depth()\"\n Default order:\n r3.out.ascii input=simple_example dp=0\n version: grass7\n order: nsbt\n north: 3.000000\n south: 0.000000\n east: 4.000000\n west: 0.000000\n top: 2.000000\n bottom: 0.000000\n rows: 3\n cols: 4\n levels: 2\n 3 4 5 6 \n 4 5 6 7 \n 5 6 7 8 \n 4 5 6 7 \n 5 6 7 8 \n 6 7 8 9 \n Inverse row order (-r) \n r3.out.ascii input=simple_example dp=0 -r\n version: grass7\n order: snbt\n north: 3.000000\n south: 0.000000\n east: 4.000000\n west: 0.000000\n top: 2.000000\n bottom: 0.000000\n rows: 3\n cols: 4\n levels: 2\n 5 6 7 8 \n 4 5 6 7 \n 3 4 5 6 \n 6 7 8 9 \n 5 6 7 8 \n 4 5 6 7\n Inverse depth order (-d) \n r3.out.ascii input=simple_example dp=0 -d\n version: grass7\n order: nstb\n north: 3.000000\n south: 0.000000\n east: 4.000000\n west: 0.000000\n top: 2.000000\n bottom: 0.000000\n rows: 3\n cols: 4\n levels: 2\n 4 5 6 7 \n 5 6 7 8 \n 6 7 8 9 \n 3 4 5 6 \n 4 5 6 7 \n 5 6 7 8\n Inverse row and depth order (-rd) \n r3.out.ascii input=simple_example dp=0 -rd\n version: grass7\n order: sntb\n north: 3.000000\n south: 0.000000\n east: 4.000000\n west: 0.000000\n top: 2.000000\n bottom: 0.000000\n rows: 3\n cols: 4\n levels: 2\n 6 7 8 9 \n 5 6 7 8 \n 4 5 6 7 \n 5 6 7 8 \n 4 5 6 7 \n 3 4 5 6\n ", "see_also": ["r3.in.ascii", "r.out.ascii", "g.region"], "authors": ["Roman Waupotitsch, Michael Shapiro, Helena Mitasova, Bill Brown, Lubos Mitas, Jaro Hofierka, S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.out.ascii"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.null.html", "name": "r3.null", "definition": "- Explicitly create the 3D NULL-value bitmap file.", "keywords": ["raster3d", "null data", "voxel"], "synopsis": "r3.null map=string  [setnull=val[-val][,val[-val],...]]   [null=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "3D raster map for which to modify null values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "setnull", "flag": "setnull", "dataType": "String", "optional": true, "explanation": "List of cell values to be set to NULL", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "The value to replace the null value by", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n Modifies the NULL values of a 3D raster map.\n ", "notes": "", "see_also": ["r.null"], "authors": ["Roman Waupotitsch, Michael Shapiro, Helena Mitasova, Bill Brown, Lubos Mitas, Jaro Hofierka"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.null"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.neighbors.html", "name": "r3.neighbors", "definition": "- Makes each voxel value a function of the values assigned to the voxels around it, and stores new voxel values in an output 3D raster map", "keywords": ["raster3d", "algebra", "voxel", "statistics", "aggregation", "neighbor", "focal statistics", "filter"], "synopsis": "r3.neighbors input=name output=name method=string  [quantile=float]  window=x,y,z  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Aggregate operation", "defaultValue": null, "alternatives": ["average", "median", "mode", "minimum", "maximum", "range", "stddev", "sum", "count", "variance", "diversity", "interspersion", "quart1", "quart3", "perc90", "quantile"], "isInputFile": false, "isOutputFile": false}, {"parameter": "quantile", "flag": "quantile", "dataType": "String", "optional": true, "explanation": "Quantile to calculate for method=quantile", "defaultValue": null, "alternatives": ["0.0-1.0"], "isInputFile": false, "isOutputFile": false}, {"parameter": "window", "flag": "window", "dataType": "String", "optional": false, "explanation": "The size of the window in x, y and z direction, values must be odd integer numbers, eg: 3,3,3", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.neighbors  looks at each voxel in a 3D raster input\n map layer, and examines the values assigned to the\n voxel in a user-defined \"neighborhood\" around it.  It\n outputs a new 3D raster map in which each voxel is\n assigned a value that is a (user-specified)\n function of the values in that voxel's neighborhood.  For\n example, each voxel in the output map might be assigned a\n value equal to the average of the values\n appearing in its 3 x 3 x 3 voxel \"neighborhood\" in the input\n map layer.\n  OPTIONS \n The user must specify the names of the 3D raster map layers to\n be used for  input  and  output , the\n  method  used to analyze neighborhood\n values (i.e., the neighborhood function or operation to be\n performed), and the moving  window  of the neighborhood.\n  Neighborhood Operation Methods: \n The  neighborhood  operators determine what new \n value a center voxel in a neighborhood will have after examining\n values inside its neighboring voxels.\n Each voxel in a 3D raster map layer becomes the center voxel of a neighborhood \n as the neighborhood window moves from voxel to voxel throughout the map layer.\n  r3.neighbors  can perform the following operations:\n  average  \n  The average value within the neighborhood.\n  median  \n  The value found half-way through a list of the\n neighborhood's values,\n when these are ranged in numerical order.\n  mode  \n  The most frequently occurring value in the neighborhood.\n  minimum  \n  The minimum value within the neighborhood.\n  maximum  \n  The maximum value within the neighborhood.\n  range \n  The range value within the neighborhood.\n  stddev  \n  The statistical standard deviation of values\n within the neighborhood.\n  sum  \n  The sum of values within the neighborhood.\n  variance  \n  The statistical variance of values\n within the neighborhood.\n  diversity  \n  The number of different values within the neighborhood.\n  interspersion  \n  The percentage of voxels containing values which differ from the values\n assigned to the center voxel in the neighborhood, plus 1.\n  Neighborhood Size: \n The neighborhood moving  window  specifies which voxel surrounding any given\n voxel fall into the neighborhood for that voxel.\n The  window  must be three comma separated odd integers. The dimension order is: x,y,z.\n For example: the parameter window=3,3,3 specifies a moving window (a cube) with 27 voxel. \n ", "notes": "\n The  r3.neighbors  program works in the current geographic region. \n It is recommended, but not required,\n that the 3D resolution of the geographic region be the same as that\n of the 3D raster map layer. \n  r3.neighbors  doesn't propagate NULLs, but computes the\n aggregation over the non-NULL voxels in the neighborhood.\n ", "see_also": ["g.region", "r.neighbors", "r3.mapcalc", "r3.stats", "r3.support"], "authors": ["Soeren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.neighbors"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.mkdspf.html", "name": "r3.mkdspf", "definition": "- Creates a display file from an existing 3D raster map according to specified threshold levels.", "keywords": ["raster3d", "display", "voxel"], "synopsis": "r3.mkdspf [-qf] input=string dspf=name  [levels=float[,float,...]]   [min=float]   [max=float]   [step=float]   [tnum=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "q", "flag": "-q", "explanation": "Suppress progress report & min/max information Use flat shading rather than gradient Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Use flat shading rather than gradient Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of an existing 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "dspf", "flag": "dspf", "dataType": "String", "optional": false, "explanation": "Name for output display file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "levels", "flag": "levels", "dataType": "String", "optional": true, "explanation": "List of thresholds for isosurfaces", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "min", "flag": "min", "dataType": "String", "optional": true, "explanation": "Minimum isosurface level", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max", "flag": "max", "dataType": "String", "optional": true, "explanation": "Maximum isosurface level", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "step", "flag": "step", "dataType": "String", "optional": true, "explanation": "Positive increment between isosurface levels", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tnum", "flag": "tnum", "dataType": "String", "optional": true, "explanation": "Number of isosurface threshold levels", "defaultValue": "7", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n Creates a display file from an existing grid3 file according to\n specified threshold levels.  The display file is a display list\n of polygons that represent isosurfaces of the data volume.  If\n specific  levels  are given, additional optional parameters \n are ignored.   Min  or  max  may be used alone or together\n to specify a sub-range of the data.  The  step \n parameter is given precedence over  tnum .\n  Flags: \n  -q \n  Suppress progress report & min/max information\n  -f \n  Use flat shading rather than gradient\n  Parameters: \n  grid3 \n  Name of an existing 3D raster map\n  dspf \n  Name of output display file\n  levels \n  List of thresholds for isosurfaces\n  min \n  Minimum isosurface level\n  max \n  Maximum isosurface level\n  step \n  Positive increment between isosurface levels\n  tnum \n  Number of isosurface threshold levels\n  Default: 7\n  Example: \n With grid3 data ( phdata ) in the range 3-7, \n we only want to see isosurface values for the range 4-6.  \n Any of these commands will produce the same results: \n r3.mkdspf phdata dspf=iso min=4.0 max=6.0 tnum=5\n r3.mkdspf phdata dspf=iso levels=4.0,4.5,5.0,5.5,6.0\n r3.mkdspf phdata dspf=iso min=4.0 max=6.0 step=0.5\n ", "notes": "", "see_also": [], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.mkdspf"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.mask.html", "name": "r3.mask", "definition": "- Establishes the current working 3D raster mask.", "keywords": ["raster3d", "mask", "voxel"], "synopsis": "r3.mask map=string  [maskvalues=val[-val][,val[-val],...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "3D raster map with reference values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maskvalues", "flag": "maskvalues", "dataType": "String", "optional": true, "explanation": "List of cell values to be masked out", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n File  map  is used as reference file.\n Cells in the mask are marked as \"mask out\" if the corresponding cell in\n  map  contains a value in the range specified with  maskvalues .\n  Before a new 3D-mask can be created the exisitng mask has to be removed\n with  g.remove .\n ", "notes": "", "see_also": ["g.remove"], "authors": ["Roman Waupotitsch, Michael Shapiro, Helena Mitasova, Bill Brown, Lubos Mitas, Jaro Hofierka"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.mask"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.mapcalc.html", "name": "r3.mapcalc", "definition": "- Raster map calculator.", "keywords": ["raster", "algebra"], "synopsis": "r3.mapcalc [-sl]  [expression=string]   [region=string]   [file=name]   [seed=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Generate random seed (result is non-deterministic) List input and output maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List input and output maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": true, "explanation": "Expression to evaluate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "region", "flag": "region", "dataType": "String", "optional": true, "explanation": "The computational region that should be used.", "defaultValue": "current", "alternatives": ["current", "intersect", "union"], "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "File containing expression(s) to evaluate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "seed", "flag": "seed", "dataType": "String", "optional": true, "explanation": "Seed for rand() function", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.mapcalc  performs arithmetic on raster map layers.\n New raster map layers can be created which are arithmetic expressions\n involving existing raster map layers, integer or floating point constants,\n and functions.\n  Program use \n  r3.mapcalc  expression have the form:\n  result =  expression \n  where  result  is the name of a raster map layer\n to contain the result of the calculation and\n  expression  is any legal arithmetic expression involving existing\n raster map layers (except  result  itself), integer or floating point constants,\n and functions known to the calculator.\n Parentheses are allowed in the expression and may be nested to any depth.\n  result  will be created in the user's current mapset.\n As  expression=  is the first option, it is the default. This\n means that passing an expression on the command line is possible\n as long as the expression is quoted and a space is included before the\n first  =  sign.\n Example ('foo' is the resulting map):\n r3.mapcalc \"foo = 1\"\n or:\n r3.mapcalc 'foo = 1'\n An unquoted expression (i.e. split over multiple arguments) won't\n work, nor will omitting the space before the = sign:\n r3.mapcalc 'foo=1'\n Sorry, <foo> is not a valid parameter\n If no options are given, it manufactures \"file=-\" (which reads from\n stdin), so you can continue to use e.g.:\n r3.mapcalc < file\n or:\n r3.mapcalc <<EOF\n foo = 1\n EOF\n But unless you need compatibility with previous versions, use file=\n explicitly, e.g.:\n r3.mapcalc file=file\n or:\n r3.mapcalc file=- <<EOF\n foo = 1\n EOF\n  The formula entered to  r3.mapcalc  by the user is recorded both in the\n  result  map title (which appears in the category file for  result )\n and in the history file for  result .\n  Some characters have special meaning to the command shell. If the user\n is entering input to  r3.mapcalc  on the command line, expressions\n should be enclosed within single quotes.  See NOTES, below.\n  Operators and order of precedence \n The following operators are supported:\n      Operator   Meaning                    Type        Precedence\n      --------------------------------------------------------------\n      -          negation                   Arithmetic  12\n      ~          one's complement           Bitwise     12\n      !          not                        Logical     12\n      ^          exponentiation             Arithmetic  11\n      %          modulus                    Arithmetic  10\n      /          division                   Arithmetic  10\n      *          multiplication             Arithmetic  10\n      +          addition                   Arithmetic   9\n      -          subtraction                Arithmetic   9\n      <<         left shift                 Bitwise      8\n      >>         right shift                Bitwise      8\n      >>>        right shift (unsigned)     Bitwise      8\n      >          greater than               Logical      7\n      >=         greater than or equal      Logical      7\n      <          less than                  Logical      7\n      <=         less than or equal         Logical      7\n      ==         equal                      Logical      6\n      !=         not equal                  Logical      6\n      &          bitwise and                Bitwise      5\n      |          bitwise or                 Bitwise      4\n      &&         logical and                Logical      3\n      &&&        logical and[1]             Logical      3\n      ||         logical or                 Logical      2\n      |||        logical or[1]              Logical      2\n      ?:         conditional                Logical      1\n (modulus is the remainder upon division)\n  [1] The &&& and ||| operators handle null values differently to other\n operators. See the section entitled  NULL support  below for more\n details.\n  The operators are applied from left to right, with those of higher precedence\n applied before those with lower precedence.\n Division by 0 and modulus by 0 are acceptable and give a NULL result.\n The logical operators give a 1 result if the comparison is true, 0 otherwise.\n  3D Grid names \n Anything in the expression which is not a number, operator, or function name\n is taken to be a 3D grid name.\n Examples:\n volume\n x3\n 3d.his\n  Most GRASS raster map layers and 3D grids meet this naming convention.\n However, if a 3D grid has a name which conflicts with the above rule, it\n should be quoted. For example, the expression\n x = a-b\n  would be interpreted as:  x equals a minus b, whereas\n x = \"a-b\"\n  would be interpreted as:  x equals the 3D grid named  a-b \n  Also\n x = 3107\n  would create  x  filled with the number 3107, while\n x = \"3107\"\n  would copy the 3D grid  3107  to the 3D grid  x .\n  Quotes are not required unless the 3D grid names look like numbers or\n contain operators, OR unless the program is run non-interactively. Examples\n given here assume the program is run interactively. See NOTES, below.\n  r3.mapcalc  will look for the 3D grids according to the user's\n current mapset search path. It is possible to override the search path\n and specify the mapset from which to select the 3D grid. This is done by\n specifying the 3D grid name in the form:\n name@mapset\n  For example, the following is a legal expression:\n result = x@PERMANENT / y@SOILS\n  The mapset specified does not have to be in the mapset search path.\n (This method of overriding the mapset search path is common to all\n GRASS commands, not just  r3.mapcalc .)\n  The neighborhood modifier \n 3D grids are data base files stored in voxel format, i.e., three-dimensional\n matrices of float/double values. In  r3.mapcalc , 3D grids may be\n followed by a  neighborhood  modifier that specifies a relative offset\n from the current cell being evaluated. The format is\n  map[r,c,d] ,\n where  r  is the row offset,  c  is the column offset and  d \n is the depth offset. For example,  map[1,2,3]  refers to the cell\n one row below, two columns to the right and 3 levels below of the current\n cell,  map[-3,-2,-1]  refers to the cell three rows above, two columns\n to the left and one level below of the current cell, and  map[0,1,0] \n refers to the cell one column to the right of the current cell. This syntax\n permits the development of neighborhood-type filters within a single 3D\n grid or across multiple 3D grids.\n  Functions \n The functions currently supported are listed in the table below.\n The type of the result is indicated in the last column.\n  F  means that the functions always results in a floating point value,\n  I  means that the function gives an integer result, and\n  *  indicates that the result is float if any of the arguments to the\n function are floating point values and integer if all arguments are integer.\n function                description                                     type\n ---------------------------------------------------------------------------\n abs(x)                  return absolute value of x                      *\n acos(x)                 inverse cosine of x (result is in degrees)      F\n asin(x)                 inverse sine of x (result is in degrees)        F\n atan(x)                 inverse tangent of x (result is in degrees)     F\n atan(x,y)               inverse tangent of y/x (result is in degrees)   F\n cos(x)                  cosine of x (x is in degrees)                   F\n double(x)               convert x to double-precision floating point    F\n eval([x,y,...,]z)       evaluate values of listed expr, pass results to z\n exp(x)                  exponential function of x                       F\n exp(x,y)                x to the power y                                F\n float(x)                convert x to single-precision floating point    F\n graph(x,x1,y1[x2,y2..]) convert the x to a y based on points in a graph F\n graph2(x,x1[,x2,..],y1[,y2..])\n                         alternative form of graph()                     F\n if                      decision options:                               *\n if(x)                   1 if x not zero, 0 otherwise\n if(x,a)                 a if x not zero, 0 otherwise\n if(x,a,b)               a if x not zero, b otherwise\n if(x,a,b,c)             a if x > 0, b if x is zero, c if x < 0\n int(x)                  convert x to integer [ truncates ]              I\n isnull(x)               check if x = NULL\n log(x)                  natural log of x                                F\n log(x,b)                log of x base b                                 F\n max(x,y[,z...])         largest value of those listed                   *\n median(x,y[,z...])      median value of those listed                    *\n min(x,y[,z...])         smallest value of those listed                  *\n mode(x,y[,z...])        mode value of those listed                      *\n nmax(x,y[,z...])        largest value of those listed, excluding NULLs  *\n nmedian(x,y[,z...])     median value of those listed, excluding NULLs   *\n nmin(x,y[,z...])        smallest value of those listed, excluding NULLs *\n nmode(x,y[,z...])       mode value of those listed, excluding NULLs     *\n not(x)                  1 if x is zero, 0 otherwise\n pow(x,y)                x to the power y                                *\n rand(a,b)               random value x : a <= x < b                     *\n round(x)                round x to nearest integer                      I\n round(x,y)              round x to nearest multiple of y\n round(x,y,z)            round x to nearest y*i+z for some integer i\n sin(x)                  sine of x (x is in degrees)                     F\n sqrt(x)                 square root of x                                F\n tan(x)                  tangent of x (x is in degrees)                  F\n xor(x,y)                exclusive-or (XOR) of x and y                   I\n Internal variables:\n  row()                  current row of moving window                    I\n  col()                  current col of moving window                    I\n  depth()                return current depth                            I\n  nrows()                number of rows in computation region            I\n  ncols()                number of columns in computation region         I\n  ndepths()              number of depth levels in computation region    I\n  x()                    current x-coordinate of moving window           F\n  y()                    current y-coordinate of moving window           F\n  z()                    return current z value                          F\n  ewres()                current east-west resolution                    F\n  nsres()                current north-south resolution                  F\n  tbres()                current top-bottom resolution                   F\n  area()                 area of current cell in square meters           F\n  null()                 NULL value\n Note, that the row(), col() and depth() indexing starts with 1. \n  Floating point values in the expression \n Floating point numbers are allowed in the expression. A floating point\n number is a number which contains a decimal point:\n     2.3   12.0   12.   .81\n Floating point values in the expression are handled in a special way.\n With arithmetic and logical operators, if either operand is float,\n the other is converted to float and the result of the operation is float.\n This means, in particular that division of integers results in a\n (truncated) integer, while division of floats results in an accurate\n floating point value.  With functions of type * (see table above),\n the result is float if any argument is float, integer otherwise.\n  Note: If you calculate with integer numbers, the resulting map will\n be integer. If you want to get a float result, add the decimal point\n to integer number(s).\n  If you want floating point division, at least one of the arguments has\n to be a floating point value. Multiplying one of them by 1.0 will\n produce a floating-point result, as will using float():\n       r3.mapcalc \"ratio = float(soil.4 - soil.3) / soil.3)\"\n  NULL support \n  Division by zero should result in NULL. \n  Modulus by zero should result in NULL. \n  NULL-values in any arithmetic or logical operation should result\n in NULL. (however, &&& and ||| are treated specially, as described below).\n  The &&& and ||| operators observe the following axioms even when x is NULL:\n \tx &&& false == false\n \tfalse &&& x == false\n \tx ||| true == true\n \ttrue ||| x == true\n  NULL-values in function arguments should result in NULL (however,\n if(), eval() and isnull() are treated specially, as described below).\n  The eval() function always returns its last argument\n  The situation for if() is:\n if(x) \n \tNULL if x is NULL; 0 if x is zero; 1 otherwise \n if(x,a) \n \tNULL if x is NULL; a if x is non-zero; 0 otherwise \n if(x,a,b) \n \tNULL if x is NULL; a if x is non-zero; b otherwise \n if(x,n,z,p) \n \tNULL if x is NULL; n if x is negative; \n z if x is zero; p if x is positive \n  The (new) function isnull(x) returns: 1 if x is NULL; \n 0 otherwise. The (new) function null() \n (which has no arguments) returns an integer NULL. \n  Non-NULL, but invalid, arguments to functions should result in NULL. \n Examples: \n log(-2) \n sqrt(-2) \n pow(a,b) where a is negative and b is not an integer \n  NULL support: Please note that any math performed with NULL cells always\n results in a NULL value for these cells. If you want to replace a NULL cell\n on-the-fly, use the isnull() test function in a if-statement.\n  Example: The users wants the NULL-valued cells to be treated like zeros. To\n add maps A and B (where B contains NULLs) to get a map C the user can use a\n construction like: \n C = A + if(isnull(B),0,B)\n  NULL and conditions: \n  For the one argument form:\n if(x) = NULL\t\tif x is NULL\n if(x) = 0\t\tif x = 0\n if(x) = 1\t\totherwise (i.e. x is neither NULL nor 0).\n  For the two argument form:\n if(x,a) = NULL\t\tif x is NULL\n if(x,a) = 0\t\tif x = 0\n if(x,a) = a\t\totherwise (i.e. x is neither NULL nor 0).\n  For the three argument form:\n if(x,a,b) = NULL\tif x is NULL\n if(x,a,b) = b\t\tif x = 0\n if(x,a,b) = a\t\totherwise (i.e. x is neither NULL nor 0).\n  For the four argument form:\n if(x,a,b,c) = NULL\tif x is NULL\n if(x,a,b,c) = a\t\tif x > 0\n if(x,a,b,c) = b\t\tif x = 0\n if(x,a,b,c) = c\t\tif x < 0\n More generally, all operators and most functions return NULL if *any*\n of their arguments are NULL.\n The functions if(), isnull() and eval() are exceptions.\n The function isnull() returns 1 if its argument is NULL and 0 otherwise.\n If the user wants the opposite, the ! operator, e.g. \"!isnull(x)\" must be\n used.\n  All forms of if() return NULL if the first argument is NULL. The 2, 3\n and 4 argument forms of if() return NULL if the \"selected\" argument is\n NULL, e.g.:\n if(0,a,b) = b\tregardless of whether a is NULL\n if(1,a,b) = a\tregardless of whether b is NULL\n eval() always returns its last argument, so it only returns NULL if\n the last argument is NULL.\n  Note : The user cannot test for NULL using the == operator, as that\n returns NULL if either or both arguments are NULL, i.e. if x and y are\n both NULL, then \"x == y\" and \"x != y\" are both NULL rather than 1 and\n 0 respectively.\n The behaviour makes sense if the user considers NULL as representing an\n unknown quantity. E.g. if x and y are both unknown, then the values of\n \"x == y\" and \"x != y\" are also unknown; if they both have unknown\n values, the user doesn't know whether or not they both have the same value.\n ", "notes": "\n  Usage from command line \n Extra care must be taken if the expression is given on the command line.\n Some characters have special meaning to the UNIX shell.\n These include, among others:\n * ( ) > & |\n  It is advisable to put single quotes around the expression; e.g.:\n 'result = volume * 2'\n Without the quotes, the *, which has special meaning to the UNIX shell,\n would be altered and  r3.mapcalc  would see something other than the *.\n  Multiple computations \n In general, it's preferable to do as much as possible in each\n r3.mapcalc command using multi-line input.\n  Backwards compatibility \n For the backwards compatibility with GRASS 6, \n if no options are given, it manufactures  file=-  (which reads from\n stdin), so you can continue to use e.g.:\n r3.mapcalc < file\n or:\n r3.mapcalc <<EOF\n foo = 1\n EOF\n But unless you need compatibility with previous GRASS GIS versions, use  file= \n explicitly, as stated above.\n When the map name contains uppercase letter(s) or a dot which are not\n allowed to be in module option names, the  r3.mapcalc  command will\n be valid also without quotes:\n r3.mapcalc volume_A=1\n r3.mapcalc volume.1=1\n However, this syntax is not recommended as quotes as stated above more safe.\n Using quotes is both backwards compatible and valid in future.\n  Interactive input in command line \n For formulas that the user enters from standard input\n (rather than from the command line), a line continuation feature now exists.\n If the user adds a backslash to the end of an input line,  r3.mapcalc  assumes that\n the formula being entered by the user continues on to the next input line.\n There is no limit to the possible number of input lines\n or to the length of a formula.\n  If the  r3.mapcalc  formula entered by the user is very long,\n the map title will contain only some of it, but most (if not all) of\n the formula will be placed into the history file for the  result  map.\n  When the user enters input to  r3.mapcalc  non-interactively on\n the command line, the program will not warn the user not to overwrite\n existing map layers.  Users should therefore take care to assign program\n outputs raster map names that do not yet exist in their current mapsets.\n  3D GRID MASK handling \n  r3.mapcalc  follows the common GRASS behavior of raster MASK handling,\n so the MASK is only applied when reading an existing GRASS raster map.\n This implies that, for example, the command:\n r3.mapcalc \"volume_amplified = volume * 3\"\n create a map respecting the masked pixels if MASK is active.\n However, when creating a map which is not based on any map,\n e.g. a map from a constant:\n r3.mapcalc \"volume_const = 200.0\"\n the created raster map is limited only by a computation region\n but it is not affected by an active MASK.\n This is expected because, as mentioned above, MASK is only applied when reading,\n not when writing a raster map.\n If also in this case the MASK should be applied, an if() statement including the\n MASK should be used, e.g.:\n r3.mapcalc \"volume_const = if(MASK, 200.0, null())\"\n When testing MASK related expressions keep in mind that when MASK is active\n you don't see data in masked areas even if they are not NULL.\n See  r.mask  for details.\n  Random number generator initialization \n  The pseudo-random number generator used by the rand() function can\n be initialised to a specific value using the  seed  option. \n This can be used to replicate a previous calculation.\n  Alternatively, it can be initialised from the system time and the\n PID using the  -r  flag. This should result in a different seed\n being used each time.\n  In either case, the seed will be written to the map's history, and\n can be seen using  r.info .\n  If you want other people to be able to verify your results, it's\n preferable to use the  seed  option to supply a seed which is\n either specified in the script or generated from a determenistic process\n such as a pseudo-random number generator given an explicit seed.\n  Note that the rand() function will generate a fatal error if neither\n the  seed  option nor the  -s  flag are given.\n  EXAMPLES \n To compute the average of two 3D grids\n  a  and  b :\n ave = (a + b)/2\n To form a weighted average:\n ave = (5*a + 3*b)/8.0\n To produce a binary representation of 3D grid\n  a  so that category 0 remains 0 and all other categories become 1:\n mask = a != 0\n This could also be accomplished by:\n mask = if(a)\n To mask 3D grid  b  by 3D grid  a :\n result = if(a,b)\n To change all values below 5 to NULL, keep otherwise:\n newmap = if(map < 5, null(), map)\n The graph() function allows users to specify a x-y conversion using \n pairs of x,y coordinates.\n In some situations a transformation from one value to another is not\n easily established mathematically, but can be represented by a 2-D\n graph and then linearly interpolated. The graph() function provides\n the opportunity to accomplish this.\n An x-axis value is provided to the graph function along with\n the associated graph represented by a series of x,y pairs.  The x\n values must be monotonically increasing (each larger than or equal to\n the previous).  The graph function linearly interpolates between\n pairs.  Any x value lower the lowest x value (i.e. first) will have\n the associated y value returned.  Any x value higher than the last\n will similarly have the associated y value returned.  Consider the\n request:\n newmap = graph(map, 1,10, 2,25, 3,50)\n X (map) values supplied and y (newmap) values returned:\n 0, 10\n 1, 10\n 1.5, 17.5\n 2.9, 47.5\n 4, 50\n 100, 50\n  KNOWN ISSUES \n The  result  variable on the left hand side of the equation should not\n appear in the  expression  on the right hand side.\n  mymap = if( mymap > 0, mymap, 0) \n  Any maps generated by a  r3.mapcalc  command only exist after the entire\n command has completed. All maps are generated concurrently, row-by-row\n (i.e. there is an implicit \"for row in rows {...}\" around the entire expression).\n Thus the  # ,  @ , and  [ ]  operators cannot be used on a map\n generated within same  r3.mapcalc  command run.\n newmap = oldmap * 3.14\n  othermap = newmap[-1, 0] / newmap[1, 0] \n  Continuation lines must end with a  \\  and have  no  trailing\n white space (blanks or tabs). If the user does leave white space at the end of\n continuation lines, the error messages produced by  r3.mapcalc  will\n be meaningless and the equation will not work as the user intended.\n This is particularly important for the  eval()  function.\n Currently, there is no comment mechanism in  r3.mapcalc .\n Perhaps adding a capability that would cause the entire line to be\n ignored when the user inserted a # at the start of a line\n as if it were not present, would do the trick.\n  The function should require the user to type \"end\" or \"exit\" instead\n of simply a blank line. This would make separation of multiple scripts\n separable by white space.\n  r3.mapcalc  does not print a warning in case of operations on\n NULL cells. It is left to the user to utilize the  isnull()  function.\n ", "see_also": ["g.region", "r3.colors", "r.mapcalc"], "authors": ["Tomas Paudits & Jaro Hofierka, funded by GeoModel s.r.o., Slovakia"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.mapcalc"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.info.html", "name": "r3.info", "definition": "- Outputs basic information about a user-specified 3D raster map layer.", "keywords": ["raster3d", "metadata", "voxel", "extent"], "synopsis": "r3.info [-grh] map=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print raster3d information in shell style Print range in shell style only Print raster history instead of info Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Print range in shell style only Print raster history instead of info Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Print raster history instead of info Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.info  reports metadata and range of 3D voxel maps.\n ", "notes": "", "see_also": ["r.info"], "authors": ["Roman Waupotitsch, Michael Shapiro, Helena Mitasova, Bill Brown, Lubos Mitas, Jaro Hofierka"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.info"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.in.xyz.html", "name": "r3.in.xyz", "definition": "- Create a 3D raster map from an assemblage of many coordinates using univariate statistics", "keywords": ["raster3d", "import", "voxel", "LIDAR", "statistics", "conversion", "aggregation", "binning"], "synopsis": "r3.in.xyz [-sgi] input=name output=name  [method=string]   [type=string]   [separator=character]   [x=integer]   [y=integer]   [z=integer]   [value_column=integer]   [vrange=min,max]   [vscale=float]   [percent=integer]   [pth=integer]   [trim=float]   [workers=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Scan data file for extent then exit In scan mode, print using shell script style Ignore broken lines Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "In scan mode, print using shell script style Ignore broken lines Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Ignore broken lines Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "ASCII file containing input data", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Statistic to use for raster values", "defaultValue": "mean", "alternatives": ["n", "min", "max", "range", "sum", "mean", "stddev", "variance", "coeff_var", "median", "percentile", "skewness", "trimmean"], "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Storage type for resultant raster map", "defaultValue": "float", "alternatives": ["float", "double"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "x", "flag": "x", "dataType": "String", "optional": true, "explanation": "Column number of x coordinates in input file (first column is 1)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y", "flag": "y", "dataType": "String", "optional": true, "explanation": "Column number of y coordinates in input file", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "z", "flag": "z", "dataType": "String", "optional": true, "explanation": "Column number of z coordinates in input file", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "value_column", "flag": "value_column", "dataType": "String", "optional": true, "explanation": "Column number of data values in input file", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vrange", "flag": "vrange", "dataType": "String", "optional": true, "explanation": "Filter range for value column data (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "vscale", "flag": "vscale", "dataType": "String", "optional": true, "explanation": "Scaling factor to apply to value column data", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "percent", "flag": "percent", "dataType": "String", "optional": true, "explanation": "Percent of map to keep in memory", "defaultValue": "100", "alternatives": ["1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "pth", "flag": "pth", "dataType": "String", "optional": true, "explanation": "pth percentile of the values", "defaultValue": null, "alternatives": ["1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "trim", "flag": "trim", "dataType": "String", "optional": true, "explanation": "Discard <trim> percent of the smallest and <trim> percent of the largest observations", "defaultValue": null, "alternatives": ["0-50"], "isInputFile": false, "isOutputFile": false}, {"parameter": "workers", "flag": "workers", "dataType": "String", "optional": true, "explanation": "Number of parallel processes to launch", "defaultValue": "1", "alternatives": ["1-256"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.in.xyz  imports sparse XYZ data from an ASCII file into\n a 3D raster map (voxels). It does this by running the  r.in.xyz \n module multiple times for different z-ranges and then assembling the\n slices with  r.to.rast3 .\n See the  r.in.xyz  help page for general\n parameter usage and tips.\n The map is created using the rows, columns, and depths set by\n current region settings. Be sure to check and adjust these with\n the  g.region  module before performing the import.\n You may either use the z-value as the data value for the voxel\n (e.g. with the 'n' statistic), or alternately scan another\n column for the data values to bin into the voxels. This alternate\n data column can be both filtered by range and have a scaling\n factor applied to it.\n ", "notes": "\n The 2D and 3D horizontal region resolutions must match. See the\n EXAMPLES section below.\n Unlike  r.in.xyz , reading from stdin and z-scaling are not\n possible. Filtering by z-range is accomplished by setting the 3D region.\n To enable parallel processing support, set the  workers=  option\n to match the number of CPUs or CPU-cores available on your system.\n Alternatively, the  WORKERS  environment variable can be set\n to the number of concurrent processes desired.\n Points falling exactly on a vertical bound will belong to the depth\n band below them, except for points exactly on the top bound, which will\n belong to the top-most slice.\n The script is expected to be nearly as efficient as if it was fully\n written in C.\n  EXAMPLE \n Using the Serpent Mound dataset. (see the\n   GRASS LiDAR wiki page )\n   #scan dataset for extent:\n   r3.in.xyz -s in=Serpent_Mound_Model_LAS_Data.txt out=dummy \n       x=1 y=2 z=3 separator=space\n   # set the 2D and 3D regions:\n   g.region n=4323641.57 s=4320942.61 w=289020.90 e=290106.02 res=1 -a\n   g.region b=166 t=216 res3=1 tbres=5 -3 -p\n   r3.in.xyz in=Serpent_Mound_Model_LAS_Data.txt out=serpent3D \n       method=mean x=1 y=2 z=3 separator=space type=float\n The same, but aggregate and store backscatter strength from column 5\n into voxels in instead of the z-value:\n   r3.in.xyz in=Serpent_Mound_Model_LAS_Data.txt out=serpent3D.bakscat \n       method=mean x=1 y=2 z=3 val=5 separator=space type=float\n  KNOWN ISSUES \n  r.to.rast3  always creates a  double  output map\n regardless of input.\n ", "see_also": ["g.region", "r.in.xyz", "r.to.rast3"], "authors": ["Hamish Bowman"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/r3.in.xyz"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.in.v5d.html", "name": "r3.in.v5d", "definition": "- Import 3-dimensional Vis5D files.", "keywords": ["raster3d", "import", "voxel"], "synopsis": "r3.in.v5d input=name output=name  [null_value=string]   [type=string]   [precision=string]   [compression=string]   [tiledimension=XxYxZ]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of V5D raster file to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Data type used in the output raster3d map", "defaultValue": "default", "alternatives": ["default", "double", "float"], "isInputFile": false, "isOutputFile": false}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Number of digits used as mantissa in the internal map storage, 0 -23 for float, 0 - 52 for double, max or default", "defaultValue": "default", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "compression", "flag": "compression", "dataType": "String", "optional": true, "explanation": "The compression method used in the output raster3d map", "defaultValue": "default", "alternatives": ["default", "zip", "none"], "isInputFile": false, "isOutputFile": false}, {"parameter": "tiledimension", "flag": "tiledimension", "dataType": "String", "optional": true, "explanation": "The dimensions of the tiles used in the output raster3d map (XxYxZ or default: 16x16x8)", "defaultValue": "default", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.in.v5d  imports 3-dimensional files (i.e. the V5D file with\n one variable and one time step). Otherwise, only first variable and\n timestep from 4/5D V5D file will be imported.\n  Vis5D  is a system\n for interactive visualization of large 5D gridded data sets such as those\n produced by numerical weather models. The user can make isosurfaces, contour\n line slices, colored slices, volume renderings, etc. of data in a 3D raster map,\n then rotate and animate the images in real time. There's also a feature\n for wind trajectory tracing, a way to make text anotations for publications,\n support for interactive data analysis, etc.\n ", "notes": "", "see_also": ["r3.out.v5d"], "authors": ["Jaro Hofierka, GeoModel s.r.o., Slovakia"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.in.v5d"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.in.lidar.html", "name": "r3.in.lidar", "definition": "- Creates a 3D raster map from LAS LiDAR points using univariate statistics.", "keywords": ["raster3d", "import", "LIDAR", "statistics", "conversion", "aggregation", "binning"], "synopsis": "r3.in.lidar [-dvopsg]  [input=name]   [file=name]   [n=name]   [sum=name]   [mean=name]   [proportional_n=name]   [proportional_sum=name]   [return_filter=string]   [class_filter=integer[,integer,...]]   [base_raster=name]   [zscale=float]   [intensity_range=min,max]   [intensity_scale=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Use base raster actual resolution instead of computational region Use only valid points Points invalid according to APSRS LAS specification will be filtered out Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Print LAS file info and exit Scan data file for extent then exit In scan mode, print using shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Use only valid points Points invalid according to APSRS LAS specification will be filtered out Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Print LAS file info and exit Scan data file for extent then exit In scan mode, print using shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Print LAS file info and exit Scan data file for extent then exit In scan mode, print using shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print LAS file info and exit Scan data file for extent then exit In scan mode, print using shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Scan data file for extent then exit In scan mode, print using shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "In scan mode, print using shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "LAS input file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "File containing names of LAS input files", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "n", "flag": "n", "dataType": "String", "optional": true, "explanation": "Count of points per cell", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sum", "flag": "sum", "dataType": "String", "optional": true, "explanation": "Sum of values of point intensities per cell", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mean", "flag": "mean", "dataType": "String", "optional": true, "explanation": "Mean of point intensities per cell", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "proportional_n", "flag": "proportional_n", "dataType": "String", "optional": true, "explanation": "3D raster map of proportional point count", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "proportional_sum", "flag": "proportional_sum", "dataType": "String", "optional": true, "explanation": "3D raster map of proportional sum of values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "return_filter", "flag": "return_filter", "dataType": "String", "optional": true, "explanation": "Only import points of selected return type", "defaultValue": null, "alternatives": ["first", "last", "mid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "class_filter", "flag": "class_filter", "dataType": "String", "optional": true, "explanation": "Only import points of selected class(es)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "base_raster", "flag": "base_raster", "dataType": "String", "optional": true, "explanation": "Subtract raster values from the z coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Scale to apply to Z data", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "intensity_range", "flag": "intensity_range", "dataType": "String", "optional": true, "explanation": "Filter range for intensity values (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "intensity_scale", "flag": "intensity_scale", "dataType": "String", "optional": true, "explanation": "Scale to apply to intensity values", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  r.in.lidar  module\n is very similar to the  r3.in.lidar  module and many parts of\n its documentation apply also for  r3.in.lidar .\n  \n     Figure: Proportional count of points per 3D cell. When 50% of all\n     points in a vertical column fall into a given 3D cell, the value\n     is 0.5. Here, the green color was assigned to 0.5, red to 1 and\n     yellow to 0. The figure shows vertical slices and green color\n     indicates high vegetation while red color indicates bare ground.\n ", "notes": "\n      \n         This module is new and partially experimental. Please don't rely\n         on its interface and be critical towards its outputs.\n         Please report issues on the mailing list or in the bug tracker.\n      \n         No reprojection is performed, you need to reproject ahead or\n         use GRASS Location which has the right coordinate system\n         which fits with the data.\n      \n         Some temporary maps are created but not cleaned up. Use of\n          --overwrite  might be necessary even when not desired.\n      \n         Expects points to have intensity and causing random (undefined)\n         result for related outputs ( sum, mean, proportional_sum )\n         when the intensity is not present but the outputs were requested.\n  EXAMPLES \n  Basic import of the data \n Set the region according to a 2D raster and adding 3D minimum\n (bottom), maximum (top) and vertical (top-bottom) resolution.\n g.region rast=secref b=80 t=160 tbres=5 -p3\n Now,  r3.in.lidar  will create the 3D raster of the size\n given by the computation region:\n r3.in.lidar input=points.las n=points_n sum=points_sum \n      mean=points_mean proportional_n=points_n_prop \n      proportional_sum=points_sum_prop\n  Point density vertical structure reduced to the terrain \n Create ground raster:\n r.in.lidar input=points.las output=ground method=mean class_filter=2\n Set vertical extent of computational region to (relative) coordinates\n above ground:\n g.region rast=secref b=0 t=47 -p3\n Compute point density:\n r3.in.lidar input=points.las n=points_n sum=points_sum \n      mean=points_mean proportional_n=points_n_prop \n      proportional_sum=points_sum_prop \n      base_raster=ground\n  Complete workflow for vertical structure analysis \n Compute the point density of points in 2D while setting the output\n extent to be based on the data ( -e ) and the resolution set to\n a relatively high number (here 10 map units, i.e. meters for\n metric projections).\n r.in.lidar input=points.las output=points_n method=n -e resolution=10\n This step can be repeated with using different resolutions (and the\n  --overwrite  flag) to determine the resolution for the further\n analysis.\n The  class_filter  option should be also provided if only part of\n the points is analyzed, for example  class_filter=3,4,5  would be\n used for low, medium, and high vegetation if the LAS file follows the\n usedstandard ASPRS class numbers.\n The resolution should be suitable for computing digital elevation model\n which will be computed in the next steps.\n Once you decided on the resolution, you can use the 2D raster to set the\n computational region extent and resolution:\n g.region raster=points_n -p3\n  class_filter=2  is used to limit \n r.in.lidar input=points.las output=ground_mean method=mean class_filter=2\n The following steps are not necessary if the point density is high\n enough to fill the raster continuously.\n Convert the raster to vector point resulting in a decimated point cloud:\n v.to.rast input=ground_mean type=point output=ground_decimated use=z\n Interpolate the ground surface from the decimated ground points:\n v.surf.rst input=ground_decimated elevation=ground\n Now we need to determine upper vertical limit for the 3D raster\n (the top value from  g.region -p3 ). This can be potentially\n done with lower resolution. The  -d  flag ensures that the ground\n raster will be used in its actual resolution regardless of the\n resolution of the output.\n r.in.lidar input=points.las method=max output=veg_max class_filter=3,4,5 base_raster=ground -d\n With that, we can finally set up the 3D extent and resolution:\n g.region rast=secref b=0 t=40 res=1 res3=1 -p3\n Note that the 2D and 3D resolutions are separate so that user can\n perform the 2D calculations on a finer resolution than the 3D\n calculations. The vertical resolution can be and often is set to a\n different value as well. Here we use the same value for all resolutions\n for simplicity.\n Finally, we perform the 3D binning where we count number of points per\n cell (voxel):\n r3.in.lidar input=points.las n=n class_filter=3,4,5 base_raster=ground -d\n ", "see_also": ["r3.in.xyz", "r.in.lidar", "v.in.lidar", "r.to.rast3", "r3.to.rast", "r3.mapcalc", "g.region"], "authors": ["Vaclav Petras,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.in.lidar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.in.bin.html", "name": "r3.in.bin", "definition": "- Imports a binary raster file into a GRASS 3D raster map.", "keywords": ["raster3d", "import", "voxel"], "synopsis": "r3.in.bin [-rdis] input=name output=name bytes=integer  [order=string]  north=float south=float east=float west=float bottom=float top=float rows=integer cols=integer depths=integer  [null=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Switch the row order in output from north->south to south->north Switch the depth order in output from bottom->top to top->bottom Binary data is of type integer Signed data (two's complement) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Switch the depth order in output from bottom->top to top->bottom Binary data is of type integer Signed data (two's complement) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Binary data is of type integer Signed data (two's complement) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Signed data (two's complement) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of binary 3D raster file to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "bytes", "flag": "bytes", "dataType": "String", "optional": false, "explanation": "Number of bytes per cell in binary file", "defaultValue": null, "alternatives": ["1", "2", "4", "8"], "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Byte order in binary file", "defaultValue": "native", "alternatives": ["big", "little", "native", "swap"], "isInputFile": false, "isOutputFile": false}, {"parameter": "north", "flag": "north", "dataType": "String", "optional": false, "explanation": "Northern limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "south", "flag": "south", "dataType": "String", "optional": false, "explanation": "Southern limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "east", "flag": "east", "dataType": "String", "optional": false, "explanation": "Eastern limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "west", "flag": "west", "dataType": "String", "optional": false, "explanation": "Western limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bottom", "flag": "bottom", "dataType": "String", "optional": false, "explanation": "Bottom limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "top", "flag": "top", "dataType": "String", "optional": false, "explanation": "Top limit of geographic region (outer edge)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rows", "flag": "rows", "dataType": "String", "optional": false, "explanation": "Number of rows", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cols", "flag": "cols", "dataType": "String", "optional": false, "explanation": "Number of columns", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "depths", "flag": "depths", "dataType": "String", "optional": false, "explanation": "Number of depths", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "Set Value to NULL", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.in.bin  allows a user to create a GRASS 3D raster map \n from a variety of binary 3D raster data formats.\n  The top, bottom, north, south, east, and west field values entered \n are the coordinates of the edges of the geographic region. \n The depths, rows and cols field values entered describe the dimensions \n of the matrix of data to follow. \n If the bytes field is entered incorrectly an error will be generated\n suggesting a closer bytes value. \n ", "notes": "\n The write order of the rows (north->south to south->north) and \n the write order of the depths (bottom->top to top->bottom) can be switched.\n Have a look at  r3.out.ascii  to manual page that \n describes the internal layout of the 3D raster maps and the supported\n row and depth switch options.\n Import of little and big endian byte order as well as signed and\n unsigned integer data types is supported. \n  Example \n First we create a specific region and a 3D raster map that we will export with\n  r3.out.bin  and import again.\n g.region w=0 e=180 s=0 n=90 b=0 t=100 res3=10\n r3.mapcalc expr=\"test_out_bin_float = float(if(row() == 2, null(), row()))\"\n r3.out.bin input=test_out_bin_float byte=4 null=-9999 \n      output=test_out_bin_float_native_b4.bin order=native\n r3.in.bin output=test_in_bin_float byte=4 null=-9999 \n      input=test_out_bin_float_native_b4.bin order=native \n      bottom=0 top=100 west=0 east=180 south=0 north=90 \n      cols=18 rows=9 depths=10\n ", "see_also": ["r3.out.bin", "r3.in.ascii", "r3.out.ascii"], "authors": ["Soren Gebbert, based on r.in.bin from Jacques Bouchard and Bob Covill"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.in.bin"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.in.ascii.html", "name": "r3.in.ascii", "definition": "- Converts a 3D ASCII raster text file into a (binary) 3D raster map.", "keywords": ["raster3d", "import", "voxel", "conversion", "ASCII"], "synopsis": "r3.in.ascii input=name output=name  [null_value=string]   [type=string]   [precision=string]   [compression=string]   [tiledimension=XxYxZ]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value data cell (use 'none' if no such value)", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Data type used in the output raster3d map", "defaultValue": "default", "alternatives": ["default", "double", "float"], "isInputFile": false, "isOutputFile": false}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Number of digits used as mantissa in the internal map storage, 0 -23 for float, 0 - 52 for double, max or default", "defaultValue": "default", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "compression", "flag": "compression", "dataType": "String", "optional": true, "explanation": "The compression method used in the output raster3d map", "defaultValue": "default", "alternatives": ["default", "zip", "none"], "isInputFile": false, "isOutputFile": false}, {"parameter": "tiledimension", "flag": "tiledimension", "dataType": "String", "optional": true, "explanation": "The dimensions of the tiles used in the output raster3d map (XxYxZ or default: 16x16x8)", "defaultValue": "default", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.in.ascii  allows a user to create a (binary) GRASS 3D raster map\n layer from a 3D ASCII raster input file.\n  The  tiledimension  parameter defines the dimension of the tiles \n used in the output file. The format is: XxYxZ\n  The  nv  parameter specifies which value to convert to NULL-value.\n If the specified value is  none , no conversion is performed.\n Default is  none .\n  NOTES \n The data is automatically imported into the correct internal coordinate system,\n that is visualized in the following picture, independently from the specified\n ordering in the ASCII input file:\n  \n  The volume coordinate system and tile layout of the imported voxel map \n ", "notes": "\n The data is automatically imported into the correct internal coordinate system,\n that is visualized in the following picture, independently from the specified\n ordering in the ASCII input file:\n  \n  The volume coordinate system and tile layout of the imported voxel map \n  NOTES \n The format of the 3D ASCII file:\n version:  \"grass7\" \n order:    \"nsbt\" or \"nstb\" or \"snbt\" or \"sntb\" \n north:    floating point \n south:    floating point \n east:     floating point \n west:     floating point \n top:      floating point \n bottom:   floating point \n rows:     integer \n cols:     integer \n levels:   integer \n The version and order option have been introduced in GRASS 7 in June 2011.\n The version option is self explaining. The order option specifies the row\n and depth order of the data in the input file.\n The supported row/depth ordering is documented in the  r3.out.ascii \n manual page. The order of the data in the input file does not specify the\n data order in the generated output 3D raster map which is in any case \n  north -> south, west -> east, bottom -> top  order.\n So dependent on the order information the data is automatically imported\n into the correct internal coordinate system.\n  The version and order options are not mandatory. In case no version and\n order option is specified, the default GRASS 6 ASCII format is assumed.\n  This header is followed by the cell values in  floating point  format \n organized in rows with constant  col  and  level  coordinate.\n The rows are organized by constant  level  coordinate. Individual cell\n values are separated by  space  or  CR .\n  EXAMPLES \n 4x3x2 sample. Note in case no specific ordering is specified in the input\n file the upper-left (NW) corner of the bottom level comes first. The according\n order option is: nsbt for north -> south, bottom -> top ordering. This is\n identical with  r.in.ascii  for single level data. So the y coordinate\n is 0 at the northern edge.\n north: 3.0 \n south: 0.0 \n east: 4.0 \n west: 0.0 \n top: 2.0 \n bottom: 0.0 \n rows: 3 \n cols: 4 \n levels: 2 \n w 111 x1,y1,z1  w 211 x2,y1,z1  w 311 x3,y1,z1  w 411 x4,y1,z1 \n w 121 x1,y2,z1  w 221 x2,y2,z1  w 321 x3,y2,z1  w 421 x4,y2,z1 \n w 131 x1,y3,z1  w 231 x2,y3,z1  w 331 x3,y3,z1  w 431 x4,y3,z1 \n w 112 x1,y1,z2  w 212 x2,y1,z2  w 312 x3,y1,z2  w 412 x4,y1,z2 \n w 122 x1,y2,z2  w 222 x2,y2,z2  w 322 x3,y2,z2  w 422 x4,y2,z2 \n w 132 x1,y3,z2  w 232 x2,y3,z2  w 332 x3,y3,z2  w 432 x4,y3,z2 \n Note that unit tests for  r3.in.ascii  are implemented in the\n  test.r3.out.ascii.sh  script located in the\n  r3.out.ascii  directory.\n  EXAMPLES \n Please refer to the detailed examples in \n  r3.out.ascii .\n  AUTHORS \n Roman Waupotitsch, Michael Shapiro, \n Helena Mitasova, Bill Brown, Lubos Mitas, Jaro Hofierka, S\u00f6ren Gebbert\n ", "see_also": ["r.in.ascii", "r3.out.ascii", "v.to.rast3", "g.region"], "authors": ["Roman Waupotitsch, Michael Shapiro, Helena Mitasova, Bill Brown, Lubos Mitas, Jaro Hofierka, S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.in.ascii"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.gwflow.html", "name": "r3.gwflow", "definition": "- Numerical calculation program for transient, confined groundwater flow in three dimensions.", "keywords": ["raster3d", "groundwater flow", "voxel", "hydrology"], "synopsis": "r3.gwflow [-mf] phead=name status=name hc_x=name hc_y=name hc_z=name  [sink=name]  yield=name  [recharge=name]  output=name  [velocity_x=name]   [velocity_y=name]   [velocity_z=name]   [budget=name]  dtime=float  [maxit=integer]   [error=float]   [solver=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Use 3D raster mask (if exists) Use a full filled quadratic linear equation system, default is a sparse linear equation system. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Use a full filled quadratic linear equation system, default is a sparse linear equation system. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "phead", "flag": "phead", "dataType": "String", "optional": false, "explanation": "Input 3D raster map with initial piezometric heads in [m]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "status", "flag": "status", "dataType": "String", "optional": false, "explanation": "Input 3D raster map providing the status for each cell, = 0 - inactive, 1 - active, 2 - dirichlet", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "hc_x", "flag": "hc_x", "dataType": "String", "optional": false, "explanation": "Input 3D raster map with the x-part of the hydraulic conductivity tensor in [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "hc_y", "flag": "hc_y", "dataType": "String", "optional": false, "explanation": "Input 3D raster map with the y-part of the hydraulic conductivity tensor in [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "hc_z", "flag": "hc_z", "dataType": "String", "optional": false, "explanation": "Input 3D raster map with the z-part of the hydraulic conductivity tensor in [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sink", "flag": "sink", "dataType": "String", "optional": true, "explanation": "Input 3D raster map with sources and sinks in [m^3/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "yield", "flag": "yield", "dataType": "String", "optional": false, "explanation": "Specific yield [1/m] input 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "recharge", "flag": "recharge", "dataType": "String", "optional": true, "explanation": "Recharge input 3D raster map in m^3/s", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output 3D raster map storing the piezometric head result of the numerical calculation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "velocity_x", "flag": "velocity_x", "dataType": "String", "optional": true, "explanation": "Output 3D raster map storing the groundwater filter velocity vector part in x direction [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "velocity_y", "flag": "velocity_y", "dataType": "String", "optional": true, "explanation": "Output 3D raster map storing the groundwater filter velocity vector part in y direction [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "velocity_z", "flag": "velocity_z", "dataType": "String", "optional": true, "explanation": "Output 3D raster map storing the groundwater filter velocity vector part in z direction [m/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "budget", "flag": "budget", "dataType": "String", "optional": true, "explanation": "Output 3D raster map storing the groundwater budget for each cell [m^3/s]", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dtime", "flag": "dtime", "dataType": "String", "optional": false, "explanation": "The calculation time in seconds", "defaultValue": "86400", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxit", "flag": "maxit", "dataType": "String", "optional": true, "explanation": "Maximum number of iteration used to solve the linear equation system", "defaultValue": "10000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "error", "flag": "error", "dataType": "String", "optional": true, "explanation": "Error break criteria for iterative solver", "defaultValue": "0.000001", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "solver", "flag": "solver", "dataType": "String", "optional": true, "explanation": "The type of solver which should solve the symmetric linear equation system", "defaultValue": "cg", "alternatives": ["cg", "pcg", "cholesky"], "isInputFile": false, "isOutputFile": false}], "description": "\n This numerical module calculates implicit transient and steady state,\n confined groundwater flow in three dimensions based on volume maps\n and the current 3D region settings.\n All initial- and boundary-conditions must be provided as volume maps.\n The unit in the location must be meters.\n  This module is sensitive to mask settings. All cells which are outside\n the mask are ignored and handled as no flow boundaries.\n  The module calculates the piezometric head and optionally the water\n balance for each cell and the groundwater velocity field in 3 dimensions.\n The vector components can be visualized with ParaView if they are exported\n with  r3.out.vtk .\n  The groundwater flow will always be calculated transient. \n For steady state computation the user should set the timestep\n to a large number (billions of seconds) or set the\n specific yield raster map to zero.\n ", "notes": "\n The groundwater flow calculation is based on Darcy's law and a numerical\n implicit finite volume discretization. The discretization results in a\n symmetric and positive definit linear equation system in form of\n  Ax = b , which must be solved. The groundwater flow partial\n differential equation is of the following form:\n  (dh/dt)*S = div (K grad h) + q\n  In detail for 3 dimensions:\n  (dh/dt)*S = Kxx * (d^2h/dx^2) + Kyy * (d^2h/dy^2) + Kzz * (d^2h/dz^2) + q\n  h -- the piezometric head im meters [m] \n  dt -- the time step for transient calculation in seconds [s] \n  S -- the specific yield  [1/m] \n  b -- the bottom surface of the aquifer meters [m] \n  Kxx -- the hydraulic conductivity tensor part in x direction in meter per second [m/s] \n  Kyy -- the hydraulic conductivity tensor part in y direction in meter per seconds [m/s] \n  Kzz -- the hydraulic conductivity tensor part in z direction in meter per seconds [m/s] \n  q - inner source/sinc in [1/s] \n  Two different boundary conditions are implemented, the Dirichlet and\n Neumann conditions. By default the calculation area is surrounded by\n homogeneous Neumann boundary conditions. The calculation and boundary\n status of single cells can be set with the status map, the following\n cell states are supported:\n  0 == inactive - the cell with status 0 will not be calculated,\n  active cells will have a no flow boundary to an inactive cell \n  1 == active - this cell is used for groundwater calculation,\n  inner sources can be defined for those cells \n  2 == Dirichlet - cells of this type will have a fixed piezometric\n  head value which do not change over time  \n  Note that all required raster maps are read into main memory. Additionally\n the linear equation system will be allocated, so the memory consumption of\n this module rapidely grow with the size of the input maps.\n  The resulting linear equation system  Ax = b  can be solved with\n several solvers. An iterative solvers with sparse and quadratic matrices\n support is implemented.\n The conjugate gradients method with (pcg) and without (cg) precondition.\n Additionally a direct Cholesky solver is available. This direct solver\n only work with normal quadratic matrices, so be careful using them with\n large maps (maps of size 10.000 cells will need more than one Gigabyte\n of RAM). The user should always prefer to use a sparse matrix solver.\n  EXAMPLE 1 \n This small script creates a working groundwater flow area and\n data. It cannot be run in a lat/lon location.\n # set the region accordingly\n g.region res=25 res3=25 t=100 b=0 n=1000 s=0 w=0 e=1000 -p3\n #now create the input raster maps for a confined aquifer\n r3.mapcalc expression=\"phead = if(row() == 1 && depth() == 4, 50, 40)\"\n r3.mapcalc expression=\"status = if(row() == 1 && depth() == 4, 2, 1)\"\n r3.mapcalc expression=\"well = if(row() == 20 && col() == 20 && depth() == 2, -0.25, 0)\"\n r3.mapcalc expression=\"hydcond = 0.00025\"\n r3.mapcalc expression=\"syield = 0.0001\"\n r.mapcalc  expression=\"recharge = 0.0\"\n r3.gwflow solver=cg phead=phead statuyield=status hc_x=hydcond hc_y=hydcond  \n     hc_z=hydcond sink=well yield=syield r=recharge output=gwresult dt=8640000 vx=vx vy=vy vz=vz budget=budget\n # The data can be visualized with ParaView when exported with r3.out.vtk\n r3.out.vtk -p in=gwresult,status,budget vector=vx,vy,vz out=/tmp/gwdata3d.vtk\n #now load the data into ParaView\n paraview --data=/tmp/gwdata3d.vtk\n  EXAMPLE 2 \n This will create a nice 3D model with geological layer with different\n hydraulic conductivities. Make sure you are not in a lat/lon projection.\n # set the region accordingly\n g.region res=15 res3=15 t=500 b=0 n=1000 s=0 w=0 e=1000\n #now create the input raster maps for a confined aquifer\n r3.mapcalc expression=\"phead = if(col() == 1 && depth() == 33, 50, 40)\"\n r3.mapcalc expression=\"status = if(col() == 1 && depth() == 33, 2, 1)\"\n r3.mapcalc expression=\"well = if(row() == 20 && col() == 20 && depth() == 3, -0.25, 0)\"\n r3.mapcalc expression=\"well = if(row() == 50 && col() == 50 && depth() == 3, -0.25, well)\"\n r3.mapcalc expression=\"hydcond = 0.0025\"\n r3.mapcalc expression=\"hydcond = if(depth() < 30 && depth() > 23 && col() < 60, 0.000025, hydcond)\"\n r3.mapcalc expression=\"hydcond = if(depth() < 20 && depth() > 13 && col() >  7, 0.000025, hydcond)\"\n r3.mapcalc expression=\"hydcond = if(depth() < 10 && depth() >  7 && col() < 60, 0.000025, hydcond)\"\n r3.mapcalc expression=\"syield = 0.0001\"\n r3.gwflow solver=cg phead=phead statuyield=status hc_x=hydcond hc_y=hydcond  \n     hc_z=hydcond sink=well yield=syield output=gwresult dt=8640000 vx=vx vy=vy vz=vz budget=budget\n # The data can be visualized with paraview when exported with r3.out.vtk\n r3.out.vtk -p in=gwresult,status,budget,hydcond,well vector=vx,vy,vz out=/tmp/gwdata3d.vtk\n #now load the data into paraview\n paraview --data=/tmp/gwdata3d.vtk\n ", "see_also": ["r.gwflow", "r.solute.transport", "r3.out.vtk"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.gwflow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.gradient.html", "name": "r3.gradient", "definition": "- Computes gradient of a 3D raster map and outputs gradient components as three 3D raster maps.", "keywords": ["raster3d", "gradient", "voxel"], "synopsis": "r3.gradient input=name output=grad_x,grad_y,grad_z[,grad_x,grad_y,grad_z,...]  [blocksize=size_x,size_y,size_z[,size_x,size_y,size_z,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output 3D raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "blocksize", "flag": "blocksize", "dataType": "String", "optional": true, "explanation": "Size of blocks", "defaultValue": "30,30,20", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n Module  r3.gradient  computes gradient from a 3D raster map. \n Results are three 3D raster maps describing the x, y, z components of \n the computed gradient field.\n  EXAMPLES \n # create a 3D raster\n g.region s=0 n=100 w=0 e=100 b=0 t=100 -p\n r3.mapcalc \"test_gradient = sqrt(row()*row() +col()*col()+ depth()*depth())\"\n # compute gradient\n r3.gradient input=test_gradient output=grad_x,grad_y,grad_z\n ", "notes": "", "see_also": ["r3.flow", "r.flow"], "authors": ["Anna Petrasova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.gradient"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.flow.html", "name": "r3.flow", "definition": "- Computes 3D flow lines and 3D flow accumulation.", "keywords": ["raster3d", "hydrology", "voxel"], "synopsis": "r3.flow [-a]  [input=name]   [vector_field=name[,name,...]]   [seed_points=name]   [flowline=name]   [flowaccumulation=name]   [sampled=name]   [unit=string]   [step=float]   [limit=integer]   [max_error=float]   [skip=integer[,integer,...]]   [direction=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Create and fill attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "vector_field", "flag": "vector_field", "dataType": "String", "optional": true, "explanation": "Names of three 3D raster maps describing x, y, z components of vector field", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "seed_points", "flag": "seed_points", "dataType": "String", "optional": true, "explanation": "Name of vector map with points from which flow lines are generated", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "flowline", "flag": "flowline", "dataType": "String", "optional": true, "explanation": "Name for vector map of flow lines", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "flowaccumulation", "flag": "flowaccumulation", "dataType": "String", "optional": true, "explanation": "Name for output flowaccumulation 3D raster", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "sampled", "flag": "sampled", "dataType": "String", "optional": true, "explanation": "Name for 3D raster sampled by flowlines", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "unit", "flag": "unit", "dataType": "String", "optional": true, "explanation": "Unit of integration step", "defaultValue": "cell", "alternatives": ["time", "length", "cell"], "isInputFile": false, "isOutputFile": false}, {"parameter": "step", "flag": "step", "dataType": "String", "optional": true, "explanation": "Integration step in selected unit", "defaultValue": "0.25", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "limit", "flag": "limit", "dataType": "String", "optional": true, "explanation": "Maximum number of steps", "defaultValue": "2000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max_error", "flag": "max_error", "dataType": "String", "optional": true, "explanation": "Maximum error of integration", "defaultValue": "1e-5", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "skip", "flag": "skip", "dataType": "String", "optional": true, "explanation": "Number of cells between flow lines in x, y and z direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "direction", "flag": "direction", "dataType": "String", "optional": true, "explanation": "Compute flowlines upstream, downstream or in both direction.", "defaultValue": "down", "alternatives": ["up", "down", "both"], "isInputFile": false, "isOutputFile": false}], "description": "\n Module  r3.flow  computes 3D flow lines and 3D flow accumulation.\n It accepts either three 3D raster maps representing the vector field or one 3D raster map.\n In case of one map, it computes on-the-fly gradient field.\n  Flow lines \n Flow lines are computed either from points (seeds) provided in  seed_points  vector map,\n or if there are no seeds, it creates seeds in a regular grid in the center of voxels (3D raster cells).\n Parameter  skip  then controls the step between the regularly distributed seeds.\n If skip is not provided, r3.flow decides optimal skip for each dimension based on current 3D region\n as one tenth of the number of columns, rows, and depths.\n Flow lines can be computed in upstream direction (in the direction of gradient or vector field),\n in downstream direction or in both directions.\n  Flow accumulation \n Flow accumulation is computed as the number of flow lines traversing each voxel.\n Since the flow lines are computed for each voxel, the flow accumulation computation\n can be more demanding.\n Parameter skip does not influence the flow accumulation computation, parameter direction does.\n  Flow line integration \n Flow line integration can be influenced by several parameters.\n Option  step  controls the integration step and influences the precision and computational time.\n The unit of step can be defined either in terms of the size of the voxel (3D raster cell),\n length in map units, or as elapsed time. \n Option  limit  specifies the maximum number of steps of each flow line.\n  Attributes \n Without using flag  a , no attribute table is created and each flow line\n is represented by one vector line with one category. With  a  flag, an attribute table is created\n and each category (record) represents one segment of a flowline, so that attributes\n specific for segments can be written. In case of  vector_field  input, only velocity is written,\n in case of  input  option, also values of the input 3D raster are written.\n Option  sampled  allows sampling (query) given 3D raster by flow lines (computed from different 3D raster) and\n write the values of the given 3D raster as attributes of the flow line segments.\n Note that using  a  flag results in longer computation time, so consider increasing\n  step  and  max_error  parameter.\n ", "notes": "\n r3.flow uses Runge-Kutta with adaptive step size\n ( Cash-Karp method ).\n  EXAMPLES \n First we create input data using\n  example 1  from\n  r3.gwflow manual page :\n # set the region accordingly\n g.region res=25 res3=25 t=100 b=0 n=1000 s=0 w=0 e=1000 -p3\n # now create the input raster maps for a confined aquifer\n r3.mapcalc expression=\"phead = if(row() == 1 && depth() == 4, 50, 40)\"\n r3.mapcalc expression=\"status = if(row() == 1 && depth() == 4, 2, 1)\"\n r3.mapcalc expression=\"well = if(row() == 20 && col() == 20 && depth() == 2, -0.25, 0)\"\n r3.mapcalc expression=\"hydcond = 0.00025\"\n r3.mapcalc expression=\"syield = 0.0001\"\n r.mapcalc  expression=\"recharge = 0.0\"\n r3.gwflow solver=cg phead=phead status=status hc_x=hydcond hc_y=hydcond  \n     hc_z=hydcond q=well s=syield r=recharge output=gwresult dt=8640000 vx=vx vy=vy vz=vz budget=budget\n Then we compute flow lines in both directions and downstream flowaccumulation.\n r3.flow vector_field=vx,vy,vz flowline=gw_flowlines skip=5,5,2 direction=both\n r3.flow vector_field=vx,vy,vz flowaccumulation=gw_flowacc\n We can visualize the result in 3D view:\n We can store velocity values (and values of the input 3D raster map if we use option  input ) for each segment of flow line\n in an attribute table.\n r3.flow -a vector_field=vx,vy,vz flowline=gw_flowlines skip=5,5,2 direction=both\n v.colors map=flowlines_color@user1 use=attr column=velocity color=bcyr\n Again, we visualize the result in 3D view and we check 'use color for thematic rendering' on 3D view vector page.\n ", "see_also": ["r.flow", "r3.gradient", "r3.gwflow"], "authors": ["Anna Petrasova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.flow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.cross.rast.html", "name": "r3.cross.rast", "definition": "- Creates cross section 2D raster map from 3D raster map based on 2D elevation map", "keywords": ["raster3d", "profile", "raster", "voxel"], "synopsis": "r3.cross.rast [-m] input=string elevation=string output=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Use 3D raster mask (if exists) with input map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Input 3D raster map for cross section", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "2D elevation map used to create the cross section map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Resulting cross section 2D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n This module creates a cross section 2D map from one 3D raster volume\n map based on a 2D elevation map. It checks if the value of the\n elevation map is located in the z-coordinate space of the 3D map. If\n so, the 3D voxel value for this position is transferred to the related\n cross section output map cell, otherwise the NULL value is set.\n  \n  How r3.cross.rast works \n  If the 2D and 3D region settings are different,\n the 2D resolution will be adjust to the 3D resolution.\n ", "notes": "\n To create a cut plane elevation map use  r.mapcalc . Some examples:\n  To create a cut plane elevation map in x direction type\n   r.mapcalc \"cutplane = col()*x\" ,  x be the value for\n  the elevation. If the range of col() is 1 ... 10, the elevation map\n  has the range 1 ... 10 if x == 1 and if x == 10 the range 10\n  ... 100 \n  To create a cut plane elevation map in y direction type\n   r.mapcalc \"cutplane = row()*x\" ,  x be the value for\n  the elevation. If the range of col() is 1 ... 10, the elevation map\n  has the range 1 ... 10 if x == 1 and if x == 10 the range 10\n  ... 100 \n  The user can also make a cut in y and x direction with  r.mapcalc  by\n      using  r.mapcalc \"cutplane = (row()+col())*x\" \n  EXAMPLE \n  Simple Spearfish example \n g.region -d\n g.region res=150 res3=150 t=1000 b=0 tbres=100\n # synthetic data, could be geological structures:\n r3.mapcalc \"map3d = sin(row())+sin(col())+sin(depth()*depth())\"\n #create a cutplane map\n r.mapcalc \"cutplane = col()*10\"\n #create the cross section map\n r3.cross.rast input=map3d elevation=cutplane output=crosssection\n ", "see_also": ["g.region", "r.mapcalc", "r3.mapcalc", "r3.to.rast"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster3d/r3.cross.rast"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.colors.out.html", "name": "r3.colors.out", "definition": "- Exports the color table associated with a 3D raster map.", "keywords": ["raster3d", "color table", "export"], "synopsis": "r3.colors.out [-p] map=name  [rules=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Output values as percentages Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Path to output rules file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.colors.out  allows the user to export the color table for a\n 3D raste map to a file which is suitable as input\n to  r3.colors .\n  EXAMPLES \n r3.colors.out map=volume_1 rules=rules.txt\n r3.colors map=volume_2 rules=rules.txt\n ", "notes": "", "see_also": ["r.colors", "r.colors.out", "r3.colors", "v.colors", "v.colors.out"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.colors.out"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.colors.html", "name": "r3.colors", "definition": "- Creates/modifies the color table associated with a 3D raster map.", "keywords": ["raster3d", "color table"], "synopsis": "r3.colors [-rwlngae]  [map=name[,name,...]]   [file=name]   [color=style]   [raster=name]   [raster_3d=name]   [rules=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Remove existing color table Only write new color table if it does not already exist List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Only write new color table if it does not already exist List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": true, "explanation": "Name of 3D raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Input file with one map name per line", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Name of color table", "defaultValue": null, "alternatives": ["aspect", "aspectcolr", "bcyr", "bgyr", "blues", "byg", "byr", "celsius", "corine", "curvature", "differences", "elevation", "etopo2", "evi", "fahrenheit", "gdd", "grass", "greens", "grey", "grey.eq", "grey.log", "grey1.0", "grey255", "gyr", "haxby", "kelvin", "ndvi", "ndwi", "oranges", "population", "population_dens", "precipitation", "precipitation_daily", "precipitation_monthly", "rainbow", "ramp", "random", "reds", "roygbiv", "rstcurv", "ryb", "ryg", "sepia", "slope", "soilmoisture", "srtm", "srtm_plus", "terrain", "viridis", "water", "wave"], "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Raster map from which to copy color table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster_3d", "flag": "raster_3d", "dataType": "String", "optional": true, "explanation": "3D raster map from which to copy color table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Path to rules file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.colors  has exactly the same functionality\n as  r.colors  but for 3D raster maps. Please refer\n to  r.colors .\n  EXAMPLES \n r3.colors map=volume_1 color=gyr\n ", "notes": "", "see_also": ["r.colors", "r.colors.out", "r3.colors.out", "v.colors", "v.colors.out"], "authors": ["Michael Shapiro and David Johnson"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.colors"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.what.html", "name": "r.what", "definition": "- Queries raster maps on their category values and category labels.", "keywords": ["raster", "querying", "position"], "synopsis": "r.what [-nfricv] map=name[,name,...]  [coordinates=east,north]   [points=name]   [null_value=string]   [output=name]   [separator=character]   [cache=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Output header row Show the category labels of the grid cell(s) Output color values as RRR:GGG:BBB Output integer category values, not cell values Turn on cache reporting Show the category for vector points map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Show the category labels of the grid cell(s) Output color values as RRR:GGG:BBB Output integer category values, not cell values Turn on cache reporting Show the category for vector points map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Output color values as RRR:GGG:BBB Output integer category values, not cell values Turn on cache reporting Show the category for vector points map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Output integer category values, not cell values Turn on cache reporting Show the category for vector points map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Turn on cache reporting Show the category for vector points map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Show the category for vector points map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of existing raster map(s) to query", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates for query", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "points", "flag": "points", "dataType": "String", "optional": true, "explanation": "Name of vector points map for query", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": "*", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "cache", "flag": "cache", "dataType": "String", "optional": true, "explanation": "Size of point cache", "defaultValue": "500", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.what  outputs the category values and (optionally) the category\n labels associated with user-specified locations on raster input map(s).\n Locations are specified as geographic x,y coordinate pairs (i.e., pair of\n eastings and northings); the user can also (optionally) associate a label\n with each location.\n  The input coordinates can be entered directly on the command line\n via  coordinates  parameter, or redirected via  stdin \n from an input text file, script, or piped from another program\n (like  v.out.ascii ). Coordinates\n can be given also as a vector points map ( points ).\n  If none of the above input methods are used and the module is run from the\n terminal prompt, the program will interactively query the user for point\n locations and labels.\n  Each line of the input consists of an easting, a northing, and an optional\n label, which are separated by spaces. In interactive mode, the word\n \" end \" must be typed after the last pair of input coordinates.\n  r.what  output consists of the input geographic location and label,\n and, for each user-named raster map layer, the category value, and (if\n the  -f  label flag is specified) the category label associated with\n the cell(s) at this geographic location.\n  EXAMPLES \n  Input coordinates given as an option \n The module's  coordinates  parameter can be used to enter coordinate\n pairs directly. The maximum number of pairs will be limited by your system's\n maximum input line length (e.g. 4096 characters).\n g.region raster=landuse96_28m,aspect -p\n r.what map=landuse96_28m,aspect coordinates=633614.08,224125.12,632972.36,225382.87 -f\n 633614.08|224125.12||2|Low Intensity Developed|209.5939|209 degrees ccw from east\n 632972.36|225382.87||15|Southern Yellow Pine|140.7571|140 degrees ccw from east\n  Input coordinates given as a vector points map \n Coordinates can be read from existing vector points map by\n specifying  points  option. Other features than points or\n centroids are ignored. Example: query North Carolina county number for\n each community college:\n g.region raster=boundary_county_500m -p\n r.what map=boundary_county_500m points=comm_colleges\n 145096.859150|154534.264884||39\n 616341.437150|146049.750884||51\n ...\n  Input coordinates given as a vector points map with cats \n Coordinates can be read from existing vector points map by\n specifying  points  option. Other features than points or\n centroids are ignored. Using the  v  flag you can get also\n the cat for each feature. Example: query North Carolina county\n number for each community college:\n g.region raster=boundary_county_500m -p\n r.what map=boundary_county_500m points=comm_colleges -v\n 1|145096.859150|154534.264884||39\n 2|616341.437150|146049.750884||51\n ...\n  Input coordinates given as a vector points map, output into CSV file \n Coordinates can be read from existing vector points map by\n specifying  points  option. Other features than points or\n centroids are ignored. The output is stored in a CSV file including header\n row. Example: query North Carolina county number for each community college:\n g.region raster=boundary_county_500m -p\n r.what map=boundary_county_500m points=comm_colleges \n         separator=comma output=result.csv -n\n        \n cat result.csv \n easting,northing,site_name,boundary_county_500m\n 145096.859150,154534.264884,,39\n 616341.437150,146049.750884,,51\n 410595.719150,174301.828884,,71\n ...\n  Input from a text file containing coordinates \n The contents of an ASCII text file can be redirected to  r.what \n as follows. If we have a file called  input_coord.txt  containing the\n whitespace separated coordinates and optionally labels, the resulting \n raster map values are extracted:\n cat input_coord.txt \n 633614.08 224125.12 site 1\n 632972.36 225382.87 site 2\n r.what map=landuse96_28m,aspect < input_coord.txt\n 633614.08|224125.12|site 1|2|209.5939\n 632972.36|225382.87|site 2|15|140.7571\n  Input from standard input on the command line \n Input coordinates may be given directly from standard input ( stdin ),\n for example (input data appears between the \" EOF \" markers):\n r.what map=landuse96_28m,aspect << EOF\n 633614.08 224125.12 site 1\n 632972.36 225382.87 site 2\n EOF\n 633614.08|224125.12|site 1|2|209.5939\n 632972.36|225382.87|site 2|15|140.7571\n echo \"633614.08 224125.12\" | r.what map=landuse96_28m,aspect\n 633614.08|224125.12||2|209.5939\n  Input coordinates piped from another program \n The input coordinates may be \"piped\" from the standard output\n ( stdout ) of another program. In the next example, vector\n point coordinates are piped from the\n  v.out.ascii  module. \n v.out.ascii comm_colleges separator=space | r.what map=boundary_county_500m\n 145096.8591495|154534.26488388|1|39\n 616341.4371495|146049.75088388|2|51\n 410595.7191495|174301.82888388|3|71\n ...\n  Output containing raster map category labels \n Here we use the  -f  label flag to enable the output of category labels\n associated with the raster cell(s), as well as values (categorical maps only).\n r.what -f map=landuse96_28m,aspect << EOF\n 633614.08 224125.12 site 1\n 632972.36 225382.87 site 2\n EOF\n 633614.08|224125.12|site 1|2|Low Intensity Developed|209.5939|209 degrees ccw from east\n 632972.36|225382.87|site 2|15|Southern Yellow Pine|140.7571|140 degrees ccw from east\n ", "notes": "\n The maximum number of raster map layers that can be queried at one time is 400.\n  TODO \n    Fix  400 maps  limit \n ", "see_also": ["r.category", "r.report", "r.stats", "r.series", "r.univar", "v.what", "v.what.rast", "v.what.vect"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.what"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.what.color.html", "name": "r.what.color", "definition": "- Queries colors for a raster map layer.", "keywords": ["raster", "querying", "color table"], "synopsis": "r.what.color [-i] input=string  [value=float[,float,...]]   [format=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Read values from stdin Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of existing raster map to query colors", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "value", "flag": "value", "dataType": "String", "optional": true, "explanation": "Values to query colors for", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Output format (printf-style)", "defaultValue": "%d:%d:%d", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.what.color  outputs the color associated with user-specified\n category values in a raster input map.\n  Values may be specified either using the  values=  option, or by\n specifying the  -i  flag and passing the values on\n  stdin , one per line.\n  For each value which is specified, a line of output will be generated\n consisting of the category value followed by the color, e.g.:\n r.what.color input=elevation.dem value=1500\n 1500: 223:127:31\n  If the input map is an integer (CELL) map, the category will be\n written as an integer (no decimal point), otherwise it will be written\n in floating point format ( printf(\"%.15g\")  format).\n  If the lookup fails for a value, the color will be output as an\n asterisk, e.g.:\n r.what.color input=elevation.dem value=9999\n 9999: *\n  If a value cannot be parsed, both the value and the color will be\n output as an asterisk, e.g.:\n r.what.color input=elevation.dem value=bogus\n *: *\n  The format can be changed using the  format=  option. The value\n should be a  printf() -style format string containing three\n conversion specifiers for the red, green and blue values respectively,\n e.g.:\n r.what.color input=elevation.dem value=1500 format='%02x:%02x:%02x'\n 1500: df:7f:1f\n  If your system supports the  %m$  syntax, you can change the\n ordering of the components, e.g.:\n r.what.color input=elevation.dem value=1500 format='%3$02x:%2$02x:%1$02x'\n 1500: 1f:7f:df\n  Common formats: \n  Tcl/Tk:  format=\"#%02x%02x%02x\" \n  WxPython:  format='\"#%02x%02x%02x\"'   or   format='\"(%d,%d,%d)\"' \n ", "notes": "", "see_also": ["r.what"], "authors": ["Glynn Clements"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.what.color"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.watershed.html", "name": "r.watershed", "definition": "- Calculates hydrological parameters and RUSLE factors.", "keywords": ["raster", "hydrology", "watershed", "accumulation", "drainage", "stream network", "stream power index", "topographic index"], "synopsis": "r.watershed [-s4mab] elevation=name  [depression=name]   [flow=name]   [disturbed_land=name]   [blocking=name]   [threshold=integer]   [max_slope_length=float]   [accumulation=name]   [tci=name]   [spi=name]   [drainage=name]   [basin=name]   [stream=name]   [half_basin=name]   [length_slope=name]   [slope_steepness=name]   [convergence=integer]   [memory=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "SFD (D8) flow (default is MFD) SFD: single flow direction, MFD: multiple flow direction Allow only horizontal and vertical flow of water Enable disk swap memory option: Operation is slow Only needed if memory requirements exceed available RAM; see manual on how to calculate memory requirements Use positive flow accumulation even for likely underestimates See manual for a detailed description of flow accumulation output Beautify flat areas Flow direction in flat areas is modified to look prettier Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "4", "flag": "-4", "explanation": "Allow only horizontal and vertical flow of water Enable disk swap memory option: Operation is slow Only needed if memory requirements exceed available RAM; see manual on how to calculate memory requirements Use positive flow accumulation even for likely underestimates See manual for a detailed description of flow accumulation output Beautify flat areas Flow direction in flat areas is modified to look prettier Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Enable disk swap memory option: Operation is slow Only needed if memory requirements exceed available RAM; see manual on how to calculate memory requirements Use positive flow accumulation even for likely underestimates See manual for a detailed description of flow accumulation output Beautify flat areas Flow direction in flat areas is modified to look prettier Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Use positive flow accumulation even for likely underestimates See manual for a detailed description of flow accumulation output Beautify flat areas Flow direction in flat areas is modified to look prettier Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Beautify flat areas Flow direction in flat areas is modified to look prettier Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "depression", "flag": "depression", "dataType": "String", "optional": true, "explanation": "Name of input depressions raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "flow", "flag": "flow", "dataType": "String", "optional": true, "explanation": "Name of input raster representing amount of overland flow per cell", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "disturbed_land", "flag": "disturbed_land", "dataType": "String", "optional": true, "explanation": "Name of input raster map percent of disturbed land", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "blocking", "flag": "blocking", "dataType": "String", "optional": true, "explanation": "Name of input raster map blocking overland surface flow", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Minimum size of exterior watershed basin", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "max_slope_length", "flag": "max_slope_length", "dataType": "String", "optional": true, "explanation": "Maximum length of surface flow in map units", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "accumulation", "flag": "accumulation", "dataType": "String", "optional": true, "explanation": "Name for output accumulation raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "tci", "flag": "tci", "dataType": "String", "optional": true, "explanation": "Name for output topographic index ln(a / tan(b)) map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "spi", "flag": "spi", "dataType": "String", "optional": true, "explanation": "Stream power index a * tan(b)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "drainage", "flag": "drainage", "dataType": "String", "optional": true, "explanation": "Name for output drainage direction raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basin", "flag": "basin", "dataType": "String", "optional": true, "explanation": "Name for output basins raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "stream", "flag": "stream", "dataType": "String", "optional": true, "explanation": "Name for output stream segments raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "half_basin", "flag": "half_basin", "dataType": "String", "optional": true, "explanation": "Name for output half basins raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "length_slope", "flag": "length_slope", "dataType": "String", "optional": true, "explanation": "Name for output slope length raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "slope_steepness", "flag": "slope_steepness", "dataType": "String", "optional": true, "explanation": "Name for output slope steepness raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "convergence", "flag": "convergence", "dataType": "String", "optional": true, "explanation": "Convergence factor for MFD (1-10)", "defaultValue": "5", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used with -m flag (in MB)", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.watershed  generates a set of maps indicating: 1) flow\n accumulation, drainage direction, the location of streams and\n watershed basins, and 2) the LS and S factors of the Revised Universal\n Soil Loss Equation (RUSLE).\n ", "notes": "\n Without flag  -m  set, the entire analysis is run in memory\n maintained by the operating system. This can be limiting, but is very\n fast. Setting this flag causes the program to manage memory on disk\n which allows very large maps to be processed but is slower.\n Flag  -s  force the module to use single flow direction (SFD, D8)\n instead of multiple flow direction (MFD). MFD is enabled by default.\n By  -4  flag the user allow only horizontal and vertical flow of\n water. Stream and slope lengths are approximately the same as outputs\n from default surface flow (allows horizontal, vertical, and diagonal\n flow of water).  This flag will also make the drainage basins look\n more homogeneous.\n When  -a  flag is specified the module will use positive flow\n accumulation even for likely underestimates. When this flag is not\n set, cells with a flow accumulation value that is likely to be an\n underestimate are converted to the negative. See below for a detailed\n description of flow accumulation output.\n Option  convergence  specifies convergence factor for MFD. Lower\n values result in higher divergence, flow is more widely\n distributed. Higher values result in higher convergence, flow is less\n widely distributed, becoming more similar to SFD.\n Option  elevation  specifies the elevation data on which entire\n analysis is based. NULL (nodata) cells are ignored, zero and negative\n values are valid elevation data.  Gaps in the elevation map that are\n located within the area of interest must be filled beforehand,\n e.g. with  r.fillnulls , to\n avoid distortions.  The elevation map need not be sink-filled because\n the module uses a least-cost algorithm.\n Option  depression  specifies the optional map of actual\n depressions or sinkholes in the landscape that are large\n enough to slow and store surface runoff from a storm event.  All cells\n that are not NULL and not zero indicate depressions. Water will flow\n into but not out of depressions.\n Raster  flow  map specifies amount of overland flow per cell.\n This map indicates the amount of overland flow units that each cell\n will contribute to the watershed basin model. Overland flow units\n represent the amount of overland flow each cell contributes to surface\n flow. If omitted, a value of one (1) is assumed.\n Input Raster map or value containing the percent of disturbed land\n (i.e., croplands, and construction sites) where the raster or input\n value of 17 equals 17%.  If no map or value is\n given,  r.watershed  assumes no disturbed land. This input is\n used for the RUSLE calculations.\n Option  blocking  specifies terrain that will block overland \n surface flow. Blocking cells and streams stop the slope length for the \n RUSLE.  All cells that are not NULL and not zero indicate blocking \n terrain.\n Option  threshold  specifies the minimum size of an exterior\n watershed basin in cells, if no flow map is input, or overland flow\n units when a flow map is given.  Warning: low threshold values will\n dramactically increase run time and generate difficult to read basin\n and half_basin results.  This parameter also controls the level of\n detail in the  stream  segments map.\n Value given by  max_slope_length  option indicates the maximum\n length of overland surface flow in meters. If overland flow travels\n greater than the maximum length, the program assumes the maximum\n length (it assumes that landscape characteristics not discernible in\n the digital elevation model exist that maximize the slope length).\n This input is used for the RUSLE calculations and is a sensitive\n parameter.\n Output  accumulation  map contains the absolute value of the\n amount of overland flow that traverses each cell. This value will be\n the number of upland cells plus one if no overland flow map is given.\n If the overland flow map is given, the value will be in overland flow\n units. Negative numbers indicate that those cells possibly have surface\n runoff from outside of the current geographic region. Thus, any cells\n with negative values cannot have their surface runoff and sedimentation\n yields calculated accurately.\n Output  tci  raster map contains topographic index TCI,\n computed as\n  ln(\u03b1 / tan(\u03b2))  where \u03b1 is the cumulative\n upslope area draining through a point per unit contour length and\n  tan(\u03b2)  is the local slope angle. The TCI reflects the\n tendency of water to accumulate at any point in the catchment and the\n tendency for gravitational forces to move that water downslope (Quinn\n et al. 1991).  This value will be negative if  \u03b1 /\n tan(\u03b2) < 1 .\n Output  spi  raster map contains stream power index SPI,\n computed as\n  \u03b1 * tan(\u03b2)  where \u03b1 is the cumulative\n upslope area draining through a point per unit contour length and\n  tan(\u03b2)  is the local slope angle. The SPI reflects the\n power of water flow at any point in the catchment and the\n tendency for gravitational forces to move that water downslope (Moore\n et al. 1991).  This value will be negative if  \u03b1 < 0 , \n i.e. for cells with possible surface runoff from outside of the current\n geographic region.\n Output  drainage  raster map contains drainage direction.\n Provides the \"aspect\" for each cell measured CCW from East.\n Multiplying positive values by 45 will give the direction in degrees\n that the surface runoff will travel from that cell.  The value 0\n (zero) indicates that the cell is a depression area (defined by the\n depression input map).  Negative values indicate that surface runoff\n is leaving the boundaries of the current geographic region.  The\n absolute value of these negative cells indicates the direction of\n flow. For MFD, drainage indicates the direction of maximum flow.\n The output  basin  map contains unique label for each watershed\n basin. Each basin will be given a unique positive even integer.  Areas\n along edges may not be large enough to create an exterior watershed\n basin.  NULL values indicate that the cell is not part of a complete\n watershed basin in the current geographic region.\n The output  stream  contains stream segments. Values correspond\n to the watershed basin values.  Can be vectorized after thinning\n ( r.thin ) with\n  r.to.vect .\n The output  half_basin  raster map stores each half-basin is\n given a unique value. Watershed basins are divided into left and right\n sides. The right-hand side cell of the watershed basin (looking\n upstream) are given even values corresponding to the values in basin.\n The left-hand side cells of the watershed basin are given odd values\n which are one less than the value of the watershed basin.\n The output  length_slope  raster map stores slope length and\n steepness (LS) factor for the Revised Universal Soil Loss Equation\n (RUSLE).  Equations taken from  Revised Universal Soil Loss\n Equation for Western Rangelands  (Weltz et al. 1987). Since the LS\n factor is a small number (usually less than one), the GRASS output map\n is of type DCELL.\n The output  slope_steepness  raster map stores slope steepness\n (S) factor for the Universal Soil Loss Equation (RUSLE).  Equations\n taken from article entitled\n  Revised Slope Steepness Factor for the Universal Soil\n Loss Equation  (McCool et al. 1987).  Since the S factor is a small \n number (usually less than one), the GRASS output map is of type DCELL.\n  A T  least-cost search algorithm \n  r.watershed  uses an A T  least-cost search algorithm\n (see REFERENCES section) designed to minimize the impact of DEM data\n errors. Compared\n to  r.terraflow , this algorithm\n provides more accurate results in areas of low slope as well as DEMs\n constructed with techniques that mistake canopy tops as the ground\n elevation. Kinner et al. (2005), for example, used SRTM and IFSAR DEMs\n to compare  r.watershed \n against  r.terraflow  results in\n Panama.  r.terraflow  was unable\n to replicate stream locations in the larger valleys\n while  r.watershed  performed much better. Thus, if forest\n canopy exists in valleys, SRTM, IFSAR, and similar data products will\n cause major errors in  r.terraflow  stream output. Under\n similar conditions,  r.watershed  will generate\n better  stream  and  half_basin  results. If watershed\n divides contain flat to low slope,  r.watershed  will generate\n better basin results\n than  r.terraflow . ( r.terraflow \n uses the same type of algorithm as ESRI's ArcGIS watershed software\n which fails under these conditions.) Also, if watershed divides\n contain forest canopy mixed with uncanopied areas using SRTM, IFSAR,\n and similar data products,  r.watershed  will generate better\n basin results\n than  r.terraflow . The\n algorithm produces results similar to those obtained when running\n  r.cost  and\n  r.drain  on every cell on the raster map.\n  Multiple flow direction (MFD) \n  r.watershed  offers two methods to calculate surface flow:\n single flow direction (SFD, D8) and multiple flow direction\n (MFD). With MFD, water flow is distributed to all neighbouring cells\n with lower elevation, using slope towards neighbouring cells as a\n weighing factor for proportional distribution. The A T \n least-cost path is always included. As a result, depressions and\n obstacles are traversed with a gracefull flow convergence before the\n overflow. The convergence factor causes flow accumulation to converge\n more strongly with higher values. The supported range is 1 to 10,\n recommended is a convergence factor of 5 (Holmgren, 1994). If many\n small sliver basins are created with MFD, setting the convergence\n factor to a higher value can reduce the amount of small sliver basins.\n  In-memory mode and disk swap mode \n There are two versions of this program:  ram  and  seg .\n  ram  is used by default,  seg  can be used by setting \n the  -m  flag.\n The  ram  version requires a maximum of 31 MB of RAM for 1\n million cells. Together with the amount of system memory (RAM)\n available, this value can be used to estimate whether the current\n region can be processed with the  ram  version.\n The  ram  version uses virtual memory managed by the operating\n system to store all the data structures and is faster than\n the  seg  version;  seg  uses the GRASS segmentation\n library which manages data in disk files.  seg  uses only as\n much system memory (RAM) as specified with the  memory  option,\n allowing other processes to operate on the same system, even when the\n current geographic region is huge.\n Due to memory requirements of both programs, it is quite easy to run\n out of memory when working with huge map regions. If the  ram \n version runs out of memory and the resolution size of the current\n geographic region cannot be increased, either more memory needs to be\n added to the computer, or the swap space size needs to be\n increased. If  seg  runs out of memory, additional disk space\n needs to be freed up for the program to run.\n The  r.terraflow  module was\n specifically designed with huge regions in mind and may be useful here\n as an alternative, although disk space requirements\n of  r.terraflow  are several times higher than of  seg .\n  Large regions with many cells \n The upper limit of the  ram  version is 2 billion\n (2 31  - 1) cells, whereas the upper limit for\n the  seg  version is 9 billion-billion (2 63  - 1 = \n  9.223372e+18 )\n cells.   In some situations, the region size (number of cells) may\n be too large for the amount of time or memory\n available. Running  r.watershed  may then require use of a\n coarser resolution. To make the results more closely resemble the\n finer terrain data, create a map layer containing the lowest elevation\n values at the coarser resolution. This is done by: 1) Setting the\n current geographic region equal to the elevation map layer\n with  g.region , and 2) Use\n the  r.neighbors  or\n  r.resamp.stats  command to\n find the lowest value for an area equal in size to the desired\n resolution. For example, if the resolution of the elevation data is 30\n meters and the resolution of the geographic region\n for  r.watershed  will be 90 meters: use the minimum function\n for a 3 by 3 neighborhood. After changing to the resolution at\n which  r.watershed  will be run,  r.watershed  should be\n run using the values from the  neighborhood  output map layer\n that represents the minimum elevation within the region of the coarser\n cell.\n  Basin threshold \n The minimum size of drainage basins, defined by the  threshold \n parameter, is only relevant for those watersheds with a single stream\n having at least the  threshold  of cells flowing into it.\n (These watersheds are called exterior basins.)  Interior drainage\n basins contain stream segments below multiple tributaries.  Interior\n drainage basins can be of any size because the length of an interior\n stream segment is determined by the distance between the tributaries\n flowing into it.\n  MASK and no data \n The  r.watershed  program does not require the user to have the\n current geographic region filled with elevation values.  Areas without\n elevation data (masked or NULL cells) are ignored. It is NOT necessary\n to create a raster map (or raster reclassification)\n named  MASK  for NULL cells.  Areas without elevation data will\n be treated as if they are off the edge of the region. Such areas will\n reduce the memory necessary to run the program.  Masking out\n unimportant areas can significantly reduce processing time if the\n watersheds of interest occupy a small percentage of the overall area.\n Gaps (NULL cells) in the elevation map that are located within the\n area of interest will heavily influence the analysis: water will flow\n into but not out of these gaps. These gaps must be filled beforehand,\n e.g. with  r.fillnulls .\n Zero (0) and negative values will be treated as elevation data (not\n no_data).\n  Further processing of output layers \n Problem areas, i.e. those parts of a basin with a likely underestimate\n of flow accumulation, can be easily identified with e.g.\n   r.mapcalc \"problems = if(flow_acc < 0, basin, null())\"\n If the region of interest contains such problem areas, and this is not\n desired, the computational region must be expanded until the catchment\n area for the region of interest is completely included.\n To isolate an individual river network using the output of this\n module, a number of approaches may be considered.\n  Use a resample of the basins catchment raster map as a MASK. \n   The equivalent vector map method is similar\n   using  v.select  or\n    v.overlay .\n  Use the  r.cost  module with a\n   point in the river as a starting point.\n  Use the  v.net.iso  module\n   with a node in the river as a starting point.\n All individual river networks in the stream segments output can be\n identified through their ultimate outlet points. These points are all\n cells in the stream segments output with negative drainage direction.\n These points can be used as start points\n for  r.water.outlet  or\n  v.net.iso .\n To create  river mile  segmentation from a vectorized streams\n map, try\n the  v.net.iso \n or  v.lrs.segment \n modules.\n The stream segments output can be easily vectorized after thinning\n with\n  r.thin . Each stream segment in the\n vector map will have the value of the associated basin. To isolate\n subbasins and streams for a larger basin, a MASK for the larger basin\n can be created with\n  r.water.outlet . The stream\n segments output serves as a guide where to place the outlet point used\n as input to  r.water.outlet .\n The basin threshold must have been sufficiently small to isolate a\n stream network and subbasins within the larger basin.\n Given that the  drainage  is 8 directions numbered\n counter-clockwise starting from 1 in north-east direction,\n multiplying the output\n by 45 (by  45.  to get a double precision floating point raster\n map in  r.mapcalc ) gives\n the directions in degrees. For most applications, zeros\n which indicate depressions specified by  depression \n and negative values which indicate runoff leaving the region\n should be replaced by NULL ( null()  in\n  r.mapcalc ).\n The following command performs these replacements:\n r.mapcalc \"drainage_degrees = if(drainage > 0, 45. * drainage, null())\"\n Alternatively, the user can use the  -a  flag or later the\n  abs()  function in\n  r.mapcalc  if the runoff is leaving\n the region.\n  EXAMPLES \n These examples use the Spearfish sample dataset.\n  Convert  r.watershed  streams map output to a vector map \n If you want a detailed stream network, set the threshold option small\n to create lots of catchment basins, as only one stream is presented\n per catchment. The  r.to.vect -v  flag preserves the catchment\n ID as the vector category number.\n   r.watershed elev=elevation.dem stream=rwater.stream\n   r.to.vect -v in=rwater.stream out=rwater_stream\n Set a different color table for the accumulation map:\n   MAP=rwater.accum\n   r.watershed elev=elevation.dem accum=$MAP\n   eval `r.univar -g \"$MAP\"`\n   stddev_x_2=`echo $stddev | awk '{print $1 * 2}'`\n   stddev_div_2=`echo $stddev | awk '{print $1 / 2}'`\n   r.colors $MAP col=rules << EOF\n     0% red\n     -$stddev_x_2 red\n     -$stddev yellow\n     -$stddev_div_2 cyan\n     -$mean_of_abs blue\n     0 white\n     $mean_of_abs blue\n     $stddev_div_2 cyan\n     $stddev yellow\n     $stddev_x_2 red\n     100% red\n   EOF\n Create a more detailed stream map using the accumulation map and\n convert it to a vector output map. The accumulation cut-off, and\n therefore fractal dimension, is arbitrary; in this example we use the\n map's mean number of upstream catchment cells (calculated in the above\n example by  r.univar ) as the\n cut-off value. This only works with SFD, not with MFD.\n   r.watershed elev=elevation.dem accum=rwater.accum\n   r.mapcalc 'MASK = if(!isnull(elevation.dem))'\n   r.mapcalc \"rwater.course = \n     if( abs(rwater.accum) > $mean_of_abs, \n         abs(rwater.accum), \n         null() )\"\n   r.colors -g rwater.course col=bcyr\n   g.remove -f type=raster name=MASK\n   #  Thinning is required before converting raster lines to vector \n   r.thin in=rwater.course out=rwater.course.Thin\n   r.colors -gn rwater.course.Thin color=grey\n   r.to.vect in=rwater.course.Thin out=rwater_course type=line\n   v.db.dropcolumn map=rwater_course column=label\n  Create watershed basins map and convert to a vector polygon map \n   r.watershed elev=elevation.dem basin=rwater.basin thresh=15000\n   r.to.vect -s in=rwater.basin out=rwater_basins type=area\n   v.db.dropcolumn map=rwater_basins column=label\n   v.db.renamecolumn map=rwater_basins column=value,catchment\n Display output in a nice way\n   r.relief map=elevation.dem\n   d.shade shade=elevation.dem.shade color=rwater.basin bright=40\n   d.vect rwater_course color=orange\n  REFERENCES \n  Ehlschlaeger C. (1989).  Using the A T  Search Algorithm\n to Develop Hydrologic Models from Digital Elevation Data ,\n  Proceedings of International Geographic Information Systems (IGIS)\n Symposium '89 , pp 275-281 (Baltimore, MD, 18-19 March 1989). \n URL:  \n http://chuck.ehlschlaeger.info/older/IGIS/paper.html \n  Holmgren P. (1994).  Multiple flow direction algorithms for runoff \n modelling in grid based elevation models: An empirical evaluation. \n  Hydrological Processes  Vol 8(4), 327-334. \n DOI:  10.1002/hyp.3360080405 \n  Kinner D., Mitasova H., Harmon R., Toma L., Stallard R. (2005).\n  GIS-based Stream Network Analysis for The Chagres River Basin,\n Republic of Panama .  The Rio Chagres: A Multidisciplinary Profile of\n a Tropical Watershed , R. Harmon (Ed.), Springer/Kluwer, p.83-95. \n URL:  \n http://www4.ncsu.edu/~hmitaso/measwork/panama/panama.html \n  McCool et al. (1987).  Revised Slope Steepness Factor for the Universal\n Soil Loss Equation ,  Transactions of the ASAE  Vol 30(5).\n  Metz M., Mitasova H., Harmon R. (2011).  Efficient extraction of \n drainage networks from massive, radar-based elevation models with least \n cost path search ,  Hydrol. Earth Syst. Sci.  Vol 15, 667-678. \n DOI:  10.5194/hess-15-667-2011 \n Moore I.D., Grayson R.B., Ladson A.R. (1991).  Digital terrain \n modelling: a review of hydrogical, geomorphological, and biological \n applications ,  Hydrological Processes , Vol 5(1), 3-30  \n DOI:  10.1002/hyp.3360050103 \n  Quinn P., K. Beven K., Chevallier P., Planchon O. (1991).  The \n prediction of hillslope flow paths for distributed hydrological modelling \n using Digital Elevation Models ,  Hydrological Processes  Vol 5(1), \n p.59-79. \n DOI:  10.1002/hyp.3360050106 \n  Weltz M. A., Renard K.G., Simanton J. R. (1987).  Revised Universal Soil\n Loss Equation for Western Rangelands ,  U.S.A./Mexico Symposium of\n Strategies for Classification and Management of Native Vegetation for\n Food Production In Arid Zones  (Tucson, AZ, 12-16 Oct. 1987).\n ", "see_also": ["g.region", "r.cost", "r.drain", "r.fillnulls", "r.flow", "r.mask", "r.neighbors", "r.param.scale", "r.resamp.interp", "r.terraflow", "r.topidx", "r.water.outlet", "r.stream.extract"], "authors": ["Original version: Charles Ehlschlaeger, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.watershed/front"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r.water.outlet.html", "name": "r.water.outlet", "definition": "- Creates watershed basins from a drainage direction map.", "keywords": ["raster", "hydrology", "watershed"], "synopsis": "r.water.outlet input=name output=name coordinates=east,north  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input drainage direction map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output watershed basin map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "Coordinates of outlet point", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  r.water.outlet  generates a watershed basin from a drainage\n direction map and a set of coordinates representing the outlet point\n of watershed.\n Input drainage direction map indicates the \"aspect\" for each\n cell. Multiplying positive values by 45 will give the direction in\n degrees that the surface runoff will travel from that cell. The value\n -1 indicates that the cell is a depression area. Other negative values\n indicate that surface runoff is leaving the boundaries of the current\n geographic region. The absolute value of these negative cells\n indicates the direction of flow. This raster map is generated from\n  r.watershed .\n Output raster map values of one (1) indicate the watershed\n basin. Values of zero (0) are not in the watershed basin.\n ", "notes": "\n In the context of this program, a watershed basin is the region\n upstream of an outlet point. Thus, if the user chooses an outlet point\n on a hill slope, the resulting map will be a thin silver of land\n representing the overland slope uphill of the point.\n  EXAMPLE \n A watershed in\n the  North\n Carolina sample dataset  region:\n g.region raster=elev_lid792_1m -p\n # the watershed outlet position should be placed on a stream (from\n # accumulation map):\n r.watershed elev_lid792_1m threshold=5000 accumulation=accum_5K drainage=draindir_5K basin=basin_5K\n r.water.outlet input=draindir_5K output=basin_A30 coordinates=638740.423248,220271.519225\n d.mon wx0\n d.rast map=accum_5K\n d.rast map=basin_A30\n # overlay with transparency\n r.colors map=basin_A30 color=grey\n d.his h=accum_5K i=basin_A30\n # report outlet size in ha\n r.report map=basin_A30 units=h\n  \n  Figure: Watershed draped over flow accumulation \n ", "see_also": ["d.where", "r.basins.fill", "r.watershed", "r.topidx"], "authors": ["Charles Ehlschlaeger, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.water.outlet"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.sample.html", "name": "t.sample", "definition": "- Samples the input space time dataset(s) with a sample space time dataset and print the result to stdout.", "keywords": ["temporal", "sampling", "time"], "synopsis": "t.sample [-cs] inputs=name[,name,...] sample=name  [intype=name]   [samtype=name]   [method=name[,name,...]]   [separator=character]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Print the column names as first row Check for spatial topological overlap Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Check for spatial topological overlap Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "inputs", "flag": "inputs", "dataType": "String", "optional": false, "explanation": "Name of the input space time datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sample", "flag": "sample", "dataType": "String", "optional": false, "explanation": "Name of the sample space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "intype", "flag": "intype", "dataType": "String", "optional": true, "explanation": "Type of the input space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "samtype", "flag": "samtype", "dataType": "String", "optional": true, "explanation": "Type of the sample space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "The method to be used for sampling the input dataset", "defaultValue": "during,overlap,contain,equal", "alternatives": ["start", "during", "overlap", "contain", "equal", "follows", "precedes"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Do not use \",\" as this char is reserved to list several map ids in a sample granule", "defaultValue": "pipe", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The purpose of this module is to compute and to show spatio-temporal \n relations between space time datasets of different type. Several input \n space time datasets are sampled by a  sample  space time dataset \n using temporal topological relations. The types of the input space time \n datasets and the type of the sample space time dataset can be \n different.\n This module is useful to analyze temporal relationships between space \n time datasets using temporal topology. The flag  -s  enables a \n spatio-temporal topology, so that only spatio-temporal related map \n layers of space time datasets are considered in the analysis.\n ", "notes": "\n The temporal relation  start  means that the start time of an \n input map layer is temporally located in an interval of a sample map \n layer.\n The textual output at the command line shows the names of the maps, \n start and end time as well as the  interval length  in days and \n the temporal  distance from begin  in days.\n The default  separator  is the pipe symbol.\n Temporal gaps, if present, in the input and sampling space time \n datasets will be used in the sampling process. Gaps have no map name, \n instead  None  is printed.\n  EXAMPLE \n In the examples below we create a space time raster dataset  A  \n and a space time vector dataset  P  that have different temporal \n layouts and number of map layers. The space time vector dataset \n contains a gap, that will be used in the sampling process.\n We use  t.sample  to inspect the topological relations between the\n time stamped map layers in  A  and  P .\n # Set an appropriate region\n g.region s=0 n=80 w=0 e=120 b=0 t=50 res=10 res3=10 -p3\n # Generate the raster map layer\n r.mapcalc expression=\"a1 = rand(0, 550)\" -s\n r.mapcalc expression=\"a2 = rand(0, 450)\" -s\n r.mapcalc expression=\"a3 = rand(0, 320)\" -s\n r.mapcalc expression=\"a4 = rand(0, 510)\" -s\n r.mapcalc expression=\"a5 = rand(0, 300)\" -s\n r.mapcalc expression=\"a6 = rand(0, 650)\" -s\n # Generate the vector map layer\n v.random -z output=pnts1 n=20 zmin=0 zmax=100 column=height\n v.random -z output=pnts2 n=20 zmin=0 zmax=100 column=height\n n1=`g.tempfile pid=1 -d` \n n2=`g.tempfile pid=2 -d`\n cat > \"${n1}\" << EOF\n a1\n a2\n a3\n a4\n a5\n a6\n EOF\n cat > \"${n2}\" << EOF\n pnts1|2001-01-01|2001-03-01\n pnts2|2001-05-01|2001-07-01\n EOF\n # Register the maps in new space time datasets\n t.create type=strds temporaltype=absolute output=A \n      title=\"A test with raster input files\" descr=\"A test with raster input files\"\n t.create type=stvds temporaltype=absolute output=P \n      title=\"A test with vector input files\" descr=\"A test with vector input files\"\n t.register type=raster -i input=A file=\"${n1}\" start=\"2001-01-01\" increment=\"1 months\"\n # Raster map layer in A\n t.rast.list A\n name|mapset|start_time|end_time\n a1|PERMANENT|2001-01-01 00:00:00|2001-02-01 00:00:00\n a2|PERMANENT|2001-02-01 00:00:00|2001-03-01 00:00:00\n a3|PERMANENT|2001-03-01 00:00:00|2001-04-01 00:00:00\n a4|PERMANENT|2001-04-01 00:00:00|2001-05-01 00:00:00\n a5|PERMANENT|2001-05-01 00:00:00|2001-06-01 00:00:00\n a6|PERMANENT|2001-06-01 00:00:00|2001-07-01 00:00:00\n t.register type=vector input=P file=\"${n2}\"\n # Vector map layer in P\n t.vect.list P\n name|layer|mapset|start_time|end_time\n pnts1|None|PERMANENT|2001-01-01 00:00:00|2001-03-01 00:00:00\n pnts2|None|PERMANENT|2001-05-01 00:00:00|2001-07-01 00:00:00\n # Start time of maps in A located in maps in P\n t.sample method=start input=A samtype=stvds sample=P -c\n P@PERMANENT|A@PERMANENT|start_time|end_time|interval_length|distance_from_begin\n pnts1@PERMANENT|a1@PERMANENT,a2@PERMANENT|2001-01-01 00:00:00|2001-03-01 00:00:00|59.0|0.0\n None|a3@PERMANENT,a4@PERMANENT|2001-03-01 00:00:00|2001-05-01 00:00:00|61.0|59.0\n pnts2@PERMANENT|a5@PERMANENT,a6@PERMANENT|2001-05-01 00:00:00|2001-07-01 00:00:00|61.0|120.0\n # P contains A\n t.sample method=contain input=A samtype=stvds sample=P -c\n P@PERMANENT|A@PERMANENT|start_time|end_time|interval_length|distance_from_begin\n pnts1@PERMANENT|a1@PERMANENT,a2@PERMANENT|2001-01-01 00:00:00|2001-03-01 00:00:00|59.0|0.0\n None|a3@PERMANENT,a4@PERMANENT|2001-03-01 00:00:00|2001-05-01 00:00:00|61.0|59.0\n pnts2@PERMANENT|a5@PERMANENT,a6@PERMANENT|2001-05-01 00:00:00|2001-07-01 00:00:00|61.0|120.0\n # A during P\n t.sample method=during intype=stvds input=P samtype=strds sample=A -c\n A@PERMANENT|P@PERMANENT|start_time|end_time|interval_length|distance_from_begin\n a1@PERMANENT|pnts1@PERMANENT|2001-01-01 00:00:00|2001-02-01 00:00:00|31.0|0.0\n a2@PERMANENT|pnts1@PERMANENT|2001-02-01 00:00:00|2001-03-01 00:00:00|28.0|31.0\n a3@PERMANENT|None|2001-03-01 00:00:00|2001-04-01 00:00:00|31.0|59.0\n a4@PERMANENT|None|2001-04-01 00:00:00|2001-05-01 00:00:00|30.0|90.0\n a5@PERMANENT|pnts2@PERMANENT|2001-05-01 00:00:00|2001-06-01 00:00:00|31.0|120.0\n a6@PERMANENT|pnts2@PERMANENT|2001-06-01 00:00:00|2001-07-01 00:00:00|30.0|151.0\n # No Overlapping\n t.sample method=overlap input=A samtype=stvds sample=P -cs\n P@PERMANENT|A@PERMANENT|start_time|end_time|interval_length|distance_from_begin\n pnts1@PERMANENT|None|2001-01-01 00:00:00|2001-03-01 00:00:00|59.0|0.0\n None|None|2001-03-01 00:00:00|2001-05-01 00:00:00|61.0|59.0\n pnts2@PERMANENT|None|2001-05-01 00:00:00|2001-07-01 00:00:00|61.0|120.0\n t.sample method=precedes input=A samtype=stvds sample=P -c\n P@PERMANENT|A@PERMANENT|start_time|end_time|interval_length|distance_from_begin\n pnts1@PERMANENT|a3@PERMANENT|2001-01-01 00:00:00|2001-03-01 00:00:00|59.0|0.0\n None|a5@PERMANENT|2001-03-01 00:00:00|2001-05-01 00:00:00|61.0|59.0\n pnts2@PERMANENT|None|2001-05-01 00:00:00|2001-07-01 00:00:00|61.0|120.0\n t.sample method=follows  input=A samtype=stvds sample=P -c\n P@PERMANENT|A@PERMANENT|start_time|end_time|interval_length|distance_from_begin\n pnts1@PERMANENT|None|2001-01-01 00:00:00|2001-03-01 00:00:00|59.0|0.0\n None|a2@PERMANENT|2001-03-01 00:00:00|2001-05-01 00:00:00|61.0|59.0\n pnts2@PERMANENT|a4@PERMANENT|2001-05-01 00:00:00|2001-07-01 00:00:00|61.0|120.0\n t.sample method=precedes,follows input=A samtype=stvds sample=P -c\n P@PERMANENT|A@PERMANENT|start_time|end_time|interval_length|distance_from_begin\n pnts1@PERMANENT|a3@PERMANENT|2001-01-01 00:00:00|2001-03-01 00:00:00|59.0|0.0\n None|a5@PERMANENT,a2@PERMANENT|2001-03-01 00:00:00|2001-05-01 00:00:00|61.0|59.0\n pnts2@PERMANENT|a4@PERMANENT|2001-05-01 00:00:00|2001-07-01 00:00:00|61.0|120.0\n ", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.sample"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rename.html", "name": "t.rename", "definition": "- Renames a space time dataset", "keywords": ["temporal", "map management", "rename", "time"], "synopsis": "t.rename input=name output=name  [type=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}], "description": "\n This module renames space time datasets of different types (STRDS, STVDS, STR3DS)\n and updates the space time dataset register entries of the registered maps.\n ", "notes": "\n Renaming of space time datasets works only for SQLite based temporal databases.\n  EXAMPLE \n A new vector space time dataset will be created, renamed and in the end removed\n #Create new and empty STVDS\n t.create type=stvds output=toberenamed semantictype=mean \n    title=\"Example to rename\" \n    description=\"This is an example just to show how rename\"\n t.rename input=toberenamed output=newname type=stvds\n t.remove input=newname type=stvds\n ", "see_also": ["t.create", "t.support", "t.register"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rename"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.remove.html", "name": "t.remove", "definition": "- Removes space time datasets from temporal database.", "keywords": ["temporal", "map management", "remove", "time"], "synopsis": "t.remove [-rf]  [inputs=name[,name,...]]   [type=string]   [file=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Remove all registered maps from the temporal and also from the spatial database Force recursive removing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Force recursive removing Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "inputs", "flag": "inputs", "dataType": "String", "optional": true, "explanation": "Name of the input space time datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the space time dataset, default is strds", "defaultValue": "strds", "alternatives": ["strds", "str3ds", "stvds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Input file with dataset names, one per line", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The module  t.remove  removes space time datasets (STRDS, STR3DS,\n STVDS) from the temporal database. In other words, by default it deletes\n the relevant database entries but not the maps.\n Optionally, also the raster, 3D raster and vector maps of the space time\n datasets can be removed from the current mapset using the  -r  (recursive)\n and  -f  (force) flags. This recursive removal only works if both flags\n are checked together (use  -rf ).\n  EXAMPLE \n In this example a space time raster dataset (STRDS) named\n  precip_months_sum  will be created using a subset of the monthly\n precipitation raster maps from the North Carolina climate sample data set.\n In order to be able to show the case of recursive removal without deleting\n the original sample data, we generate new data by means of computing\n yearly precipitation sums. Eventually, all newly produced data (STRDS and\n raster maps) are removed:\n #Create new and empty STRDS\n t.create output=precip_months_sum semantictype=mean \n    title=\"Monthly sum of precipitation\" \n    description=\"Monthly sum of precipitation for the \n    North Carolina sample data location\"\n #Register maps from sample dataset (selecting a subset with g.list)\n t.register -i type=raster input=precip_months_sum \n    maps=$(g.list type=raster pattern=\"201*_precip\" separator=comma) \n    start=\"2010-01-01\" increment=\"1 months\"\n #Create some new data by aggregating with 1 years granularity\n t.rast.aggregate input=precip_months_sum \n    output=precip_years_sum basename=precip_years_sum granularity=\"1 \n    years\" method=sum\n #Remove all newly produced data:\n # a) the aggregated STRDS with 1 years granularity along with its raster maps\n t.remove -rf type=strds input=precip_years_sum\n # b) the STRDS with 1 months granularity, but not the original sample data\n t.remove type=strds input=precip_months_sum\n ", "notes": "", "see_also": ["t.create", "t.info", "t.register"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.remove"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.register.html", "name": "t.register", "definition": "- Assigns timestamps and registers raster, vector and raster3d maps in a space time dataset.", "keywords": ["temporal", "map management", "register", "time"], "synopsis": "t.register [-i]  [input=name]   [maps=name[,name,...]]   [type=name]   [file=name]   [start=string]   [end=string]   [unit=string]   [increment=string]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Create an interval (start and end time) in case an increment and the start time are provided Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of the input space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "maps", "flag": "maps", "dataType": "String", "optional": true, "explanation": "Name of the input maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input map", "defaultValue": "raster", "alternatives": ["raster", "vector", "raster_3d"], "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Input file with map names, one per line", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start", "flag": "start", "dataType": "String", "optional": true, "explanation": "Valid start date and time of the first map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "end", "flag": "end", "dataType": "String", "optional": true, "explanation": "Valid end date and time of all map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "unit", "flag": "unit", "dataType": "String", "optional": true, "explanation": "Time stamp unit", "defaultValue": null, "alternatives": ["years", "months", "days", "hours", "minutes", "seconds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "increment", "flag": "increment", "dataType": "String", "optional": true, "explanation": "Time increment, works only in conjunction with start option", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator character of the input file", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n The module  t.register  has double functionality: it either only assigns\n timestamps to raster, 3D raster and vector maps in the temporal database\n (if  input  option is not provided, see below) or additionally, it also registers\n them within input space time datasets (stds). The existing timestamp modules\n  r.timestamp ,\n  r3.timestamp  and\n  v.timestamp  do not register the maps in the\n temporal database of GRASS GIS. However, timestamps that have been created\n with these modules can be read and used by  t.register . This\n works only for maps that are not already registered in the temporal\n database.\n If the  input  option is not used (i.e., no stds is provided), maps\n will be only registered in the temporal database with assigned\n timestamps. If, on the other hand, the  input  option\n is used and a stds is provided, maps will be first registered in the temporal\n database (if not registered before) and then, in the stds specified. If the\n user wants to register maps that are already registered in the temporal\n database in a different stds, there is no need to pass information regarding\n start and end time,  t.register  will read timestamps from the temporal\n database (i.e., in this case only passing map names will be enough).\n The module  t.register  supports absolute and relative time. The absolute temporal type\n refers to a fixed date while the relative temporal type refers to data\n without fixed timestamps (e.g., sequential maps used to calculate\n multi-decadal averages).\n Maps can be registered by command line argument (i.e., a list of comma separated map\n names) or using an input file. The start time, end time and a temporal\n increment can be provided through command line or in the input file. End time and\n increment are mutually exclusive. The user can register single maps or a\n list of maps at once. Maps can be registered in several space time\n datasets using the same timestamp. For the case of vector time series,\n the user can also register a single vector map connected to different\n layers representing time steps using the  map:layer  notation (See \n example below). \n The  increment  option and the  -i  flag (to create time intervals)\n work only in conjunction with the  start  option.\n If an input file with timestamps (either start time or start time and end time)\n is used, then the  increment  option and the  -i  flag are not supported.\n Start time and end time with absolute time must be provided using the\n format  yyyy-mm-dd HH:MM:SS +HHMM . It is also supported to specify\n only the date  yyyy-mm-dd . In case of relative time, the temporal\n unit (years, months, days, hours, minutes or seconds) must be provided.\n In this case, the relative start time, end time and increment are integers.\n ", "notes": "\n The timestamps of registered maps will be stored in the temporal\n database and in the metadata of the grass maps in the spatial database.\n This assures that timestamps can always be accessed with\n  (r|r3|v).timestamp  and the temporal modules. Timestamps should\n only be modified with  t.register  because the\n  (r|r3|v).timestamp  modules have no access to the temporal\n database.\n  INPUT FILE FORMAT \n There are several options to register maps by means of a file. The input file\n consists of a list of map names, optionally along with timestamps. Each map\n name (and timestaps if provided) should be stored in a new line in this file.\n When only map names are provided, the  increment  option and the  -i \n flag are supported. However, when along with map names any kind of timestamp is\n provided, as well, the  increment  option and the  -i  are no longer\n supported.\n Specification of map names only ( increment  option and  -i  flag\n supported):\n terra_lst_day20020113\n terra_lst_day20020114\n terra_lst_day20020115\n terra_lst_day20020116\n terra_lst_day20020117\n Specification of map names and absolute start time (date) of the time\n instances (no support for  increment  option nor  -i  flag):\n terra_lst_day20020113|2002-01-13\n terra_lst_day20020114|2002-01-14\n terra_lst_day20020115|2002-01-15\n terra_lst_day20020116|2002-01-16\n terra_lst_day20020117|2002-01-17\n Specification of map names and absolute start time (datetime) of the time\n instances (no support for  increment  option nor  -i  flag):\n terra_lst_day20020113|2002-01-13 10:30\n terra_lst_day20020114|2002-01-14 10:30\n terra_lst_day20020115|2002-01-15 10:30\n terra_lst_day20020116|2002-01-16 10:30\n terra_lst_day20020117|2002-01-17 10:30\n Specification of map names and absolute time interval with start and end time\n (no support for  increment  option nor  -i  flag):\n prec_1|2001-01-01|2001-04-01\n prec_2|2001-04-01|2001-07-01\n prec_3|2001-07-01|2001-10-01\n prec_4|2001-10-01|2002-01-01\n prec_5|2002-01-01|2002-04-01\n prec_6|2002-04-01|2002-07-01\n  EXAMPLE \n  North Carolina dataset \n  Using a text file \n Register maps in an absolute space time dataset, creating a time interval\n # first:  prepare a text file with a list of input maps (see above)\n # second: register maps\n t.register -i type=raster input=precipitation_monthly \n      file=list_of_input_maps.txt start=\"2009-01-01\" \n      increment=\"1 months\"\n  Using  g.list  to generate the input \n Register maps in an absolute space time dataset, creating a time interval\n t.register -i type=raster input=precipitation_monthly \n      maps=`g.list raster pattern=\"*precip*\" sep=comma` start=\"2009-01-01\" \n      increment=\"1 months\"\n  Register a vector map with layers representing time steps \n Assume a vector map of points that represent meteorological stations and\n it is connected to different layers depicting daily time steps. In this\n example, only the fifth layer of the vector map will be registered.\n # the layer is specified behind the colon\n t.register type=vector input=meteo_stations_nc_daily \n      maps=meteo_stations_nc:5 start=\"2009-01-05\"\n  Synthetic maps \n In this example we create 6 raster maps that will be registered in a\n single space time raster dataset named precip_abs using a monthly\n temporal granularity. The  -i  flag generates time intervals of the\n provided  increment . The generated timestamps will be inspected\n using  r.timestamp  and  t.rast.list . We will register an\n additional map with a timestamp that was set with  r.timestamp .\n r.mapcalc expression=\"prec_1 = 100\"\n r.mapcalc expression=\"prec_2 = 200\"\n r.mapcalc expression=\"prec_3 = 300\"\n r.mapcalc expression=\"prec_4 = 400\"\n r.mapcalc expression=\"prec_5 = 500\"\n r.mapcalc expression=\"prec_6 = 600\"\n t.create type=strds temporaltype=absolute \n      output=precip_abs title=\"Example\" \n      descr=\"Example\"\n t.register -i type=raster input=precip_abs \n      maps=prec_1,prec_2,prec_3,prec_4,prec_5,prec_6 \n      start=\"2001-01-01\" increment=\"1 months\"\n r.timestamp prec_1\n 1 Jan 2001 00:00:00 / 1 Feb 2001 00:00:00\n r.timestamp prec_2\n 1 Feb 2001 00:00:00 / 1 Mar 2001 00:00:00\n t.rast.list input=precip_abs\n name|mapset|start_time|end_time\n prec_1|PERMANENT|2001-01-01 00:00:00|2001-02-01 00:00:00\n prec_2|PERMANENT|2001-02-01 00:00:00|2001-03-01 00:00:00\n prec_3|PERMANENT|2001-03-01 00:00:00|2001-04-01 00:00:00\n prec_4|PERMANENT|2001-04-01 00:00:00|2001-05-01 00:00:00\n prec_5|PERMANENT|2001-05-01 00:00:00|2001-06-01 00:00:00\n prec_6|PERMANENT|2001-06-01 00:00:00|2001-07-01 00:00:00\n r.mapcalc expression=\"prec_7 = 700\"\n r.timestamp map=prec_7 date=\"1 jul 2001 / 1 aug 2001\"\n t.register type=raster input=precip_abs maps=prec_7\n t.rast.list input=precip_abs\n name|mapset|start_time|end_time\n prec_1|PERMANENT|2001-01-01 00:00:00|2001-02-01 00:00:00\n prec_2|PERMANENT|2001-02-01 00:00:00|2001-03-01 00:00:00\n prec_3|PERMANENT|2001-03-01 00:00:00|2001-04-01 00:00:00\n prec_4|PERMANENT|2001-04-01 00:00:00|2001-05-01 00:00:00\n prec_5|PERMANENT|2001-05-01 00:00:00|2001-06-01 00:00:00\n prec_6|PERMANENT|2001-06-01 00:00:00|2001-07-01 00:00:00\n prec_7|PERMANENT|2001-07-01 00:00:00|2001-08-01 00:00:00\n  Importing and registering ECA&D climatic data \n The European Climate Assessment & Dataset (ECA&D) project\n offers the E-OBS dataset which is a daily gridded observational\n dataset for precipitation, temperature and sea level pressure in\n Europe based on ECA&D information.\n Download and decompress mean temperature data from:\n  here \n by accepting their\n  Terms of use .\n # import E-OBS V12 into a lat-long location (alternatively, use r.external)\n r.in.gdal -oe input=tg_0.25deg_reg_1950-1964_v12.0.nc \n    output=temperature_mean offset=0\n r.in.gdal -oe input=tg_0.25deg_reg_1965-1979_v12.0.nc \n    output=temperature_mean offset=5479 --o\n r.in.gdal -oe input=tg_0.25deg_reg_1980-1994_v12.0.nc \n    output=temperature_mean offset=10957 --o\n r.in.gdal -oe input=tg_0.25deg_reg_1995-2015_v12.0.nc \n    output=temperature_mean offset=16436 --o\n # create STRDS\n t.create type=strds output=temperature_mean_1950_2015_daily \n    temporaltype=absolute semantictype=mean \n    title=\"European mean temperature 1950-2015\" \n    description=\"The European daily mean temperature from ECAD\"\n # create text file with all temperature_mean rasters, one per line,\n # a) using a shell script\n for i in `seq 1 23922` ; do\n     echo temperature_mean.$i >> map_list.txt\n done\n # b) using a Python script\n file = open(\"map_list.txt\", \"w\")\n for i in range(23922):\n     file.write(\"temperature_mean.%i\\n \" % (i + 1))\n file.close()\n # register daily maps using the file created above\n t.register -i type=raster input=temperature_mean_1950_2015_daily \n                file=map_list.txt start=\"1950-01-01\" increment=\"1 days\"\n ", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.register"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast3d.univar.html", "name": "t.rast3d.univar", "definition": "- Calculates univariate statistics from the non-null cells for each registered 3D raster map of a space time 3D raster dataset.", "keywords": ["temporal", "statistics", "raster3d", "voxel", "time"], "synopsis": "t.rast3d.univar [-es] input=name  [output=name]   [where=sql_query]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Calculate extended statistics Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster3d dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator character between the output columns", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast3d.univar  provides the same functionality as\n  t.rast.univar , the only difference is the \n 3D raster map layer metadata. Please refer to the manual page of\n  t.rast.univar  for documentation and examples.\n ", "notes": "", "see_also": ["t.rast.univar", "t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast3d.univar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast3d.mapcalc.html", "name": "t.rast3d.mapcalc", "definition": "- Performs r3.mapcalc expressions on maps of sampled space time 3D raster datasets.", "keywords": ["temporal", "algebra", "raster3d", "voxel", "time"], "synopsis": "t.rast3d.mapcalc [-ns] inputs=name[,name,...] expression=string  [method=name[,name,...]]  output=name basename=string  [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register Null maps Check the spatial topology of temporally related maps and process only spatially related maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Check the spatial topology of temporally related maps and process only spatially related maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "inputs", "flag": "inputs", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster3d datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": false, "explanation": "r3.mapcalc expression applied to each time step of the sampled data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "The method to be used for sampling the input dataset", "defaultValue": "during,overlap,contain,equal", "alternatives": ["start", "during", "overlap", "contain", "equal", "follows", "precedes"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time raster3d dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r3.mapcalc processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast3d.mapcalc  provides exact the same functionality as \n  t.rast.mapcalc , but for space time 3D raster datasets. Please \n refer to  t.rast.mapcalc  for \n documentation.\n It is a simple wrapper for  r3.mapcalc  \n enhanced with temporal functions.\n ", "notes": "", "see_also": ["t.rast.mapcalc", "t.rast3d.algebra", "r3.mapcalc"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast3d.mapcalc"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast3d.list.html", "name": "t.rast3d.list", "definition": "- Lists registered maps of a space time raster3d dataset.", "keywords": ["temporal", "map management", "list", "raster3d", "voxel", "time"], "synopsis": "t.rast3d.list [-s] input=name  [order=string[,string,...]]   [columns=string[,string,...]]   [where=sql_query]   [method=string]   [separator=character]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster3d dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Order the space time dataset by category", "defaultValue": "start_time", "alternatives": ["id", "name", "creator", "mapset", "temporal_type", "creation_time", "start_time", "end_time", "north", "south", "west", "east", "nsres", "tbres", "ewres", "cols", "rows", "depths", "number_of_cells", "min", "max"], "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Columns to be printed to stdout", "defaultValue": "name,mapset,start_time,end_time", "alternatives": ["id", "name", "creator", "mapset", "temporal_type", "creation_time", "start_time", "end_time", "north", "south", "west", "east", "nsres", "tbres", "ewres", "cols", "rows", "depths", "number_of_cells", "min", "max"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Method used for data listing", "defaultValue": "cols", "alternatives": ["cols", "comma", "delta", "deltagaps", "gran"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator character between the output columns", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  t.rast3d.list  provides the same functionality as\n  t.rast.list , the only difference is the\n 3D raster map layer metadata. Please refer to the manual page of\n  t.rast.list .\n ", "notes": "", "see_also": ["t.rast.list", "g.list", "t.create", "t.info", "t.list", "t.vect.list"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast3d.list"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast3d.extract.html", "name": "t.rast3d.extract", "definition": "- Extracts a subset of a space time 3D raster dataset.", "keywords": ["temporal", "extract", "raster3d", "voxel", "time"], "synopsis": "t.rast3d.extract [-n] input=name  [where=sql_query]   [expression=string]  output=name  [basename=string]   [suffix=string]   [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register Null maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster3d dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": true, "explanation": "The r3.mapcalc expression assigned to all extracted 3D raster maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time raster3d dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": true, "explanation": "Basename of the new generated 3D raster maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r3.mapcalc processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast3d.extract  is used to extract a subset of a space \n time 3D raster dataset and to store that subset in a different space time \n 3D raster dataset. It has exactly the same functionality as \n  t.rast.extract . The only difference is the\n that this module works on STR3DS and 3D raster maps.\n Please refer to  t.rast.extract  for\n documentation and examples.\n ", "notes": "", "see_also": ["t.rast.extract", "t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast3d.extract"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast3d.algebra.html", "name": "t.rast3d.algebra", "definition": "- Apply temporal and spatial operations on space time 3D raster datasets using temporal 3D raster algebra.", "keywords": ["temporal", "algebra", "raster3d", "voxel", "time"], "synopsis": "t.rast3d.algebra [-sng] expression=string basename=string  [nprocs=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Check the spatial topology of temporally related maps and process only spatially related maps Register Null maps Use granularity sampling instead of the temporal topology approach Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Register Null maps Use granularity sampling instead of the temporal topology approach Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Use granularity sampling instead of the temporal topology approach Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": false, "explanation": "Algebraic expression for temporal and spatial analysis of space time 3D raster datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r3.mapcalc processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast3d.algebra  performs temporal and spatial map algebra \n operations on space time 3D raster datasets (STR3DS) by using the \n temporal 3D raster algebra.\n  NOTES \n The module expects an  expression  as input parameter in the following form:\n  \"result = expression\" \n The statement structure is exact the same as of  t.rast.algebra ,\n see  t.rast.algebra  but allows four-dimensional\n indexing.\n ", "notes": "", "see_also": ["t.rast.algebra", "t.rast3d.mapcalc", "r.mapcalc", "t.vect.algebra", "t.select"], "authors": ["Thomas Leppelt, S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast3d.algebra"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.what.html", "name": "t.rast.what", "definition": "- Sample a space time raster dataset at specific vector point coordinates and write the output to stdout using different layouts", "keywords": ["temporal", "sampling", "raster", "time"], "synopsis": "t.rast.what [-niv]  [points=name]   [coordinates=east,north]  strds=name  [output=name]   [where=sql_query]   [null_value=string]   [separator=character]   [order=string[,string,...]]   [layout=string]   [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Output header row Use stdin as input and ignore coordinates and point option Show the category for vector points map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Use stdin as input and ignore coordinates and point option Show the category for vector points map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Show the category for vector points map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "points", "flag": "points", "dataType": "String", "optional": true, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Comma separated list of coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "strds", "flag": "strds", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for the output file or \"-\" in case stdout should be used", "defaultValue": "-", "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Sort the maps by category", "defaultValue": "start_time", "alternatives": ["id", "name", "creator", "mapset", "creation_time", "modification_time", "start_time", "end_time", "north", "south", "west", "east", "min", "max"], "isInputFile": false, "isOutputFile": false}, {"parameter": "layout", "flag": "layout", "dataType": "String", "optional": true, "explanation": "The layout of the output. One point per row (row), one point per column (col), all timsteps in one row (timerow)", "defaultValue": "row", "alternatives": ["row", "col", "timerow"], "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r.what processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.what  is designed to sample space time raster datasets\n at specific point coordinates using  r.what \n internally. The output of  r.what  is transformed\n to different output layouts.\n The output layouts can be specified using the  layout  option.\n Three layouts can be specified:\n      row  - Row order, one vector sample point value per row \n      col  - Column order, create a column for each vector sample\n      point of a single time step/raster layer \n      timerow  - Time order, create a column for each time step, \n      this order is the original  r.what  output, except that the column\n      names are the timestamps \n Please have a look at the example to see the supported layouts.\n This module is designed to run several instances of  r.what  to sample\n subsets of a space time raster dataset in parallel. Several intermediate\n text files will be created that are merged into a single file at the\n end of the processing.\n Coordinates can be provided as vector map using the  points  option\n or as comma separated coordinate list with the  coordinates  option.\n An output file can be specified using the  output  option. \n Stdout will be used if no output is specified or if the \n  output  option is set to \"-\".\n     \n  EXAMPLES \n  Data preparation \n In the following examples we sample a space time raster dataset that contains\n 4 raster map layers. First we create the STRDS that will be sampled with\n  t.rast.what .\n g.region s=0 n=80 w=0 e=120 b=0 t=50 res=10\n # Generate data\n r.mapcalc expression=\"a_1 = 1\" -s\n r.mapcalc expression=\"a_2 = 2\" -s\n r.mapcalc expression=\"a_3 = 3\" -s\n r.mapcalc expression=\"a_4 = 4\" -s\n t.create type=strds output=A title=\"A test\" descr=\"A test\"\n t.register -i type=raster input=A maps=a_1,a_2,a_3,a_4 \n      start='1990-01-01' increment=\"1 month\"\n  Example 1 \n The first approach uses text coordinates as input and stdout as output,\n the layout is one coordinate(point per column:\n t.rast.what strds=A coordinates=\"115,36,79,45\" layout=col -n\n start|end|115.0000000000;36.0000000000|79.0000000000;45.0000000000\n 1990-01-01 00:00:00|1990-02-01 00:00:00|1|1\n 1990-02-01 00:00:00|1990-03-01 00:00:00|2|2\n 1990-03-01 00:00:00|1990-04-01 00:00:00|3|3\n 1990-04-01 00:00:00|1990-05-01 00:00:00|4|4\n  Example 2 \n A vector map layer can be used as input to sample the STRDS. All\n three available layouts are demonstrated using the vector map for sampling.\n # First create the vector map layer based on random points\n v.random output=points n=3 seed=1\n # Row layout using a text file as output\n t.rast.what strds=A points=points output=result.txt layout=row -n\n cat result.txt\n 115.0043586274|36.3593955783|1990-01-01 00:00:00|1990-02-01 00:00:00|1\n 115.0043586274|36.3593955783|1990-02-01 00:00:00|1990-03-01 00:00:00|2\n 115.0043586274|36.3593955783|1990-03-01 00:00:00|1990-04-01 00:00:00|3\n 115.0043586274|36.3593955783|1990-04-01 00:00:00|1990-05-01 00:00:00|4\n 79.6816763826|45.2391522853|1990-01-01 00:00:00|1990-02-01 00:00:00|1\n 79.6816763826|45.2391522853|1990-02-01 00:00:00|1990-03-01 00:00:00|2\n 79.6816763826|45.2391522853|1990-03-01 00:00:00|1990-04-01 00:00:00|3\n 79.6816763826|45.2391522853|1990-04-01 00:00:00|1990-05-01 00:00:00|4\n 97.4892579600|79.2347263950|1990-01-01 00:00:00|1990-02-01 00:00:00|1\n 97.4892579600|79.2347263950|1990-02-01 00:00:00|1990-03-01 00:00:00|2\n 97.4892579600|79.2347263950|1990-03-01 00:00:00|1990-04-01 00:00:00|3\n 97.4892579600|79.2347263950|1990-04-01 00:00:00|1990-05-01 00:00:00|4\n # Column layout order using stdout as output\n t.rast.what strds=A points=points layout=col -n\n start|end|115.0043586274;36.3593955783|79.6816763826;45.2391522853|97.4892579600;79.2347263950\n 1990-01-01 00:00:00|1990-02-01 00:00:00|1|1|1\n 1990-02-01 00:00:00|1990-03-01 00:00:00|2|2|2\n 1990-03-01 00:00:00|1990-04-01 00:00:00|3|3|3\n 1990-04-01 00:00:00|1990-05-01 00:00:00|4|4|4\n # Timerow layout, one time series per row \n # using the where statement to select a subset of the STRDS\n # and stdout as output\n t.rast.what strds=A points=points \n      where=\"start_time >= '1990-03-01'\" layout=timerow -n\n x|y|1990-03-01 00:00:00;1990-04-01 00:00:00|1990-04-01 00:00:00;1990-05-01 00:00:00\n 115.004358627375|36.3593955782903|3|4\n 79.681676382576|45.2391522852909|3|4\n 97.4892579600048|79.2347263950131|3|4\n ", "notes": "", "see_also": ["g.region", "r.mask", "r.neighbors", "r.what", "t.info", "t.rast.aggregate.ds", "t.rast.extract", "v.what.strds"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.what"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.univar.html", "name": "t.rast.univar", "definition": "- Calculates univariate statistics from the non-null cells for each registered raster map of a space time raster dataset.", "keywords": ["temporal", "statistics", "raster", "time"], "synopsis": "t.rast.univar [-eru] input=name  [output=name]   [where=sql_query]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Calculate extended statistics Ignore the current region settings and use the raster map regions for univar statistical calculation Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Ignore the current region settings and use the raster map regions for univar statistical calculation Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "u", "flag": "-u", "explanation": "Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator character between the output columns", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.univar  calculates univariate statistics from the\n non-null cells for each registered raster map of a space time raster\n dataset.\n By default it returns the name of the map, the start and end date of\n dataset and the following values: mean, minimum and maximum vale,\n mean_of_abs, standard deviation, variance, coeff_var, number of null\n cells, total number of cell.\n Using the  e  flag it can calculate also extended statistics:\n first quartile, median value, third quartile and percentile 90.\n  EXAMPLE \n Obtain the univariate statistics for the raster space time dataset\n \"tempmean_monthly\" (precision reduced to 2 decimals in this example):\n t.rast.univar -e tempmean_monthly\n id|start|end|mean|min|max|mean_of_abs|stddev|variance|coeff_var|sum|null_cells|cells|first_quartile|median|third_quartile|percentile_90\n 2009_01_tempmean@climate_2009_2012|2009-01-01 00:00:00|2009-02-01 00:00:00|3.90|-3.38|7.43|3.95|1.79|3.20|45.91|1977967.31|503233|1010600|2.80|3.92|5.21|6.23\n 2009_02_tempmean@climate_2009_2012|2009-02-01 00:00:00|2009-03-01 00:00:00|5.91|-1.82|8.01|5.92|1.63|2.65|27.53|2999555.60|503233|1010600|5.44|6.26|7.07|7.48\n ...\n 2012_11_tempmean@climate_2009_2012|2012-11-01 00:00:00|2012-12-01 00:00:00|8.03|1.79|10.91|8.03|1.32|1.73|16.41|4072472.77|503233|1010600|7.49|8.13|8.96|9.48\n 2012_12_tempmean@climate_2009_2012|2012-12-01 00:00:00|2013-01-01 00:00:00|8.71|1.76|11.98|8.71|1.72|2.95|19.74|4418403.77|503233|1010600|7.84|8.95|9.99|10.67\n ", "notes": "", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.univar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.to.vect.html", "name": "t.rast.to.vect", "definition": "- Converts a space time raster dataset into a space time vector dataset", "keywords": ["temporal", "conversion", "raster", "vector", "time"], "synopsis": "t.rast.to.vect [-ntszbv] input=name output=name  [where=sql_query]  type=string basename=string  [suffix=string]   [column=string]   [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register empty vector maps Do not create attribute tables Smooth corners of area features Write raster values as z coordinate Table is not created. Currently supported only for points. Do not build vector topology Name must be SQL compliant Use raster values as categories instead of unique sequence (CELL only) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create attribute tables Smooth corners of area features Write raster values as z coordinate Table is not created. Currently supported only for points. Do not build vector topology Name must be SQL compliant Use raster values as categories instead of unique sequence (CELL only) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Smooth corners of area features Write raster values as z coordinate Table is not created. Currently supported only for points. Do not build vector topology Name must be SQL compliant Use raster values as categories instead of unique sequence (CELL only) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Write raster values as z coordinate Table is not created. Currently supported only for points. Do not build vector topology Name must be SQL compliant Use raster values as categories instead of unique sequence (CELL only) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build vector topology Name must be SQL compliant Use raster values as categories instead of unique sequence (CELL only) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Use raster values as categories instead of unique sequence (CELL only) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": false, "explanation": "Output feature type", "defaultValue": null, "alternatives": ["point", "line", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of attribute column to store value", "defaultValue": "value", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r.to.vect processes to run in parallel, more than 1 process works only in conjunction with flag -t", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.to.vect  is designed to convert a space time raster dataset\n into a space time vector dataset. This module works as a front-end to\n  r.to.vect  and therefore supports all parameter\n of this module. Hence, all raster map layers in a space time raster dataset\n are passed to  r.to.vect  that converts them into\n vector map layers (using point,line or area as conversion criteria). \n Please refer to the  r.to.vect  documentation \n for a detailed description of the raster to vector conversion options.\n The new generated vector map\n layers will be registered in the output space time vector dataset, using \n the same time stamps as their raster map layer origins.\n This module supports the parallel processing of  r.to.vect \n module instances. The number of parallel processes \n can be set with the  nprocs  option. \n However, this will only work in conjunction with the  -t \n flag, that avoids the creation of attribute tables. \n The parallel creation of attribute tables is not supported.\n The  where  option allows selecting subsets of the input space time raster\n dataset.\n The flag  -n  can be used to force the registration of empty \n vector map layers. Empty vector maps may occur in case that empty \n raster map layers should be converted into vector map layers.\n ", "notes": "", "see_also": ["r.to.vect", "t.rast.db.select", "t.info"], "authors": ["S\u00f6ren Gebbert, Geoinformatikb\u00fcro Dassau"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.to.vect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.to.rast3.html", "name": "t.rast.to.rast3", "definition": "- Converts a space time raster dataset into a 3D raster map.", "keywords": ["temporal", "conversion", "raster", "raster3d", "voxel", "time"], "synopsis": "t.rast.to.rast3 input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  t.rast.to.rast3  is designed to convert a space time raster\n dataset (STRDS) into a space time voxel cube. A space time voxel cube\n is a 3 dimensional raster map layer (3D raster map or voxel map layer)\n that as time as unit for the z-dimension.\n A space time raster dataset that should be converted into a space time\n voxel cube must have a valid temporal topology. Hence, overlapping or\n inclusion of time stamps is not allowed. The granularity of the STRDS\n is used to set the resolution of the 3D raster map layer and to sample\n the registered time stamped raster map layers.\n Gaps between raster map layer in the STRDS will\n be represented by NULL values in the voxel map layer.\n ", "notes": "\n The reference time for all space time voxel cubes is\n 1900-01-0100:00:00. This allows the alignment space time voxel cubes\n with different granularities.\n Be aware that the granularity of a STRDS is used to sample time stamped\n map layers! If you have gaps between monthly intervals that have the\n size of a second, the monthly intervals will be sampled by a second\n based granularity as well. This may result in millions of space time\n voxel cube layers!\n  Management of open file limits \n The maximum number of raster maps that can be processed is given by the \n per-user limit of the operating system. For example, both the the hard and soft\n limit for users is typically 1024. The soft limit can be changed with e.g. \n ulimit -n 4096 (UNIX-based operating systems) but not higher than the \n hard limit. If the latter is too low, you can as superuser add an entry in\n /etc/security/limits.conf\n # <domain>      <type>  <item>         <value>\n your_username  hard    nofile          4096\n This will raise the hard limit to 4096 files. Also have a look at the overall \n limit of the operating system\n cat /proc/sys/fs/file-max\n which, on modern Linux systems, is several 100,000 files.\n  EXAMPLE \n To create a voxel map layer from a subset of the  tempmean_monthly \n space time dataset, run:\n # create the subset for 2012 data\n t.rast.extract input=tempmean_monthly output=tempmean_monthly_later_2012 \n                 where=\"start_time >= '2012-01-01'\"\n # set the right 3D region\n g.region -p3 res3=500\n # convert to 3D raster map\n t.rast.to.rast3 input=tempmean_monthly_later_2012@climate_2009_2012 output=tempmean_monthly_2012\n t.info type=raster_3d input=tempmean_monthly_2012\n  +-------------------- 3D Raster Dataset -------------------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ tempmean_monthly_2012@climate_2009_2012\n  | Name: ...................... tempmean_monthly_2012\n  | Mapset: .................... climate_2009_2012\n  | Creator: ................... lucadelu\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-28 11:10:51.679294\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-01-01 00:00:00\n  | End time:................... 2013-01-01 00:00:00\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 320000.0\n  | South:...................... 10000.0\n  | East:.. .................... 935000.0\n  | West:....................... 120000.0\n  | Top:........................ 1357.0\n  | Bottom:..................... 1345.0\n  +-------------------- Metadata information ----------------------------------+\n  | Datatype:................... DCELL\n  | Number of columns:.......... 620\n  | Number of rows:............. 1630\n  | Number of cells:............ 12127200\n  | North-South resolution:..... 500.0\n  | East-west resolution:....... 500.0\n  | Minimum value:.............. -0.534994\n  | Maximum value:.............. 28.794653\n  | Number of depths:........... 12\n  | Top-Bottom resolution:...... 1.0\n  | Registered datasets ........\n  +----------------------------------------------------------------------------+\n r3.info tempmean_monthly_2012\n  +----------------------------------------------------------------------------+\n  | Layer:    tempmean_monthly_2012          Date: Fri Nov 28 11:10:50 2014    |\n  | Mapset:   climate_2009_2012              Login of Creator: lucadelu        |\n  | Location: nc_spm_temporal_workshop                                         |\n  | DataBase: /grassdata                                                       |\n  | Title:    Space time voxel cube                                            |\n  | Units:    none                                                             |\n  | Vertical unit: months                                                      |\n  | Timestamp: none                                                            |\n  |----------------------------------------------------------------------------|\n  |                                                                            |\n  |   Type of Map:  3d cell              Number of Categories: 0               |\n  |   Data Type:    DCELL                                                      |\n  |   Rows:         620                                                        |\n  |   Columns:      1630                                                       |\n  |   Depths:       12                                                         |\n  |   Total Cells:  12127200                                                   |\n  |   Total size:           28414287 Bytes                                     |\n  |   Number of tiles:      4230                                               |\n  |   Mean tile size:       6717 Bytes                                         |\n  |   Tile size in memory:  23520 Bytes                                        |\n  |   Number of tiles in x, y and  z:   47, 45, 2                              |\n  |   Dimension of a tile in x, y, z:   35, 14, 6                              |\n  |                                                                            |\n  |        Projection: Lambert Conformal Conic (zone 0)                        |\n  |            N:     320000    S:      10000   Res:   500                     |\n  |            E:     935000    W:     120000   Res:   500                     |\n  |            T:       1357    B:       1345   Res:     1                     |\n  |   Range of data:   min = -0.53499434 max = 28.79465315                     |\n  |                                                                            |\n  |   Data Source:                                                             |\n  |                                                                            |\n  |                                                                            |\n  |                                                                            |\n  |   Data Description:                                                        |\n  |    This space time voxel cube was created with t.rast.to.rast3             |\n  |                                                                            |\n  |   Comments:                                                                |\n  |    r.to.rast3 input=\"2012_01_tempmean@climate_2009_2012,2012_02_tempmea\\   |\n  |    n@climate_2009_2012,2012_03_tempmean@climate_2009_2012,2012_04_tempm\\   |\n  |    ean@climate_2009_2012,2012_05_tempmean@climate_2009_2012,2012_06_tem\\   |\n  |    pmean@climate_2009_2012,2012_07_tempmean@climate_2009_2012,2012_08_t\\   |\n  |    empmean@climate_2009_2012,2012_09_tempmean@climate_2009_2012,2012_10\\   |\n  |    _tempmean@climate_2009_2012,2012_11_tempmean@climate_2009_2012,2012_\\   |\n  |    12_tempmean@climate_2009_2012\" output=\"tempmean_monthly_2012\" tilesi\\   |\n  |    ze=32                                                                   |\n  |                                                                            |\n  +----------------------------------------------------------------------------+\n ", "see_also": ["r3.mapcalc", "r3.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.to.rast3"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.series.html", "name": "t.rast.series", "definition": "- Performs different aggregation algorithms from r.series on all or a subset of raster maps in a space time raster dataset.", "keywords": ["temporal", "aggregation", "series", "raster", "time"], "synopsis": "t.rast.series [-tn] input=name method=string  [quantile=float]   [order=string[,string,...]]   [where=sql_query]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Do not assign the space time raster dataset start and end time to the output map Propagate NULLs Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Propagate NULLs Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Aggregate operation to be performed on the raster maps", "defaultValue": "average", "alternatives": ["average", "count", "median", "mode", "minimum", "min_raster", "maximum", "max_raster", "stddev", "range", "sum", "variance", "diversity", "slope", "offset", "detcoeff", "quart1", "quart3", "perc90", "quantile", "skewness", "kurtosis"], "isInputFile": false, "isOutputFile": false}, {"parameter": "quantile", "flag": "quantile", "dataType": "String", "optional": true, "explanation": "Quantile to calculate for method=quantile", "defaultValue": null, "alternatives": ["0.0-1.0"], "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Sort the maps by category", "defaultValue": "start_time", "alternatives": ["id", "name", "creator", "mapset", "creation_time", "modification_time", "start_time", "end_time", "north", "south", "west", "east", "min", "max"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  t.rast.series  is a simple wrapper for the raster module\n  r.series . It supports a subset of the aggregation methods of\n  r.series .\n The input of this module is a single space time raster dataset, the\n output is a single raster map layer. A subset of the input space time\n raster dataset can be selected using the  where  option. The\n sorting of the raster map layer can be set using the  order \n option. Be aware that the order of the maps can significantly influence\n the result of the aggregation (e.g.: slope). By default the maps are\n ordered by  start_time .\n  EXAMPLE \n Estimate average temperature for the whole time series\n t.rast.series input=tempmean_monthly output=tempmean_general method=average\n Estimate average temperature for all January maps in the time series, the \n so-called climatology\n t.rast.series input=tempmean_monthly \n      method=average output=tempmean_january \n      where=\"strftime('%m', start_time)='01'\"\n # equivalently, we can use \n t.rast.series input=tempmean_monthly \n      output=tempmean_january method=average \n      where=\"start_time = datetime(start_time, 'start of year', '0 month')\"\n # if we want also February and March averages\n t.rast.series input=tempmean_monthly \n      output=tempmean_february method=average \n      where=\"start_time = datetime(start_time, 'start of year', '1 month')\"\n t.rast.series input=tempmean_monthly \n      output=tempmean_march method=average \n      where=\"start_time = datetime(start_time, 'start of year', '2 month')\"\n Generalizing a bit, we can estimate monthly climatologies for all months \n by means of different methods\n for i in `seq -w 1 12` ; do \n   for m in average stddev minimum maximum ; do \n     t.rast.series input=tempmean_monthly method=${m} output=tempmean_${m}_${i} \n      where=\"strftime('%m', start_time)='${i}'\"\n   done\n done\n ", "notes": "", "see_also": ["r.series", "t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.series"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.out.vtk.html", "name": "t.rast.out.vtk", "definition": "- Exports space time raster dataset as VTK time series.", "keywords": ["temporal", "export", "raster", "VTK", "time"], "synopsis": "t.rast.out.vtk [-pcg] input=name directory=string  [elevation=name]   [where=sql_query]   [null=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Create VTK point data instead of VTK cell data (if no elevation map is given) Correct the coordinates to fit the VTK-OpenGL precision Export files using the space time dataset granularity for equidistant time between maps, where statement will be ignored Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Correct the coordinates to fit the VTK-OpenGL precision Export files using the space time dataset granularity for equidistant time between maps, where statement will be ignored Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Export files using the space time dataset granularity for equidistant time between maps, where statement will be ignored Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "directory", "flag": "directory", "dataType": "String", "optional": false, "explanation": "Path to the export directory", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Name of input elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null", "flag": "null", "dataType": "String", "optional": true, "explanation": "Value to represent no data cell", "defaultValue": "-99999.99", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This module exports all maps registered in a space time raster datasets \n as VTK legacy files using a numerical numbering scheme. The VTK files \n can be visualized with any VTK based visualize. Our preferred tool is \n ParaView. The VTK legacy files are created using  r.out.vtk .\n  EXAMPLE \n In this simple example we create several raster maps with random values \n and one elevation map. The random value raster maps are registered in a \n space time raster dataset. All maps of this space time raster dataset \n are exported using  t.rast.out.vtk  into the directory \n  /tmp/test1 .\n mkdir /tmp/export\n t.rast.out.vtk input=precip_abs expdir=/tmp/export elevation=elevation\n ls -1 /tmp/export\n 000000_tempmean_monthly.vtk\n 000001_tempmean_monthly.vtk\n 000002_tempmean_monthly.vtk\n 000003_tempmean_monthly.vtk\n 000004_tempmean_monthly.vtk\n 000005_tempmean_monthly.vtk\n 000006_tempmean_monthly.vtk\n 000007_tempmean_monthly.vtk\n 000008_tempmean_monthly.vtk\n 000009_tempmean_monthly.vtk\n 000010_tempmean_monthly.vtk\n 000011_tempmean_monthly.vtk\n ", "notes": "", "see_also": ["r.out.vtk", "ParaView"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.out.vtk"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.neighbors.html", "name": "t.rast.neighbors", "definition": "- Performs a neighborhood analysis for each map in a space time raster dataset.", "keywords": ["temporal", "aggregation", "raster", "time"], "synopsis": "t.rast.neighbors [-nr] input=name output=name  [where=sql_query]   [size=integer]  method=string basename=string  [suffix=string]   [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register Null maps Ignore the current region settings and use the raster map regions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Ignore the current region settings and use the raster map regions Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Neighborhood size", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Aggregate operation to be performed on the raster maps", "defaultValue": "average", "alternatives": ["average", "median", "mode", "minimum", "maximum", "range", "stddev", "sum", "count", "variance", "diversity", "interspersion", "quart1", "quart3", "perc90", "quantile"], "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r.neighbor processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.neighbors  performs  r.neighbors \n computations on the maps of a space time raster dataset (STRDS). This\n module supports a subset of options that are available in\n  r.neighbors . The size of the neighborhood\n and the aggregation method can be chosen.\n The user must provide an input and an output space time raster dataset and\n the basename of the resulting raster maps. The resulting STRDS will have\n the same temporal resolution as the input dataset.\n All maps will be processed using the current region settings.\n The user can select a subset of the input space time raster dataset for\n processing using a SQL WHERE statement. The number of CPU's to be used\n for parallel processing can be specified with the  nprocs \n option to speedup the computation on multi-core system.\n  EXAMPLE \n To smooth the maps contained in a space time dataset run:\n t.rast.neighbors input=tempmean_monthly output=smooth_tempmean_monthly \n                   basename=tmean_smooth size=5 method=average nprocs=4\n # show some info about the new space time dataset\n t.info smooth_tempmean_monthly\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ smooth_tempmean_monthly@climate_2000_2012\n  | Name: ...................... smooth_tempmean_monthly\n  | Mapset: .................... climate_2000_2012\n  | Creator: ................... lucadelu\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-27 11:41:36.444579\n  | Modification time:.......... 2014-11-27 11:41:39.978232\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2009-01-01 00:00:00\n  | End time:................... 2013-01-01 00:00:00\n  | Granularity:................ 1 month\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 320000.0\n  | South:...................... 10000.0\n  | East:.. .................... 935000.0\n  | West:....................... 120000.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_ea1c9a83524e41a784d72744b08c6107\n  | North-South resolution min:. 500.0\n  | North-South resolution max:. 500.0\n  | East-west resolution min:... 500.0\n  | East-west resolution max:... 500.0\n  | Minimum value min:.......... -6.428905\n  | Minimum value max:.......... 18.867296\n  | Maximum value min:.......... 4.247691\n  | Maximum value max:.......... 28.767953\n  | Aggregation type:........... None\n  | Number of registered maps:.. 48\n  |\n  | Title:\n  | Monthly precipitation\n  | Description:\n  | Dataset with monthly precipitation\n  | Command history:\n  | # 2014-11-27 11:41:36\n  | t.rast.neighbors input=\"tempmean_monthly\"\n  |     output=\"smooth_tempmean_monthly\" basename=\"tmean_smooth\" size=\"5\"\n  |     method=\"average\" nprocs=\"4\"\n  |\n  +----------------------------------------------------------------------------+\n # now compare the values between the original and the smoothed dataset\n t.rast.list input=smooth_tempmean_monthly columns=name,start_time,min,max\n name|start_time|min|max\n tmean_smooth_1|2009-01-01 00:00:00|-3.361714|7.409861\n tmean_smooth_2|2009-02-01 00:00:00|-1.820261|7.986794\n tmean_smooth_3|2009-03-01 00:00:00|2.912971|11.799684\n ...\n tmean_smooth_46|2012-10-01 00:00:00|9.38767|18.709297\n tmean_smooth_47|2012-11-01 00:00:00|1.785653|10.911189\n tmean_smooth_48|2012-12-01 00:00:00|1.784212|11.983857\n t.rast.list input=tempmean_monthly columns=name,start_time,min,max\n name|start_time|min|max\n 2009_01_tempmean|2009-01-01 00:00:00|-3.380823|7.426054\n 2009_02_tempmean|2009-02-01 00:00:00|-1.820261|8.006386\n 2009_03_tempmean|2009-03-01 00:00:00|2.656992|11.819274\n ...\n 2012_10_tempmean|2012-10-01 00:00:00|9.070884|18.709297\n 2012_11_tempmean|2012-11-01 00:00:00|1.785653|10.911189\n 2012_12_tempmean|2012-12-01 00:00:00|1.761019|11.983857\n ", "notes": "", "see_also": ["r.neighbors", "t.rast.aggregate.ds", "t.rast.extract", "t.info", "g.region", "r.mask"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.neighbors"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.mapcalc.html", "name": "t.rast.mapcalc", "definition": "- Performs spatio-temporal mapcalc expressions on temporally sampled maps of space time raster datasets.", "keywords": ["temporal", "algebra", "raster", "time"], "synopsis": "t.rast.mapcalc [-ns] inputs=name[,name,...] expression=string  [method=name[,name,...]]  output=name basename=basename  [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register Null maps Check the spatial topology of temporally related maps and process only spatially related maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Check the spatial topology of temporally related maps and process only spatially related maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "inputs", "flag": "inputs", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": false, "explanation": "Spatio-temporal mapcalc expression", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "The method to be used for sampling the input dataset", "defaultValue": "equal", "alternatives": ["start", "during", "overlap", "contain", "equal", "follows", "precedes"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename for output raster maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r.mapcalc processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.mapcalc  performs spatio-temporal\n  mapcalc  expressions on maps of temporally sampled space time\n raster datasets (STRDS). Spatial and temporal operators and internal\n variables are available in the expression string. The description of\n the spatial operators, functions and internal variables is available in\n the  r.mapcalc  manual page. The temporal\n functions are described in detail below.\n This module expects several parameters. All space time raster datasets\n that are referenced in the  mapcalc expression  must be listed\n in the  input  option. The  first  space time raster\n dataset that is listed as input will be used to temporally sample all\n other space time raster datasets. The temporal sampling method can be\n chosen using the  method  option. The order of the STRDS's in\n the mapcalc expression can be different to the order of the STRDS's in\n the input option. The resulting space time raster dataset must be\n specified in the  output  option together with the  basename \n of generated raster maps that are registered in the resulting\n STRDS. Empty maps resulting from map-calculation are not registered by\n default. This behavior can be changed with the  -n  flag. The\n flag  -s  can be used to assure that only spatially related maps\n in the STRDS's are processed. Spatially related means that temporally\n related maps overlap in their spatial extent.\n The module  t.rast.mapcalc  supports parallel processing. The option\n  nprocs  specifies the number of processes that can be started in\n parallel.\n A mapcalc expression must be provided to process the temporal\n sampled maps. Temporal internal variables are available in addition to\n the  r.mapcalc  spatial operators and functions:\n The supported internal variables for relative and absolute time are:\n    td()  - This internal variable represents the size of the\n   current sample time interval in days and fraction of days for absolute\n   time, and in relative units in case of relative time. \n    start_time()  - This internal variable represents\n   the time difference between the start time of the sample space time\n   raster dataset and the start time of the current sample interval or instance.\n   The time is measured in days and fraction of days for absolute time,\n   and in relative units in case of relative time. \n    end_time()  - This internal variable represents\n   the time difference between the start time of the sample space time\n   raster dataset and the end time of the current sample interval. The\n   time is measured in days and fraction of days for absolute time,\n   and in relative units in case of relative time.\n   The end_time() will be represented by null() in case of a time instance. \n The supported internal variables for the current sample interval or instance\n for absolute time are:\n    start_doy()  - Day of year (doy) from the start time [1 - 366] \n    start_dow()  - Day of week (dow) from the start time [1 - 7],\n   the start of the week is Monday == 1 \n    start_year()  - The year of the start time [0 - 9999] \n    start_month()  - The month of the start time [1 - 12] \n    start_week()  - Week of year of the start time [1 - 54] \n    start_day()  - Day of month from the start time [1 - 31] \n    start_hour()  - The hour of the start time [0 - 23] \n    start_minute()  - The minute of the start time [0 - 59] \n    start_second()  - The second of the start time [0 - 59] \n    end_doy()  - Day of year (doy) from the end time [1 - 366] \n    end_dow()  - Day of week (dow) from the end time [1 - 7],\n   the start of the week is Monday == 1 \n    end_year()  - The year of the end time [0 - 9999] \n    end_month()  - The month of the end time [1 - 12] \n    end_woy()  - Week of year (woy) of the end time [1 - 54] \n    end_day()  - Day of month from the start time [1 - 31] \n    end_hour()  - The hour of the end time [0 - 23] \n    end_minute()  - The minute of the end time [0 - 59] \n    end_second()  - The second of the end time [0 - 59]. \n The  end_*  functions are represented by the null() internal variable\n in case of time instances.\n ", "notes": "\n We will discuss the internal work of  t.rast.mapcalc  with an\n example. Imagine we have two STRDS as input, each one of monthly\n granularity. The first one  A  has 6 raster maps (a3 ... a8)\n with a temporal range from March to August. The second STRDS  B \n has 12 raster maps (b1 ... b12) ranging from January to December. The\n value of the raster maps is the number of the month from their interval\n start time. Dataset  A  will be used to sample dataset\n  B  to create a dataset  C . We want to add all maps with\n equal time stamps if the month of the start time is May or June,\n otherwise we multiply the maps. The command will look as follows:\n t.rast.mapcalc input=A,B output=C basename=c method=equal \n      expression=\"if(start_month() == 5 || start_month() == 6, (A + B), (A * B))\"\n The resulting raster maps in dataset C can be listed with  t.rast.list :\n name    start_time              min     max\n c_1     2001-03-01 00:00:00     9.0     9.0\n c_2     2001-04-01 00:00:00     16.0    16.0\n c_3     2001-05-01 00:00:00     10.0    10.0\n c_4     2001-06-01 00:00:00     12.0    12.0\n c_5     2001-07-01 00:00:00     49.0    49.0\n c_6     2001-08-01 00:00:00     64.0    64.0\n Internally the spatio-temporal expression will be analyzed for each\n time interval of the sample dataset A, the temporal functions will be\n replaced by numerical values, the names of the space time raster\n datasets will be replaced by the corresponding raster maps. The final\n expression will be passed to  r.mapcalc , resulting in 6 runs:\n r.mapcalc expression=\"c_1 = if(3 == 5 || 3 == 6, (a3 + b3), (a3 * b3))\"\n r.mapcalc expression=\"c_2 = if(4 == 5 || 4 == 6, (a4 + b4), (a4 * b4))\"\n r.mapcalc expression=\"c_3 = if(5 == 5 || 5 == 6, (a5 + b5), (a5 * b5))\"\n r.mapcalc expression=\"c_4 = if(6 == 5 || 6 == 6, (a6 + b6), (a6 * b6))\"\n r.mapcalc expression=\"c_5 = if(7 == 5 || 7 == 6, (a7 + b7), (a7 * b7))\"\n r.mapcalc expression=\"c_6 = if(8 == 5 || 8 == 6, (a8 + b8), (a8 * b8))\"\n  EXAMPLE \n The following command creates a new space time raster dataset \n  january_under_0  that will set to null all cells with\n temperature above zero in the January maps while keeping all the rest\n as in the original time series. This will change the maximum values\n of all January maps in the new STRDS as compared to the original one,\n  tempmean_monthly .\n t.rast.mapcalc input=tempmean_monthly output=january_under_0 basename=january_under_0 \n      expression=\"if(start_month() == 1 && tempmean_monthly > 0, null(), tempmean_monthly)\"\n # print minimum and maximum only for January in the new strds\n t.rast.list january_under_0 columns=name,start_time,min,max | grep 01-01\n name|start_time|min|max\n january_under_0_01|2009-01-01 00:00:00|-3.380823|-7e-06\n january_under_0_13|2010-01-01 00:00:00|-5.266929|-0.000154\n january_under_0_25|2011-01-01 00:00:00|-4.968747|-6.1e-05\n january_under_0_37|2012-01-01 00:00:00|-0.534994|-0.014581\n # print minimum and maximum only for January in the original strds,\n # note that the maximum is different\n t.rast.list tempmean_monthly columns=name,start_time,min,max | grep 01-01\n 2009_01_tempmean|2009-01-01 00:00:00|-3.380823|7.426054\n 2010_01_tempmean|2010-01-01 00:00:00|-5.266929|5.71131\n 2011_01_tempmean|2011-01-01 00:00:00|-4.968747|4.967295\n 2012_01_tempmean|2012-01-01 00:00:00|-0.534994|9.69511\n ", "see_also": ["r.mapcalc", "t.register", "t.rast.list", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.mapcalc"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.list.html", "name": "t.rast.list", "definition": "- Lists registered maps of a space time raster dataset.", "keywords": ["temporal", "map management", "raster", "list", "time"], "synopsis": "t.rast.list [-u] input=name  [order=string[,string,...]]   [columns=string[,string,...]]   [where=sql_query]   [method=string]   [granule=string]   [separator=character]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "u", "flag": "-u", "explanation": "Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Sort the space time dataset by category", "defaultValue": "start_time", "alternatives": ["id", "name", "creator", "mapset", "temporal_type", "creation_time", "start_time", "end_time", "north", "south", "west", "east", "nsres", "ewres", "cols", "rows", "number_of_cells", "min", "max"], "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Columns to be printed to stdout", "defaultValue": "name,mapset,start_time,end_time", "alternatives": ["id", "name", "creator", "mapset", "temporal_type", "creation_time", "start_time", "end_time", "north", "south", "west", "east", "nsres", "ewres", "cols", "rows", "number_of_cells", "min", "max"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Method used for data listing", "defaultValue": "cols", "alternatives": ["cols", "comma", "delta", "deltagaps", "gran"], "isInputFile": false, "isOutputFile": false}, {"parameter": "granule", "flag": "granule", "dataType": "String", "optional": true, "explanation": "The granule to be used for listing. The granule must be specified as string eg.: absolute time \"1 months\" or relative time \"1\"", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator character between the output columns", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n List time stamped raster map layers that are registered in a space time\n raster dataset.  t.rast.list  provides several options to list map layers\n and their metadata. Listing of map layer can be ordered by metadata,\n metadata columns can be specified and SQL where conditions can be\n provided to select a map layer subset of the input space time raster\n dataset. Most of the raster map  specific metadat is available for\n column selection, sorting and SQL where statements.\n Using the  method  option allows the specification of different\n methods to list map layers. Method  col  is the default option and\n sensitive to the  column , order  and  where  options.\n It will simply print user specified metadata columns of one map layer\n per line. The  comma  method will list the map layer as comma\n separated list that can be used as input for spatial modules.\n To print interval length in days and distance from the begin use method\n  delta . Method  deltagap  will additionally print temporal\n gaps between map layer. The  gran  method allows the listing of\n map layer sampled by a user defined  granule . As default the\n granularity of the space time raster dataset is used for sampling.\n The output column separator can be specified with the  separator \n option.\n  EXAMPLES \n This example shows several options that are available for map layers listing.\n  Default query \n The following command is the default one, returning standard information\n like name, mapset, start_time, end_time of each map in the space time dataset\n t.rast.list tempmean_monthly\n name|mapset|start_time|end_time\n 2009_01_tempmean|climate_2000_2012|2009-01-01 00:00:00|2009-02-01 00:00:00\n 2009_02_tempmean|climate_2000_2012|2009-02-01 00:00:00|2009-03-01 00:00:00\n ....\n 2012_11_tempmean|climate_2000_2012|2012-11-01 00:00:00|2012-12-01 00:00:00\n 2012_12_tempmean|climate_2000_2012|2012-12-01 00:00:00|2013-01-01 00:00:00\n  Add more info \n The following command let the user to choose the columns to show\n t.rast.list tempmean_monthly columns=name,start_time,min,max\n name|start_time|min|max\n 2009_01_tempmean|2009-01-01 00:00:00|-3.380823|7.426054\n 2009_02_tempmean|2009-02-01 00:00:00|-1.820261|8.006386\n ...\n 2009_01_tempmean|2009-01-01 00:00:00|-3.380823|7.426054\n 2009_02_tempmean|2009-02-01 00:00:00|-1.820261|8.006386\n  Filtering the result by value \n In this example the result is filtered showing only the maps with max\n value major than 24\n t.rast.list tempmean_monthly columns=name,start_time,min,max where=\"max > 24\"\n name|start_time|min|max\n 2009_06_tempmean|2009-06-01 00:00:00|15.962669|25.819681\n 2009_07_tempmean|2009-07-01 00:00:00|15.32852|26.103664\n 2009_08_tempmean|2009-08-01 00:00:00|16.37995|27.293282\n ....\n 2012_06_tempmean|2012-06-01 00:00:00|14.929379|24.000651\n 2012_07_tempmean|2012-07-01 00:00:00|18.455802|28.794653\n 2012_08_tempmean|2012-08-01 00:00:00|15.718526|26.151115\n  Filtering the result by time range \n In this example the result is filtered showing only the maps which\n fall into a specified time range (from .. to):\n t.rast.list tempmean_monthly columns=name,start_time,min,max \n    where=\"start_time > '2009-06-01 00:00:00' and start_time < '2012-08-01 00:00:00'\"\n name|start_time|min|max\n 2009_06_tempmean|2009-06-01 00:00:00|15.962669|25.819681\n 2009_07_tempmean|2009-07-01 00:00:00|15.32852|26.103664\n 2009_08_tempmean|2009-08-01 00:00:00|16.37995|27.293282\n ....\n 2012_06_tempmean|2012-06-01 00:00:00|14.929379|24.000651\n 2012_07_tempmean|2012-07-01 00:00:00|18.455802|28.794653\n 2012_08_tempmean|2012-08-01 00:00:00|15.718526|26.151115\n  Filtering the result by selecting recurring timestamps \n In this example the result is filtered showing only the maps which\n fall into a specified recurring time range (here one month per year):\n t.rast.list Tseasonal_fieldata_garda where=\"strftime('%m', start_time)='06'\"\n  Using method option \n Method option is able to show raster in different way. By default  cols \n value is used, the value  comma  will print only the list of maps\n inside the space time dataset:\n t.rast.list method=comma input=tempmean_monthly\n 2009_01_tempmean@climate_2009_2012,2009_02_tempmean@climate_2009_2012,2009_03_tempmean@climate_2009_2012, \n  2009_04_tempmean@climate_2009_2012,2009_05_tempmean@climate_2009_2012,2009_06_tempmean@climate_2009_2012, \n  2009_07_tempmean@climate_2009_2012,2009_08_tempmean@climate_2009_2012,2009_09_tempmean@climate_2009_2012, \n  2009_10_tempmean@climate_2009_2012,2009_11_tempmean@climate_2009_2012,2009_12_tempmean@climate_2009_2012, \n  2010_01_tempmean@climate_2009_2012,2010_02_tempmean@climate_2009_2012,2010_03_tempmean@climate_2009_2012, \n  2010_04_tempmean@climate_2009_2012,2010_05_tempmean@climate_2009_2012,2010_06_tempmean@climate_2009_2012, \n  2010_07_tempmean@climate_2009_2012,2010_08_tempmean@climate_2009_2012,2010_09_tempmean@climate_2009_2012, \n  2010_10_tempmean@climate_2009_2012,2010_11_tempmean@climate_2009_2012,2010_12_tempmean@climate_2009_2012, \n  2011_01_tempmean@climate_2009_2012,2011_02_tempmean@climate_2009_2012,2011_03_tempmean@climate_2009_2012, \n  2011_04_tempmean@climate_2009_2012,2011_05_tempmean@climate_2009_2012,2011_06_tempmean@climate_2009_2012, \n  2011_07_tempmean@climate_2009_2012,2011_08_tempmean@climate_2009_2012,2011_09_tempmean@climate_2009_2012, \n  2011_10_tempmean@climate_2009_2012,2011_11_tempmean@climate_2009_2012,2011_12_tempmean@climate_2009_2012, \n  2012_01_tempmean@climate_2009_2012,2012_02_tempmean@climate_2009_2012,2012_03_tempmean@climate_2009_2012, \n  2012_04_tempmean@climate_2009_2012,2012_05_tempmean@climate_2009_2012,2012_06_tempmean@climate_2009_2012, \n  2012_07_tempmean@climate_2009_2012,2012_08_tempmean@climate_2009_2012,2012_09_tempmean@climate_2009_2012, \n  2012_10_tempmean@climate_2009_2012,2012_11_tempmean@climate_2009_2012,2012_12_tempmean@climate_2009_2012\n The  delta  value calculate the interval between maps and the\n distance from the first map:\n t.rast.list method=delta input=tempmean_monthly\n id|name|mapset|start_time|end_time|interval_length|distance_from_begin\n 2009_01_tempmean@climate_2000_2012|2009_01_tempmean|climate_2000_2012|2009-01-01 00:00:00|2009-02-01 00:00:00|31.0|0.0\n 2009_02_tempmean@climate_2000_2012|2009_02_tempmean|climate_2000_2012|2009-02-01 00:00:00|2009-03-01 00:00:00|28.0|31.0\n 2009_03_tempmean@climate_2000_2012|2009_03_tempmean|climate_2000_2012|2009-03-01 00:00:00|2009-04-01 00:00:00|31.0|59.0\n ...\n 2012_10_tempmean@climate_2000_2012|2012_10_tempmean|climate_2000_2012|2012-10-01 00:00:00|2012-11-01 00:00:00|31.0|1369.0\n 2012_11_tempmean@climate_2000_2012|2012_11_tempmean|climate_2000_2012|2012-11-01 00:00:00|2012-12-01 00:00:00|30.0|1400.0\n 2012_12_tempmean@climate_2000_2012|2012_12_tempmean|climate_2000_2012|2012-12-01 00:00:00|2013-01-01 00:00:00|31.0|1430.0\n The  gran  value it is used to return data sampled by a user\n defined granule. As default the granularity of the space time raster\n dataset is used for sampling.\n t.rast.list  method=gran input=tempmean_monthly\n id|name|mapset|start_time|end_time|interval_length|distance_from_begin\n 2009_01_tempmean@climate_2009_2012|2009_01_tempmean|climate_2009_2012|2009-01-01 00:00:00|2009-02-01 00:00:00|31.0|0.0\n 2009_02_tempmean@climate_2009_2012|2009_02_tempmean|climate_2009_2012|2009-02-01 00:00:00|2009-03-01 00:00:00|28.0|31.0\n 2009_03_tempmean@climate_2009_2012|2009_03_tempmean|climate_2009_2012|2009-03-01 00:00:00|2009-04-01 00:00:00|31.0|59.0\n 2009_04_tempmean@climate_2009_2012|2009_04_tempmean|climate_2009_2012|2009-04-01 00:00:00|2009-05-01 00:00:00|30.0|90.0\n ....\n 2012_09_tempmean@climate_2009_2012|2012_09_tempmean|climate_2009_2012|2012-09-01 00:00:00|2012-10-01 00:00:00|30.0|1339.0\n 2012_10_tempmean@climate_2009_2012|2012_10_tempmean|climate_2009_2012|2012-10-01 00:00:00|2012-11-01 00:00:00|31.0|1369.0\n 2012_11_tempmean@climate_2009_2012|2012_11_tempmean|climate_2009_2012|2012-11-01 00:00:00|2012-12-01 00:00:00|30.0|1400.0\n 2012_12_tempmean@climate_2009_2012|2012_12_tempmean|climate_2009_2012|2012-12-01 00:00:00|2013-01-01 00:00:00|31.0|1430.0\n t.rast.list  method=gran input=tempmean_monthly gran=\"2 months\"\n id|name|mapset|start_time|end_time|interval_length|distance_from_begin\n 2009_01_tempmean@climate_2009_2012|2009_01_tempmean|climate_2009_2012|2009-01-01 00:00:00|2009-03-01 00:00:00|59.0|0.0\n 2009_03_tempmean@climate_2009_2012|2009_03_tempmean|climate_2009_2012|2009-03-01 00:00:00|2009-05-01 00:00:00|61.0|59.0\n 2009_05_tempmean@climate_2009_2012|2009_05_tempmean|climate_2009_2012|2009-05-01 00:00:00|2009-07-01 00:00:00|61.0|120.0\n ....\n 2012_07_tempmean@climate_2009_2012|2012_07_tempmean|climate_2009_2012|2012-07-01 00:00:00|2012-09-01 00:00:00|62.0|1277.0\n 2012_09_tempmean@climate_2009_2012|2012_09_tempmean|climate_2009_2012|2012-09-01 00:00:00|2012-11-01 00:00:00|61.0|1339.0\n 2012_11_tempmean@climate_2009_2012|2012_11_tempmean|climate_2009_2012|2012-11-01 00:00:00|2013-01-01 00:00:00|61.0|1400.0\n For the  deltagaps  value you can see the example for space time\n vector dataset  t.vect.list \n ", "notes": "", "see_also": ["g.list", "t.create", "t.info", "t.list", "t.rast3d.list", "t.vect.list"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.list"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.import.html", "name": "t.rast.import", "definition": "- Imports space time raster dataset.", "keywords": ["temporal", "import", "raster", "time", "create location"], "synopsis": "t.rast.import [-rleoc] input=name output=name  [basename=string]  directory=name  [title=string]   [description=string]   [location=string]   [memory=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Set the current region from the last map that was imported Link the raster files using r.external Extend location extents based on new dataset Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the space time raster datasets. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Link the raster files using r.external Extend location extents based on new dataset Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the space time raster datasets. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Extend location extents based on new dataset Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the space time raster datasets. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the space time raster datasets. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Create the location specified by the \"location\" parameter and exit. Do not import the space time raster datasets. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": true, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "directory", "flag": "directory", "dataType": "String", "optional": false, "explanation": "Path to the extraction directory", "defaultValue": "/tmp", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title of the new space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "description", "flag": "description", "dataType": "String", "optional": true, "explanation": "Description of the new space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Create a new location and import the data into it. Do not run this module in parallel or interrupt it when a new location should be created", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used (in MB)", "defaultValue": "300", "alternatives": ["0-2047"], "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.import  imports a space time raster dataset archive that\n was exported with  t.rast.export .\n ", "notes": "\n Optionally a base map name can be provided to avoid that existing\n raster maps are overwritten by the map names that are used in the STRDS\n archive.\n The  directory  is used as work directory in case of import but\n can also be used as a data directory when using GeoTIFF for the data\n exchange.\n  EXAMPLE \n The North Carolina space time dataset contains a data package called \n  lst_daily.tar.bzip2  with daily data from MODIS LST. Import it\n by running:\n t.rast.import input=lst_daily.tar.bzip2 output=lst_daily \n                basename=lst directory=/tmp\n ", "see_also": ["t.rast.export", "t.create", "t.info", "r.in.gdal", "r.unpack", "t.vect.import"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.import"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.gapfill.html", "name": "t.rast.gapfill", "definition": "- Replaces gaps in a space time raster dataset with interpolated raster maps.", "keywords": ["temporal", "interpolation", "raster", "time"], "synopsis": "t.rast.gapfill [-t] input=name  [where=sql_query]  basename=string  [suffix=string]   [nprocs=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Assign the space time raster dataset start and end time to the output map Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of interpolation processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.gapfill  fills temporal gaps in space time raster datasets\n using linear interpolation. Temporal all gaps will be detected in the input\n space time raster dataset automatically. The predecessor and successor maps\n of the gaps will be identified and used to linear interpolate the raster\n map between them.\n ", "notes": "\n This module uses  r.series.interp  to\n perform the interpolation for each gap independently. Hence several\n interpolation processes can be run in parallel.\n Each gap is re-sampled by the space time raster dataset granularity. \n Therefore several time stamped raster map layers will be interpolated \n if the gap is larger than the STRDS granularity.\n  Examples \n In this example we will create 3 raster maps and register them in the\n temporal database an then in the newly created space time raster dataset.\n There are gaps of one and two day size between the raster maps. The values of\n the maps are chosen so that the interpolated values can be estimated.\n We expect one map with a value of 2 for the first gap and\n two maps (values 3.666 and 4.333) for the second gap after interpolation.\n r.mapcalc expression=\"map1 = 1\" \n r.mapcalc expression=\"map2 = 3\" \n r.mapcalc expression=\"map3 = 5\" \n t.register type=raster maps=map1 start=2012-08-20 end=2012-08-21\n t.register type=raster maps=map2 start=2012-08-22 end=2012-08-23\n t.register type=raster maps=map3 start=2012-08-25 end=2012-08-26\n t.create type=strds temporaltype=absolute \n           output=precipitation_daily \n           title=\"Daily precipitation\" \n           description=\"Test dataset with daily precipitation\"\n          \n t.register type=raster input=precipitation_daily maps=map1,map2,map3\n t.rast.list input=precipitation_daily columns=name,start_time,min,max\n name|start_time|min|max\n map1|2012-08-20 00:00:00|1.0|1.0\n map2|2012-08-22 00:00:00|3.0|3.0\n map3|2012-08-25 00:00:00|5.0|5.0\n t.rast.list input=precipitation_daily method=deltagaps\n id|name|mapset|start_time|end_time|interval_length|distance_from_begin\n map1@PERMANENT|map1|PERMANENT|2012-08-20 00:00:00|2012-08-21 00:00:00|1.0|0.0\n None|None|None|2012-08-21 00:00:00|2012-08-22 00:00:00|1.0|1.0\n map2@PERMANENT|map2|PERMANENT|2012-08-22 00:00:00|2012-08-23 00:00:00|1.0|2.0\n None|None|None|2012-08-23 00:00:00|2012-08-24 00:00:00|1.0|3.0\n map3@PERMANENT|map3|PERMANENT|2012-08-24 00:00:00|2012-08-25 00:00:00|1.0|4.0\n t.rast.gapfill input=precipitation_daily basename=gap\n t.rast.list input=precipitation_daily columns=name,start_time,min,max\n name|start_time|min|max\n map1|2012-08-20 00:00:00|1.0|1.0\n gap_6_1|2012-08-21 00:00:00|2.0|2.0\n map2|2012-08-22 00:00:00|3.0|3.0\n gap_7_1|2012-08-23 00:00:00|3.666667|3.666667\n gap_7_2|2012-08-24 00:00:00|4.333333|4.333333\n map3|2012-08-25 00:00:00|5.0|5.0\n ", "see_also": ["r.series.interp", "t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.gapfill"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.extract.html", "name": "t.rast.extract", "definition": "- Extracts a subset of a space time raster datasets.", "keywords": ["temporal", "extract", "raster", "time"], "synopsis": "t.rast.extract [-n] input=name  [where=sql_query]   [expression=string]  output=name  [basename=string]   [suffix=string]   [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register Null maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": true, "explanation": "r.mapcalc expression assigned to all extracted raster maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": true, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r.mapcalc processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The purpose of  t.rast.extract  is to extract a subset of a space\n time raster dataset and to store that subset in a different space time\n raster dataset. The  where  condition is used to select the\n subset. In addition a  r.mapcalc  sub-expression can be\n specified that performs operations on all maps of the selected subset.\n In this expression the name of the input space time raster dataset can\n be used as simple map name. Other STRDS than the input STRDS can not be\n specified, but any raster map. In case a  r.mapcalc \n sub-expression is defined, the base name of the resulting raster maps\n must be specified. The  r.mapcalc  expression can be used to\n select maps as well, since by default resulting empty maps are not\n registered in the output space time raster dataset and removed after\n processing. The number of parallel GRASS GIS processes can be specified\n to speed up the processing.\n If no  r.mapcalc  expression is defined, the selected maps are\n simply registered in the new created output space time raster dataset\n to avoid data duplication.\n ", "notes": "\n The  r.mapcalc  sub-expression should not contain the left side\n  \"map =\"  of a full  r.mapcalc  expression, only the right\n side, eg.:\n t.rast.extract input=tempmean_monthly where=\"start_time > '2010-01-05'\" \n                 output=selected_tempmean_monthly basename=new_tmean_month \n                 expression=\"if(tempmean_monthly < 0, null(), tempmean_monthly)\"\n  EXAMPLE \n t.rast.extract input=tempmean_monthly output=tempmean_monthly_later_2012 \n                 where=\"start_time >= '2012-01-01'\"\n t.rast.list tempmean_monthly_later_2012\n name|mapset|start_time|end_time\n 2012_01_tempmean|climate_2000_2012|2012-01-01 00:00:00|2012-02-01 00:00:00\n 2012_02_tempmean|climate_2000_2012|2012-02-01 00:00:00|2012-03-01 00:00:00\n 2012_03_tempmean|climate_2000_2012|2012-03-01 00:00:00|2012-04-01 00:00:00\n 2012_04_tempmean|climate_2000_2012|2012-04-01 00:00:00|2012-05-01 00:00:00\n 2012_05_tempmean|climate_2000_2012|2012-05-01 00:00:00|2012-06-01 00:00:00\n 2012_06_tempmean|climate_2000_2012|2012-06-01 00:00:00|2012-07-01 00:00:00\n 2012_07_tempmean|climate_2000_2012|2012-07-01 00:00:00|2012-08-01 00:00:00\n 2012_08_tempmean|climate_2000_2012|2012-08-01 00:00:00|2012-09-01 00:00:00\n 2012_09_tempmean|climate_2000_2012|2012-09-01 00:00:00|2012-10-01 00:00:00\n 2012_10_tempmean|climate_2000_2012|2012-10-01 00:00:00|2012-11-01 00:00:00\n 2012_11_tempmean|climate_2000_2012|2012-11-01 00:00:00|2012-12-01 00:00:00\n 2012_12_tempmean|climate_2000_2012|2012-12-01 00:00:00|2013-01-01 00:00:00\n ", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.extract"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.export.html", "name": "t.rast.export", "definition": "- Exports space time raster dataset.", "keywords": ["temporal", "export", "raster", "time"], "synopsis": "t.rast.export input=name output=name  [directory=name]   [compression=string]   [format=string]   [type=string]   [createopt=string[,string,...]]   [metaopt=string[,string,...]]   [nodata=float]   [where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of a space time raster dataset archive", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "directory", "flag": "directory", "dataType": "String", "optional": true, "explanation": "Path to the work directory, default is /tmp", "defaultValue": "/tmp", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "compression", "flag": "compression", "dataType": "String", "optional": true, "explanation": "Compression method of the tar archive", "defaultValue": "bzip2", "alternatives": ["no", "gzip", "bzip2"], "isInputFile": false, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "The export format of a single raster map", "defaultValue": "GTiff", "alternatives": ["GTiff", "AAIGrid", "pack"], "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Data type", "defaultValue": null, "alternatives": ["Byte", "Int16", "UInt16", "Int32", "UInt32", "Float32", "Float64", "CInt16", "CInt32", "CFloat32", "CFloat64"], "isInputFile": false, "isOutputFile": false}, {"parameter": "createopt", "flag": "createopt", "dataType": "String", "optional": true, "explanation": "Creation option(s) to pass to the output format driver", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "metaopt", "flag": "metaopt", "dataType": "String", "optional": true, "explanation": "Metadata key(s) and value(s) to include", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nodata", "flag": "nodata", "dataType": "String", "optional": true, "explanation": "Assign a specified nodata value to output bands", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.export  exports a space time raster dataset (strds) as a tar\n archive. The archive contains the raster maps either as GeoTIFF files or as GRASS\n binary files exported using  r.pack . The map specific color tables\n are exported in case of GeoTIFF files. In addition several metadata files\n are created in the archive that describe the\n temporal layout. All time stamps are stored in the file \"list.txt\",\n for each map one row. The name of the map, the start time and the\n end time are written. In case of a time instance, the start time is\n equal to the end time. The \"init.txt\" file stores the temporal type,\n the number of maps, the chosen export format and some other\n metadata. The \"proj.txt\" file stores the projection information as a\n proj4 string of the location the space time raster dataset was\n exported from. The file \"readme.txt\" describes the file format. The\n output of  r.info  for each raster map in the space time dataset is\n stored in \"metadata.txt\".\n The tar archive can be compressed using the  compress  option. Gzip\n and bzip2 (default) are available. A  where  option can be specified,\n to export only a subset of the space time dataset. Archives exported\n with  t.rast.export  can be imported with\n  t.rast.import .\n ", "notes": "\n The name of output file has to carry the suffix of the archive type, the\n following suffix can be used:\n  .tar  in the case of  compress=no \n  .tar.bzip2  in the case of  compress=bzip2 \n  .tar.gzip  in the case of  compress=gzip \n  EXAMPLE \n In this example, all the raster maps of 2012 of \"tempmean_monthly\" will be exported:\n t.rast.export input=tempmean_monthly output=tempmean_monthly.tar.bzip2 \n                where=\"start_time >= '2012-01-01' and start_time < '2013-01-01'\"\n tar xvjf precipitation_daily.tar.bzip2\n 2012_01_tempmean.tif\n 2012_01_tempmean.color\n 2012_02_tempmean.tif\n 2012_02_tempmean.color\n 2012_03_tempmean.tif\n 2012_03_tempmean.color\n 2012_04_tempmean.tif\n 2012_04_tempmean.color\n 2012_05_tempmean.tif\n 2012_05_tempmean.color\n 2012_06_tempmean.tif\n 2012_06_tempmean.color\n 2012_07_tempmean.tif\n 2012_07_tempmean.color\n 2012_08_tempmean.tif\n 2012_08_tempmean.color\n 2012_09_tempmean.tif\n 2012_09_tempmean.color\n 2012_10_tempmean.tif\n 2012_10_tempmean.color\n 2012_11_tempmean.tif\n 2012_11_tempmean.color\n 2012_12_tempmean.tif\n 2012_12_tempmean.color\n list.txt\n proj.txt\n init.txt\n readme.txt\n metadata.txt\n cat init.txt\n stds_type=strds\n format=GTiff\n temporal_type=absolute\n semantic_type=mean\n number_of_maps=48\n north=320000.0\n south=10000.0\n east=935000.0\n west=120000.0\n cat proj.txt\n +proj=lcc\n +lat_1=36.16666666666666\n +lat_2=34.33333333333334\n +lat_0=33.75\n +lon_0=-79\n +x_0=609601.22\n +y_0=0\n +no_defs\n +a=6378137\n +rf=298.257222101\n +towgs84=0.000,0.000,0.000\n +to_meter=1\n cat list.txt\n 2012_01_tempmean|2012-01-01 00:00:00|2012-02-01 00:00:00\n 2012_02_tempmean|2012-02-01 00:00:00|2012-03-01 00:00:00\n 2012_03_tempmean|2012-03-01 00:00:00|2012-04-01 00:00:00\n 2012_04_tempmean|2012-04-01 00:00:00|2012-05-01 00:00:00\n 2012_05_tempmean|2012-05-01 00:00:00|2012-06-01 00:00:00\n 2012_06_tempmean|2012-06-01 00:00:00|2012-07-01 00:00:00\n 2012_07_tempmean|2012-07-01 00:00:00|2012-08-01 00:00:00\n 2012_08_tempmean|2012-08-01 00:00:00|2012-09-01 00:00:00\n 2012_09_tempmean|2012-09-01 00:00:00|2012-10-01 00:00:00\n 2012_10_tempmean|2012-10-01 00:00:00|2012-11-01 00:00:00\n 2012_11_tempmean|2012-11-01 00:00:00|2012-12-01 00:00:00\n 2012_12_tempmean|2012-12-01 00:00:00|2013-01-01 00:00:00\n cat readme.txt\n This space time raster dataset was exported with t.rast.export of GRASS GIS 7\n Files:\n        *.tif  -- GeoTIFF raster files\n      *.color  -- GRASS GIS raster color rules\n      proj.txt -- Projection information in PROJ.4 format\n      init.txt -- GRASS GIS space time raster dataset information\n      list.txt -- Time series file, lists all maps by name with interval\n                  time stamps in ISO-Format. Field separator is |\n  metadata.txt -- The output of t.info\n    readme.txt -- This file\n ", "see_also": ["t.rast.import", "t.create", "t.info", "r.out.gdal", "r.pack", "t.vect.export"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.export"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.contour.html", "name": "t.rast.contour", "definition": "- Produces a space time vector dataset of specified contours from a space time raster dataset.", "keywords": ["temporal", "contour", "raster", "vector", "time"], "synopsis": "t.rast.contour [-nt] input=name output=name  [where=sql_query]  basename=string  [suffix=string]   [step=float]   [levels=float[,float,...]]   [minlevel=float]   [maxlevel=float]   [cut=integer]   [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register empty vector maps Do not create attribute tables Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create attribute tables Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "step", "flag": "step", "dataType": "String", "optional": true, "explanation": "Increment between contour levels", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "levels", "flag": "levels", "dataType": "String", "optional": true, "explanation": "List of contour levels", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "minlevel", "flag": "minlevel", "dataType": "String", "optional": true, "explanation": "Minimum contour level", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maxlevel", "flag": "maxlevel", "dataType": "String", "optional": true, "explanation": "Maximum contour level", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cut", "flag": "cut", "dataType": "String", "optional": true, "explanation": "Minimum number of points for a contour line (0 -> no limit)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r.contour processes to run in parallel, more than 1 process works only in conjunction with flag -t", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.contour  is designed to produce a space time vector dataset of \n specified contours from a space time raster dataset. This module works as a front-end to\n  r.contour  and therefore supports all parameter\n of this module. Hence, all raster map layers in a space time raster dataset\n are successively passed to  r.contour  that computes \n the contour lines. \n Please refer to the  r.contour  documentation \n for a detailed description.\n The new generated vector contour map\n layers will be registered in the output space time vector dataset, using \n the same time stamps as their raster map layer origins.\n This module supports the parallel processing of  r.contour \n module instances. The number of parallel processes \n can be set with the  nprocs  option. \n However, this will only work in conjunction with the  -t \n flag, that avoids the creation of attribute tables. \n The parallel creation of attribute tables is not supported.\n The  where  option allows selecting subsets of the input space time raster\n dataset.\n The flag  -n  can be used to force the registration of empty \n vector map layers. Empty vector maps may occur in case that empty \n raster map layers should be converted into vector map layers, or in case the\n chosen steps or contour levels are not present in the raster map layers.\n ", "notes": "", "see_also": ["r.contour", "t.rast.db.select", "t.info"], "authors": ["S\u00f6ren Gebbert, Geoinformatikb\u00fcro Dassau"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.contour"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.colors.html", "name": "t.rast.colors", "definition": "- Creates/modifies the color table associated with each raster map of the space time raster dataset.", "keywords": ["temporal", "color table", "raster", "time"], "synopsis": "t.rast.colors [-rwlngae] input=name  [color=style]   [raster=name]   [raster_3d=name]   [rules=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Remove existing color table Only write new color table if it does not already exist List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Only write new color table if it does not already exist List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Invert colors Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Logarithmic scaling Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Logarithmic-absolute scaling Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Histogram equalization Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Name of color table (see r.color help)", "defaultValue": null, "alternatives": ["aspect", "aspectcolr", "bcyr", "bgyr", "blues", "byg", "byr", "celsius", "corine", "curvature", "differences", "elevation", "etopo2", "evi", "fahrenheit", "gdd", "grass", "greens", "grey", "grey.eq", "grey.log", "grey1.0", "grey255", "gyr", "haxby", "kelvin", "ndvi", "ndwi", "oranges", "population", "population_dens", "precipitation", "precipitation_daily", "precipitation_monthly", "rainbow", "ramp", "random", "reds", "roygbiv", "rstcurv", "ryb", "ryg", "sepia", "slope", "soilmoisture", "srtm", "srtm_plus", "terrain", "viridis", "water", "wave"], "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Raster map from which to copy color table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster_3d", "flag": "raster_3d", "dataType": "String", "optional": true, "explanation": "3D raster map from which to copy color table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Path to rules file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.colors  computes a color table based on all registered maps\n of a space time raster dataset and to assign this color table to each map.\n Hence the created color table reflects the data range of\n the space time raster dataset. This module is a simple\n wrapper around  r.colors .\n All options of  r.colors  are supported.\n Internally a file with map names is created and passed\n to the  file  option of  r.colors .\n Please have a look at the  r.colors \n manual page for further information.\n  EXAMPLE \n Set Celsius color table to monthly dataset\n t.rast.colors input=tempmean_monthly color=celsius\n r.colors.out map=2009_01_tempmean\n -80 0:0:40\n -40 91:10:168\n -30 220:220:220\n -25 91:50:128\n -20 50:0:150\n -15 4:25:130\n -10 8:54:106\n -8 4:20:150\n -5 0:50:255\n -2 8:10:118\n -0.061449 8:113:155\n 0.013855 8:118:157\n 0.090594 8:123:158\n 0.168767 8:128:159\n 0.248375 8:133:159\n 0.329417 8:136:160\n ...\n 40.6976 183:163:163\n 41.0483 185:167:167\n 41.4004 188:170:171\n 41.754 190:174:174\n 42.109 191:178:178\n 42.4655 193:182:182\n 42.8233 195:185:185\n 43.1827 197:189:189\n 43.5434 199:192:193\n 43.9056 200:197:197\n 44.2692 202:200:201\n 44.6342 204:204:204\n 45.0007 206:206:206\n 80 155:10:155\n nv 255:255:255\n default 255:255:255\n ", "notes": "", "see_also": ["r.colors"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.colors"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.algebra.html", "name": "t.rast.algebra", "definition": "- Apply temporal and spatial operations on space time raster datasets using temporal raster algebra.", "keywords": ["temporal", "algebra", "raster", "time"], "synopsis": "t.rast.algebra [-sngd] expression=string basename=string  [suffix=string]   [nprocs=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Check the spatial topology of temporally related maps and process only spatially related maps Register Null maps Use granularity sampling instead of the temporal topology approach Perform a dry run, compute all dependencies and module calls but don't run them Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Register Null maps Use granularity sampling instead of the temporal topology approach Perform a dry run, compute all dependencies and module calls but don't run them Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Use granularity sampling instead of the temporal topology approach Perform a dry run, compute all dependencies and module calls but don't run them Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Perform a dry run, compute all dependencies and module calls but don't run them Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": false, "explanation": "r.mapcalc expression for temporal and spatial analysis of space time raster datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "num", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r.mapcalc processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.algebra  performs temporal and spatial map algebra operations on\n space time raster datasets (STRDS) using the temporal raster algebra.\n  PROGRAM USE \n The module expects an  expression  as input parameter in the \n following form:\n  \"result = expression\" \n The statement structure is similar to that of  r.mapcalc .\n In this statement,  result  represents the name of the space time \n raster dataset (STRDS) that will contain the result of the calculation\n that is given as  expression  on the right side of the equality sign.\n These expressions can be any valid or nested combination of temporal\n operations and spatial overlay or buffer functions that are provided by\n the temporal algebra.\n The temporal raster algebra works only with space time raster datasets\n (STRDS). The algebra provides methods for map selection based on their\n temporal relations. It is also possible to temporally shift maps, to\n create temporal buffer and to snap time instances to create a valid\n temporal topology. Furthermore, expressions can be nested and evaluated\n in conditional statements (if, else statements). Within if-statements,\n the algebra provides temporal variables like start time, end time, day\n of year, time differences or number of maps per time interval to build\n up conditions.\n In addition the algebra provides a subset of the spatial operations\n from  r.mapcalc . All these operations can be\n assigned to STRDS or to the map lists resulting of operations between \n STRDS.\n By default, only temporal topological relations among space time datasets\n (STDS) are evaluated. The  -s  flag can be used to additionally\n activate the evaluation of the spatial topology based on the spatial\n extent of maps.\n The expression option must be passed as  quoted  expression, for\n example:\n t.rast.algebra expression=\"C = A + B\" basename=result\n Where  C  is the new space time raster dataset that will contain\n maps with the basename \"result\" and a numerical suffix separated by an\n underscore that represent the sum of maps from the STRDS\n  A  and temporally equal maps (i.e., maps with equal temporal\n topology relation) from the STRDS  B .\n The map  basename  for the result STRDS must always be specified.\n  TEMPORAL RASTER ALGEBRA \n The temporal algebra provides a wide range of temporal operators and\n functions that will be presented in the following section.\n  TEMPORAL RELATIONS \n Several temporal topology relations are supported between maps registered\n in space time datasets:\n equals            A ------\n                   B ------\n during            A  ----\n                   B ------\n contains          A ------\n                   B  ----\n starts            A ----\n                   B ------\n started           A ------\n                   B ----\n finishs           A   ----\n                   B ------\n finished          A ------\n                   B   ----\n precedes          A ----\n                   B     ----\n follows           A     ----\n                   B ----\n overlapped        A   ------\n                   B ------\n overlaps          A ------\n                   B   ------\n over              both overlaps and overlapped\n The relations must be read as: A is related to B, like - A equals B - A\n is during B - A contains B.\n Topological relations must be specified with curly brackets {}.\n  TEMPORAL OPERATORS \n The temporal algebra defines temporal operators that can be combined with\n other operators to perform spatio-temporal operations. \n The temporal operators process the time instances and intervals of two\n temporally related maps and calculate the resulting temporal extent in\n five possible different ways.\n LEFT REFERENCE     l       Use the time stamp of the left space time dataset\n INTERSECTION       i       Intersection\n DISJOINT UNION     d       Disjoint union\n UNION              u       Union\n RIGHT REFERENCE    r       Use the time stamp of the right space time dataset\n  TEMPORAL SELECTION \n The temporal selection simply selects parts of a space time dataset without\n processing any raster or vector data. The algebra provides a selection\n operator  :  that by default selects parts of a space time dataset\n that are temporally equal to parts of a second space time dataset. The\n following expression\n C = A : B\n means: select all parts of space time dataset A that are equal to B and\n store them in space time dataset C. These parts are time stamped maps.\n In addition, the inverse selection operator  !:  is defined as the\n complement of the selection operator, hence the following expression\n C = A !: B\n means: select all parts of space time time dataset A that are not equal\n to B and store them in space time dataset C.\n To select parts of a STRDS using different topological relations\n regarding to other STRDS, the temporal topology selection operator\n can be used. This operator consists of the temporal selection operator,\n the topological relations that must be separated by the logical OR\n operator  |  and, the temporal extent operator. All three parts \n are separated by comma and surrounded by curly brackets as follows:\n {\"temporal selection operator\", \"topological relations\", \"temporal operator\"}.\n  Examples: \n C = A {:,equals} B\n C = A {!:,equals} B\n We can now define arbitrary topological relations using the OR operator \"|\"\n to connect them:\n C = A {:,equals|during|overlaps} B\n Select all parts of A that are equal to B, during B or overlaps B. \n In addition, we can define the temporal extent of the resulting STRDS by\n adding the temporal operator.\n C = A {:,during,r} B\n Select all parts of A that are during B and use the temporal extents\n from B for C. \n The selection operator is implicitly contained in the temporal topology\n selection operator, so that the following statements are exactly the same:\n C = A : B\n C = A {:} B\n C = A {:,equal} B\n C = A {:,equal,l} B\n Same for the complementary selection:\n C = A !: B\n C = A {!:} B\n C = A {!:,equal} B\n C = A {!:,equal,l} B\n  CONDITIONAL STATEMENTS \n Selection operations can be evaluated within conditional statements as\n showed below. Note that A and B can be either space time datasets or \n expressions. The temporal relationship between the conditions and the\n conclusions can be defined at the beginning of the if statement (third\n and fourth examples below). The relationship between then and else \n conclusion must be always equal.\n if statement                        decision option                        temporal relations\n   if(if, then, else)\n   if(conditions, A)                   A if conditions are True;              temporal topological relation between if and then is equal.\n   if(conditions, A, B)                A if conditions are True, B otherwise; temporal topological relation between if, then and else is equal.\n   if(topologies, conditions, A)       A if conditions are True;              temporal topological relation between if and then is explicitly specified by topologies.\n   if(topologies, conditions, A, B)    A if conditions are True, B otherwise; temporal topological relation between if, then and else is explicitly specified by topologies.\n The conditions are comparison expressions that are used to evaluate\n space time datasets. Specific values of temporal variables are\n compared by logical operators and evaluated for each map of the STRDS.\n  Important:  The conditions are evaluated from left to right. \n  Logical operators \n Symbol  description\n   ==    equal\n   !=    not equal\n   >     greater than\n   >=    greater than or equal\n   <     less than\n   <=    less than or equal\n   &&    and\n   ||    or\n  Temporal functions \n The following temporal functions are evaluated only for the STDS that\n must be given in parenthesis.\n td(A)                    Returns a list of time intervals of STDS A\n start_time(A)            Start time as HH::MM:SS\n start_date(A)            Start date as yyyy-mm-DD\n start_datetime(A)        Start datetime as yyyy-mm-DD HH:MM:SS\n end_time(A)              End time as HH:MM:SS\n end_date(A)              End date as yyyy-mm-DD\n end_datetime(A)          End datetime as  yyyy-mm-DD HH:MM\n start_doy(A)             Day of year (doy) from the start time [1 - 366]\n start_dow(A)             Day of week (dow) from the start time [1 - 7], the start of the week is Monday == 1\n start_year(A)            The year of the start time [0 - 9999]\n start_month(A)           The month of the start time [1 - 12]\n start_week(A)            Week of year of the start time [1 - 54]\n start_day(A)             Day of month from the start time [1 - 31]\n start_hour(A)            The hour of the start time [0 - 23]\n start_minute(A)          The minute of the start time [0 - 59]\n start_second(A)          The second of the start time [0 - 59]\n end_doy(A)               Day of year (doy) from the end time [1 - 366]\n end_dow(A)               Day of week (dow) from the end time [1 - 7], the start of the week is Monday == 1\n end_year(A)              The year of the end time [0 - 9999]\n end_month(A)             The month of the end time [1 - 12]\n end_week(A)              Week of year of the end time [1 - 54]\n end_day(A)               Day of month from the start time [1 - 31]\n end_hour(A)              The hour of the end time [0 - 23]\n end_minute(A)            The minute of the end time [0 - 59]\n end_second(A)            The second of the end time [0 - 59]\n  Comparison operator \n As mentioned above, the conditions are comparison expressions that are\n used to evaluate space time datasets. Specific values of temporal \n variables are compared by logical operators and evaluated for each map\n of the STDS and (optionally) related maps.\n For complex relations, the comparison operator can be used to combine\n conditions. \n The structure is similar to the select operator with the addition of an\n aggregation operator: \n {\"comparison operator\", \"topological relations\", aggregation operator, \"temporal operator\"}\n This aggregation operator (| or &) defines the behaviour when a map is\n related to more than one map, e.g. for the topological relation 'contains'.\n Should all (&) conditions for the related maps be true or is it sufficient\n to have any (|) condition that is true. The resulting boolean value is\n then compared to the first condition by the comparison operator (|| or &&).\n By default, the aggregation operator is related to the comparison\n operator: \n comparison operator -> aggregation operator:\n || -> | and && -> & \n  Examples: \n Condition 1 {||, equal, r} Condition 2\n Condition 1 {&&, equal|during, l} Condition 2\n Condition 1 {&&, equal|contains, |, l} Condition 2\n Condition 1 {&&, equal|during, l} Condition 2 && Condition 3\n Condition 1 {&&, equal|during, l} Condition 2 {&&,contains, |, r} Condition 3\n  Hash operator \n Additionally, the number of maps in intervals can be computed and used in \n conditional statements with the hash (#) operator.\n A {#, contains} B\n This expression computes the number of maps from space time dataset B\n which are during the time intervals of maps from space time dataset A. \n A list of integers (scalars) corresponding to the maps of A that contain\n maps from B will be returned.\n C = if({equal}, A {#, contains} B > 2, A {:, contains} B)\n This expression selects all maps from A that temporally contain at least 2 \n maps from B and stores them in space time dataset C. The leading equal\n statement in the if condition specifies the temporal relation between\n the if and then part of the if expression. This is very important, so we\n do not need to specify a global time reference (a space time dataset)\n for temporal processing.\n Furthermore, the temporal algebra allows temporal buffering, shifting\n and snapping with the functions buff_t(), tshift() and tsnap(),\n respectively.\n buff_t(A, size)         Buffer STDS A with granule (\"1 month\" or 5)\n tshift(A, size)         Shift STDS A with granule (\"1 month\" or 5)\n tsnap(A)                Snap time instances and intervals of STDS A\n  Single map with temporal extent \n The temporal algebra can also handle single maps with time stamps in the\n tmap() function.\n tmap()\n For example:\n C = A {:, during} tmap(event)\n This statement selects all maps from space time data set A that are during \n the temporal extent of the single map 'event'\n  Spatial raster operators \n The module supports the following raster operations: \n Symbol  description     precedence\n   %     modulus         1\n   /     division        1\n   *     multiplication  1\n   +     addition        2\n   -     subtraction     2\n And raster functions:\n abs(x)                  return absolute value of x\n float(x)                convert x to foating point\n int(x)                  convert x to integer [ truncates ]\n log(x)                  natural log of x\n sqrt(x)                 square root of x\n tan(x)                  tangent of x (x is in degrees)\n round(x)                round x to nearest integer\n sin(x)                  sine of x (x is in degrees)\n isnull(x)               check if x = NULL\n isntnull(x)             check if x is not NULL\n null                    set null value\n exist(x)                Check if x is in the current mapset                 \n  Single raster map  \n The temporal raster algebra features also a function to integrate single\n raster maps without time stamps into the expressions.\n map()\n For example:\n C = A * map(constant_value)\n This statement multiplies all raster maps from space time raster data\n set A with the raster map 'constant_value'\n  Combinations of temporal, raster and select operators \n The user can combine the temporal topology relations, the temporal\n operators and the spatial/select operators to create spatio-temporal\n operators as follows:\n {\"spatial or select operator\", \"list of temporal relations\", \"temporal operator\"}\n For multiple topological relations or several related maps the spatio-temporal \n operators feature implicit aggregation.\n The algebra evaluates the stated STDS by their temporal topologies and apply \n the given spatio-temporal operators in a aggregated form.\n If we have two STDS A and B, B has three maps: b1, b2, b3 that are all during \n the temporal extent of the single map a1 of A, then the following arithmetic \n calculations would implicitly aggregate all maps of B into one result map for \n a1 of A:\n  C = A {+, contains} B --> c1 = a1 + b1 + b2 + b3\n  Important : the aggregation behaviour is not symmetric\n  C = B {+, during} A --> c1 = b1 + a1\n                          c2 = b2 + a1\n                          c3 = b3 + a1\n  Temporal neighbourhood modifier \n The neighbourhood modifier of  r.mapcalc  is extended for the temporal \n raster algebra with the temporal dimension. The format is strds[t,r,c], \n where t is the temporal offset, r is the row offset and c is the column \n offset.\n strds[2] \n refers to the second successor of the current map.\n strds[1,2]\n refers to the cell one row below and two columns to the right of the current\n cell in the current map.\n strds[1,-2,-1] \n refers to the cell two rows above and one column to the left of the current\n cell of the first successor map.\n strds[-2,0,1]\n refers to the cell one column to the right of the current cell in the\n second predecessor map.\n  EXAMPLES \n  Computation of NDVI \n # Sentinel-2 bands are stored separately in two STDRS \"S2_b4\" and \"S2_b8\"\n g.region raster=sentinel2_B04_10m -p\n t.rast.list S2_b4\n t.rast.list S2_b8\n t.rast.algebra basename=ndvi expression=\"ndvi = float(S2_b8 - S2_b4) / ( S2_b8 + S2_b4 )\" \n t.rast.colors input=ndvi color=ndvi\n  Sum of space-time raster datasets \n Sum maps from STRDS A with maps from STRDS B which have equal time stamps\n and are temporally before Jan. 1. 2005 and store them in STRDS D:\n D = if(start_date(A) < \"2005-01-01\", A + B)\n Create the sum of all maps from STRDS A and B that have equal time stamps\n and store the new maps in STRDS C:\n C = A + B\n  Sum of space-time raster datasets with temporal topology relation \n Same expression with explicit definition of the temporal topology relation\n and temporal operators:\n C = A {+,equal,l} B\n  Selection of raster cells \n Select all cells from STRDS B with equal temporal relations to STRDS A, if\n the cells of A are in the range [100.0, 1600] of time intervals that have\n more than 30 days (Jan, Mar, May, Jul, Aug, Oct, Dec):\n C = if(A > 100 && A < 1600 && td(A) > 30, B)\n  Selection of raster cells with temporal topology relation \n Same expression with explicit definition of the temporal topology relation\n and temporal operators:\n C = if({equal}, A > 100 && A < 1600 {&&,equal} td(A) > 30, B)\n  Conditional computation \n Compute the recharge in meters per second for all cells of precipitation\n STRDS \"Prec\" if the mean temperature specified in STRDS \"Temp\" is higher\n than 10 degrees. Computation is performed if STRDS \"Prec\" and \"Temp\" have\n equal time stamps. The number of days or fraction of days per interval is\n computed using the td() function that has as argument the STRDS \"Prec\":\n C = if(Temp > 10.0, Prec / 3600.0 / 24.0 / td(Prec))\n  Conditional computation with temporal topology relation \n Same expression with explicit definition of the temporal topology relation\n and temporal operators:\n C = if({equal}, Temp > 10.0, Prec / 3600.0 / 24.0 {/,equal,l} td(Prec))\n  Computation with time intervals \n Compute the mean value of all maps from STRDS A that are located during time\n intervals of STRDS B if more than one map of A is contained in an interval\n of B, use A otherwise. The resulting time intervals are either from B or A:\n C = if(B {#,contain} A > 1, (B {+,contain,l} A - B) / (B {#,contain} A), A)\n  Computation with time intervals with temporal topology relation \n Same expression with explicit definition of the temporal topology relation\n and temporal operators:\n C = if({equal}, B {#,contain} A > 1, (B {+,contain,l} A {-,equal,l} B) {equal,=/} (B {#,contain} A), A)\n  SEE ALSO \n  r.mapcalc ,\n  t.vect.algebra ,\n  t.rast3d.algebra ,\n  t.select ,\n  t.rast3d.mapcalc ,\n  t.rast.mapcalc \n  Temporal data processing Wiki \n  REFERENCES \n The use of this module requires the following software to be installed:\n  PLY(Python-Lex-Yacc) \n # Ubuntu/Debian\n sudo apt-get install python-ply\n # Fedora\n sudo dnf install python-ply\n ", "notes": "", "see_also": ["r.mapcalc", "t.vect.algebra", "t.rast3d.algebra", "t.select", "t.rast3d.mapcalc", "t.rast.mapcalc", "v.overlay", "v.buffer", "v.patch", "r.mapcalc", "v.overlay", "v.buffer", "v.patch", "r.mapcalc"], "authors": ["Thomas Leppelt, S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.algebra"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.aggregate.html", "name": "t.rast.aggregate", "definition": "- Aggregates temporally the maps of a space time raster dataset by a user defined granularity.", "keywords": ["temporal", "aggregation", "raster", "time"], "synopsis": "t.rast.aggregate [-n] input=name output=name basename=string  [suffix=string]  granularity=string method=string  [offset=integer]   [nprocs=integer]   [file_limit=integer]   [sampling=name[,name,...]]   [where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register Null maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "granularity", "flag": "granularity", "dataType": "String", "optional": false, "explanation": "Aggregation granularity, format absolute time \"x years, x months, x weeks, x days, x hours, x minutes, x seconds\" or an integer value for relative time", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Aggregate operation to be performed on the raster maps", "defaultValue": "average", "alternatives": ["average", "count", "median", "mode", "minimum", "min_raster", "maximum", "max_raster", "stddev", "range", "sum", "variance", "diversity", "slope", "offset", "detcoeff", "quart1", "quart3", "perc90", "quantile", "skewness", "kurtosis"], "isInputFile": false, "isOutputFile": false}, {"parameter": "offset", "flag": "offset", "dataType": "String", "optional": true, "explanation": "Offset that is used to create the output map ids, output map id is generated as: basename_ (count + offset)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r.series processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file_limit", "flag": "file_limit", "dataType": "String", "optional": true, "explanation": "The maximum number of open files allowed for each r.series process", "defaultValue": "1000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sampling", "flag": "sampling", "dataType": "String", "optional": true, "explanation": "The method to be used for sampling the input dataset", "defaultValue": "contains", "alternatives": ["equal", "overlaps", "overlapped", "starts", "started", "finishes", "finished", "during", "contains"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.aggregate  temporally aggregates space time raster\n datasets by a specific temporal granularity. This module support\n  absolute  and  relative time . The temporal granularity\n of absolute time can be  seconds, minutes, hours, days, weeks,\n months  or  years . Mixing of granularities eg. \"1 year, 3\n months 5 days\" is not supported. In case of relative time the temporal\n unit of the input space time raster dataset is used. The granularity\n must be specified with an integer value.\n This module is sensitive to the current region and mask settings,\n hence spatial extent and spatial resolution. In case the registered\n raster maps of the input space time raster dataset have different\n spatial resolutions, the default nearest neighbor resampling method\n is used for runtime spatial aggregation.\n ", "notes": "\n The raster module  r.series  is used internally. Hence all\n aggregate methods of  r.series  are supported. See the\n  r.series  manual page for details.\n This module will shift the start date for each aggregation process\n depending on the provided temporal granularity. The following shifts\n will performed:\n      granularity years : will start at the first of January,\n       hence 14-08-2012 00:01:30 will be shifted to 01-01-2012 00:00:00 \n      granularity months : will start at the first day of a month,\n       hence 14-08-2012 will be shifted to 01-08-2012 00:00:00 \n      granularity weeks : will start at the first day of a week (Monday),\n       hence 14-08-2012 01:30:30 will be shifted to 13-08-2012 01:00:00 \n      granularity days : will start at the first hour of a day,\n       hence 14-08-2012 00:01:30 will be shifted to 14-08-2012 00:00:00 \n      granularity hours : will start at the first minute of a hour,\n       hence 14-08-2012 01:30:30 will be shifted to 14-08-2012 01:00:00 \n      granularity minutes : will start at the first second of a minute,\n       hence 14-08-2012 01:30:30 will be shifted to 14-08-2012 01:30:00 \n The specification of the temporal relation between the aggregation\n intervals and the raster map layers is always formulated from the\n aggregation interval viewpoint. Hence, the relation  contains \n has to be specified to aggregate map layer that are temporally located\n in an aggregation interval.\n Parallel processing is supported in case that more than one interval is\n available for aggregation computation. Internally several\n  r.series  modules will be started, depending on the number of\n specified parallel processes ( nprocs ) and the number of\n intervals to aggregate.\n  EXAMPLES \n  Aggregation of monthly data into yearly data \n In this example the user is going to aggregate monthly data into yearly\n data, running:\n t.rast.aggregate input=tempmean_monthly output=tempmean_yearly \n                   basename=tempmean_year \n                   granularity=\"1 years\" method=average\n t.support input=tempmean_yearly \n            title=\"Yearly precipitation\" \n            description=\"Aggregated precipitation dataset with yearly resolution\"\n t.info tempmean_yearly\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ tempmean_yearly@climate_2000_2012\n  | Name: ...................... tempmean_yearly\n  | Mapset: .................... climate_2000_2012\n  | Creator: ................... lucadelu\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-27 10:25:21.243319\n  | Modification time:.......... 2014-11-27 10:25:21.862136\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2009-01-01 00:00:00\n  | End time:................... 2013-01-01 00:00:00\n  | Granularity:................ 1 year\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 320000.0\n  | South:...................... 10000.0\n  | East:.. .................... 935000.0\n  | West:....................... 120000.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_514082e62e864522a13c8123d1949dea\n  | North-South resolution min:. 500.0\n  | North-South resolution max:. 500.0\n  | East-west resolution min:... 500.0\n  | East-west resolution max:... 500.0\n  | Minimum value min:.......... 7.370747\n  | Minimum value max:.......... 8.81603\n  | Maximum value min:.......... 17.111387\n  | Maximum value max:.......... 17.915511\n  | Aggregation type:........... average\n  | Number of registered maps:.. 4\n  |\n  | Title: Yearly precipitation\n  | Monthly precipitation\n  | Description: Aggregated precipitation dataset with yearly resolution\n  | Dataset with monthly precipitation\n  | Command history:\n  | # 2014-11-27 10:25:21\n  | t.rast.aggregate input=\"tempmean_monthly\"\n  |     output=\"tempmean_yearly\" basename=\"tempmean_year\" granularity=\"1 years\"\n  |     method=\"average\"\n  |\n  | # 2014-11-27 10:26:21\n  | t.support input=tempmean_yearly \n   |        title=\"Yearly precipitation\" \n   |        description=\"Aggregated precipitation dataset with yearly resolution\"\n  +----------------------------------------------------------------------------+\n  Different aggregations and map name suffix variants \n Examples of resulting naming schemes for different aggregations when\n using the  suffix  option:\n  Weekly aggregation \n t.rast.aggregate input=daily_temp output=weekly_avg_temp \n    basename=weekly_avg_temp method=average granularity=\"1 weeks\"\n t.rast.list weekly_avg_temp\n name|mapset|start_time|end_time\n weekly_avg_temp_2003_01|climate|2003-01-03 00:00:00|2003-01-10 00:00:00\n weekly_avg_temp_2003_02|climate|2003-01-10 00:00:00|2003-01-17 00:00:00\n weekly_avg_temp_2003_03|climate|2003-01-17 00:00:00|2003-01-24 00:00:00\n weekly_avg_temp_2003_04|climate|2003-01-24 00:00:00|2003-01-31 00:00:00\n weekly_avg_temp_2003_05|climate|2003-01-31 00:00:00|2003-02-07 00:00:00\n weekly_avg_temp_2003_06|climate|2003-02-07 00:00:00|2003-02-14 00:00:00\n weekly_avg_temp_2003_07|climate|2003-02-14 00:00:00|2003-02-21 00:00:00\n Variant with  suffix  set to granularity:\n t.rast.aggregate input=daily_temp output=weekly_avg_temp \n    basename=weekly_avg_temp suffix=gran method=average \n    granularity=\"1 weeks\"\n t.rast.list weekly_avg_temp\n name|mapset|start_time|end_time\n weekly_avg_temp_2003_01_03|climate|2003-01-03 00:00:00|2003-01-10 00:00:00\n weekly_avg_temp_2003_01_10|climate|2003-01-10 00:00:00|2003-01-17 00:00:00\n weekly_avg_temp_2003_01_17|climate|2003-01-17 00:00:00|2003-01-24 00:00:00\n weekly_avg_temp_2003_01_24|climate|2003-01-24 00:00:00|2003-01-31 00:00:00\n weekly_avg_temp_2003_01_31|climate|2003-01-31 00:00:00|2003-02-07 00:00:00\n weekly_avg_temp_2003_02_07|climate|2003-02-07 00:00:00|2003-02-14 00:00:00\n weekly_avg_temp_2003_02_14|climate|2003-02-14 00:00:00|2003-02-21 00:00:00\n  Monthly aggregation \n t.rast.aggregate input=daily_temp output=monthly_avg_temp \n    basename=monthly_avg_temp suffix=gran method=average \n    granularity=\"1 months\"\n t.rast.list monthly_avg_temp\n name|mapset|start_time|end_time\n monthly_avg_temp_2003_01|climate|2003-01-01 00:00:00|2003-02-01 00:00:00\n monthly_avg_temp_2003_02|climate|2003-02-01 00:00:00|2003-03-01 00:00:00\n monthly_avg_temp_2003_03|climate|2003-03-01 00:00:00|2003-04-01 00:00:00\n monthly_avg_temp_2003_04|climate|2003-04-01 00:00:00|2003-05-01 00:00:00\n monthly_avg_temp_2003_05|climate|2003-05-01 00:00:00|2003-06-01 00:00:00\n monthly_avg_temp_2003_06|climate|2003-06-01 00:00:00|2003-07-01 00:00:00\n  Yearly aggregation \n t.rast.aggregate input=daily_temp output=yearly_avg_temp \n    basename=yearly_avg_temp suffix=gran method=average \n    granularity=\"1 years\"\n t.rast.list yearly_avg_temp\n name|mapset|start_time|end_time\n yearly_avg_temp_2003|climate|2003-01-01 00:00:00|2004-01-01 00:00:00\n yearly_avg_temp_2004|climate|2004-01-01 00:00:00|2005-01-01 00:00:00\n ", "see_also": ["t.rast.aggregate.ds", "t.rast.extract", "t.info", "r.series", "g.region", "r.mask"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.aggregate"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.aggregate.ds.html", "name": "t.rast.aggregate.ds", "definition": "- Aggregates data of an existing space time raster dataset using the time intervals of a second space time dataset.", "keywords": ["temporal", "aggregation", "raster", "time"], "synopsis": "t.rast.aggregate.ds [-n] input=name sample=name  [type=name]  output=name basename=string  [suffix=string]  method=string  [offset=integer]   [nprocs=integer]   [sampling=name[,name,...]]   [where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register Null maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "sample", "flag": "sample", "dataType": "String", "optional": false, "explanation": "Time intervals from this space time dataset (raster, vector or raster3d) are used for aggregation computation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the space time dataset from which aggregation will be copied", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Aggregate operation to be performed on the raster maps", "defaultValue": "average", "alternatives": ["average", "count", "median", "mode", "minimum", "min_raster", "maximum", "max_raster", "stddev", "range", "sum", "variance", "diversity", "slope", "offset", "detcoeff", "quart1", "quart3", "perc90", "quantile", "skewness", "kurtosis"], "isInputFile": false, "isOutputFile": false}, {"parameter": "offset", "flag": "offset", "dataType": "String", "optional": true, "explanation": "Offset that is used to create the output map ids, output map id is generated as: basename_ (count + offset)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of r.mapcalc processes to run in parallel", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sampling", "flag": "sampling", "dataType": "String", "optional": true, "explanation": "The method to be used for sampling the input dataset", "defaultValue": "contains", "alternatives": ["equal", "overlaps", "overlapped", "starts", "started", "finishes", "finished", "during", "contains"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.aggregate.ds  works like\n  t.rast.aggregate  but instead of \n defining a fixed granularity for temporal aggregation the time \n intervals of all maps registered in a second space time dataset (can be \n STRDS, STR3DS or STVDS) are used to aggregate the maps of the input \n space time raster dataset.\n ", "notes": "\n The sampling method must be specified from the sampler dataset point of view.\n It defines the temporal relationships between intervals of the sampling \n dataset and the input space time raster dataset.\n  EXAMPLES \n  Precipitation aggregation \n In this example we create 7 raster maps that will be registered in a \n single space time raster dataset named  precipitation_daily  \n using a daily temporal granularity. The names of the raster maps are \n stored in a text file that is used for raster map registration.\n A space time vector dataset is created out of two vector maps with \n different temporal resolution. The maps are created using v.random. The \n first map has a granule of 3 days the second a granule of 4 days.  \n The space time raster dataset  precipitation_daily  with daily \n temporal granularity will be aggregated using the space time vector \n dataset resulting in the output space time raster dataset \n  precipitation_agg . The aggregation method is set to \n  sum  to accumulate the precipitation values of all intervals in \n the space time vector dataset. The sampling option assures that only \n raster maps that are temporally during the time intervals of the space \n time vector dataset are considered for computation. Hence the option is set \n to contains (time stamped vector map layers temporally  contain \n the raster map layers): \n MAPS=\"map_1 map_2 map_3 map_4 map_5 map_6 map_7\"\n for map in ${MAPS} ; do\n     r.mapcalc expression=\"${map} = 1\" \n     echo ${map} >> map_list.txt \n done\n t.create type=strds temporaltype=absolute \n           output=precipitation_daily \n           title=\"Daily precipitation\" \n           description=\"Test dataset with daily precipitation\"\n t.register -i type=raster input=precipitation_daily \n             file=map_list.txt start=\"2012-08-20\" increment=\"1 days\"\n t.info type=strds input=precipitation_daily\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precipitation_daily@PERMANENT\n  | Name: ...................... precipitation_daily\n  | Mapset: .................... PERMANENT\n  | Creator: ................... soeren\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-23 16:48:17.686979\n  | Modification time:.......... 2014-11-23 16:48:18.302978\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-09-10 00:00:00\n  | End time:................... 2012-09-17 00:00:00\n  | Granularity:................ 1 day\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 80.0\n  | South:...................... 0.0\n  | East:.. .................... 120.0\n  | West:....................... 0.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_3225725979b14b5db343a00835b882c7\n  | North-South resolution min:. 10.0\n  | North-South resolution max:. 10.0\n  | East-west resolution min:... 10.0\n  | East-west resolution max:... 10.0\n  | Minimum value min:.......... 1.0\n  | Minimum value max:.......... 1.0\n  | Maximum value min:.......... 1.0\n  | Maximum value max:.......... 1.0\n  | Aggregation type:........... None\n  | Number of registered maps:.. 7\n  |\n  | Title:\n  | Daily precipitation\n  | Description:\n  | Test dataset with daily precipitation\n  | Command history:\n  | # 2014-11-23 16:48:17 \n  | t.create type=\"strds\" temporaltype=\"absolute\"\n  |     output=\"precipitation_daily\" title=\"Daily precipitation\"\n  |     description=\"Test dataset with daily precipitation\"\n  | # 2014-11-23 16:48:18 \n  | t.register -i type=\"rast\" input=\"precipitation_daily\"\n  |     file=\"map_list.txt\" start=\"2012-08-20\" increment=\"1 days\"\n  | \n  +----------------------------------------------------------------------------+\n v.random output=points_1 n=20\n v.random output=points_2 n=20\n t.create type=stvds temporaltype=absolute \n           output=points \n           title=\"Points\" \n           description=\"Points for aggregation\"\n t.register -i type=vector input=points \n             map=points_1 start=\"2012-08-20\" increment=\"3 days\"\n t.register -i type=vector input=points \n             map=points_2 start=\"2012-08-23\" increment=\"4 days\"\n t.info type=stvds input=points\n  +-------------------- Space Time Vector Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ points@PERMANENT\n  | Name: ...................... points\n  | Mapset: .................... PERMANENT\n  | Creator: ................... soeren\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-23 16:48:49.193903\n  | Modification time:.......... 2014-11-23 16:48:50.185671\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-08-20 00:00:00\n  | End time:................... 2012-08-27 00:00:00\n  | Granularity:................ 1 day\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 79.283411\n  | South:...................... 5.724954\n  | East:.. .................... 118.881168\n  | West:....................... 0.016755\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Vector register table:...... vector_map_register_6f02d33e0ee243d1a521aaaca39ecb31\n  | Number of points ........... 40\n  | Number of lines ............ 0\n  | Number of boundaries ....... 0\n  | Number of centroids ........ 0\n  | Number of faces ............ 0\n  | Number of kernels .......... 0\n  | Number of primitives ....... 40\n  | Number of nodes ............ 0\n  | Number of areas ............ 0\n  | Number of islands .......... 0\n  | Number of holes ............ 0\n  | Number of volumes .......... 0\n  | Number of registered maps:.. 2\n  |\n  | Title:\n  | Points\n  | Description:\n  | Points for aggregation\n  | Command history:\n  | # 2014-11-23 16:48:49 \n  | t.create type=\"stvds\" temporaltype=\"absolute\"\n  |     output=\"points\" title=\"Points\" description=\"Points for aggregation\"\n  | # 2014-11-23 16:48:49 \n  | t.register -i type=\"vect\" input=\"points\"\n  |     map=\"points_1\" start=\"2012-08-20\" increment=\"3 days\"\n  | # 2014-11-23 16:48:50 \n  | t.register -i type=\"vect\" input=\"points\"\n  |     map=\"points_2\" start=\"2012-08-23\" increment=\"4 days\"\n  | \n  +----------------------------------------------------------------------------+\n t.rast.aggregate.ds input=precipitation_daily \n                      output=precipitation_agg \n                      sample=points type=stvds \n                      basename=prec_agg \n                      method=sum sampling=contains\n t.support input=precipitation_agg \n            title=\"Aggregated precipitation\" \n            description=\"Aggregated precipitation dataset\"\n                  \n t.info type=strds input=precipitation_agg\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precipitation_agg@PERMANENT\n  | Name: ...................... precipitation_agg\n  | Mapset: .................... PERMANENT\n  | Creator: ................... soeren\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-23 16:53:23.488799\n  | Modification time:.......... 2014-11-23 16:53:28.714886\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-08-20 00:00:00\n  | End time:................... 2012-08-27 00:00:00\n  | Granularity:................ 1 day\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 80.0\n  | South:...................... 0.0\n  | East:.. .................... 120.0\n  | West:....................... 0.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_7b025eb7431747c98c5c1ad971e8c282\n  | North-South resolution min:. 10.0\n  | North-South resolution max:. 10.0\n  | East-west resolution min:... 10.0\n  | East-west resolution max:... 10.0\n  | Minimum value min:.......... 3.0\n  | Minimum value max:.......... 4.0\n  | Maximum value min:.......... 3.0\n  | Maximum value max:.......... 4.0\n  | Aggregation type:........... sum\n  | Number of registered maps:.. 2\n  |\n  | Title:\n  | Aggregated precipitation\n  | Description:\n  | Aggregated precipitation dataset\n  | Command history:\n  | # 2014-11-23 16:53:23 \n  | t.rast.aggregate.ds input=\"precipitation_daily\"\n  |     output=\"precipitation_agg\" sample=\"points\" type=\"stvds\" basename=\"prec_agg\"\n  |     method=\"sum\" sampling=\"contains\"\n  | # 2014-11-23 16:53:28 \n  | t.support input=\"precipitation_agg\"\n  |     title=\"Aggregated precipitation\"\n  |     description=\"Aggregated precipitation dataset\"\n  | \n  +----------------------------------------------------------------------------+\n  MODIS satellite sensor daily data aggregation to 8 days \n In this example the aggregation from daily data to eight days is shown.\n This \"eight-day week\" is used in some MODIS satellite sensor products.\n # NOTE: the example is written in shell language\n # create maps every 8 days as seed maps\n for year in `seq 2000 2001` ; do\n    for doy in `seq -w 1 8 365` ; do \n       r.mapcalc -s expression=\"8day_${year}_${doy} = rand(0.0,40.0)\"\n    done\n done\n # From de name of each map, we take year and doy, and convert it\n # to a YYYY-MM-DD date for start and end, and create a file with\n # mapnames, start date and end date\n g.list type=raster pattern=8day_20??_* > names_list\n for NAME in `cat names_list` ; do\n    \n    # Parse\n    YEAR=`echo $NAME | cut -d'_' -f2`\n    DOY=`echo $NAME | cut -d'_' -f3`\n    \n    # convert YYYY_DOY to YYYY-MM-DD\n    DOY=`echo \"$DOY\" | sed 's/^0*//'`\n    doy_end=0\n    if [ $DOY -le \"353\" ] ; then\n       doy_end=$(( $DOY + 8 ))\n    elif [ $DOY -eq \"361\" ] ; then \n       if [ $[$YEAR % 4] -eq 0 ] && [ $[$YEAR % 100] -ne 0 ] || [ $[$YEAR % 400] -eq 0 ] ; then\n          doy_end=$(( $DOY + 6 ))\n       else\n \t     doy_end=$(( $DOY + 5 ))\n       fi\n    fi\n    DATE_START=`date -d \"${YEAR}-01-01 +$(( ${DOY} - 1 ))days\" +%Y-%m-%d`\n    DATE_END=`date -d \"${YEAR}-01-01 +$(( ${doy_end} -1 ))days\" +%Y-%m-%d`\n    \n    # text file with mapnames, start date and end date\n    echo \"$NAME|$DATE_START|$DATE_END\" >> list_map_start_end_time.txt\n          \n done\n # check the list created. \n cat list_map_start_end_time.txt\n 8day_2000_001|2000-01-01|2000-01-09\n 8day_2000_009|2000-01-09|2000-01-17\n ...\n 8day_2000_353|2000-12-18|2000-12-26\n 8day_2000_361|2000-12-26|2001-01-01\n 8day_2001_001|2001-01-01|2001-01-09\n 8day_2001_009|2001-01-09|2001-01-17\n ...\n 8day_2001_345|2001-12-11|2001-12-19\n 8day_2001_353|2001-12-19|2001-12-27\n 8day_2001_361|2001-12-27|2002-01-01\n # all maps except for the last map in each year represent 8-days \n # intervals. But the aggregation starts all over again every \n # January 1st.\n # create 8-day MODIS-like strds\n t.create type=strds temporaltype=absolute \n     output=8day_ts title=\"8 day time series\" \n     description=\"STRDS with MODIS like 8 day aggregation\"\n # register maps\n t.register type=raster input=8day_ts \n     file=list_map_start_end_time.txt\n # check\n t.info input=8day_ts\n t.rast.list input=8day_ts\n # finally, copy the aggregation to a daily time series\n t.rast.aggregate.ds input=daily_ts sample=8day_ts \n     output=8day_agg basename=8day_agg method=average \n     sampling=contains suffix=gran\n # add metadata\n t.support input=8day_agg \n     title=\"8 day aggregated ts\" \n     description=\"8 day MODIS-like aggregated dataset\"\n # check map list in newly created aggregated strds\n t.rast.list input=8day_agg\n name|mapset|start_time|end_time\n 8day_agg_2000_01_01|modis|2000-01-01 00:00:00|2000-01-09 00:00:00\n 8day_agg_2000_01_09|modis|2000-01-09 00:00:00|2000-01-17 00:00:00\n 8day_agg_2000_01_17|modis|2000-01-17 00:00:00|2000-01-25 00:00:00\n ...\n 8day_agg_2000_12_18|modis|2000-12-18 00:00:00|2000-12-26 00:00:00\n 8day_agg_2000_12_26|modis|2000-12-26 00:00:00|2001-01-01 00:00:00\n 8day_agg_2001_01_01|modis|2001-01-01 00:00:00|2001-01-09 00:00:00\n ...\n 8day_agg_2001_12_11|modis|2001-12-11 00:00:00|2001-12-19 00:00:00\n 8day_agg_2001_12_19|modis|2001-12-19 00:00:00|2001-12-27 00:00:00\n 8day_agg_2001_12_27|modis|2001-12-27 00:00:00|2002-01-01 00:00:00\n ", "see_also": ["t.rast.aggregate", "t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.aggregate.ds"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.accumulate.html", "name": "t.rast.accumulate", "definition": "- Computes cyclic accumulations of a space time raster dataset.", "keywords": ["temporal", "accumulation", "raster", "time"], "synopsis": "t.rast.accumulate [-nr] input=name output=name  [lower=name]   [upper=name]  start=string  [stop=string]  cycle=string  [offset=string]   [granularity=string]  basename=string  [suffix=string]  limits=lower,upper  [scale=float]   [shift=float]   [method=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register empty maps in the output space time raster dataset, otherwise they will be deleted Reverse time direction in cyclic accumulation Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Reverse time direction in cyclic accumulation Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "lower", "flag": "lower", "dataType": "String", "optional": true, "explanation": "Input space time raster dataset that defines the lower threshold, values lower than this threshold are excluded from accumulation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "upper", "flag": "upper", "dataType": "String", "optional": true, "explanation": "Input space time raster dataset that defines the upper threshold, values higher than this threshold are excluded from accumulation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start", "flag": "start", "dataType": "String", "optional": false, "explanation": "The temporal starting point to begin the accumulation, eg '2001-01-01'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stop", "flag": "stop", "dataType": "String", "optional": true, "explanation": "The temporal date to stop the accumulation, eg '2009-01-01'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cycle", "flag": "cycle", "dataType": "String", "optional": false, "explanation": "The temporal cycle to restart the accumulation, eg '12 months'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "offset", "flag": "offset", "dataType": "String", "optional": true, "explanation": "The temporal offset to the beginning of the next cycle, eg '6 months'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "granularity", "flag": "granularity", "dataType": "String", "optional": true, "explanation": "The granularity for accumulation '1 day'", "defaultValue": "1 day", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add to the basename. Set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "limits", "flag": "limits", "dataType": "String", "optional": false, "explanation": "Use these limits in case lower and/or upper input space time raster datasets are not defined or contain NULL values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Scale factor for input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "shift", "flag": "shift", "dataType": "String", "optional": true, "explanation": "Shift factor for input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "This method will be applied to compute the accumulative values from the input maps in a single granule", "defaultValue": "mean", "alternatives": ["mean", "gdd", "bedd", "huglin"], "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.accumulate  is designed to perform temporal accumulations \n of space time raster datasets.\n This module expects a space time raster dataset as input that will be \n sampled by a given  granularity . All maps that have the start \n time during the actual granule will be accumulated with the predecessor \n granule accumulation result using the raster module\n  r.series.accumulate . The default \n granularity is 1 day, but any temporal granularity can be set.\n The  start  time and the  end  time of the accumulation \n process must be set, eg.  start=\"2000-03-01\" end=\"2011-01-01\" . In \n addition, a  cycle , eg.  cycle=\"8 months\" , can be specified, \n that defines after which interval of time the accumulation process \n restarts. The  offset  option specifies the time that should be \n skipped between two cycles, eg.  offset=\"4 months\" .\n The  lower  and  upper   limits  of the accumulation \n process can be set, either by using space time raster datasets or by \n using fixed values for all raster cells and time steps. The raster \n maps that specify the lower and upper limits of the actual granule \n will be detected using the following temporal relations: equals, \n during, overlaps, overlapped and contains. First, all maps with time \n stamps equal to the current granule will be detected, the first lower \n map and the first upper map found will be used as limit definitions. \n If no equal maps are found, then maps with a temporal during relation \n are detected, then maps that temporally overlap the actual granules, \n until maps that have a temporal contain relation are detected. If no \n maps are found or lower/upper STRDS are not defined, then the \n  limits  option is used, eg.  limits=10,30 .\n The  upper   limit  is only used in the Biologically \n Effective Degree Days calculation.\n The options  shift ,  scale  and  method  are passed to \n  r.series.accumulate . \n Please refer to the manual page of\n  r.series.accumulate  for detailed\n option description.\n The  output  is a new space time raster dataset with the provided \n start time, end time and granularity containing the accumulated raster \n maps. The  base  name of the generated maps must always be set. \n The  output  space time raster dataset can then be analyzed using \n  t.rast.accdetect  to detect specific \n accumulation patterns.\n  EXAMPLE \n This is an example how to accumulate the daily mean temperature of \n Europe from 1990 to 2000 using the growing-degree-day method to detect \n grass hopper reproduction cycles that are critical to agriculture. \n # Get the temperature data\n wget http://www-pool.math.tu-berlin.de/~soeren/grass/temperature_mean_1990_2000_daily_celsius.tar.gz\n # Create a temporary location directory\n mkdir -p /tmp/grassdata/LL\n # Start GRASS and create a new location with PERMANENT mapset\n grass75 -c EPSG:4326 /tmp/grassdata/LL/PERMANENT\n # Import the temperature data\n t.rast.import input=temperature_mean_1990_2000_daily_celsius.tar.gz \n        output=temperature_mean_1990_2000_daily_celsius directory=/tmp\n # We need to set the region correctly\n g.region -p raster=`t.rast.list input=temperature_mean_1990_2000_daily_celsius column=name | tail -1`\n # We can zoom to the raster map\n g.region -p zoom=`t.rast.list input=temperature_mean_1990_2000_daily_celsius column=name | tail -1`\n #############################################################################\n #### ACCUMULATION USING GDD METHOD ##########################################\n #############################################################################\n # The computation of grashopper pest control cycles is based on:\n #\n #   Using Growing Degree Days For Insect Management\n #   Nancy E. Adams\n #   Extension Educator, Agricultural Resources\n #\n # available here: http://extension.unh.edu/agric/gddays/docs/growch.pdf\n # Now we compute the Biologically Effective Degree Days \n # from 1990 - 2000 for each year (12 month cycle) with\n # a granularity of one day. Base temperature is 10\u00b0C, upper limit is 30\u00b0C.\n # Hence the accumulation starts at 10\u00b0C and does not accumulate values above 30\u00b0C. \n t.rast.accumulate input=\"temperature_mean_1990_2000_daily_celsius\" \n        output=\"temperature_mean_1990_2000_daily_celsius_accumulated_10_30\" \n        limits=\"10,30\" start=\"1990-01-01\" stop=\"2000-01-01\" cycle=\"12 months\" \n        basename=\"temp_acc_daily_10_30\" method=\"bedd\"\n #############################################################################\n #### ACCUMULATION PATTERN DETECTION #########################################\n #############################################################################\n # Now we detect the three grasshopper pest control cycles\n # First cycle at 325\u00b0C - 427\u00b0C GDD\n t.rast.accdetect input=temperature_mean_1990_2000_daily_celsius_accumulated_10_30@PERMANENT \n        occ=leafhopper_occurrence_c1_1990_2000 start=\"1990-01-01\" stop=\"2000-01-01\" \n        cycle=\"12 months\" range=325,427 basename=lh_c1 indicator=leafhopper_indicator_c1_1990_2000\n # Second cycle at 685\u00b0C - 813\u00b0C GDD\n t.rast.accdetect input=temperature_mean_1990_2000_daily_celsius_accumulated_10_30@PERMANENT \n        occ=leafhopper_occurrence_c2_1990_2000 start=\"1990-01-01\" stop=\"2000-01-01\" \n        cycle=\"12 months\" range=685,813 basename=lh_c2 indicator=leafhopper_indicator_c2_1990_2000\n # Third cycle at 1047\u00b0C - 1179\u00b0C GDD\n t.rast.accdetect input=temperature_mean_1990_2000_daily_celsius_accumulated_10_30@PERMANENT \n        occ=leafhopper_occurrence_c3_1990_2000 start=\"1990-01-01\" stop=\"2000-01-01\" \n        cycle=\"12 months\" range=1047,1179 basename=lh_c3 indicator=leafhopper_indicator_c3_1990_2000\n #############################################################################\n #### YEARLY SPATIAL OCCURRENCE COMPUTATION OF ALL CYCLES ####################\n #############################################################################\n # Extract the areas that have full cycles\n t.rast.aggregate input=leafhopper_indicator_c1_1990_2000 gran=\"1 year\" \n        output=leafhopper_cycle_1_1990_2000_yearly method=maximum basename=li_c1\n t.rast.mapcalc input=leafhopper_cycle_1_1990_2000_yearly basename=lh_clean_c1 \n                 output=leafhopper_cycle_1_1990_2000_yearly_clean \n                 expression=\"if(leafhopper_cycle_1_1990_2000_yearly == 3, 1, null())\"\n t.rast.aggregate input=leafhopper_indicator_c2_1990_2000 gran=\"1 year\" \n        output=leafhopper_cycle_2_1990_2000_yearly method=maximum basename=li_c2\n t.rast.mapcalc input=leafhopper_cycle_2_1990_2000_yearly basename=lh_clean_c2 \n                 output=leafhopper_cycle_2_1990_2000_yearly_clean \n                 expression=\"if(leafhopper_cycle_2_1990_2000_yearly == 3, 2, null())\"\n t.rast.aggregate input=leafhopper_indicator_c3_1990_2000 gran=\"1 year\" \n        output=leafhopper_cycle_3_1990_2000_yearly method=maximum basename=li_c3\n t.rast.mapcalc input=leafhopper_cycle_3_1990_2000_yearly basename=lh_clean_c3 \n                 output=leafhopper_cycle_3_1990_2000_yearly_clean \n                 expression=\"if(leafhopper_cycle_3_1990_2000_yearly == 3, 3, null())\"\n t.rast.mapcalc input=leafhopper_cycle_1_1990_2000_yearly_clean,leafhopper_cycle_2_1990_2000_yearly_clean,leafhopper_cycle_3_1990_2000_yearly_clean \n                 basename=lh_cleann_all_cycles \n                 output=leafhopper_all_cycles_1990_2000_yearly_clean \n                 expression=\"if(isnull(leafhopper_cycle_3_1990_2000_yearly_clean), \n  \t         if(isnull(leafhopper_cycle_2_1990_2000_yearly_clean), \n  \t\t if(isnull(leafhopper_cycle_1_1990_2000_yearly_clean), \n  \t\t null() ,1),2),3)\"\n cat > color.table << EOF\n 3 yellow\n 2 blue\n 1 red\n EOF\n t.rast.colors input=leafhopper_cycle_1_1990_2000_yearly_clean rules=color.table\n t.rast.colors input=leafhopper_cycle_2_1990_2000_yearly_clean rules=color.table\n t.rast.colors input=leafhopper_cycle_3_1990_2000_yearly_clean rules=color.table\n t.rast.colors input=leafhopper_all_cycles_1990_2000_yearly_clean rules=color.table\n #############################################################################\n ################ DURATION COMPUTATION #######################################\n #############################################################################\n # Extract the duration in days of the first cycle\n t.rast.aggregate input=leafhopper_occurrence_c1_1990_2000 gran=\"1 year\" \n        output=leafhopper_min_day_c1_1990_2000 method=minimum basename=occ_min_day_c1\n t.rast.aggregate input=leafhopper_occurrence_c1_1990_2000 gran=\"1 year\" \n        output=leafhopper_max_day_c1_1990_2000 method=maximum basename=occ_max_day_c1\n t.rast.mapcalc input=leafhopper_min_day_c1_1990_2000,leafhopper_max_day_c1_1990_2000 \n                 basename=occ_duration_c1 \n                 output=leafhopper_duration_c1_1990_2000 \n                 expression=\"leafhopper_max_day_c1_1990_2000 - leafhopper_min_day_c1_1990_2000\"\n # Extract the duration in days of the second cycle\n t.rast.aggregate input=leafhopper_occurrence_c2_1990_2000 gran=\"1 year\" \n        output=leafhopper_min_day_c2_1990_2000 method=minimum basename=occ_min_day_c2\n t.rast.aggregate input=leafhopper_occurrence_c2_1990_2000 gran=\"1 year\" \n        output=leafhopper_max_day_c2_1990_2000 method=maximum basename=occ_max_day_c2\n t.rast.mapcalc input=leafhopper_min_day_c2_1990_2000,leafhopper_max_day_c2_1990_2000 \n                 basename=occ_duration_c2 \n                 output=leafhopper_duration_c2_1990_2000 \n                 expression=\"leafhopper_max_day_c2_1990_2000 - leafhopper_min_day_c2_1990_2000\"\n # Extract the duration in days of the third cycle\n t.rast.aggregate input=leafhopper_occurrence_c3_1990_2000 gran=\"1 year\" \n        output=leafhopper_min_day_c3_1990_2000 method=minimum basename=occ_min_day_c3\n t.rast.aggregate input=leafhopper_occurrence_c3_1990_2000 gran=\"1 year\" \n        output=leafhopper_max_day_c3_1990_2000 method=maximum basename=occ_max_day_c3\n t.rast.mapcalc input=leafhopper_min_day_c3_1990_2000,leafhopper_max_day_c3_1990_2000 \n                 basename=occ_duration_c3 \n                 output=leafhopper_duration_c3_1990_2000 \n                 expression=\"leafhopper_max_day_c3_1990_2000 - leafhopper_min_day_c3_1990_2000\"\n t.rast.colors input=leafhopper_duration_c1_1990_2000 color=rainbow\n t.rast.colors input=leafhopper_duration_c2_1990_2000 color=rainbow\n t.rast.colors input=leafhopper_duration_c3_1990_2000 color=rainbow\n #############################################################################\n ################ MONTHLY CYCLES OCCURRENCE ##################################\n #############################################################################\n # Extract the monthly indicator that shows the start and end of a cycle\n # First cycle\n t.rast.aggregate input=leafhopper_indicator_c1_1990_2000 gran=\"1 month\" \n        output=leafhopper_indi_min_month_c1_1990_2000 method=minimum basename=occ_indi_min_month_c1\n t.rast.aggregate input=leafhopper_indicator_c1_1990_2000 gran=\"1 month\" \n        output=leafhopper_indi_max_month_c1_1990_2000 method=maximum basename=occ_indi_max_month_c1\n t.rast.mapcalc input=leafhopper_indi_min_month_c1_1990_2000,leafhopper_indi_max_month_c1_1990_2000 \n                 basename=indicator_monthly_c1 \n                 output=leafhopper_monthly_indicator_c1_1990_2000 \n                 expression=\"if(leafhopper_indi_min_month_c1_1990_2000 == 1, 1, if(leafhopper_indi_max_month_c1_1990_2000 == 3, 3, 2))\"\n # Second cycle\n t.rast.aggregate input=leafhopper_indicator_c2_1990_2000 gran=\"1 month\" \n        output=leafhopper_indi_min_month_c2_1990_2000 method=minimum basename=occ_indi_min_month_c2\n t.rast.aggregate input=leafhopper_indicator_c2_1990_2000 gran=\"1 month\" \n        output=leafhopper_indi_max_month_c2_1990_2000 method=maximum basename=occ_indi_max_month_c2\n t.rast.mapcalc input=leafhopper_indi_min_month_c2_1990_2000,leafhopper_indi_max_month_c2_1990_2000 \n                 basename=indicator_monthly_c2 \n                 output=leafhopper_monthly_indicator_c2_1990_2000 \n                 expression=\"if(leafhopper_indi_min_month_c2_1990_2000 == 1, 1, if(leafhopper_indi_max_month_c2_1990_2000 == 3, 3, 2))\"\n # Third cycle\n t.rast.aggregate input=leafhopper_indicator_c3_1990_2000 gran=\"1 month\" \n        output=leafhopper_indi_min_month_c3_1990_2000 method=minimum basename=occ_indi_min_month_c3\n t.rast.aggregate input=leafhopper_indicator_c3_1990_2000 gran=\"1 month\" \n        output=leafhopper_indi_max_month_c3_1990_2000 method=maximum basename=occ_indi_max_month_c3\n t.rast.mapcalc input=leafhopper_indi_min_month_c3_1990_2000,leafhopper_indi_max_month_c3_1990_2000 \n                 basename=indicator_monthly_c3 \n                 output=leafhopper_monthly_indicator_c3_1990_2000 \n                 expression=\"if(leafhopper_indi_min_month_c3_1990_2000 == 1, 1, if(leafhopper_indi_max_month_c3_1990_2000 == 3, 3, 2))\"\n cat > color.table << EOF\n 3 red\n 2 yellow\n 1 green\n EOF\n t.rast.colors input=leafhopper_monthly_indicator_c1_1990_2000 rules=color.table\n t.rast.colors input=leafhopper_monthly_indicator_c2_1990_2000 rules=color.table\n t.rast.colors input=leafhopper_monthly_indicator_c3_1990_2000 rules=color.table\n #############################################################################\n ################ VISUALIZATION ##############################################\n #############################################################################\n # Now we use g.gui.animation to visualize the yearly occurrence, the duration and the monthly occurrence\n # Yearly occurrence of all reproduction cycles \n g.gui.animation strds=leafhopper_all_cycles_1990_2000_yearly_clean\n # Yearly duration of reproduction cycle 1\n g.gui.animation strds=leafhopper_duration_c1_1990_2000\n # Yearly duration of reproduction cycle 2\n g.gui.animation strds=leafhopper_duration_c2_1990_2000\n # Yearly duration of reproduction cycle 3\n g.gui.animation strds=leafhopper_duration_c3_1990_2000\n # Monthly occurrence of reproduction cycle 1\n g.gui.animation strds=leafhopper_monthly_indicator_c1_1990_2000\n # Monthly occurrence of reproduction cycle 2\n g.gui.animation strds=leafhopper_monthly_indicator_c2_1990_2000\n # Monthly occurrence of reproduction cycle 3\n g.gui.animation strds=leafhopper_monthly_indicator_c3_1990_2000\n ", "notes": "", "see_also": ["t.rast.accdetect", "t.rast.aggregate", "t.rast.mapcalc", "t.info", "g.region", "r.series.accumulate"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.accumulate"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.rast.accdetect.html", "name": "t.rast.accdetect", "definition": "- Detects accumulation patterns in temporally accumulated space time raster datasets created by t.rast.accumulate.", "keywords": ["temporal", "accumulation", "raster", "time"], "synopsis": "t.rast.accdetect [-nr] input=name  [minimum=name]   [maximum=name]  occurrence=name  [indicator=name]  start=string  [stop=string]  cycle=string  [offset=string]  basename=string  [suffix=string]   [range=min,max]   [staend=start,intermediate,end]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register empty maps in the output space time raster dataset, otherwise they will be deleted Reverse time direction in cyclic accumulation Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Reverse time direction in cyclic accumulation Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "minimum", "flag": "minimum", "dataType": "String", "optional": true, "explanation": "Input space time raster dataset that specifies the minimum values to detect the accumulation pattern", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maximum", "flag": "maximum", "dataType": "String", "optional": true, "explanation": "Input space time raster dataset that specifies the maximum values to detect the accumulation pattern", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "occurrence", "flag": "occurrence", "dataType": "String", "optional": false, "explanation": "The output space time raster dataset that stores the occurrence of the the accumulation pattern using the provided data range", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "indicator", "flag": "indicator", "dataType": "String", "optional": true, "explanation": "The output space time raster dataset that stores the indication of the start, intermediate and end of the specified data range", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start", "flag": "start", "dataType": "String", "optional": false, "explanation": "The temporal starting point to begin the accumulation, eg '2001-01-01'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stop", "flag": "stop", "dataType": "String", "optional": true, "explanation": "The temporal date to stop the accumulation, eg '2009-01-01'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cycle", "flag": "cycle", "dataType": "String", "optional": false, "explanation": "The temporal cycle to restart the accumulation, eg '12 months'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "offset", "flag": "offset", "dataType": "String", "optional": true, "explanation": "The temporal offset to the begin of the next cycle, eg '6 months'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'count' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "range", "flag": "range", "dataType": "String", "optional": true, "explanation": "The minimum and maximum value of the occurrence of accumulated values, these values will be used if the min/max space time raster datasets are not specified", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "staend", "flag": "staend", "dataType": "String", "optional": true, "explanation": "The user defined values that indicate start, intermediate and end status in the indicator output space time raster dataset", "defaultValue": "1,2,3", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.rast.accdetect  is designed to detect accumulation pattern in \n temporally accumulated space time raster datasets created by\n  t.rast.accumulate .\n This module's input is a space time raster dataset resulting from \n a  t.rast.accumulate  run.\n The  start  time and the  end  time of the pattern detection \n process must be set, eg.  start=\"2000-03-01\" end=\"2011-01-01\" . \n The  start  and  end  time do not need to be the same as for \n the accumulation run that produced the input space time raster dataset. \n In addition a  cycle , eg. \"8 months\", can be specified, that \n defines after which time interval the accumulation pattern detection \n process restarts. The  offset  option specifies the time that \n should be skipped between two cycles, eg. \"4 months\". The  cycle  \n and  offset  options must be exactly the same that were used in the \n accumulation process that generated the input space time raster dataset, \n otherwise the accumulation pattern detection will produce wrong \n results.\n The  minimum  and  maximum  values for the pattern detection \n process can be set either by using space time raster datasets or \n by using fixed values for all raster cells and time steps. \n Using space time raster datasets allows specifying minimum and maximum \n values for each raster cell and each time step. For example, we want to \n detect the germination (minimum value) and harvesting (maximum value) \n dates for different crops in Germany using the growing-degree-day (GDD) \n method for several years. Different crops may grow in different raster \n cells and change with time because of crop rotation. Hence we need to \n specify different GDD germination/harvesting (minimum/maximum) values \n for different raster cells and different years.\n The raster maps that specify the minimum and maximum values of the \n actual granule will be detected using the following temporal relations: \n equals, during, overlaps, overlapped and contains. First, all maps with \n time stamps  equal  to the current granule of the input STRDS will be \n detected, the first minimum map and the first maximum map that are \n found will be used as range definitions. If no equal maps are found, then \n maps with a temporal  during  relation will be detected, then maps \n that temporally  overlap  the actual granules and finally, maps that \n have a temporal  contain  relation will be detected. If no maps are \n found or minimum/maximum STRDS are not set, then the  range  option \n is used, eg.  range=480,730 .\n The  base  name of of the generated maps must always be set.\n This module produces two output space time raster datasets: occurrence \n and indicator. The  occurrence  output STRDS stores the time in \n days from the beginning of a given cycle for each raster cell and time \n step that has a value within the minimum and maximum definition. These \n values can be used to compute the duration of the recognized accumulation \n pattern. \n The  indicator  output STRDS uses three integer values to mark \n raster cells as beginning, intermediate state or end of an accumulation \n pattern. By default, the module uses 1 to indicate the start, 2 for \n the intermediate state and 3 to mark the end of the accumulation pattern \n in a cycle. These default values can be changed using the  staend  \n option.\n  EXAMPLE \n Please have a look at the  t.rast.accumulate  example.\n ", "notes": "", "see_also": ["t.rast.accumulate", "t.rast.aggregate", "t.rast.mapcalc", "t.info", "r.series.accumulate", "g.region"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.rast.accdetect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.merge.html", "name": "t.merge", "definition": "- Merges several space time datasets into a single space time dataset.", "keywords": ["temporal", "time management", "merge", "time"], "synopsis": "t.merge inputs=name[,name,...] output=name  [type=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "inputs", "flag": "inputs", "dataType": "String", "optional": false, "explanation": "Name of the input space time datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}], "description": "\n This module is designed to register the maps of several input space \n time datasets in a single output dataset. The datasets to merge can be \n either space time raster, 3D raster or vector datasets and must have \n the same temporal type (absolute or relative).\n Existing space time datasets located in the current mapset can be \n specified as output as well. The maps from the input space time \n datasets will be added to the output.\n Maps from the input space time datasets will be registered only once in \n the output space time dataset, hence the same maps can be registered in \n different input space time datasets.\n ", "notes": "\n Temporal databases stored in other mapsets can be used as long as they\n are in the user's current mapset search path (managed with\n  g.mapsets ).\n  Examples \n In this example we will create two space time raster datasets and \n register two unique maps in each of it. Then we merge the two space \n time raster datasets together.\n r.mapcalc expression=\"map1 = rand(0, 10)\"  -s\n r.mapcalc expression=\"map2 = rand(10, 20)\" -s\n t.create type=strds temporaltype=absolute \n           output=precipitation_daily_1 \n           title=\"Daily precipitation\" \n           description=\"Test dataset with daily precipitation\"\n t.register -i type=raster input=precipitation_daily_1 \n             maps=map1,map2 start=2012-08-20 increment=\"1 days\"\n t.info precipitation_daily_1\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precipitation_daily_1@soeren\n  | Name: ...................... precipitation_daily_1\n  | Mapset: .................... soeren\n  | Creator: ................... soeren\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-23 15:26:57.395355\n  | Modification time:.......... 2014-11-23 15:26:57.860513\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-08-20 00:00:00\n  | End time:................... 2012-08-22 00:00:00\n  | Granularity:................ 1 day\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 80.0\n  | South:...................... 0.0\n  | East:.. .................... 120.0\n  | West:....................... 0.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_6e6efe25ee9b40e39eb31421d737439b\n  | North-South resolution min:. 10.0\n  | North-South resolution max:. 10.0\n  | East-west resolution min:... 10.0\n  | East-west resolution max:... 10.0\n  | Minimum value min:.......... 0.0\n  | Minimum value max:.......... 10.0\n  | Maximum value min:.......... 9.0\n  | Maximum value max:.......... 19.0\n  | Aggregation type:........... None\n  | Number of registered maps:.. 2\n  |\n  | Title:\n  | Daily precipitation\n  | Description:\n  | Test dataset with daily precipitation\n  | Command history:\n  | # 2014-11-23 15:26:57 \n  | t.create type=\"strds\" temporaltype=\"absolute\"\n  |     output=\"precipitation_daily_1\" title=\"Daily precipitation\"\n  |     description=\"Test dataset with daily precipitation\"\n  | # 2014-11-23 15:26:57 \n  | t.register -i type=\"rast\"\n  |     input=\"precipitation_daily_1\" maps=\"map1,map2\" start=\"2012-08-20\"\n  |     increment=\"1 days\"\n  | \n  +----------------------------------------------------------------------------+\n r.mapcalc expression=\"map3 = rand(20, 30)\" -s\n r.mapcalc expression=\"map4 = rand(30, 40)\" -s\n t.create type=strds temporaltype=absolute \n           output=precipitation_daily_2 \n           title=\"Daily precipitation\" \n           description=\"Test dataset with daily precipitation\"\n t.register -i type=raster input=precipitation_daily_2 \n             maps=map3,map4 start=2012-08-22 increment=\"1 days\"\n t.info precipitation_daily_2\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precipitation_daily_2@soeren\n  | Name: ...................... precipitation_daily_2\n  | Mapset: .................... soeren\n  | Creator: ................... soeren\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-23 15:27:20.165074\n  | Modification time:.......... 2014-11-23 15:27:20.613543\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-08-22 00:00:00\n  | End time:................... 2012-08-24 00:00:00\n  | Granularity:................ 1 day\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 80.0\n  | South:...................... 0.0\n  | East:.. .................... 120.0\n  | West:....................... 0.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_04eaede279b2476a80c2683254232f84\n  | North-South resolution min:. 10.0\n  | North-South resolution max:. 10.0\n  | East-west resolution min:... 10.0\n  | East-west resolution max:... 10.0\n  | Minimum value min:.......... 20.0\n  | Minimum value max:.......... 30.0\n  | Maximum value min:.......... 29.0\n  | Maximum value max:.......... 39.0\n  | Aggregation type:........... None\n  | Number of registered maps:.. 2\n  |\n  | Title:\n  | Daily precipitation\n  | Description:\n  | Test dataset with daily precipitation\n  | Command history:\n  | # 2014-11-23 15:27:20 \n  | t.create type=\"strds\" temporaltype=\"absolute\"\n  |     output=\"precipitation_daily_2\" title=\"Daily precipitation\"\n  |     description=\"Test dataset with daily precipitation\"\n  | # 2014-11-23 15:27:20 \n  | t.register -i type=\"rast\"\n  |     input=\"precipitation_daily_2\" maps=\"map3,map4\" start=\"2012-08-22\"\n  |     increment=\"1 days\"\n  | \n  +----------------------------------------------------------------------------+\n t.merge input=precipitation_daily_1,precipitation_daily_2 \n          output=precipitation_daily_3\n t.info precipitation_daily_3\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precipitation_daily_3@soeren\n  | Name: ...................... precipitation_daily_3\n  | Mapset: .................... soeren\n  | Creator: ................... soeren\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-23 15:27:44.069272\n  | Modification time:.......... 2014-11-23 15:27:44.088930\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-08-20 00:00:00\n  | End time:................... 2012-08-24 00:00:00\n  | Granularity:................ 1 day\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 80.0\n  | South:...................... 0.0\n  | East:.. .................... 120.0\n  | West:....................... 0.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_33715c8c849a43fbb9bce02e1f28ff5a\n  | North-South resolution min:. 10.0\n  | North-South resolution max:. 10.0\n  | East-west resolution min:... 10.0\n  | East-west resolution max:... 10.0\n  | Minimum value min:.......... 0.0\n  | Minimum value max:.......... 30.0\n  | Maximum value min:.......... 9.0\n  | Maximum value max:.......... 39.0\n  | Aggregation type:........... None\n  | Number of registered maps:.. 4\n  |\n  | Title:\n  | Merged space time dataset\n  | Description:\n  | Merged space time dataset\n  | Command history:\n  | # 2014-11-23 15:27:44 \n  | t.merge\n  |     input=\"precipitation_daily_1,precipitation_daily_2\"\n  |     output=\"precipitation_daily_3\"\n  | \n  +----------------------------------------------------------------------------+\n ", "see_also": ["t.create", "t.support", "t.register"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.merge"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.list.html", "name": "t.list", "definition": "- Lists space time datasets and maps registered in the temporal database.", "keywords": ["temporal", "map management", "list", "time"], "synopsis": "t.list [-c]  [type=string]   [temporaltype=name[,name,...]]   [order=string[,string,...]]   [columns=string[,string,...]]   [where=sql_query]   [separator=character]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Print the column names as first row Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the space time dataset or map, default is strds", "defaultValue": "strds", "alternatives": ["strds", "str3ds", "stvds", "raster", "raster_3d", "vector"], "isInputFile": false, "isOutputFile": false}, {"parameter": "temporaltype", "flag": "temporaltype", "dataType": "String", "optional": true, "explanation": "The temporal type of the space time dataset", "defaultValue": "absolute,relative", "alternatives": ["absolute", "relative"], "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Sort the space time dataset by category", "defaultValue": "id", "alternatives": ["id", "name", "creator", "mapset", "number_of_maps", "creation_time", "start_time", "end_time", "interval", "north", "south", "west", "east", "granularity"], "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Columns to be printed to stdout", "defaultValue": "id", "alternatives": ["id", "name", "creator", "mapset", "number_of_maps", "creation_time", "start_time", "end_time", "north", "south", "west", "east", "granularity", "all"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator character between the output columns", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  t.list  lists any dataset that is registered in the temporal\n database. Datasets are raster, 3D raster and vector maps as well as\n their corresponding space time datasets (STRDS, STR3DS and STVDS). The\n type of the dataset can be specified using the  type  option,\n default is STRDS. By default all datasets with relative and absolute\n time are listed. However, the user has the ability to specify a single\n temporal type with the  temporaltype  option. The user can\n define the columns that should be printed for each dataset and the\n order of the datasets. In addition a SQL WHERE statement can be\n specified to select a subset of the requested datasets.\n ", "notes": "\n The SQL  where  and  sort  expression will be applied for\n each temporal database that was found in accessible mapsets. Hence\n sorting works only on mapset basis.\n Temporal databases stored in other mapsets can be used as long as they\n are in the user's current mapset search path (managed with\n  g.mapsets ).\n  EXAMPLES \n Obtain the list of space time raster dataset(s):\n t.list strds\n ----------------------------------------------\n Space time raster datasets with absolute time available in mapset <climate_2000_2012>:\n tempmean_monthly@climate_2000_2012\n Obtain the list of space time raster datasets in a specific mapset (Note \n that the target mapset must be in the user's search path):\n # strds in PERMANENT\n t.list strds where=\"mapset = 'PERMANENT'\"\n ----------------------------------------------\n # strds in climate_2000_2012\n t.list strds where=\"mapset = 'climate_2000_2012'\"\n ----------------------------------------------\n Space time raster datasets with absolute time available in mapset <climate_2000_2012>:\n precip_abs@climate_2000_2012\n precipitation@climate_2000_2012\n tempmean@climate_2000_2012\n The  where  option can also be used to list the stds with a \n certain pattern in their name, i.e. as the pattern option in  g.list .\n # strds whose name start with \"precip\"\n t.list type=strds where=\"name LIKE 'precip%'\"\n ----------------------------------------------\n Space time raster datasets with absolute time available in mapset <climate_1970_2012>:\n precip_abs@climate_1970_2012\n precipitation@climate_1970_2012\n The user can also obtain the list of time stamped raster maps. These maps \n might be registered in strds or not. The output of the following command \n can vary according to the accessible mapsets specified through \n  g.mapsets .\n t.list raster\n Time stamped raster maps with absolute time available in mapset <climate_2000_2012>:\n 2009_01_tempmean@climate_2000_2012\n 2009_02_tempmean@climate_2000_2012\n 2009_03_tempmean@climate_2000_2012\n ...\n 2012_10_tempmean@climate_2000_2012\n 2012_11_tempmean@climate_2000_2012\n 2012_12_tempmean@climate_2000_2012\n ", "see_also": ["g.list", "t.create", "t.info", "t.rast.list", "t.rast3d.list", "t.vect.list"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.list"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.info.html", "name": "t.info", "definition": "- Lists information about space time datasets and maps.", "keywords": ["temporal", "metadata", "extent", "time"], "synopsis": "t.info [-ghd] input=name  [type=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print in shell script style Print history information in human readable shell style for space time datasets Print information about the temporal DBMI interface and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Print history information in human readable shell style for space time datasets Print information about the temporal DBMI interface and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Print information about the temporal DBMI interface and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of an existing space time dataset or map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input space time dataset", "defaultValue": "strds", "alternatives": ["strds", "str3ds", "stvds", "raster", "raster_3d", "vector"], "isInputFile": false, "isOutputFile": false}], "description": "\n  t.info  reports information about any dataset that is\n registered in the temporal database in human readable or shell script\n style. Datasets are raster, 3D raster and vector maps as well as their\n corresponding space time datasets (STRDS, STR3DS and STVDS). This\n module reports the information that are stored in the temporal\n database. These are basic information (id, name, mapset, creator,\n creation time, temporal type), the temporal and spatial extent and\n dataset type specific metadata. The user has to utilize  r.info ,\n  r3.info ,  v.info  to report detailed information about\n raster, 3D raster and vector maps, since not all map specific\n information and metadata are stored in the temporal database.\n In addition, information about the chosen temporal database backend\n can be reported.\n ", "notes": "\n Temporal databases stored in other mapsets can be used as long as they\n are in the user's current mapset search path (managed with\n  g.mapsets ).\n  EXAMPLES \n  Temporal DBMI information \n In order to obtain information about temporal DBMI backend, run:\n t.info -d\n  +------------------- Temporal DBMI backend information ----------------------+\n  | DBMI Python interface:...... sqlite3\n  | Temporal database string:... /grassdata/nc_spm_temporal_workshop/climate_2000_2012/tgis/sqlite.db\n  | SQL template path:.......... /usr/local/grass-7.0.0/etc/sql\n  | tgis_db_version .......... 2\n  | creation_time .......... 2014-11-22 20:06:46.863733\n  | tgis_version .......... 2\n  +----------------------------------------------------------------------------+\n  Space time dataset information \n In order to obtain information about a space time dataset, run:\n t.info input=tempmean_monthly\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ tempmean_monthly@climate_2000_2012\n  | Name: ...................... tempmean_monthly\n  | Mapset: .................... climate_2000_2012\n  | Creator: ................... lucadelu\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-27 08:50:48.443229\n  | Modification time:.......... 2014-11-27 09:44:32.800282\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2009-01-01 00:00:00\n  | End time:................... 2013-01-01 00:00:00\n  | Granularity:................ 1 month\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 320000.0\n  | South:...................... 10000.0\n  | East:.. .................... 935000.0\n  | West:....................... 120000.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_d567423784c740bea1fba75dc7c0fa3d\n  | North-South resolution min:. 500.0\n  | North-South resolution max:. 500.0\n  | East-west resolution min:... 500.0\n  | East-west resolution max:... 500.0\n  | Minimum value min:.......... -6.464337\n  | Minimum value max:.......... 18.54137\n  | Maximum value min:.......... 4.247691\n  | Maximum value max:.......... 28.805381\n  | Aggregation type:........... None\n  | Number of registered maps:.. 48\n  |\n  | Title:\n  | Monthly precipitation\n  | Description:\n  | Dataset with monthly precipitation\n  | Command history:\n  | # 2014-11-27 08:50:48\n  | t.create type=\"strds\" temporaltype=\"absolute\"\n  |     output=\"tempmean_monthly\" title=\"Monthly precipitation\"\n  |     description=\"Dataset with monthly precipitation\"\n  | # 2014-11-27 09:44:32\n  | t.register -i type=\"rast\" input=\"tempmean_monthly\" maps=\"2009_01_tempmean,...,2012_12_tempmean\" start=\"2009-01-01\" increment=\"1 months\"\n  |\n  +----------------------------------------------------------------------------+\n The \"granularity\" is the smallest gap size between the found time instances, i.e.\n it the greatest common divisor between all gaps in the time series.\n  Temporal maps information \n In order to obtain information about a map in a space time dataset, run:\n t.info input=2009_01_tempmean type=raster\n  +-------------------- Raster Dataset ----------------------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ 2009_01_tempmean@climate_2000_2012\n  | Name: ...................... 2009_01_tempmean\n  | Mapset: .................... climate_2000_2012\n  | Creator: ................... lucadelu\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-27 09:44:26.280147\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2009-01-01 00:00:00\n  | End time:................... 2009-02-01 00:00:00\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 320000.0\n  | South:...................... 10000.0\n  | East:.. .................... 935000.0\n  | West:....................... 120000.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Datatype:................... DCELL\n  | Number of columns:.......... 620\n  | Number of rows:............. 1630\n  | Number of cells:............ 1010600\n  | North-South resolution:..... 500.0\n  | East-west resolution:....... 500.0\n  | Minimum value:.............. -3.380823\n  | Maximum value:.............. 7.426054\n  | Registered datasets ........ tempmean_monthly@climate_2000_2012\n  +----------------------------------------------------------------------------+\n ", "see_also": ["t.create", "t.list", "t.register", "r.info", "r3.info", "v.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.info"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.create.html", "name": "t.create", "definition": "- Creates a space time dataset.", "keywords": ["temporal", "map management", "create", "time"], "synopsis": "t.create output=name  [type=name]   [temporaltype=name]  semantictype=string title=string description=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the output space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "temporaltype", "flag": "temporaltype", "dataType": "String", "optional": true, "explanation": "The temporal type of the space time dataset", "defaultValue": "absolute", "alternatives": ["absolute", "relative"], "isInputFile": false, "isOutputFile": false}, {"parameter": "semantictype", "flag": "semantictype", "dataType": "String", "optional": false, "explanation": "Semantic type of the space time dataset", "defaultValue": "mean", "alternatives": ["min", "max", "sum", "mean"], "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": false, "explanation": "Title of the new space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "description", "flag": "description", "dataType": "String", "optional": false, "explanation": "Description of the new space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.create  is used to create space time datasets of\n type raster (STRDS), 3D raster (STR3DS) and vector (STVDS).\n Space time datasets represent spatio-temporal fields in the temporal\n GRASS framework. They are designed to collect any amount of time\n stamped maps with time intervals and time instances. The temporal\n type of a space time dataset can be absolute (means with a fixed date)\n or relative (only sequential maps) and must be set during\n dataset creation along with the name and the description.\n Time stamped maps can registered in and unregistered from space time\n datasets. The spatio-temporal extent as well as the metadata of a space\n time dataset is derived from its registered maps. Hence the metadata is\n dependent from the dataset type (raster, 3D raster, vector).\n  EXAMPLE \n  Absolute STRDS dataset \n Create a raster space time datasets\n t.create type=strds temporaltype=absolute \n           output=precipitation_monthly \n           title=\"Monthly precipitation\" \n           description=\"Dataset with monthly precipitation\"\n  Relative STVDS dataset \n Create a vector space time datasets\n t.create type=stvds temporaltype=relative \n           output=precipitation_monthly_30y \n           title=\"Monthly precipitation 30 years\" \n           description=\"Test dataset with monthly average \n           precipitation in the last 30 year\"\n ", "notes": "", "see_also": ["t.register", "t.remove", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.create"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.connect.html", "name": "t.connect", "definition": "- Prints/sets general temporal GIS database connection for current mapset.", "keywords": ["temporal", "settings", "metadata"], "synopsis": "t.connect [-pcdg]  [driver=name]   [database=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print current connection parameters and exit Check connection parameters, set if uninitialized, and exit Set from default settings and exit Overwrite current settings if initialized Print current connection parameter in shell style and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Check connection parameters, set if uninitialized, and exit Set from default settings and exit Overwrite current settings if initialized Print current connection parameter in shell style and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Set from default settings and exit Overwrite current settings if initialized Print current connection parameter in shell style and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print current connection parameter in shell style and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["sqlite", "pg"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/tgis/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.connect  allows the user to set the temporal database connection.\n The default setting is that the temporal database of\n type  sqlite3  is located in the current mapset directory.\n  The  -p  flag will display the current temporal database connection parameters.\n  The  -pg  flag will display the current temporal database connection parameters\n using shell style.\n  The  -c  flag will silently check if the temporal database connection\n parameters have been set, and if not will set them to use GRASS's\n default values.\n ", "notes": "\n Setting the connection with  t.connect  will not test the connection for validity.\n Hence a database connection will not be established.\n The connection values are stored in the mapset's  VAR  file.\n The  -d  flag will set the default\n TGIS connection parameters.\n A SQLite database \"tgis/sqlite.db\" will be created in the current mapset directory.\n It will be located in the \"tgis\" sub-directory to not\n interfere with the  sqlite3  database used for vector attribute storage.\n In case you have tens of thousands of maps to register in the\n temporal database or you need concurrent read and write access in the\n temporal database, consider to use a PostgreSQL connection instead.\n Be aware that you have to set the PostgreSQL connection explicitly in\n every mapset that should store temporal information in the temporal database.\n PostgreSQL and SQLite databases can not be mixed in a location.\n ", "see_also": [], "authors": ["Soeren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.connect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/r3.univar.html", "name": "r3.univar", "definition": "- Calculates univariate statistics from the non-null cells of a 3D raster map.", "keywords": ["raster3d", "statistics", "univariate statistics"], "synopsis": "r3.univar [-get] map=name  [zones=name]   [output=name]   [percentile=float[,float,...]]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print the stats in shell script style Calculate extended statistics Table output format instead of standard output format Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Calculate extended statistics Table output format instead of standard output format Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Table output format instead of standard output format Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zones", "flag": "zones", "dataType": "String", "optional": true, "explanation": "3D Raster map used for zoning, must be of type CELL", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "percentile", "flag": "percentile", "dataType": "String", "optional": true, "explanation": "Percentile to calculate (requires extended statistics flag)", "defaultValue": "90", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  r3.univar  calculates the univariate statistics for a 3D raster map.\n This includes the number of cells counted, minimum and maximum cell values,\n range, arithmetic mean, population variance, standard deviation,\n coefficient of variation, and sum. Statistics are calculated separately for every\n category/zone found in the  zones  input map if given.\n If the  -e  extended statistics flag is given the 1st quartile, median,\n 3rd quartile, and given  percentile  are calculated.\n If the  -g  flag is given the results are presented in a format suitable\n for use in a shell script.\n If the  -t  flag is given the results are presented in tabular format\n with the given field separator. The table can immediately be converted to a\n vector attribute table which can then be linked to a vector, e.g. the vector\n that was rasterized to create the  zones  input raster.\n ", "notes": "\n As with most GRASS raster3d modules,  r3.univar  operates on the voxel\n array defined by the current 3d region settings, not the original extent and\n resolution of the input map. See  g.region .\n This module can use large amounts of system memory when the  -e \n extended statistics flag is used with a very large region setting. If the\n region is too large the module should exit gracefully with a memory allocation\n error. Basic statistics can be calculated using any size input region.\n  EXAMPLE \n Computing univariate statistics of a 3D raster with randomly generated values:\n # define volume\n g.region n=10 s=0 w=0 e=10 b=0 t=10 res=1 res3=1 -p3\n # generate random map\n r3.mapcalc \"random_0_1 = rand(0., 1)\" -s\n # compute univariate statistics, along with extended statistics\n r3.univar -e map=random_0_1 percentile=98\n  100%\n total null and non-null cells: 1000\n total null cells: 0\n Of the non-null cells:\n ----------------------\n n: 1000\n minimum: 0.00053905\n maximum: 0.998322\n range: 0.997783\n mean: 0.513676\n mean of absolute values: 0.513676\n standard deviation: 0.289969\n variance: 0.0840821\n variation coefficient: 56.4498 %\n sum: 513.676463040334\n 1st quartile: 0.257654\n median (even number of cells): 0.524313\n 3rd quartile: 0.763637\n 98th percentile: 0.982924\n # script style output, along with extended statistics\n r3.univar -ge map=random_0_1 percentile=98\n n=1000\n null_cells=0\n cells=1000\n min=0.000539049520323687\n max=0.998322037540536\n range=0.997782988020212\n mean=0.513676463040334\n mean_of_abs=0.513676463040334\n stddev=0.289969154194666\n variance=0.0840821103843701\n coeff_var=56.4497646005434\n sum=513.676463040334\n first_quartile=0.257654\n median=0.524313\n third_quartile=0.763637\n percentile_98=0.982924\n  TODO \n To be implemented  mode, skewness, kurtosis .\n ", "see_also": ["g.region", "r.univar", "r.mode", "r.quantile", "r.series", "r3.stats", "r.statistics", "v.rast.stats", "v.univar"], "authors": ["Soeren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/raster/r.univar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.dropcolumn.html", "name": "v.db.dropcolumn", "definition": "- Drops a column from the attribute table connected to a given vector map.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.db.dropcolumn map=name  [layer=string]  columns=name[,name,...]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": false, "explanation": "Name of attribute column(s) to drop", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.dropcolumn  drops a column from the attribute table connected\n to a given vector map. It automatically checks the connection for the specified\n layer.  v.db.dropcolumn  omits to delete the 'cat' column which is\n relevant to keep the connection between vector map and table.\n ", "notes": "\n  v.db.dropcolumn  is a front-end to  db.execute  to allow easier usage.\n  The existing database connection(s) can be verified with  v.db.connect .\n  EXAMPLES \n Dropping a column: \n g.copy vect=roadsmajor,myroads\n v.info -c myroads\n v.db.dropcolumn myroads column=SHAPE_LEN\n v.info -c myroads\n ", "see_also": ["db.connect", "db.dropcolumn", "db.execute", "v.db.addcolumn", "v.db.connect", "v.db.droptable", "v.db.select", "v.db.update", "GRASS SQL interface"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.dropcolumn"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.connect.html", "name": "v.db.connect", "definition": "- Prints/sets DB connection for a vector map to attribute table.", "keywords": ["vector", "attribute table", "database", "layer"], "synopsis": "v.db.connect [-pgcod] map=name  [driver=name]   [database=name]   [table=name]   [key=name]   [layer=string]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print all map connection parameters and exit Print all map connection parameters in shell script style and exit Format: layer[/layer name] table key database driver Print types/names of table columns for specified layer and exit Overwrite connection parameter for certain layer Delete connection for certain layer (not the table) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print all map connection parameters in shell script style and exit Format: layer[/layer name] table key database driver Print types/names of table columns for specified layer and exit Overwrite connection parameter for certain layer Delete connection for certain layer (not the table) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Print types/names of table columns for specified layer and exit Overwrite connection parameter for certain layer Delete connection for certain layer (not the table) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Overwrite connection parameter for certain layer Delete connection for certain layer (not the table) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Delete connection for certain layer (not the table) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": true, "explanation": "Name of attribute table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "key", "flag": "key", "dataType": "String", "optional": true, "explanation": "Name of key column", "defaultValue": "cat", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator for shell script style output", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.connect  prints or sets database connection for a vector\n map. The user can add or remove link to attribute table on the certain\n layer.\n ", "notes": "\n Connection information (driver, database, table, key) is stored for\n each map, in the file\n <database>/<location>/<mapset>/vector/<map>/dbln\n If parameters for database connection are already set with \n  db.connect , they are taken as default values and\n do not need to be specified each time.\n  When printing database connection ( p  or  g  flag) the parameter\n  layer  is ignored, i.e.  all  connections are printed to the\n output.\n  Attention:  Removing a vector map will also delete all tables\n linked to it! If you use  v.db.connect  to\n link further tables to your map, it is advisable to make a copy from\n those tables first and connect the copied tables to the vector map\n (see also  v.overlay ).\n  EXAMPLE \n Note: The default database backend setting is SQLite.\n  Print database connection \n Print all database connection parameters for vector map.\n v.db.connect -p map=roads\n  Print column types and names of table linked to vector map.\n v.db.connect -c map=roads\n  Connect vector map to database (DBF driver) \n Connect vector map to DBF table without or with variables. \n  Using default DB connection:\n v.db.connect map=vectormap table=table\n  Using hardcoded path to DBF directory (not recommended): \n v.db.connect map=vectormap table=table \n               database=/home/user/grassdata/spearfish60/PERMANENT/dbf\n  Using variable as DBF directory definition, single quotes must be used: \n v.db.connect map=vectormap table=table \n               database='$GISDBASE/$LOCATION_NAME/$MAPSET/dbf/'\n  Connect vector map layer 2 and key ID to database with variables\n (note: if needed, single quotes must be used for the  database \n parameter):\n v.db.connect map=vectormap table=table layer=2 key=ID\n  Connect vector map to database (SQLite driver) \n Very similar to DBF driver example above.\n db.connect driver=sqlite database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'\n db.tables -p\n v.db.connect map=vectormap table=table driver=sqlite \n               database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'\n v.db.connect -p map=vectormap\n  Connect vector map to database (MySQL driver) \n # note: connection which requires password\n db.connect driver=mysql database=\"host=dbserver.foo.org,dbname=my_database\"\n db.login user=joshua [password=xxx]\n # ... or enter password interactively.\n db.tables -p\n # connect external table to layer 2:\n v.db.connect map=my_map table=my_mysql_table key=baz layer=2\n v.db.connect -p my_map\n  Connect vector map to database (PostgreSQL driver) \n # note: connection without password being asked\n v.db.connect map=vectormap table=table layer=1 key=oid driver=pg \n               database=\"host=myserver.itc.it,dbname=mydb,user=name\" \n               table=mytable key=id\n  Store geometry in GRASS but attributes in PostgreSQL \n This example illustrated a mixed data storage with possibility\n top update attributes in external PostgreSQL database:\n # Check current settings for attribute storage:\n db.connect -p\n # Import table from PostgreSQL to new map\n # (NOTE: output map name needs to be different from table name in \n #        case that GRASS is connected to PostgreSQL):\n v.in.db driver=pg database=\"host=localhost,dbname=meteo\" \n          table=mytable x=lon y=lat key=cat out=mytable\n v.db.connect map=mytable -p\n # Cancel table connection between map and attribute table:\n v.db.connect map=mytable -d\n v.db.connect map=mytable -p\n # Drop table which was replicated due to import:\n db.tables -p\n echo \"DROP TABLE mytable\" | db.execute\n db.tables -p\n # reconnect map to table in PostgreSQL:\n v.db.connect map=mytable driver=pg database=\"host=localhost,dbname=meteo\" \n          table=mytable key=cat\n # Now the geometry is stored in GRASS while the attributes are stored\n # in PostgreSQL.\n An alternative is to create a \"view\" of only ID, x, y [,z] columns and\n to use  v.in.db  on this view, then connect the original\n table to the geometry. This will be faster if the original table\n is very large.\n  Store geometry in GRASS but attributes in PostGIS \n This example illustrated a mixed data storage with possibility\n top update attributes in external PostGIS database:\n # Check current settings for attribute storage:\n db.connect -p\n # Import table from PostGIS to new map\n # (NOTE: output map name needs to be different from table name in \n #        case that GRASS is connected to PostGIS):\n v.in.db driver=pg database=\"host=localhost,dbname=meteo\" \n          table=mytable x=\"x(geom)\" y=\"y(geom)\" key=cat out=mytable\n v.db.connect map=mytable -p\n # Cancel table connection between map and attribute table:\n v.db.connect map=mytable -d\n v.db.connect map=mytable -p\n # Drop table which was replicated due to import:\n db.tables -p\n echo \"DROP TABLE mytable\" | db.execute\n db.tables -p\n # reconnect map to table in PostGIS:\n v.db.connect map=mytable driver=pg database=\"host=localhost,dbname=meteo\" \n          table=mytable key=cat\n # Now the geometry is stored in GRASS while the attributes are stored\n # in PostGIS.\n ", "see_also": ["db.connect", "db.copy", "db.tables", "v.db.addtable", "v.db.droptable", "v.db.addcolumn", "v.db.dropcolumn", "v.external", "v.in.db", "v.overlay"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.db.connect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.addtable.html", "name": "v.db.addtable", "definition": "- Creates and connects a new attribute table to a given layer of an existing vector map.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.db.addtable map=name  [table=string]   [layer=integer]   [key=name]   [columns=name type[,name type,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": true, "explanation": "Name of new attribute table (default: vector map name)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number where to add new attribute table", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "key", "flag": "key", "dataType": "String", "optional": true, "explanation": "Name of key column", "defaultValue": "cat", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Name and type of the new column(s) ('name type [,name type, ...]')", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.addtable  creates and adds a new attribute table to a given vector\n map. It links the table to the specified layer of the vector map. If the vector\n map is not yet linked to any table, new a database link is established based on\n the MAPSET database settings (see  db.connect ).\n ", "notes": "\n  v.db.addtable  is a front-end to  db.execute  to allow easier\n usage.\n  v.db.addtable  will only insert category values into the table for those features \n which actually have a category value in the relevant layer. The use can add \n category values automatically by using  v.category  or manually with \n  wxGUI vector digitizer \n before running v.db.addtable. Or one can run v.db.addtable first\n and then use either a combinatino of  v.category  +  v.to.db  or \n  wxGUI vector digitizer \n to add the relevant lines to the table.\n The supported types of columns depend on the database backend. However, all\n backends should support VARCHAR, INT, DOUBLE PRECISION and DATE.\n  The existing database connection(s) can be verified with  v.db.connect .\n  EXAMPLE \n Adding a new attribute table with a single column to default layer 1: \n g.copy vect=roadsmajor,myroads\n v.db.addtable myroads columns=\"slope double precision\"\n v.db.connect -p myroads\n v.info -c myroads\n  Adding a new attribute table with two columns to layer 2: \n g.copy vect=roadsmajor,myroads\n v.db.addtable myroads columns=\"slope double precision, roadname varchar(15)\" layer=2\n v.db.connect -p myroads\n v.info -c myroads\n v.info -c myroads layer=2\n ", "see_also": ["db.connect", "db.droptable", "db.execute", "v.db.addtable", "v.db.connect", "v.db.dropcolumn", "v.db.droptable", "v.db.select", "v.db.update", "GRASS SQL interface"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.addtable"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.addcolumn.html", "name": "v.db.addcolumn", "definition": "- Adds one or more columns to the attribute table connected to a given vector map.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.db.addcolumn map=name  [layer=string]  columns=name type[,name type,...]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number where to add column(s)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": false, "explanation": "Name and type of the new column(s) ('name type [,name type, ...]')", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.addcolumn  adds one or more column(s) to the attribute table\n connected to a given vector map. It automatically checks the connection for the\n specified layer.\n ", "notes": "\n  v.db.addcolumn  is a front-end to  db.execute  to allow easier usage.\n The supported types of columns depend on the database backend. However, all\n backends should support VARCHAR, INT, DOUBLE PRECISION and DATE.\n  The existing database connection(s) can be verified with  v.db.connect .\n  EXAMPLES \n Adding a single column: \n g.copy vect=roadsmajor,myroads\n v.db.addcolumn myroads columns=\"slope double precision\"\n v.info -c myroads\n  Adding two columns: \n g.copy vect=roadsmajor,myroads\n v.db.addcolumn myroads columns=\"slope double precision,myname varchar(15)\"\n v.info -c myroads\n ", "see_also": ["db.connect", "db.execute", "v.db.addtable", "v.db.connect", "v.db.dropcolumn", "v.db.droptable", "v.db.select", "v.db.update", "GRASS SQL interface"], "authors": ["Moritz Lennert (mlennert@club.worldonline.be)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.addcolumn"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.colors.out.html", "name": "v.colors.out", "definition": "- Exports the color table associated with a vector map.", "keywords": ["vector", "color table", "export"], "synopsis": "v.colors.out [-p] map=name  [layer=string]   [rules=name]   [column=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Output values as percentages Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Path to output rules file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of attribute (numeric) column to which refer color rules", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.colors.out  allows the user to export the color table for a\n vector map to a file which is suitable as input\n to  v.colors .\n  EXAMPLES \n v.colors.out map=soils_general rules=rules.txt\n v.colors map=soils_wake rules=rules.txt\n ", "notes": "", "see_also": ["v.colors", "r.colors", "r3.colors", "r.colors.out", "r3.colors.out"], "authors": ["Martin Landa, Czech Technical University in Prague, Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.colors.out"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.colors.html", "name": "v.colors", "definition": "- Creates/modifies the color table associated with a vector map.", "keywords": ["vector", "color table"], "synopsis": "v.colors [-rwlngac] map=name  [layer=string]  use=string  [column=name]   [range=min,max]   [color=style]   [raster=name]   [raster_3d=name]   [rules=name]   [rgb_column=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Remove existing color table Only write new color table if it does not already exist List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Convert color rules from RGB values to color table Option 'rgb_column' with valid RGB values required Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Only write new color table if it does not already exist List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Convert color rules from RGB values to color table Option 'rgb_column' with valid RGB values required Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available rules then exit Invert colors Logarithmic scaling Logarithmic-absolute scaling Convert color rules from RGB values to color table Option 'rgb_column' with valid RGB values required Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Invert colors Logarithmic scaling Logarithmic-absolute scaling Convert color rules from RGB values to color table Option 'rgb_column' with valid RGB values required Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Logarithmic scaling Logarithmic-absolute scaling Convert color rules from RGB values to color table Option 'rgb_column' with valid RGB values required Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Logarithmic-absolute scaling Convert color rules from RGB values to color table Option 'rgb_column' with valid RGB values required Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Convert color rules from RGB values to color table Option 'rgb_column' with valid RGB values required Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "use", "flag": "use", "dataType": "String", "optional": false, "explanation": "Source values", "defaultValue": "cat", "alternatives": ["attr", "cat", "z"], "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of column containing numeric data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "range", "flag": "range", "dataType": "String", "optional": true, "explanation": "Manually set range (refers to 'column' option)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Name of color table", "defaultValue": null, "alternatives": ["aspect", "aspectcolr", "bcyr", "bgyr", "blues", "byg", "byr", "celsius", "corine", "curvature", "differences", "elevation", "etopo2", "evi", "fahrenheit", "gdd", "grass", "greens", "grey", "grey.eq", "grey.log", "grey1.0", "grey255", "gyr", "haxby", "kelvin", "ndvi", "ndwi", "oranges", "population", "population_dens", "precipitation", "precipitation_daily", "precipitation_monthly", "rainbow", "ramp", "random", "reds", "roygbiv", "rstcurv", "ryb", "ryg", "sepia", "slope", "soilmoisture", "srtm", "srtm_plus", "terrain", "viridis", "water", "wave"], "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": true, "explanation": "Raster map from which to copy color table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster_3d", "flag": "raster_3d", "dataType": "String", "optional": true, "explanation": "3D raster map from which to copy color table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Path to rules file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rgb_column", "flag": "rgb_column", "dataType": "String", "optional": true, "explanation": "Name of color column to populate RGB values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.colors  allows creating or modifying color table associated\n with a vector map similarly\n to  r.colors  for raster maps.\n  Color rules are built from features category values\n ( use=cat ) or numeric data column ( use=attr ) defined\n by  column  option. For 3D vector maps is allowed to define color\n rules based on points or centroids z-coordinate ( use=z ). 3D\n vector lines are not supported.\n  The  raster  option allows user to specify a raster map from\n which to copy the color table, similarly  raster_3d  option for 3D\n raster map.\n  The  rules  color table type will cause  v.colors  to\n read color table specifications from given file and will build the\n color table accordingly. See\n  r.colors  manual page for details.\n  If the user specifies the  -w  flag, the current color table\n file for the input map will not be overwritten. This means that the\n color table is created only if the vector map does not already have a\n color table. If this option is not specified, the color table will be\n created if one does not exist, or modified if it does.\n  Alternatively the color rules can be stored in a string column\n ( rgb_column ) by saving the RRR:GGG:BBB values suitable for use\n with  d.vect .\n ", "notes": "\n For vector maps with a large number of features it's more convenient\n to store color rules in an attribute column (given by  rgb_column )\n rather then in a color table file. Reading color tables with more then 1000\n items is slow.\n  EXAMPLES \n  Define color table based on categories \n Define color table  wave  based on categories from layer 1\n v.colors map=soils_general layer=1 color=wave\n  Define color table based on attribute values \n Define color table  ryg  based on values from attribute\n column  AREA . Attribute table is linked to layer 1.\n v.to.db map=soils_general layer=1 option=area column=AREA\n v.colors map=soils_general layer=1 color=wave use=attr column=AREA\n  Define color table stored as RGB values in attribute table \n   \n Write color values to the attribute table (column  GRASSRGB )\n instead of creating color table.\n v.colors map=soils_general layer=1 color=wave use=attr column=AREA rgb_column=GRASSRGB\n # See some GRASSRGB values:\n v.db.select map=soils_general where=\"cat < 4\"\n cat|OBJECTID|AREA|PERIMETER|GSLNC250_|GSLNC250_I|GSL_NAME|GRASSRGB\n 1|1|0|164616.125|2|1|NC113|212:42:127\n 2|2|0|30785.529297|3|2|NC096|212:42:127\n 3|3|0|87572.882812|4|3|NC097|212:42:127\n  Convert RGB attribute values into color table \n Convert existing RGB values to color table rules.\n v.colors -c map=soils_general rgb_column=GRASSRGB\n Note that in this case the vector map has a proper color table\n assigned (check\n by  v.colors.out ) together\n with GRASSRGB attribute column. Also note that color table is preferred\n over RGB values stored in attribute table.\n  Remove existing color table \n Existing color table can be removed by  -r  flag.\n v.colors -r map=soils_general\n Before removing color table you can store color rules to the file\n by  v.colors.out  and later to\n assign by  rules  option.\n v.colors.out map=soils_general rules=soils.colr\n v.colors map=soils_general rules=soils.colr\n To drop RGB column\n use  v.db.dropcolumn .\n v.db.dropcolumn map=soils_general column=GRASSRGB\n ", "see_also": ["d.vect", "r.colors", "r.colors.out", "r3.colors", "r3.colors.out", "v.colors.out"], "authors": ["Martin Landa, OSGeoREL, Czech Technical University in Prague, Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.colors"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.cluster.html", "name": "v.cluster", "definition": "- Performs cluster identification.", "keywords": ["vector", "point cloud", "cluster", "clump", "level1"], "synopsis": "v.cluster [-2bt] input=name output=name  [layer=string]   [distance=float]   [min=integer]   [method=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "2", "flag": "-2", "explanation": "Force 2D clustering Do not build topology Advantageous when handling a large number of points Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name for cluster ids", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": true, "explanation": "Maximum distance to neighbors", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "min", "flag": "min", "dataType": "String", "optional": true, "explanation": "Minimum number of points to create a cluster", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Clustering method", "defaultValue": "dbscan", "alternatives": ["dbscan", "dbscan2", "density", "optics", "optics2"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.cluster  partitions a point cloud into clusters or clumps. \n If the minimum number of points is not specified with the  min  \n option, the minimum number of points to constitute a cluster is \n  number of dimensions + 1 , i.e. 3 for 2D points and 4 for 3D \n points.\n If the maximum distance is not specified with the  distance  \n option, the maximum distance is estimated from the observed distances \n to the neighbors using the upper 99% confidence interval.\n  v.cluster  supports different methods for clustering. The \n recommended methods are  method=dbscan  if all clusters should \n have a density (maximum distance between points) not larger than \n  distance  or  method=density  if clusters should be created \n separately for each observed density (distance to the farthest neighbor).\n  dbscan \n The  Density-Based Spatial \n Clustering of Applications with Noise  is a commonly used clustering \n algorithm. A new cluster is started for a point with at least \n  min  - 1 neighbors within the maximum distance. These neighbors \n are added to the cluster. The cluster is then expanded as long as at \n least  min  - 1 neighbors are within the maximum distance for each \n point already in the cluster.\n  dbscan2 \n Similar to  dbscan , but here it is sufficient if the resultant \n cluster consists of at least  min  points, even if no point in the \n cluster has at least  min - 1  neighbors within  distance .\n  density \n This method creates clusters according to their point density. The \n maximum distance is not used. Instead, the points are sorted ascending \n by the distance to their farthest neighbor (core distance), inspecting \n  min - 1  neighbors. The densest cluster is created first, using \n as threshold the core distance of the seed point. The cluster is \n expanded as for DBSCAN, with the difference that each cluster has its \n own maximum distance. This method can identify clusters with different \n densities and can create nested clusters.\n  optics \n This method is  Ordering Points to \n Identify the Clustering Structure . It is controlled by the number \n of neighbor points (option  min  - 1). The core distance of a \n point is the distance to the farthest neighbor. The reachability of a \n point  q  is its distance from a point  p  (original optics: \n max(core-distance(p), distance(p, q))). The aim of the  optics  \n method is to reduce the reachability of each point. Each unprocessed \n point is the seed for a new cluster. Its neighbors are added to a queue \n sorted by smallest reachability if their reachability can be reduced. \n The points in the queue are processed and their unprocessed neighbors \n are added to a queue sorted by smallest reachability if their \n reachability can be reduced.\n The  optics  method does not create clusters itself, but produces \n an ordered list of the points together with their reachability. The \n output list is ordered according to the order of processing: the first \n point processed is the first in the list, the last point processed is \n the last in the list. Clusters can be extracted from this list by \n identifying valleys in the points' reachability, e.g. by using a \n threshold value. If a maximum distance is specified, this is used to \n identify clusters, otherwise each separated network will constitute a \n cluster.\n The OPTICS algorithm uses each yet unprocessed point to start a new \n cluster. The order of the input points is arbitrary and can thus \n influence the resultant clusters.\n  optics2 \n  EXPERIMENTAL  This method is similar to OPTICS, minimizing the \n reachability of each point. Points are reconnected if their \n reachability can be reduced. Contrary to OPTICS, a cluster's seed is \n not fixed but changed if possible. Each point is connected to another \n point until the core of the cluster (seed point) is reached. \n Effectively, the initial seed is updated in the process. Thus separated \n networks of points are created, with each network representing a \n cluster. The maximum distance is not used.\n  EXAMPLE \n Analysis of random points for areas in areas of the vector \n  urbanarea  (North Carolina sample dataset).\n First generate 1000 random points within the areas the vector urbanarea\n and within the subregion, then do clustering and visualize the result:\n # pick a subregion of the vector urbanarea\n g.region -p n=272950 s=188330 w=574720 e=703090 res=10\n # create random points in areas\n v.random output=random_points npoints=1000 restrict=urbanarea\n # identify clusters\n v.cluster input=random_points output=clusters_optics method=optics\n # set random vector color table for the clusters\n v.colors map=clusters_optics layer=2 use=cat color=random\n # display in command line\n d.mon wx0\n # note the second layer and transparent (none) color of the circle border\n d.vect map=clusters_optics layer=2 icon=basic/point size=10 color=none\n  \n     Figure: Four different methods with default settings applied to\n     1000 random points generated in the same way as in the example.\n Generate random points for analysis (100 points per area), use different\n method for clustering and visualize using color stored the attribute table.\n # pick a subregion of the vector urbanarea\n g.region -p n=272950 s=188330 w=574720 e=703090 res=10\n # create clustered points\n v.random output=rand_clust npoints=100 restrict=urbanarea -a\n # identify clusters\n v.cluster in=rand_clust out=rand_clusters method=dbscan\n # create colors for clusters\n v.db.addtable map=rand_clusters layer=2 columns=\"cat integer,grassrgb varchar(11)\"\n v.colors map=rand_clusters layer=2 use=cat color=random rgb_column=grassrgb\n # display with your preferred method\n # remember to use the second layer and RGB column\n # for example use\n d.vect map=rand_clusters layer=2 color=none rgb_column=grassrgb icon=basic/circle\n ", "notes": "", "see_also": ["r.clump", "v.hull", "v.distance"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.cluster"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.clip.html", "name": "v.clip", "definition": "- Extracts features of input map which overlay features of clip map.", "keywords": ["vector", "clip", "area"], "synopsis": "v.clip [-dr] input=name clip=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Do not dissolve clip map Clip by region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Clip by region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of vector map to be clipped", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "clip", "flag": "clip", "dataType": "String", "optional": false, "explanation": "Name of clip vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.clip  module enables extracting those features of input\n vector map, which overlay features of clip map, as well as their\n storing in a new vector map.\n  In default, boundaries of clip map are dissolved before\n clipping. Alternatively, flag  -d  can be ticked to retain the\n boundaries of clip map. Flag  -b  facilitates clipping by current\n computational region.\n  It is possible to clip vector maps consisting of points, lines,\n areas or combinations of these. However, the current version does not\n fully support clipping of mixed geometry containing points. In such a\n case, the output map will only store clipped lines and/or areas.\n ", "notes": "\n  v.clip  is a front-end\n to  v.overlay , as well\n as  v.select . Clipping of areas\n and/or lines can be achieved\n using  v.overlay . Clipping of\n points can be performed\n with  v.select .\n  EXAMPLES \n  Basic use \n Clip railroads by counties Wake and Johnston in North Carolina (North\n Carolina data set).\n v.extract input=boundary_county where=\"NAME='WAKE' OR NAME='JOHNSTON'\" output=county_WAKE_JOHNSTON\n v.clip input=railroads clip=county_WAKE_JOHNSTON output=railroads_WAKE_JOHNSTON\n   \n   Figure: v.clip example - basic use \n  Retain boundaries of clip map \n v.clip -d input=railroads clip=county_WAKE_JOHNSTON output=railroads_WAKE_JOHNSTON\n  Clip by current computational region \n Clip hospitals by computational region adjusted to counties Wake and\n Johnston in North Carolina (North Carolina data set).\n It is not obligatory to enter name of clip map. In case it is stated,\n the clip map will be omitted.\n v.extract input=boundary_county where=\"NAME='WAKE' OR NAME='JOHNSTON'\" output=county_WAKE_JOHNSTON\n v.clip -r input=hospitals output=hospitals_clip\n   \n   Figure: v.clip example - clip by computational region \n ", "see_also": ["v.overlay", "v.select", "v.dissolve", "v.in.region"], "authors": ["Zofie Cimburova,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.clip"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.clean.html", "name": "v.clean", "definition": "- Toolset for cleaning topology of vector map.", "keywords": ["vector", "topology", "geometry", "snapping"], "synopsis": "v.clean [-bc] input=name  [layer=string]   [type=string[,string,...]]  output=name  [error=name]  tool=string[,string,...]  [threshold=float[,float,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "b", "flag": "-b", "explanation": "Do not build topology for the output vector Combine tools with recommended follow-up tools Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Combine tools with recommended follow-up tools Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid,area,face,kernel", "alternatives": ["point", "line", "boundary", "centroid", "area", "face", "kernel"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "error", "flag": "error", "dataType": "String", "optional": true, "explanation": "Name of output map where errors are written", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tool", "flag": "tool", "dataType": "String", "optional": false, "explanation": "Cleaning tool", "defaultValue": null, "alternatives": ["break", "snap", "rmdangle", "chdangle", "rmbridge", "chbridge", "rmdupl", "rmdac", "bpol", "prune", "rmarea", "rmline", "rmsa"], "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Threshold in map units, one value for each tool", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.clean  allows the user to automatically fix topology of vector \n maps. Several tools may be listed to be executed sequentially. In this\n case, also the threshold parameter requires several values to be listed\n accordingly. An error map is optionally written which stores the erroneous\n geometries.\n  Break lines/boundaries \n  tool=break \n The  break  tool breaks lines/boundaries at intersections and it \n also breaks lines/boundaries forming a collapsed loop. \n For example, 0.0;1.0;0.0 is broken at 1.0.\n Threshold does not apply (it is ignored), use an arbitrary value (e.g., 0)\n if  v.clean  is run with several tools.\n Hint: Breaking lines should be followed by removing duplicates, e.g. \n  v.clean ... tool=break,rmdupl . If the  -c  flag is used with \n  v.clean ... tool=break , duplicates are automatically removed.\n  Remove duplicate geometry features \n  tool=rmdupl \n The  rmdupl  tool removes geometry features with identical \n coordinates. Categories are merged. If a point and a centroid have \n identical coordinates, one of them will be removed if both points and \n centroids are selected with  v.clean ... type=point,centroid .\n The  same applies for lines and boundaries.\n Threshold does not apply (it is ignored), use an arbitrary value (e.g., 0)\n if  v.clean  is run with several tools.\n The  rmdupl  tool should be used after breaking lines and \n breaking polygons.\n  Remove dangles or change boundary dangles to type line \n  tool=rmdangle  and  tool=chdangle \n A line/boundary is considered to be a dangle if no other line of given \n  type  is on at least one end node. If a dangle is formed by \n several lines, such a string of lines is taken as one dangle and line \n lengths are summarized. The  rmdangle  tool deletes a dangle if \n the (combined) length is shorter than  thresh  or  thresh  \n < 0. If the combined length is larger than  thresh , nothing \n is deleted.\n Threshold has to be given as maximum line/boundary length in map units; \n for latitude-longitude locations in degree. Dangles shorter than\n  thresh  are removed sequentially. All dangles will be removed if\n  thresh  < 0.\n With  thresh  < 0, only closed loops and lines connecting \n loops will remain. This is useful to remove all incorrect boundaries \n after other cleaning operations with  thres  is < 0. Areas can \n then be successfully built. \n To preferentially remove shortest dangles first, a first pass with a \n small  thresh  value can be followed by subsequent passes with \n higher  thresh  values. This can be done as one  v.clean \n job by listing the tool several times and by defining a list of increasing\n  thresh  values.\n The  chdangle  tool is similar to the  rmdangle  tool, but \n works only on boundaries and changes dangling boundaries to lines \n instead of removing them.\n  Remove or change bridges connecting an area and an island or two islands \n  tool=rmbridge  and  tool=chbridge \n A bridge is an area type connection of an island (polygon in a polygon) \n to the outer polygon. This is topologically incorrect (but OGC Simple \n Features allow it). The  rmbridge  tool removes bridges and the \n  chbridge  tool changes bridges to type line:\n     +-------------+             +-------------+   +-------------+\n     |            P|  P: polygon |            P|   |            P|\n     |    +---+    |  I: island  |    +---+    |   |    +---+    |\n     |    | I |    |  B: bridge  |    | I |    |   |    | I |    |\n     |    |   |    |  L: line    |    |   |    |   |    |   |    |\n     |    +-+-+    |             |    +---+    |   |    +-.-+    |\n     |      |      |             |             |   |      .      |\n     |      | B    |             |             |   |      . L    |\n     |      |      |             |             |   |      .      |\n     +------+------+             +-------------+   +-------------+\n Islands and areas must be already clean, i.e. without dangles or small \n angles, e.g.\n  v.clean ... type=boundary tool=rmdangle,rmsa,break,rmdupl,rmbridge \n thresh=-1,0,0,0,0 .\n Threshold does not apply (it is ignored), use an arbitrary value (e.g., 0)\n if  v.clean  is run with several tools.\n  Snap lines to vertex in threshold \n  tool=snap \n The  snap  tool snaps vertices to another vertex not farther away \n than  thresh . If there is no other vertex within  thresh , \n no snapping will be done. The  type  option can have a strong \n influence on the result. A too large threshold and  type=boundary \n can severely damage area topology, beyond repair.\n Threshold gives maximum distance to another vertex in map units, \n for latitude-longitude locations in degree. \n Snapped boundaries may need to be cleaned with  break,rmdupl,rmsa . \n If the  -c  flag is used with  v.clean tool=snap , the \n sequence of  break,rmdupl,rmsa  is automatically repeated after \n snapping until no more small angles a left. Additional cleaning with e.g.\n  tool=rmdangle may be necessary.\n  Remove duplicate area centroids \n  tool=rmdac \n The  rmdac  tool removes duplicate area centroids that can result \n from deleting boundaries.\n Threshold does not apply (it is ignored), use an arbitrary value (e.g., 0)\n if  v.clean  is run with several tools.\n  Break (topologically clean) areas (imported from a non topological \n format like ShapeFile) \n  tool=bpol \n The  bpol  tool breaks boundaries on each point shared between 2 \n and more areas where angles of boundary segments are different and on \n all boundary nodes (start and end points of each boundary). The \n  bpol  tool behaves similar to  break  for boundaries, but \n does not break collapsed loops. The  bpol  tool is faster than \n the  break  tool but needs more memory.\n Threshold does not apply (it is ignored), use an arbitrary value (e.g., 0)\n if  v.clean  is run with several tools.\n The  bpol  tool should be followed by  rmdupl . If the \n  -c  flag is used with  v.clean ... tool=bpol , duplicates are \n automatically removed.\n  Remove vertices in threshold from lines and boundaries \n  tool=prune \n The  prune  tool simplifies lines and boundaries by removing\n vertices according to threshold. This tool preserves area topology,\n areas are never deleted and centroid attachment is never changed.\n  v.generalize  offers much more\n functionality for line simplification but does not preserve area\n topology.\n  Remove small areas \n  tool=rmarea \n The  rmarea  tool removes all areas <=  thresh . The \n longest boundary with an adjacent area is removed or all boundaries if \n there is no adjacent area. Area categories are not combined when a small \n area is merged with a larger area.\n Threshold must always be in square meters, also for latitude-longitude \n locations or locations with units other than meters.\n  Remove all lines or boundaries of zero length \n  tool=rmline \n The  rmline  tool removes all lines or boundaries of zero length \n that may have resulted from other cleaning operations. Zero length \n boundaries are redundant and do not influence area topology.\n Threshold does not apply (it is ignored), use an arbitrary value (e.g., 0)\n if  v.clean  is run with several tools.\n  Remove small angles between lines at nodes \n  tool=rmsa \n The  rmsa  tool only concerns angles which are so small that the \n calculated angle is 0. The following figure should help demonstrate what \n the tool does.\n Threshold does not apply, use dummy value if  v.clean  is \n run with several tools.\n  tool=rmsa \n The  rmsa  tool should be followed by  break,rmdupl . The \n  rmsa  tool followed by  break,rmdupl  may need to be run \n more than once to remove all small angles. If the  -c  flag is \n used with  v.clean ... tool=rmsa , the sequence of \n  rmsa,break,rmdupl  is automatically repeated until no more small \n angles a left.\n ", "notes": "\n The user does  not  have to run  v.build \n on the  output  vector, unless the  -b  flag was used. The\n  -b  flag affects  only  the  output  vector - \n topology is always built for  error  vector.\n  EXAMPLES \n  Snap lines to vertex in threshold \n v.clean input=testmap output=cleanmap tool=snap threshold=1\n  Inspecting the topological errors visually \n Both  v.build  and  v.clean  can\n collect the topological errors into a vector map:\n v.build -e map=imported error=build_errors\n v.clean -c input=imported output=clean error=cleaning_errors tool=snap,rmdangle,rmbridge,chbridge,bpol,prune threshold=5\n The vector maps can be visualized together with the original data\n by the following set of display commands:\n d.vect map=imported color=26:26:26 fill_color=77:77:77 width=5\n d.vect map=build_errors color=255:33:36 fill_color=none width=5 icon=basic/point size=30\n d.vect map=cleaning_errors color=255:33:36 fill_color=none width=5 icon=basic/point size=30\n  \n  Figure: Topological errors detected in the original data (left)\n and cleaned data (right) \n  Cleaning OGR imported data (Simple Feature data) such as SHAPE file \n The import of areas with  v.in.ogr  -c \n (no cleaning) requires a subsequent run of  v.clean  to update \n the map to a topologically valid structure (removal of duplicate \n collinear lines etc). The tools used for that are  bpol  and \n  rmdupl :\n v.clean input=areamap output=areamap_clean tool=bpol,rmdupl type=boundary\n  Extracting intersection points of vector lines \n v.clean input=lines1 output=lines2 err=points tool=break type=line\n Intersection points are written to 'points' map.\n  Break lines \n  v.clean  will break the lines where they cross, \n creating new node if needed. Example:\n v.in.ascii -n out=crossed_lines format=standard << EOF\n L 2\n  0 5\n  10 5\n L 2\n  5 0\n  5 10\n EOF\n v.clean in=crossed_lines out=crossed_lines_brk \n          error=intersection tool=break type=line\n  Remove all lines of zero length \n v.out.ascii zero format=standard \n L  2 1\n  -819832.09065589 -987825.2187231\n  -806227.28362601 -971104.80702988\n  1     1         \n L  2 1\n  -799165.24638913 -972974.16982788\n  -799165.24638913 -972974.16982788\n  1     2         \n v.clean input=zero output=zero_clean tool=rmline type=line\n v.out.ascii zero_clean format=standard \n L  2 1\n  -819832.09065589 -987825.2187231\n  -806227.28362601 -971104.80702988\n  1     1         \n v.clean type=boundary would remove nothing.\n  Repeatedly remove dangling lines up to 50m length \n v.clean input=testmap output=cleanmap type=line \n          tool=rmdangle,rmdangle,rmdangle,rmdangle threshold=5,10,20,50\n ", "see_also": ["v.info", "v.build", "g.gui.vdigit", "v.edit", "v.generalize"], "authors": ["David Gerdes, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.clean"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.class.html", "name": "v.class", "definition": "- Classifies attribute data, e.g. for thematic mapping", "keywords": ["vector", "classification", "attribute table", "statistics"], "synopsis": "v.class [-g] map=name  [layer=string]  column=name  [where=sql_query]  algorithm=string nbclasses=integer  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print only class breaks (without min and max) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Column name or expression", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "algorithm", "flag": "algorithm", "dataType": "String", "optional": false, "explanation": "Algorithm to use for classification", "defaultValue": null, "alternatives": ["int", "std", "qua", "equ", "dis"], "isInputFile": false, "isOutputFile": false}, {"parameter": "nbclasses", "flag": "nbclasses", "dataType": "String", "optional": false, "explanation": "Number of classes to define", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.class  classifies vector attribute data into classes, for \n example for thematic mapping. Classification can be on a column or on an\n expression including several columns, all in the table linked to the\n vector map. The user indicates the number of classes desired and the\n algorithm to use for classification.\n Several algorithms are implemented for classification: equal interval,\n standard deviation, quantiles, equal probabilities, and a discontinuities\n algorithm developed by Jean-Pierre Grimmeau at the Free University of\n Brussels (ULB).\n It can be used to pipe class breaks into thematic mapping modules such\n as  d.vect.thematic  (see example below);\n ", "notes": "\n  The  equal interval  algorithm simply divides the range max-min\n by the number of breaks to determine the interval between class breaks.\n  The  quantiles  algorithm creates classes which all contain\n approximately the same number of observations.\n  The  standard deviations  algorithm creates class breaks which\n are a combination of the mean +/- the standard deviation. It calculates\n a scale factor (<1) by which to multiply the standard deviation in\n order for all of the class breaks to fall into the range min-max of the\n data values.\n  The  equiprobabilites  algorithm creates classes that would be\n equiprobable if the distribution was normal. If some of the class breaks\n fall outside the range min-max of the data values, the algorithm prints\n a warning and reduces the number of breaks, but the probabilities used\n are those of the number of breaks asked for.\n  The  discont  algorithm systematically searches discontinuities\n in the slope of the cumulated frequencies curve, by approximating this\n curve through straight line segments whose vertices define the class\n breaks. The first approximation is a straight line which links the two\n end nodes of the curve. This line is then replaced by a two-segmented\n polyline whose central node is the point on the curve which is farthest\n from the preceding straight line. The point on the curve furthest from\n this new polyline is then chosen as a new node to create break up one of\n the two preceding segments, and so forth. The problem of the difference\n in terms of units between the two axes is solved by rescaling both\n amplitudes to an interval between 0 and 1. In the original algorithm,\n the process is stopped when the difference between the slopes of the two\n new segments is no longer significant (alpha = 0.05). As the slope is\n the ratio between the frequency and the amplitude of the corresponding \n interval, i.e. its density, this effectively tests whether the frequencies\n of the two newly proposed classes are different from those obtained by\n simply distributing the sum of their frequencies amongst them in proportion\n to the class amplitudes. In the GRASS implementation, the algorithm\n continues, but a warning is printed.\n  EXAMPLE \n Classify column pop of map communes into 5 classes using quantiles:\n v.class map=communes column=pop algo=qua nbclasses=5\n This example uses population and area to calculate a population density\n and to determine the density classes:\n v.class map=communes column=pop/area algo=std nbclasses=5\n The following example uses the output of d.class and feeds it directly\n into  d.vect.thematic :\n d.vect.thematic -l map=communes2 column=pop/area \n      breaks=`v.class -g map=communes2 column=pop/area algo=std nbcla=5` \n      colors=0:0:255,50:100:255,255:100:50,255:0:0,156:0:0\n ", "see_also": ["v.univar", "d.vect.thematic"], "authors": ["Moritz Lennert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.class"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.centroids.html", "name": "v.centroids", "definition": "- Adds missing centroids to closed boundaries.", "keywords": ["vector", "centroid", "area"], "synopsis": "v.centroids input=name output=name  [option=string]   [layer=string]   [cat=integer]   [step=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "option", "flag": "option", "dataType": "String", "optional": true, "explanation": "Action to be taken", "defaultValue": "add", "alternatives": ["add"], "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cat", "flag": "cat", "dataType": "String", "optional": true, "explanation": "Category number starting value", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "step", "flag": "step", "dataType": "String", "optional": true, "explanation": "Category increment", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n GRASS defines vector areas as composite entities consisting of a set of\n closed boundaries and a centroid. The attribute information associated\n with that area is linked to the centroid. The  v.centroids  module\n adds centroids to closed boundaries in the  input  file and assigns a\n category number to them. The starting value as well as the increment size\n may be set using optional parameters. \n  Multiple attributes may be linked to a single vector entity through\n numbered fields referred to as layers. Refer to  v.category \n for more details, as  v.centroids  is simply a frontend to that\n module.\n  The boundary itself is often stored without any category reference as it\n can mark the border between two adjacent areas. Thus it would be ambiguous\n as to which feature the attribute would belong. In some cases it may, for\n example, represent a road between two parcels of land. In this case it\n is entirely appropriate for the boundary to contain category information.\n  EXAMPLES \n Create an area from a closed line using North Carolina sample dataset:\n v.type input=busroute11 output=busroute11_boundary from_type=line to_type=boundary\n v.centroids input=busroute11_boundary output=busroute11_area\n  Figure: Creating area from closed line \n ", "notes": "", "see_also": ["v.category"], "authors": ["module: M. Hamish Bowman, Dept. Marine Science, Otago University, New Zealand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.centroids"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.category.html", "name": "v.category", "definition": "- Attaches, deletes or reports vector categories to map geometry.", "keywords": ["vector", "category", "layer"], "synopsis": "v.category [-gt] input=name  [layer=string[,string,...]]   [type=string[,string,...]]   [ids=range]   [output=name]  option=string  [cat=integer]   [step=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Shell script style, currently only for report Format: layer type count min max Do not copy attribute table(s) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not copy attribute table(s) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,centroid,face", "alternatives": ["point", "line", "boundary", "centroid", "area", "face", "kernel"], "isInputFile": false, "isOutputFile": false}, {"parameter": "ids", "flag": "ids", "dataType": "String", "optional": true, "explanation": "Feature ids (by default all features are processed)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "option", "flag": "option", "dataType": "String", "optional": false, "explanation": "Action to be done", "defaultValue": null, "alternatives": ["add", "del", "chlayer", "sum", "report", "print", "layers", "transfer"], "isInputFile": false, "isOutputFile": false}, {"parameter": "cat", "flag": "cat", "dataType": "String", "optional": true, "explanation": "Category value", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "step", "flag": "step", "dataType": "String", "optional": true, "explanation": "Category increment", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.category  attaches, copies, deletes or reports categories of \n vector geometry objects. Further on,  v.category  adds a number \n given by the  cat  option to categories of the selected layer. \n These categories (IDs) are used to assign IDs or to group geometry objects\n into categories (several different geometry objects share the same \n category). These categories are also used to link geometry\n object(s) to attribute records (from an attribute table linked to vector map).\n ", "notes": "\n Use  v.to.db  to upload related categories\n to a linked attribute table.\n  The  type  parameter specifies the type of geometry objects to which\n the category is added; it is similar to an input filter - only the\n geometry specified in 'type' is processed.\n  If the  type  parameter is set to  centroid  and\n the  option  parameter set to  add , new categories will be\n added to existing centroids. Note however, that new centroids cannot\n be created this way.  To do so, they must be added manually\n using  wxGUI vector\n digitizer  or by running  v.category  with the type\n parameter set to area.\n  If categories are copied with  option=transfer , a warning is \n issued if categories already exit in the layer they are copied to. In \n this case the user must make sure beforehand that copying categories \n from one layer to another layer does not cause undesired grouping of \n different geometry objects into the same categories. This can be avoided \n by specifying only one  layer . The module will then find the \n next free layer number and copy categories to there. The new layer number \n is reported at the end.\n     \n  Areas are a special case because it is impossible to attach a cat to\n an area without a centroid; in this case, the module places new\n centroids in areas automatically.\n  The  cat  parameter is only used with  option = add , \n  option = sum  and  option = del .\n  Categories can be deleted for the given layer with  option=del . \n If  cat  is set to  -1 , all categories for the given layer \n are deleted. If  cat  is zero or positive, only this category value \n will be deleted. By default,  cat  is set to  1  which means \n that only categories of value  1  will be deleted. \n  The  ids  parameter specifies the list of feature IDs to which the\n operation is performed; by default, all vector feature ids are processed. \n The  feature ID  is an internal (unique) geometry ID that all vector\n primitives possess, and is separate from any category the feature may\n also possess. \n Use  \n    v.edit  map=inputname tool=select\n to find out the geometry ids of certain features.\n  EXAMPLES \n  Report vector categories \n v.category input=testmap option=report\n LAYER/TABLE 1/testmap:\n type       count        min        max\n point          0          0          0\n line        1379          1       1379\n boundary       0          0          0\n centroid       0          0          0\n area           0          0          0\n all         1379          1       1379\n  Delete all vector categories in layer 1 \n v.category input=testmap output=outmap option=del cat=-1\n  Add vector categories in layer 1 with step=2 \n v.category input=outmap output=stepmap option=add step=2\n # report\n v.category input=stepmap option=report\n LAYER/TABLE 1/outmap:\n type       count        min        max\n point          0          0          0\n line        1379          1       2757\n boundary       0          0          0\n centroid       0          0          0\n area           0          0          0\n all         1379          1       2757\n  Add categories/centroids to a vector map without categories \n v.category input=wkt output=wktnew option=add\n Results can be tested\n using  d.what.vect .\n  Copy categories from layer 1 to layer 2,3,4,5,6,7 and 8 \n Existing layer will be overwritten, non-existing will be created.\n v.category input=observer output=observer_new option=transfer layer=1,2,3,4,5,6,7,8\n  Print vector categories of given layer \n Print vector categories from the first layer, only for feature ids 1-50.\n v.category input=roads option=print layer=1 id=1-50\n ", "see_also": ["v.centroids", "v.db.connect", "v.edit", "v.to.db"], "authors": ["Radim Blazek, ITC-irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.category"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.build.polylines.html", "name": "v.build.polylines", "definition": "- Builds polylines from lines or boundaries.", "keywords": ["vector", "topology", "geometry", "line", "node", "vertex"], "synopsis": "v.build.polylines input=name output=name  [cats=string]   [type=string[,string,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category number mode", "defaultValue": "no", "alternatives": ["no", "first", "multi", "same"], "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "line,boundary", "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.build.polylines  builds polylines from the lines or\n boundaries in a vector map.\n  A line is defined by one start node, one end node and any number of\n vertices between the start and end nodes. The shortest possible line\n consists of only two vertices where the coordinates of the start and end\n nodes are identical to those of the two vertices.\n  v.build.polylines  picks a line and from its start node, walks\n back as long as exactly one other line of the same type is connected to\n this node. Line directions are reversed as required, i.e. it does not\n matter if the next line is connected to the current node by its start or\n end node. Once the start line of a polyline is identified, it walks\n forward and adds all vertices (in reverse order if needed) of\n connected lines to the start line, i.e. the start line and connecting\n lines are reversed as needed. That is, if a line is reversed depends\n on what node is initially picked for building polylines. If the\n direction of lines is important (it's not for boundaries to build\n areas), you have to manually change line directions with\n either  v.edit  or\n the  wxGUI vector\n digitizer .\n  Polylines provide the most appropriate representation of curved lines when\n it is important that nodes serve to define topology rather than geometry.\n Curved lines are usually digitized as polylines, but these are sometimes broken\n into their constituent straight line segments during conversion from one data\n format to another.  v.build.polylines  can be used to rebuild such\n broken polylines. \n ", "notes": "\n  v.build.polylines  combines only lines of the same type to\n a new polyline, i.e. lines and boundaries are kept separate.\n  Category number(s) are assigned to a polyline based on  cats  parameter.\n    cats=no  - No category number is assigned to a\n   polyline. Also attributes tables linked to the input vector map are\n   not copied to the output vector map. \n    cats=first  - Assign to a polyline category number of the\n   first line. All linked attributes tables are copied to the output\n   vector map without filtering, but the categories are processed according \n   to the cats option. \n    cats=multi  - If the lines that make up a polyline have\n   different category numbers then  v.build.polylines  will\n   set the multiple category numbers to a polyline.  Also all linked\n   attributes tables are copied to the output vector map. \n    cats=same  - Assigned lines to a polyline have\n   same category numbers in all layers. Linked\n   attributes tables are copied to the output vector map. \n  v.build.polylines  correctly handles  input  vector maps\n containing lines, boundaries, centroids and points. Lines and\n boundaries will be converted to polylines.  Areas\n are guaranteed to be preserved.\n  ACKNOWLEDGEMENTS \n This program was originally written during Mark Lake's tenure of a \n Leverhulme Special Research Fellowship at University College London. \n ", "see_also": ["v.build", "v.in.ascii", "v.edit", "v.split"], "authors": ["Mark Lake, Institute of Archaeology, University College London."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.build.polylines"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.build.html", "name": "v.build", "definition": "- Creates topology for vector map.", "keywords": ["vector", "topology", "geometry"], "synopsis": "v.build [-e] map=name  [error=name]  option=string[,string,...]  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Extensive checks for topological errors Perform in-depth checks for topological errors when building topology Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "error", "flag": "error", "dataType": "String", "optional": true, "explanation": "Name for output vector map where erroneous vector features are written to", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "option", "flag": "option", "dataType": "String", "optional": false, "explanation": "Build topology or dump topology or indices to standard output", "defaultValue": "build", "alternatives": ["build", "dump", "sdump", "cdump", "fdump"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.build  builds support files for GRASS vector maps. These\n support files supply topology and category information including\n spatial index that are needed by other GRASS modules.\n GRASS is generating these support files automatically, only in rare\n cases the user has to (re)build them.\n Refer to\n  vector data processing in GRASS GIS  for\n more information on GRASS vector data model.\n ", "notes": "\n  v.build  creates support files only for vector maps located in\n the user's current mapset. It's not possible to rebuild support files\n ( option=build ) for vector maps from other mapsets.\n In case of errors, the user can optionally generate an  error \n vector map containing the erroneous vectors for later inspection.\n If  error  vector map is specified,  v.build  checks:\n    isolated bondaries (which are not forming any areas), \n    centroids outside of area, \n    duplicated centroids. \n Extensive checks for topological errors (flag  -e ) also\n includes:\n    lines or boundaries of zero length, \n    intersecting boundaries, ie. overlapping areas, \n    areas without centroids that are not isles. \n  EXAMPLES \n  Build topology \n Note that  option=build  recreates also spatial and category\n indices, not only topology. For linked OGR layers\n (see  v.external ) also feature\n index is created.\n v.build map=urbanarea option=build\n Note that the vector map  urbanarea  must be located in the\n current mapset.\n  Dump topology or indices \n Dump options print topology, spatial, category or feature index to\n standard output. Such information can be printed also for vector maps\n from other mapsets. A description of the vector topology is available in\n the  GRASS GIS 7 Programmer's Manual ,\n section \"Vector library topology management\".\n v.build map=urbanarea option=dump\n ", "see_also": ["v.build.all", "v.build.polylines", "v.edit", "v.split"], "authors": ["Dave Gerdes, U.S.Army Construction Engineering Research Laboratory,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.build"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.build.all.html", "name": "v.build.all", "definition": "- Rebuilds topology on all vector maps in the current mapset.", "keywords": ["vector", "topology"], "synopsis": "v.build.all  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}], "description": "", "notes": "", "see_also": [], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.build.all"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.buffer.html", "name": "v.buffer", "definition": "- Creates a buffer around vector features of given type.", "keywords": ["vector", "buffer", "area", "circle", "geometry", "line", "grow", "shrink"], "synopsis": "v.buffer [-sct] input=name  [layer=string]   [cats=range]   [where=sql_query]   [type=string[,string,...]]  output=name  [distance=float]   [minordistance=float]   [angle=float]   [column=name]   [scale=float]   [tolerance=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Make outside corners straight Do not make caps at the ends of polylines Transfer categories and attributes Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Do not make caps at the ends of polylines Transfer categories and attributes Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Transfer categories and attributes Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,area", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": true, "explanation": "Buffer distance along major axis in map units", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "minordistance", "flag": "minordistance", "dataType": "String", "optional": true, "explanation": "Buffer distance along minor axis in map units", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "angle", "flag": "angle", "dataType": "String", "optional": true, "explanation": "Angle of major axis in degrees", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of column to use for buffer distances", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Scaling factor for attribute column values", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tolerance", "flag": "tolerance", "dataType": "String", "optional": true, "explanation": "Maximum distance between theoretical arc and polygon segments as multiple of buffer (default 0.01)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.buffer  creates a buffer around features of\n given  type , which have a category in the\n given  layer . The  tolerance  controls the number of vector\n segments being generated (the smaller the value, the more vector\n segments are generated).\n ", "notes": "\n Internal buffers for areas can be generated with negative distance \n values (\"inward buffer\" or \"negative buffer\" or \"shrinking\").\n  v.buffer  fusions the geometries of buffers by default.\n Categories and attribute table will not be transferred (this would\n not make sense as one buffer geometry can be the result of many\n different input geometries). To transfer the categories and\n attributes the user can set the  t  flag. This will result in\n buffers being cut up where buffers of individual input geometries\n overlap.  Each part that is the result of overlapping buffers of\n multiple geometries will have multiple categories corresponding to\n those geometries, and multiple buffer areas can have the same\n category. The buffer for the input feature with category X can thus\n be retrieved by selecting all buffer areas with category X (see\n example below).\n Buffers for lines and areas are generated using the algorithms from\n the GEOS library.\n  For advanced users:  built-in buffer algorithm no longer\n desired, we use GEOS: If GRASS is not compiled with GEOS support\n or  environmental\n variable   GRASS_VECTOR_BUFFER  is defined, then GRASS\n generates buffers using built-in buffering algorithm (which is still\n buggy for some input data).\n The options  minordistance ,  angle ,  tolerance  are \n kept for backward compatibility and have no effect with GEOS buffering.\n  Corner settings \n The following vector line related corners (also called \"cap\") exist:\n  no cap: \u00a0\u00a0\u00a0\u00a0\u00a0  \n  rounded cap:  \n  square cap:  \n By default  v.buffer  creates rounded buffers (blue color on\n figure below): \n    \n Straight corners with caps are created by  -s  flag (red color on\n the figure below), while  -c  flag doesn't make caps at the ends of\n polylines (green color on the figure below):\n    \n    \n Using  -s  with a point vector map as input data, square buffers are \n created instead of round buffers.\n    \n  EXAMPLES \n All examples are based on the North Carolina sample dataset.\n  Buffer around input lines \n v.buffer input=roadsmajor output=roadsmajor_buffer type=line distance=100\n Buffer of 100m along the \"roadsmajor\" lines (map subset, original center line\n shown in black)\n  Circles around input points \n v.buffer input=hospitals output=hospitals_circled type=point distance=2000 \n Buffer of 2000m around the \"hospitals\" points (map subset, original points\n shown in black, new area centroids in red)\n  Circles around input points with attribute transfer \n v.buffer input=hospitals output=hospitals_circled type=point distance=1000 -t\n # display buffer around hospital with category 36,\n # this buffer is composed of several areas:\n d.vect map=hospitals_circled type=area layer=1 cats=36\n # extract this buffer, dissolving boundaries\n v.extract in=hospitals_circled output=hospital_36_circled layer=1 cats=36 -d\n  Buffer around input areas \n v.buffer input=lakes output=lakes_buffer type=area distance=100\n Buffer of 100m around the \"lakes\" polygons (map subset, original areas\n shown in black)\n  Buffer inside input areas \n In this example, an internal buffer (\"inward buffer\" or \"negative buffer\")\n is generated using a negative  distance  value:\n v.buffer input=lakes output=lakes_buffer type=area distance=-50\n Internal buffer of 50m inside the \"lakes\" polygons (map subset, original areas\n shown in black)  \n Not all features are buffered, only the polygons that allow creation inside\n a topological cleaned polygon.\n  REFERENCES \n  GEOS Library \n ", "see_also": ["r.buffer", "v.parallel", "v.extract", "v.type", "v.patch", "v.db.connect"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.buffer"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/test.raster3d.lib.html", "name": "test.raster3d.lib", "definition": "- Performs unit and integration tests for the raster3d library", "keywords": ["raster3d", "unit test"], "synopsis": "test.raster3d.lib [-ul]  [unit=string]   [depths=integer]   [rows=integer]   [cols=integer]   [tile_size=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "u", "flag": "-u", "explanation": "Run all unit tests Switch zip compression on Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Switch zip compression on Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "unit", "flag": "unit", "dataType": "String", "optional": true, "explanation": "Choose the unit tests to run", "defaultValue": null, "alternatives": ["coord", "putget", "large"], "isInputFile": false, "isOutputFile": false}, {"parameter": "depths", "flag": "depths", "dataType": "String", "optional": true, "explanation": "The number of depths to be used for the large file put/get value test", "defaultValue": "20", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rows", "flag": "rows", "dataType": "String", "optional": true, "explanation": "The number of rows to be used for the large file put/get value test", "defaultValue": "5400", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cols", "flag": "cols", "dataType": "String", "optional": true, "explanation": "The number of columns to be used for the large file put/get value test", "defaultValue": "10800", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tile_size", "flag": "tile_size", "dataType": "String", "optional": true, "explanation": "The tile size in kilo bytes to be used for the large file put/get value test. Set the tile size to 2048 and the number of row*cols*depths > 130000 to reproduce the tile rle error.", "defaultValue": "32", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "", "notes": "", "see_also": [], "authors": ["S\u00f6ren Gebbert"], "source_code": null},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/test.r3flow.html", "name": "test.r3flow", "definition": "- Testing flow lines.", "keywords": ["raster3d", "unit test"], "synopsis": "test.r3flow test=string  [coordinates=float[,float,...]]   [input=name[,name,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "test", "flag": "test", "dataType": "String", "optional": false, "explanation": "Select what is tested", "defaultValue": null, "alternatives": ["interpolation", "gradient"], "isInputFile": false, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "x,y,z coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input 3D raster map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}], "description": "\n Testing module for  r3.flow .\n  AUTHORS \n Anna Petrasova\n ", "notes": "", "see_also": ["r3.flow"], "authors": ["Anna Petrasova"], "source_code": null},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.vect.what.strds.html", "name": "t.vect.what.strds", "definition": "- Stores raster map values at spatial and temporal positions of vector points as vector attributes.", "keywords": ["temporal", "sampling", "vector", "time"], "synopsis": "t.vect.what.strds input=name strds=name  [column=string]  method=string  [where=sql_query]   [t_where=sql_query]   [sampling=name[,name,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "strds", "flag": "strds", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of the vector column to be created and to store sampled raster values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Aggregate operation to be performed on the raster maps", "defaultValue": "disabled", "alternatives": ["disabled", "average", "count", "median", "mode", "minimum", "min_raster", "maximum", "max_raster", "stddev", "range", "sum", "variance", "diversity", "slope", "offset", "detcoeff", "quart1", "quart3", "perc90", "quantile", "skewness", "kurtosis"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "t_where", "flag": "t_where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sampling", "flag": "sampling", "dataType": "String", "optional": true, "explanation": "The method to be used for sampling the input dataset", "defaultValue": "start", "alternatives": ["start", "during", "overlap", "contain", "equal", "follows", "precedes"], "isInputFile": false, "isOutputFile": false}], "description": "\n The module  t.vect.what.strds  samples a space time raster dataset \n (STRDS) at the spatio-temporal locations of a space time vector dataset (STVDS).\n  EXAMPLE \n The example is based on the space time vector dataset \"precip_stations@climate_2009_2012\"\n created in the  t.vect.observe.strds  example.\n In the example below, the module fills the new column \"new_temp\" with values\n extracted from the \"tempmean_monthly\" space time raster dataset:\n t.vect.what.strds input=precip_stations@climate_2009_2012 \n                    strds=tempmean_monthly@climate_2009_2012 \n                    column=new_temp method=average\n ", "notes": "", "see_also": ["r.univar", "v.univar", "v.what.rast", "v.what.rast3", "v.what.strds", "v.what.vect", "t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.vect.what.strds"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.vect.univar.html", "name": "t.vect.univar", "definition": "- Calculates univariate statistics of attributes for each registered vector map of a space time vector dataset", "keywords": ["temporal", "statistics", "vector", "time"], "synopsis": "t.vect.univar [-eu] input=name  [output=name]   [layer=string]  column=name  [twhere=sql_query]   [where=sql_query]   [type=string]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Calculate extended statistics Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "u", "flag": "-u", "explanation": "Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "twhere", "flag": "twhere", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator character between the output columns", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n The module  t.vect.univar  computes univariate statistics of a\n space time vector dataset based on a single attribute row.\n  EXAMPLE \n The example is based on the  t.vect.observe.strds \n example; so create the  precip_stations  space time vector dataset\n and after run the following command:\n t.vect.univar input=precip_stations col=month\n id|start|end|n|nmissing|nnull|min|max|range|mean|mean_abs|population_stddev|population_variance|population_coeff_variation|sample_stddev|sample_variance|kurtosis|skewness\n precip_stations_monthly@climate_2009_2012|2009-01-01 00:00:00|2009-02-01 00:00:00|132|0|4|-2.31832|7.27494|9.59326|3.44624|3.5316|1.79322|3.21564|0.520341|1.80005|3.24019|0.484515|-0.338519\n precip_stations_monthly@climate_2009_2012|2009-02-01 00:00:00|2009-03-01 00:00:00|132|0|4|-0.654152|7.90613|8.56028|5.47853|5.48844|1.73697|3.01708|0.317051|1.74359|3.04011|0.875252|-1.0632\n ....\n precip_stations_monthly@climate_2009_2012|2012-10-01 00:00:00|2012-11-01 00:00:00|132|0|4|9.67596|18.4654|8.78945|14.945|14.945|1.90659|3.6351|0.127574|1.91386|3.66285|-0.0848967|-0.700833\n precip_stations_monthly@climate_2009_2012|2012-11-01 00:00:00|2012-12-01 00:00:00|132|0|4|3.56755|10.6211|7.05357|7.72153|7.72153|1.33684|1.78715|0.173132|1.34194|1.8008|0.90434|-0.863935\n precip_stations_monthly@climate_2009_2012|2012-12-01 00:00:00|2013-01-01 00:00:00|132|0|4|3.04325|11.6368|8.5935|8.20147|8.20147|1.78122|3.17275|0.217183|1.78801|3.19697|-0.177991|-0.501295\n ", "notes": "", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.vect.univar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.vect.observe.strds.html", "name": "t.vect.observe.strds", "definition": "- Observes specific locations in a space time raster dataset over a period of time using vector points.", "keywords": ["temporal", "sampling", "vector", "time"], "synopsis": "t.vect.observe.strds input=name strds=name[,name,...] output=name vector_output=name columns=string[,string,...]  [where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "strds", "flag": "strds", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "vector_output", "flag": "vector_output", "dataType": "String", "optional": false, "explanation": "Name of the new created vector map that stores the sampled values in different layers", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": false, "explanation": "Names of the vector columns to be created and to store sampled raster values, one name for each STRDS", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The module  t.vect.observe.strds  is used to observe specific\n locations in a space time raster dataset over a period of time using\n vector points.\n The first input is a vector map layer with vector points. The second \n input is one or several space time raster datasets (STRDS) that should \n be sampled over time at the vector point positions. The space time \n raster dataset will be sampled over its whole temporal extent (from \n start to end). A column name must be specified for each input space\n time raster dataset.\n The result is a new space time vector dataset that contains a single\n (new) vector map which links to as many time-stamped attribute tables\n as raster map layers are present in the input space time raster dataset. \n Hence, for each time step in the space time raster dataset a new \n attribute table is created. The GRASS GIS Temporal Framework allows \n to time stamp attribute tables that can be linked to a single vector \n map layer.\n The module  v.what.rast  is used internally for sampling the \n time stamped raster map layers. All sampled values of a single time \n stamped raster map layer are written into a new time stamped attribute \n table.\n Use  t.vect.db.select  to print attribute values of the space\n time vector dataset to stdout.\n  EXAMPLE \n The example shows how to create a space time vector dataset and a vector\n layer starting from a point vector and a space time raster dataset:\n t.vect.observe.strds input=precip_30ynormals_3d strds=tempmean_monthly \n                       output=precip_stations vect=precip_stations_monthly \n                       columns=month\n t.info precip_stations type=stvds\n  +-------------------- Space Time Vector Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precip_stations@climate_2009_2012\n  | Name: ...................... precip_stations\n  | Mapset: .................... climate_2009_2012\n  | Creator: ................... lucadelu\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-12-02 00:42:39.187615\n  | Modification time:.......... 2014-12-02 00:42:55.215169\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2009-01-01 00:00:00\n  | End time:................... 2013-01-01 00:00:00\n  | Granularity:................ 1 month\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 306221.830194\n  | South:...................... 27606.895351\n  | East:.. .................... 917004.829165\n  | West:....................... 151768.568246\n  | Top:........................ 1615.44\n  | Bottom:..................... 2.4384\n  +-------------------- Metadata information ----------------------------------+\n  | Vector register table:...... vector_map_register_be074525097c4088997c9a1979f17065\n  | Number of points ........... 6664\n  | Number of lines ............ 0\n  | Number of boundaries ....... 0\n  | Number of centroids ........ 0\n  | Number of faces ............ 0\n  | Number of kernels .......... 0\n  | Number of primitives ....... 6664\n  | Number of nodes ............ 0\n  | Number of areas ............ 0\n  | Number of islands .......... 0\n  | Number of holes ............ 0\n  | Number of volumes .......... 0\n  | Number of registered maps:.. 49\n  |\n  | Title:\n  | Observaion of space time raster dataset(s) tempmean_monthly\n  | Description:\n  | Observation of space time raster dataset(s) tempmean_monthly with vector map precip_30ynormals_3d\n  | Command history:\n  | # 2014-12-02 00:42:39\n  | t.vect.observe.strds input=\"precip_30ynormals_3d\"\n  |     strds=\"tempmean_monthly\" output=\"precip_stations\"\n  |     vect=\"precip_stations_monthly\" columns=\"month\"\n  |\n  +----------------------------------------------------------------------------+\n v.info precip_stations_monthly\n  +----------------------------------------------------------------------------+\n  | Name:            precip_stations_monthly                                   |\n  | Mapset:          climate_2009_2012                                         |\n  | Location:        nc_spm_temporal_workshop                                  |\n  | Database:        /grassdata                                                |\n  | Title:           North Carolina 30 year precipitation normals (3D)         |\n  | Map scale:       1:1                                                       |\n  | Name of creator: neteler                                                   |\n  | Organization:                                                              |\n  | Source date:     Wed May  9 14:32:39 2007                                  |\n  | Timestamp (first layer): none                                              |\n  |----------------------------------------------------------------------------|\n  | Map format:      native                                                    |\n  |----------------------------------------------------------------------------|\n  |   Type of map: vector (level: 2)                                           |\n  |                                                                            |\n  |   Number of points:       136             Number of centroids:  0          |\n  |   Number of lines:        0               Number of boundaries: 0          |\n  |   Number of areas:        0               Number of islands:    0          |\n  |   Number of faces:        0               Number of kernels:    0          |\n  |   Number of volumes:      0               Number of holes:      0          |\n  |                                                                            |\n  |   Map is 3D:              Yes                                              |\n  |   Number of dblinks:      49                                               |\n  |                                                                            |\n  |   Projection: Lambert Conformal Conic                                      |\n  |                                                                            |\n  |               N:     306221.830194    S:      27606.895351                 |\n  |               E:     917004.829165    W:     151768.568246                 |\n  |               B:            2.4384    T:           1615.44                 |\n  |                                                                            |\n  |   Digitization threshold: 0                                                |\n  |   Comment:                                                                 |\n  |                                                                            |\n  +----------------------------------------------------------------------------+\n ", "notes": "", "see_also": ["t.create", "t.info", "t.vect.db.select", "t.vect.what.strds"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.vect.observe.strds"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.vect.list.html", "name": "t.vect.list", "definition": "- Lists registered maps of a space time vector dataset.", "keywords": ["temporal", "map management", "vector", "list", "time"], "synopsis": "t.vect.list [-u] input=name  [order=string[,string,...]]   [columns=string[,string,...]]   [where=sql_query]   [method=string]   [separator=character]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "u", "flag": "-u", "explanation": "Suppress printing of column names Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Sort the space time dataset by category", "defaultValue": "start_time", "alternatives": ["id", "name", "layer", "creator", "mapset", "temporal_type", "creation_time", "start_time", "end_time", "north", "south", "west", "east", "points", "lines", "boundaries", "centroids", "faces", "kernels", "primitives", "nodes", "areas", "islands", "holes", "volumes"], "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Columns to be printed to stdout", "defaultValue": "name,layer,mapset,start_time,end_time", "alternatives": ["id", "name", "layer", "creator", "mapset", "temporal_type", "creation_time", "start_time", "end_time", "north", "south", "west", "east", "points", "lines", "boundaries", "centroids", "faces", "kernels", "primitives", "nodes", "areas", "islands", "holes", "volumes"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Method used for data listing", "defaultValue": "cols", "alternatives": ["cols", "comma", "delta", "deltagaps", "gran"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator character between the output columns", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n This module provides the same functionality as\n  t.rast.list , the only difference is the\n vector map layer metadata.\n  EXAMPLE \n  Default query \n This example show a relative space time vector dataset with the first\n three maps with a range of years, instead the last five are valid only\n for one year:\n t.vect.list shoreline@shoreline\n name|layer|mapset|start_time|end_time\n shoreline_1849_1873|None|shoreline|1849|1873\n shoreline_1925_1946|None|shoreline|1925|1946\n shoreline_1970_1988|None|shoreline|1970|1988\n shoreline_1997|None|shoreline|1997|None\n shoreline_1998|None|shoreline|1998|None\n shoreline_2003|None|shoreline|2003|None\n shoreline_2004|None|shoreline|2004|None\n shoreline_2009|None|shoreline|2009|None\n  Using method option \n Method option is able to show vector in different way. By default  cols \n value is used, the value  deltagaps  will print the delta between\n maps and also the gaps if they exist (like in this example).\n t.vect.list method=deltagaps input=shoreline\n id|name|layer|mapset|start_time|end_time|interval_length|distance_from_begin\n shoreline_1849_1873@shoreline|shoreline_1849_1873|None|shoreline|1849|1873|24|0\n None|None|None|None|1873|1925|52|24\n shoreline_1925_1946@shoreline|shoreline_1925_1946|None|shoreline|1925|1946|21|76\n None|None|None|None|1946|1970|24|97\n shoreline_1970_1988@shoreline|shoreline_1970_1988|None|shoreline|1970|1988|18|121\n None|None|None|None|1988|1997|9|139\n shoreline_1997@shoreline|shoreline_1997|None|shoreline|1997|None|None|148\n None|None|None|None|1997|1998|1|148\n shoreline_1998@shoreline|shoreline_1998|None|shoreline|1998|None|None|149\n None|None|None|None|1998|2003|5|149\n shoreline_2003@shoreline|shoreline_2003|None|shoreline|2003|None|None|154\n None|None|None|None|2003|2004|1|154\n shoreline_2004@shoreline|shoreline_2004|None|shoreline|2004|None|None|155\n None|None|None|None|2004|2009|5|155\n shoreline_2009@shoreline|shoreline_2009|None|shoreline|2009|None|None|160\n ", "notes": "", "see_also": ["g.list", "t.create", "t.info", "t.list", "t.rast.list", "t.rast3d.list"], "authors": ["S\u00f6ren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.vect.list"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.vect.import.html", "name": "t.vect.import", "definition": "- Imports a space time vector dataset from a GRASS GIS specific archive file.", "keywords": ["temporal", "import", "vector", "time", "create location"], "synopsis": "t.vect.import [-eoc] input=name output=name  [basename=string]  directory=name  [title=string]   [description=string]   [location=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Extend location extents based on new dataset Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the space time vector datasets. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the space time vector datasets. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Create the location specified by the \"location\" parameter and exit. Do not import the space time vector datasets. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": true, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "directory", "flag": "directory", "dataType": "String", "optional": false, "explanation": "Path to the extraction directory", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title of the new space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "description", "flag": "description", "dataType": "String", "optional": true, "explanation": "Description of the new space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Create a new location and import the data into it. Do not run this module in parallel or interrupt it when a new location should be created", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.vect.import  imports a space time vector dataset archive that\n was exported with  t.vect.export .\n ", "notes": "\n Optionally a base map name can be provided to avoid that existing\n vector maps are overwritten by the map names that are used in the STRDS\n archive.\n The  directory  is used as work directory in case of import but\n can also be used as a data directory when using GML for the data\n exchange.\n  EXAMPLE \n In this example, five vector maps are created and registered in a single space time \n vector dataset named  random_locations . Each vector map represents\n random locations within the boundary of the state taken at 1 month intervals.\n The space time dataset is then exported and re-imported.\n db.connect -d\n for i in `seq 1 5` ; do\n     v.random output=map_$i n=500 restrict=boundary_state@PERMANENT\n     echo map_$i >> map_list.txt\n done\n t.create type=stvds temporaltype=absolute \n           output=random_locations \n           title=\"Random locations\" \n           description=\"Vector test dataset with random locations\"\n t.register -i type=vector input=random_locations \n             file=map_list.txt start=\"2012-01-01\" increment=\"1 months\"\n t.vect.list random_locations\n t.vect.export input=random_locations output=random_locations.tar.gz \n                compression=gzip\n t.vect.import input=random_locations.tar.gz output=new_random_locations \n                basename=new_map directory=/tmp\n t.vect.list new_random_locations\n id|name|layer|mapset|start_time|end_time\n new_map_1@user1|new_map_1|None|user1|2012-01-01 00:00:00|2012-02-01 00:00:00\n new_map_2@user1|new_map_2|None|user1|2012-02-01 00:00:00|2012-03-01 00:00:00\n new_map_3@user1|new_map_3|None|user1|2012-03-01 00:00:00|2012-04-01 00:00:00\n new_map_4@user1|new_map_4|None|user1|2012-04-01 00:00:00|2012-05-01 00:00:00\n new_map_5@user1|new_map_5|None|user1|2012-05-01 00:00:00|2012-06-01 00:00:00\n ", "see_also": ["t.vect.export", "t.create", "t.info", "v.in.ogr", "v.pack", "t.rast.import"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.vect.import"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.vect.extract.html", "name": "t.vect.extract", "definition": "- Extracts a subset of a space time vector dataset.", "keywords": ["temporal", "extract", "vector", "time"], "synopsis": "t.vect.extract [-n] input=name  [where=sql_query]   [expression=sql_query]  output=name  [layer=string]   [type=string[,string,...]]   [basename=string]   [suffix=string]   [nprocs=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Register empty maps Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of the output space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid,area", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": true, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "suffix", "flag": "suffix", "dataType": "String", "optional": true, "explanation": "Suffix to add at basename: set 'gran' for granularity, 'time' for the full time format, 'num' for numerical suffix with a specific number of digits (default %05)", "defaultValue": "gran", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "The number of v.extract processes to run in parallel. Use only if database backend is used which supports concurrent writing", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The purpose of  t.vect.extract  is to extract a subset of a space \n time vector dataset and to store that subset in a different space time \n vector dataset.\n  EXAMPLE \n In the following example a new space time vector dataset will be create\n with all the data later than 2000:\n t.vect.extract input=shoreline where=\"start_time > 2000\" \n                 output=shoreline_later_2000 basename=new_shoreline\n t.info shoreline_later_2000@shoreline type=stvds\n  +-------------------- Space Time Vector Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ shoreline_later_2000@shoreline\n  | Name: ...................... shoreline_later_2000\n  | Mapset: .................... shoreline\n  | Creator: ................... lucadelu\n  | Temporal type: ............. relative\n  | Creation time: ............. 2014-11-29 08:43:50.043219\n  | Modification time:.......... 2014-11-29 08:43:50.085407\n  | Semantic type:.............. mean\n  +-------------------- Relative time -----------------------------------------+\n  | Start time:................. 2003\n  | End time:................... 2009\n  | Relative time unit:......... years\n  | Granularity:................ 1\n  | Temporal type of maps:...... point\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 1039175.31479\n  | South:...................... 34705.216018\n  | East:.. .................... 3052322.44671\n  | West:....................... 2130004.16779\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Vector register table:...... vector_map_register_8395740fc8de42149fef74a3d25bbb05\n  | Number of points ........... 0\n  | Number of lines ............ 407\n  | Number of boundaries ....... 0\n  | Number of centroids ........ 0\n  | Number of faces ............ 0\n  | Number of kernels .......... 0\n  | Number of primitives ....... 407\n  | Number of nodes ............ 767\n  | Number of areas ............ 0\n  | Number of islands .......... 0\n  | Number of holes ............ 0\n  | Number of volumes .......... 0\n  | Number of registered maps:.. 3\n  |\n  | Title:\n  | North Carolina shoreline\n  | Description:\n  | North Caroline shoreline from 2000 to 2009\n  | Command history:\n  | # 2014-11-29 08:43:50 \n  | t.vect.extract input=\"shoreline\"\n  |     where=\"start_time > 2000\" output=\"shoreline_later_2000\"\n  |     basename=\"new_shoreline\"\n  | # 2014-11-29 08:44:14 \n  | t.support type=\"stvds\"\n  |     input=\"shoreline_later_2000@shoreline\"\n  |     descr=\"North Caroline shoreline from 2000 to 2009\"\n  +----------------------------------------------------------------------------+\n t.vect.list shoreline_later_2000\n name|layer|mapset|start_time|end_time\n shoreline_2003|None|shoreline|2003|None\n shoreline_2004|None|shoreline|2004|None\n shoreline_2009|None|shoreline|2009|None\n ", "notes": "", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.vect.extract"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.vect.export.html", "name": "t.vect.export", "definition": "- Exports a space time vector dataset as GRASS GIS specific archive file.", "keywords": ["temporal", "export", "vector", "time"], "synopsis": "t.vect.export input=name output=name  [directory=name]   [compression=string]   [format=string]   [where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of a space time vector dataset archive", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "directory", "flag": "directory", "dataType": "String", "optional": true, "explanation": "Path to the work directory, default is /tmp", "defaultValue": "/tmp", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "compression", "flag": "compression", "dataType": "String", "optional": true, "explanation": "Compression method of the tar archive", "defaultValue": "bzip2", "alternatives": ["no", "gzip", "bzip2"], "isInputFile": false, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "The export format of a single vector map", "defaultValue": "GML", "alternatives": ["GML", "pack"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.vect.export  exports a space time vector dataset (stvds)\n to a tar archive as either GML (using  v.out.ogr )\n or GRASS pack files. In addition to the pack or GML files, several\n metadata files are also created in the archive that describe the\n temporal layout. All time stamps are stored in the file \"list.txt\",\n for each map one row. The name of the map, the start time and the\n end time are written. In case of a time instance, the start time is\n equal to the end time. The \"init.txt\" file stores the temporal type,\n the number of maps, the chosen export format and some other\n metadata. The \"proj.txt\" file stores the projection information as a\n proj4 string of the location the space time vector dataset was\n exported from. The file \"readme.txt\" describes the file format. The\n output of  v.info  for each vector map in the space time dataset is\n stored in \"metadata.txt\".\n The tar archive can be compressed using the  compress  option. Gzip\n and bzip2 (default) are available. A  where  option can be specified,\n to export only a subset of the space time dataset. Archives exported\n with  t.vect.export  can be imported with\n  t.vect.import .\n ", "notes": "\n The name of output file has to carry the suffix of the archive type, the\n following suffix can be used:\n  .tar  in the case of  compress=no \n  .tar.bzip2  in the case of  compress=bzip2 \n  .tar.gzip  in the case of  compress=gzip \n  EXAMPLE \n In this example, five vector maps are created and\n registered in a single space time vector dataset named  random_locations .\n Each vector map represents random locations\n within the boundary of the state taken at 1 month intervals.\n t.vect.export input=shoreline output=shoreline_nc.tar.bzip2\n tar xvfj shoreline_nc.tar.bzip2\n shoreline_1849_1873.xml\n shoreline_1849_1873.xsd\n shoreline_1925_1946.xml\n shoreline_1925_1946.xsd\n shoreline_1970_1988.xml\n shoreline_1970_1988.xsd\n shoreline_1997.xml\n shoreline_1997.xsd\n shoreline_1998.xml\n shoreline_1998.xsd\n shoreline_2003.xml\n shoreline_2003.xsd\n shoreline_2004.xml\n shoreline_2004.xsd\n shoreline_2009.xml\n shoreline_2009.xsd\n list.txt\n proj.txt\n init.txt\n readme.txt\n metadata.txt\n cat init.txt\n stds_type=stvds\n format=GML\n temporal_type=relative\n semantic_type=mean\n relative_time_unit=years\n number_of_maps=8\n north=1039175.31479\n south=9403.301982\n east=3052352.00337\n west=651481.84739\n cat proj.txt\n +proj=lcc\n +lat_1=36.16666666666666\n +lat_2=34.33333333333334\n +lat_0=33.75\n +lon_0=-79\n +x_0=609601.22\n +y_0=0\n +no_defs\n +a=6378137\n +rf=298.257222101\n +towgs84=0.000,0.000,0.000\n +to_meter=1\n cat list.txt\n shoreline_1849_1873|1849|1873\n shoreline_1925_1946|1925|1946\n shoreline_1970_1988|1970|1988\n shoreline_1997|1997|1997\n shoreline_1998|1998|1998\n shoreline_2003|2003|2003\n shoreline_2004|2004|2004\n shoreline_2009|2009|2009\n cat readme.txt\n This space time vector dataset was exported with t.vect.export of GRASS GIS 7\n Files:\n        *.xml  -- Vector GML files\n      proj.txt -- Projection information in PROJ.4 format\n      init.txt -- GRASS GIS space time vector dataset information\n      list.txt -- Time series file, lists all maps by name with interval\n                  time stamps in ISO-Format. Field separator is |\n  metadata.txt -- The output of t.info\n    readme.txt -- This file\n ", "see_also": ["t.vect.import", "t.create", "t.info", "v.out.ogr", "v.unpack", "t.rast.export"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.vect.export"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.vect.db.select.html", "name": "t.vect.db.select", "definition": "- Prints attributes of vector maps registered in a space time vector dataset.", "keywords": ["temporal", "attribute table", "vector", "database", "select", "time"], "synopsis": "t.vect.db.select input=name  [columns=name[,name,...]]   [separator=character]   [layer=string]   [where=sql_query]   [t_where=sql_query]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time vector dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Name of attribute column(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator character between the output columns", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "t_where", "flag": "t_where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The module  t.vect.db.select  prints attributes of vector maps\n registered in a space time vector dataset.\n  EXAMPLE \n The example is querying the  shoreline  space time dataset:\n t.vect.db.select input=shoreline\n start_time|end_time|cat|DESCR|SOURCE|DATE\n 1849|1873|1|T-736|NOAA/USGS|01/01/1858\n 1849|1873|2|T-657|NOAA/USGS|01/01/1857\n 1849|1873|3|T-381(2)|NOAA/USGS|01/01/1852\n 1849|1873|4|T-381(1)|NOAA/USGS|01/01/1852\n 1849|1873|5|T-381(1)|NOAA/USGS|01/01/1852\n ...\n 2009||44|2009 USDA NAIP|2009-07-11|VA, SAND, Wet / Dry\n 2009||45|2009 USDA NAIP|2009-07-11|Carolina Beach, SAND, Wet / Dry\n 2009||46|2009 USDA NAIP|2009-07-11|Carolina Beach, REVETMENT-ROCK, Hard Structure\n 2009||47|2009 USDA NAIP|2009-07-11|Fort Fisher, REVETMENT-ROCK, Hard Structure\n In the following example it print only DATE and SOURCE columns for data\n before 1900-01-01.\n t.vect.db.select input=shoreline column=DATE,SOURCE t_where=\"start_time < 1900\"\n start_time|end_time|DATE|SOURCE\n 1849|1873|01/01/1858|NOAA/USGS\n 1849|1873|01/01/1857|NOAA/USGS\n 1849|1873|01/01/1852|NOAA/USGS\n 1849|1873|01/01/1852|NOAA/USGS\n ...\n 1849|1873|01/01/1860|NOAA/USGS\n 1849|1873|01/01/1860|NOAA/USGS\n 1849|1873|01/01/1873|Coastal Carolina University\n 1849|1873|01/01/1873|Coastal Carolina University\n 1849|1873|01/01/1873|Coastal Carolina University\n ", "notes": "", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.vect.db.select"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.vect.algebra.html", "name": "t.vect.algebra", "definition": "- Apply temporal and spatial operations on space time vector datasets using temporal vector algebra.", "keywords": ["temporal", "algebra", "vector", "time"], "synopsis": "t.vect.algebra [-s] expression=expression basename=basename  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Check the spatial topology of temporally related maps and process only spatially related maps Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": false, "explanation": "Spatio-temporal mapcalc expression", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "basename", "flag": "basename", "dataType": "String", "optional": false, "explanation": "Basename of the new generated output maps", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.vect.algebra  performs temporal and spatial overlay and\n buffer functions on space time vector datasets (STVDS) by using the\n temporal vector algebra. New STVDS can be created, which are\n expressions of existing STVDS.\n  PROGRAM USE \n The module expects an  expression  as input parameter in the following form:\n \"result = expression\"\n The statement structure is similar to r.mapcalc, see  r.mapcalc .\n Where  result  represents the name of a space time dataset (STVDS) that will\n contain the result of the calculation that is given as  expression \n on the right side of the equality sign.\n These expression can be any valid or nested combination of temporal \n operations and functions that are provided by the temporal vector \n algebra. \n The algebra provides methods for map selection from STDS based on their \n temporal relations. It is also possible to temporally shift maps, to \n create temporal buffer and to snap time instances to create a valid \n temporal topology. Furthermore expressions can be nested and evaluated \n in conditional statements (if, else statements). Within if-statements \n the algebra provides temporal variables like start time, end time, day \n of year, time differences or number of maps per time interval to build \n up conditions. These operations can be assigned to space time datasets \n or to the results of operations between space time datasets.\n The type of the input space time datasets must be defined \n with the input parameter  type . Possible options are STRDS, STVDS \n or STR3DS. The default is set to space time raster datasets (STRDS). \n   As default, topological relationships between space time datasets \n will be evaluated only temporal. Use the  s  flag to activate the \n additionally spatial topology evaluation.   The expression option \n must be passed as  quoted  expression, for example:  \n t.select expression=\"C = A : B\"\n Where  C  is the new space time raster dataset that will contain \n maps from  A  that are selected by equal temporal relationships to \n the existing dataset  B  in this case.\n  TEMPORAL VECTOR ALGEBRA \n The temporal algebra provides a wide range of temporal operators and\n functions that will be presented in the following section.  \n  TEMPORAL RELATIONS \n Several temporal topology relations between registered maps of space\n time datasets are supported:  \n equals            A ------\n                   B ------\n during            A  ----\n                   B ------\n contains          A ------\n                   B  ----\n starts            A ----\n                   B ------\n started           A ------\n                   B ----\n finishs           A   ----\n                   B ------\n finished          A ------\n                   B   ----\n precedes          A ----\n                   B     ----\n follows           A     ----\n                   B ----\n overlapped        A   ------\n                   B ------\n overlaps          A ------\n                   B   ------\n over              booth overlaps and overlapped\n The relations must be read as: A is related to B, like - A equals B - A is\n during B - A contains B  \n Topological relations must be specified in {} parentheses.  \n  TEMPORAL OPERATORS \n The temporal algebra defines temporal operators that can be combined \n with other operators to perform spatio-temporal operations. The \n temporal operators process the time instances and intervals of two \n temporal related maps and calculate the result temporal extent by five \n different possibilities.\n LEFT REFERENCE     l       Use the time stamp of the left space time dataset\n INTERSECTION       i       Intersection\n DISJOINT UNION     d       Disjoint union\n UNION              u       Union\n RIGHT REFERENCE    r       Use the time stamp of the right space time dataset\n  TEMPORAL SELECTION \n The temporal selection simply selects parts of a space time dataset without\n processing raster or vector data.\n The algebra provides a selection operator  :  that selects parts\n of a space time dataset that are temporally equal to parts of a second one\n by default. The following expression\n C = A : B\n means: Select all parts of space time dataset A that are equal to B and \n store it in space time dataset C. The parts are time stamped maps.\n   \n In addition the inverse selection operator  !:  is defined as \n the complement of the selection operator, hence the following \n expression\n C = A !: B\n means: select all parts of space time time dataset A that are not equal to B\n and store it in space time dataset (STDS) C. \n To select parts of a STDS by different topological relations to other \n STDS, the temporal topology selection operator can be used. The \n operator consists of the temporal selection operator, the topological \n relations, that must be separated by the logical OR operator  |  \n and the temporal extent operator. All three parts are separated by \n comma and surrounded by curly braces:\n {\"temporal selection operator\", \"topological relations\", \"temporal operator\"}\n Examples:\n C = A {:, equals} B\n C = A {!:, equals} B\n We can now define arbitrary topological relations using the OR operator \"|\"\n to connect them:\n C = A {:,equals|during|overlaps} B\n Select all parts of A that are equal to B, during B or overlaps B.  \n In addition we can define the temporal extent of the result STDS by adding the\n temporal operator.\n C = A {:, during,r} B\n Select all parts of A that are during B and use the temporal extents\n from B for C.\n The selection operator is implicitly contained in the temporal topology\n selection operator, so that the following statements are exactly the same:\n C = A : B\n C = A {:} B\n C = A {:,equal} B\n C = A {:,equal,l} B\n Same for the complementary selection:\n C = A !: B\n C = A {!:} B\n C = A {!:,equal} B\n C = A {!:,equal,l} B\n  CONDITIONAL STATEMENTS \n Selection operations can be evaluated within conditional statements.\n Note A and B can either be space time datasets or expressions. The temporal \n relationship between the conditions and the conclusions can be defined at the \n beginning of the if statement. The relationship between then and else conclusion \n must be always equal.\n if statement                           decision option                        temporal relations\n   if(if, then, else)\n   if(conditions, A)                    A if conditions are True;              temporal topological relation between if and then is equal.\n   if(conditions, A, B)                 A if conditions are True, B otherwise; temporal topological relation between if, then and else is equal.\n   if(topologies, conditions, A)        A if conditions are True;              temporal topological relation between if and then is explicit specified by topologies.\n   if(topologies, conditions, A, B)     A if conditions are True, B otherwise; temporal topological relation between if, then and else is explicit specified by topologies.\n  Logical operators \n Symbol  description\n   ==    equal\n   !=    not equal\n   >     greater than\n   >=    greater than or equal\n   <     less than\n   <=    less than or equal\n   &&    and\n   ||    or\n  Temporal functions \n The following temporal function are evaluated only for the STDS that \n must be given in parenthesis.\n td(A)                    Returns a list of time intervals of STDS A\n start_time(A)            Start time as HH::MM:SS\n start_date(A)            Start date as yyyy-mm-DD\n start_datetime(A)        Start datetime as yyyy-mm-DD HH:MM:SS\n end_time(A)              End time as HH:MM:SS\n end_date(A)              End date as yyyy-mm-DD\n end_datetime(A)          End datetime as  yyyy-mm-DD HH:MM\n start_doy(A)             Day of year (doy) from the start time [1 - 366]\n start_dow(A)             Day of week (dow) from the start time [1 - 7], the start of the week is Monday == 1\n start_year(A)            The year of the start time [0 - 9999]\n start_month(A)           The month of the start time [1 - 12]\n start_week(A)            Week of year of the start time [1 - 54]\n start_day(A)             Day of month from the start time [1 - 31]\n start_hour(A)            The hour of the start time [0 - 23]\n start_minute(A)          The minute of the start time [0 - 59]\n start_second(A)          The second of the start time [0 - 59]\n end_doy(A)               Day of year (doy) from the end time [1 - 366]\n end_dow(A)               Day of week (dow) from the end time [1 - 7], the start of the week is Monday == 1\n end_year(A)              The year of the end time [0 - 9999]\n end_month(A)             The month of the end time [1 - 12]\n end_week(A)              Week of year of the end time [1 - 54]\n end_day(A)               Day of month from the start time [1 - 31]\n end_hour(A)              The hour of the end time [0 - 23]\n end_minute(A)            The minute of the end time [0 - 59]\n end_second(A)            The second of the end time [0 - 59]\n  Comparison operator \n The conditions are comparison expressions that are used to evaluate\n space time datasets. Specific values of temporal variables are\n compared by logical operators and evaluated for each map of the STDS and \n the related maps.\n For complex relations the comparison operator can be used to combine conditions: \n The structure is similar to the select operator with the extension of an aggregation operator:\n {\"comparison operator\", \"topological relations\", aggregation operator, \"temporal operator\"}\n This aggregation operator (| or &) define the behaviour if a map is related the more \n than one map, e.g for the topological relations 'contains'.\n Should all (&) conditions for the related maps be true or is it sufficient to \n have any (|) condition that is true. The resulting boolean value is then compared \n to the first condition by the comparison operator (|| or &&). \n As default the aggregation operator is related to the comparison operator:  \n Comparison operator -> aggregation operator:\n || -> | and && -> & \n Examples:\n Condition 1 {||, equal, r} Condition 2\n Condition 1 {&&, equal|during, l} Condition 2\n Condition 1 {&&, equal|contains, |, l} Condition 2\n Condition 1 {&&, equal|during, l} Condition 2 && Condition 3\n Condition 1 {&&, equal|during, l} Condition 2 {&&,contains, |, r} Condition 3\n  Hash operator \n Additionally the number of maps in intervals can be computed and used in \n conditional statements with the hash (#) operator.  \n A{#, contains}B\n This expression computes the number of maps from space\n time dataset B which are during the time intervals of maps from\n space time dataset A. \n A list of integers (scalars) corresponding to the maps of A\n that contain maps from B will be returned.\n C = if({equal}, A {#, contains} B > 2, A {:, contains} B)\n This expression selects all maps from A that temporally contains at least 2 \n maps from B and stores them in space time dataset C. The leading equal statement \n in the if condition specifies the temporal relation between the if and then part \n of the if expression. This is very important, so we do not need to specify a \n global time reference (a space time dataset) for temporal processing.\n Furthermore the temporal algebra allows temporal buffering, shifting\n and snapping with the functions buff_t(), tshift() and tsnap()\n respectively.\n buff_t(A, size)         Buffer STDS A with granule (\"1 month\" or 5)\n tshift(A, size)         Shift STDS A with granule (\"1 month\" or 5)\n tsnap(A)                Snap time instances and intervals of STDS A\n  Single map with temporal extent \n The temporal algebra can also handle single maps with time stamps in \n the tmap function.\n tmap()\n For example:\n  C = A {:,during} tmap(event)\n This statement select all maps from space time data set A that are \n during the temporal extent of single map 'event'\n  Spatial vector operators \n The module supports the following boolean vector operations: \n  Boolean Name   Operator Meaning         Precedence   Correspondent function \n ---------------------------------------------------------------------------------- \n  AND            &        Intersection          1      (v.overlay operator=and) \n  OR             |        Union                 1      (v.overlay operator=or)  \n  DISJOINT OR    +        Disjoint union        1      (v.patch)              \n  XOR            ^        Symmetric difference  1      (v.overlay operator=xor) \n  NOT            ~        Complement            1      (v.overlay operator=not) \n And vector functions:\n  buff_p(A, size)    \t  Buffer the points of vector map layer A with size\n  buff_l(A, size)    \t  Buffer the lines of vector map layer A with size\n  buff_a(A, size)    \t  Buffer the areas of vector map layer A with size\n  Combinations of temporal, vector and select operators \n We combine the temporal topology relations, the temporal operators and \n the spatial/select operators to create spatio-temporal vector \n operators:\n {\"spatial or select operator\" , \"list of temporal relations\", \"temporal operator\" } \n For multiple topological relations or several related maps the spatio-temporal \n operators feature implicit aggregation.\n The algebra evaluates the stated STDS by their temporal topologies and apply \n the given spatio temporal operators in a aggregated form.\n If we have two STDS A and B, B has three maps: b1, b2, b3 that are all during \n the temporal extent of the single map a1 of A, then the following overlay \n calculations would implicitly aggregate all maps of B into one result map for \n a1 of A:\n C = A {&, contains} B --> c1 = a1 & b1 & b2 & b3\n Keep attention that the aggregation behaviour is not symmetric:\n C = B {&, during} A --> c1 = b1 & a1\n                         c2 = b2 & a1\n                         c3 = b3 & a1\n  Examples:  \n Spatio-temporal intersect all maps from space time dataset A with all \n maps from space time dataset B which have equal time stamps and are \n temporary before Jan. 1. 2005 and store them in space time dataset D.\n D = if(start_date(A) < \"2005-01-01\", A & B)\n Buffer all vector points from space time vector dataset A and B with a \n distance of one and intersect the results with overlapping, containing, \n during and equal temporal relations to store the result in space time \n vector dataset D with intersected time stamps.\n D = buff_p(A, 1) {&,overlaps|overlapped|equal|during|contains,i} buff_p(B, 1)\n Select all maps from space time dataset B which are during the temporal \n buffered space time dataset A with a map interval of three days, else\n select maps from C and store them in space time dataset D.\n D = if(contains, td(buff_t(A, \"1 days\")) == 3, B, C)\n  REFERENCES \n  PLY(Python-Lex-Yacc) \n ", "notes": "", "see_also": ["t.select"], "authors": ["Thomas Leppelt, Soeren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.vect.algebra"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.unregister.html", "name": "t.unregister", "definition": "- Unregisters raster, vector and raster3d maps from the temporal database or a specific space time dataset.", "keywords": ["temporal", "map management", "unregister", "time"], "synopsis": "t.unregister  [input=name]   [file=name]   [type=name]   [maps=name[,name,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of the input space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Input file with map names, one per line", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input map", "defaultValue": "raster", "alternatives": ["raster", "vector", "raster_3d"], "isInputFile": false, "isOutputFile": false}, {"parameter": "maps", "flag": "maps", "dataType": "String", "optional": true, "explanation": "Name(s) of existing raster, vector or raster3d map(s) to unregister", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This module is designed to unregister raster, 3D raster and vector map\n layers from space time datasets and the temporal database.\n Map layer that should be unregistered from the temporal database can be\n specified as a list of comma separated map names or using a text file,\n that contains one map layer name per line. By default the map type that\n should be unregistered is set to raster. The option type  must\n be used to specify 3D raster or vector map layer types.\n  INPUT FILE FORMAT \n Specification of map names:\n a1\n a2\n a3\n a4\n a5\n a6\n  NOTE \n In case the  input  option is used to specify a space time dataset\n the maps are only unregistered from the space time dataset, but not from the\n temporal database. The reason is that maps can be registered in\n multiple space time datasets and there is a need to\n unregister them from a specific STDS without affecting other STDS.\n  EXAMPLE \n In this example a precipitation map it is registered into temperature\n dataset, so the wrong map will be unregister.\n t.register -i type=raster input=tempmean_monthly@climate_2009_2012 \n      maps=2012_01_precip \n      start=\"2013-01-01\" increment=\"1 month\"\n # We unregister raster map 2012_01_precip from a space time dataset,\n # the raster maps are still present in the temporal database\n t.unregister type=raster input=tempmean_monthly@climate_2009_2012 maps=2012_01_precip\n # We unregister raster map 2012_01_precip from the temporal database, hence\n # the time stamps are removed\n t.unregister type=raster maps=2012_01_precip\n ", "notes": "", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.unregister"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.topology.html", "name": "t.topology", "definition": "- Lists temporal topology of a space time dataset.", "keywords": ["temporal", "topology", "time"], "synopsis": "t.topology [-ms] input=name  [type=name]   [where=sql_query]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Print temporal topological relationships and exit Print spatio-temporal topological relationships and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Print spatio-temporal topological relationships and exit Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The module  t.topology  lists temporal relations of the maps in\n a space time dataset.\n  EXAMPLE \n In order to obtain information about space time dataset topology, run:\n t.topology tempmean_monthly@climate_2009_2012\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ tempmean_monthly@climate_2009_2012\n  | Name: ...................... tempmean_monthly\n  | Mapset: .................... climate_2009_2012\n  | Creator: ................... lucadelu\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-28 10:40:55.060096\n  | Modification time:.......... 2014-11-28 16:08:42.166628\n  | Semantic type:.............. mean\n  +-------------------- Temporal topology -------------------------------------+\n  | Is subset of dataset: ...... False\n  | Temporal topology is: ...... valid\n  | Number of intervals: ....... 48\n  | Invalid time stamps: ....... 0\n  | Number of points: .......... 0\n  | Number of gaps: ............ 0\n  | Granularity: ............... 1 month\n  +-------------------- Topological relations ---------------------------------+\n  | Overlaps: .................. 0\n  | Overlapped: ................ 0\n  | Finishes: .................. 0\n  | Started: ................... 0\n  | Follows: ................... 47\n  | Contains: .................. 0\n  | Equal:...................... 0\n  | Finished: .................. 0\n  | Precedes: .................. 47\n  | Starts: .................... 0\n  | During: .................... 0\n  +----------------------------------------------------------------------------+\n ", "notes": "", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.topology"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.support.html", "name": "t.support", "definition": "- Modifies the metadata of a space time dataset.", "keywords": ["temporal", "metadata", "time"], "synopsis": "t.support [-mu] input=name  [semantictype=string]   [type=name]   [title=string]   [description=string]   [aggr_type=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "m", "flag": "-m", "explanation": "Update the metadata information and spatial extent of registered maps from the GRASS spatial database Check for removed maps and delete them from the temporal database and all effected space time datasets Update metadata information, temporal and spatial extent from registered maps based on database entries. Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "u", "flag": "-u", "explanation": "Update metadata information, temporal and spatial extent from registered maps based on database entries. Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of the input space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "semantictype", "flag": "semantictype", "dataType": "String", "optional": true, "explanation": "Semantic type of the space time dataset", "defaultValue": "mean", "alternatives": ["min", "max", "sum", "mean"], "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "title", "flag": "title", "dataType": "String", "optional": true, "explanation": "Title of the space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "description", "flag": "description", "dataType": "String", "optional": true, "explanation": "Description of the space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "aggr_type", "flag": "aggr_type", "dataType": "String", "optional": true, "explanation": "Aggregation type of the space time raster or 3D raster dataset", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This module is dedicated to modify and update the metadata of a space time dataset.\n The title, description and the semantic type can be modified.\n The flag  -u  allows updating the STDS metadata from registered\n map layers. This is useful in case the map layers have been modified\n without using temporal commands.\n The flag  -m  will update the metadata from registered maps, but\n also checks if the registered map layers have been removed from the\n spatial database. It deletes missing map layers from the space time\n dataset register table and the temporal database.\n  Examples \n Modification of title and description of space time raster dataset  A .\n t.support type=strds input=tempmean_monthly title=\"Monthly temperature for North Carolina\" \n            description=\"Dataset with monthly temperature for North Carolina\"\n Update the metadata of space time raster dataset  A  and check\n for removed map layers.\n t.support -m type=strds input=tempmean_monthly\n ", "notes": "", "see_also": ["t.create", "t.info"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.support"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.snap.html", "name": "t.snap", "definition": "- Snaps temporally the maps of a space time dataset.", "keywords": ["temporal", "time management", "snapping", "time"], "synopsis": "t.snap input=name  [type=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of an existing space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}], "description": "\n  t.snap  is designed to convert time instances of maps into time\n intervals or to create valid temporal topologies for space time\n datasets. Raster, 3D raster and vector space time datasets are\n supported with absolute and relative time.\n This module \"snaps\" the end time of each registered map of a space time\n dataset to the start time of the map that is the temporal nearest\n neighbour in the future. Maps with equal time stamps are not modified\n and must be removed or modified to create a valid temporal topology. In\n case the last map in the space time dataset is a time instance, the\n granularity of the space time dataset will be used to create the time\n interval.\n  EXAMPLE \n A raster space time dataset will be create using precipitation maps for 2012\n then using absolute time in a space time raster dataset using an increment\n of one month.\n At the end we snap the created time instances resulting in time intervals.\n # Generate data\n t.create type=strds temporaltype=absolute \n           output=precipitation_monthly \n           title=\"Monthly precipitation\" \n           description=\"Dataset with monthly precipitation\"\n t.register type=raster input=precipitation_monthly \n             maps=`g.list type=raster pattern=\"2012*precip\" sep=comma` \n             start=2012-01-01 increment=\"1 months\"\n # please take attention to \"Temporal type of maps\" value\n t.info type=strds input=precipitation_monthly\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precipitation_monthly@climate_2009_2012\n  | Name: ...................... precipitation_monthly\n  | Mapset: .................... climate_2009_2012\n  | Creator: ................... lucadelu\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-28 15:52:30.801148\n  | Modification time:.......... 2014-11-28 15:53:18.430773\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-01-01 00:00:00\n  | End time:................... 2012-12-01 00:00:00\n  | Granularity:................ 1 month\n  | Temporal type of maps:...... point\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 320000.0\n  | South:...................... 10000.0\n  | East:.. .................... 935000.0\n  | West:....................... 120000.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_282454f66ff5455299526ec3c1db7362\n  | North-South resolution min:. 500.0\n  | North-South resolution max:. 500.0\n  | East-west resolution min:... 500.0\n  | East-west resolution max:... 500.0\n  | Minimum value min:.......... 0.0\n  | Minimum value max:.......... 95.58169\n  | Maximum value min:.......... 132.413284\n  | Maximum value max:.......... 356.502949\n  | Aggregation type:........... None\n  | Number of registered maps:.. 12\n  |\n  | Title:\n  | Monthly precipitation\n  | Description:\n  | Dataset with monthly precipitation\n  | Command history:\n  | # 2014-11-28 15:52:30\n  | t.create type=\"strds\" temporaltype=\"absolute\"\n  |     output=\"precipitation_monthly\" title=\"Monthly precipitation\"\n  |     description=\"Dataset with monthly precipitation\"\n  | # 2014-11-28 15:53:18\n  | t.register type=\"rast\" input=\"precipitation_monthly\"\n  |     maps=\"2012_01_precip,2012_02_precip, ... ,2012_11_precip,2012_12_precip\"\n  |     start=\"2012-01-01\" increment=\"1 months\"\n  |\n  +----------------------------------------------------------------------------+\n # you can see that end time is not set\n t.rast.list input=precipitation_monthly\n name|mapset|start_time|end_time\n 2012_01_precip|climate_2009_2012|2012-01-01 00:00:00|None\n 2012_02_precip|climate_2009_2012|2012-02-01 00:00:00|None\n 2012_03_precip|climate_2009_2012|2012-03-01 00:00:00|None\n 2012_04_precip|climate_2009_2012|2012-04-01 00:00:00|None\n 2012_05_precip|climate_2009_2012|2012-05-01 00:00:00|None\n 2012_06_precip|climate_2009_2012|2012-06-01 00:00:00|None\n 2012_07_precip|climate_2009_2012|2012-07-01 00:00:00|None\n 2012_08_precip|climate_2009_2012|2012-08-01 00:00:00|None\n 2012_09_precip|climate_2009_2012|2012-09-01 00:00:00|None\n 2012_10_precip|climate_2009_2012|2012-10-01 00:00:00|None\n 2012_11_precip|climate_2009_2012|2012-11-01 00:00:00|None\n 2012_12_precip|climate_2009_2012|2012-12-01 00:00:00|None\n t.snap type=strds input=precipitation_monthly\n # please take attention to \"Temporal type of maps\" value again\n t.info type=strds input=precipitation_monthly\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precipitation_monthly@climate_2009_2012\n  | Name: ...................... precipitation_monthly\n  | Mapset: .................... climate_2009_2012\n  | Creator: ................... lucadelu\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-28 15:52:30.801148\n  | Modification time:.......... 2014-11-28 15:54:28.739905\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-01-01 00:00:00\n  | End time:................... 2013-01-01 00:00:00\n  | Granularity:................ 1 month\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 320000.0\n  | South:...................... 10000.0\n  | East:.. .................... 935000.0\n  | West:....................... 120000.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_282454f66ff5455299526ec3c1db7362\n  | North-South resolution min:. 500.0\n  | North-South resolution max:. 500.0\n  | East-west resolution min:... 500.0\n  | East-west resolution max:... 500.0\n  | Minimum value min:.......... 0.0\n  | Minimum value max:.......... 95.58169\n  | Maximum value min:.......... 132.413284\n  | Maximum value max:.......... 356.502949\n  | Aggregation type:........... None\n  | Number of registered maps:.. 12\n  |\n  | Title:\n  | Monthly precipitation\n  | Description:\n  | Dataset with monthly precipitation\n  | Command history:\n  | # 2014-11-28 15:52:30\n  | t.create type=\"strds\" temporaltype=\"absolute\"\n  |     output=\"precipitation_monthly\" title=\"Monthly precipitation\"\n  |     description=\"Dataset with monthly precipitation\"\n  | # 2014-11-28 15:53:18\n  | t.register type=\"rast\" input=\"precipitation_monthly\"\n  |     maps=\"2012_01_precip,2012_02_precip, ... ,2012_11_precip,2012_12_precip\"\n  |     start=\"2012-01-01\" increment=\"1 months\"\n  | # 2014-11-28 15:54:28\n  | t.snap type=\"strds\" input=\"precipitation_monthly\"\n  |\n  +----------------------------------------------------------------------------+\n # now instead end time is set\n t.rast.list input=precipitation_daily\n 2012_01_precip|climate_2009_2012|2012-01-01 00:00:00|2012-02-01 00:00:00\n 2012_02_precip|climate_2009_2012|2012-02-01 00:00:00|2012-03-01 00:00:00\n 2012_03_precip|climate_2009_2012|2012-03-01 00:00:00|2012-04-01 00:00:00\n 2012_04_precip|climate_2009_2012|2012-04-01 00:00:00|2012-05-01 00:00:00\n 2012_05_precip|climate_2009_2012|2012-05-01 00:00:00|2012-06-01 00:00:00\n 2012_06_precip|climate_2009_2012|2012-06-01 00:00:00|2012-07-01 00:00:00\n 2012_07_precip|climate_2009_2012|2012-07-01 00:00:00|2012-08-01 00:00:00\n 2012_08_precip|climate_2009_2012|2012-08-01 00:00:00|2012-09-01 00:00:00\n 2012_09_precip|climate_2009_2012|2012-09-01 00:00:00|2012-10-01 00:00:00\n 2012_10_precip|climate_2009_2012|2012-10-01 00:00:00|2012-11-01 00:00:00\n 2012_11_precip|climate_2009_2012|2012-11-01 00:00:00|2012-12-01 00:00:00\n 2012_12_precip|climate_2009_2012|2012-12-01 00:00:00|2013-01-01 00:00:00\n ", "notes": "", "see_also": ["t.shift", "t.create", "t.register"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.snap"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.shift.html", "name": "t.shift", "definition": "- Shifts temporally the maps of a space time dataset.", "keywords": ["temporal", "time management", "shift", "time"], "synopsis": "t.shift input=name  [type=name]  granularity=string  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of an existing space time dataset", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "granularity", "flag": "granularity", "dataType": "String", "optional": false, "explanation": "Shift granularity", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.shift  is designed to temporally shift all registered maps in \n a space time dataset with a user defined granularity. Raster, 3D raster \n and vector space time datasets are supported.\n The format of the absolute time granularity is \"number unit\". Number is \n an integer, unit is the temporal unit that can be one of year(s), \n month(s), week(s), day(s), hour(s), minute(s) or second(s).\n The granularity in case of relative time is an integer. The temporal \n unit is the unit of the space time dataset and can not be modified.\n ", "notes": "\n Be careful when shifting space time datasets with absolute time. The \n temporal granularity may change if you shift a space time dataset with \n a unit that is different from the space time dataset granularity. Be \n aware that the shifting with months and years may result in incorrect \n days per month. Shifting the date 20012-03-31 with a granularity of one \n month will result in 2012-04-31 which is incorrect. In this case an \n error will raise and the shifting will not performed for the whole \n dataset.\n You can use the extraction module to shift only a subset of maps from a \n space time dataset. Be aware that the shifting of maps affect all space \n time datasets in which they are registered.\n  EXAMPLE \n We create 6 raster maps and register them in a space time raster \n dataset using an increment of one day. Then we shift the time intervals \n with a granularity of 12 hours.\n r.mapcalc expression=\"prec_1 = rand(0, 550)\" -s\n r.mapcalc expression=\"prec_2 = rand(0, 450)\" -s\n r.mapcalc expression=\"prec_3 = rand(0, 320)\" -s\n r.mapcalc expression=\"prec_4 = rand(0, 510)\" -s\n r.mapcalc expression=\"prec_5 = rand(0, 300)\" -s\n r.mapcalc expression=\"prec_6 = rand(0, 650)\" -s\n t.create type=strds temporaltype=absolute \n           output=precipitation_daily \n           title=\"Daily precipitation\" \n           description=\"Test dataset with daily precipitation\"\n t.register -i type=raster input=precipitation_daily \n             maps=prec_1,prec_2,prec_3,prec_4,prec_5,prec_6 \n             start=2012-01-01 increment=\"1 day\"\n t.info type=strds input=precipitation_daily\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precipitation_daily@PERMANENT\n  | Name: ...................... precipitation_daily\n  | Mapset: .................... PERMANENT\n  | Creator: ................... soeren\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-23 19:20:26.004855\n  | Modification time:.......... 2014-11-23 19:20:26.471536\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-01-01 00:00:00\n  | End time:................... 2012-01-07 00:00:00\n  | Granularity:................ 1 day\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 80.0\n  | South:...................... 0.0\n  | East:.. .................... 120.0\n  | West:....................... 0.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_882043e9afaa4e60b845aceb1a1fee2c\n  | North-South resolution min:. 10.0\n  | North-South resolution max:. 10.0\n  | East-west resolution min:... 10.0\n  | East-west resolution max:... 10.0\n  | Minimum value min:.......... 0.0\n  | Minimum value max:.......... 16.0\n  | Maximum value min:.......... 297.0\n  | Maximum value max:.......... 647.0\n  | Aggregation type:........... None\n  | Number of registered maps:.. 6\n  |\n  | Title:\n  | Daily precipitation\n  | Description:\n  | Test dataset with daily precipitation\n  | Command history:\n  | # 2014-11-23 19:20:26 \n  | t.create type=\"strds\" temporaltype=\"absolute\"\n  |     output=\"precipitation_daily\" title=\"Daily precipitation\"\n  |     description=\"Test dataset with daily precipitation\"\n  | # 2014-11-23 19:20:26 \n  | t.register -i type=\"rast\" input=\"precipitation_daily\"\n  |     maps=\"prec_1,prec_2,prec_3,prec_4,prec_5,prec_6\" start=\"2012-01-01\"\n  |     increment=\"1 day\"\n  | \n  +----------------------------------------------------------------------------+\n t.rast.list input=precipitation_daily\n name|mapset|start_time|end_time\n prec_1|PERMANENT|2012-01-01 00:00:00|2012-01-02 00:00:00\n prec_2|PERMANENT|2012-01-02 00:00:00|2012-01-03 00:00:00\n prec_3|PERMANENT|2012-01-03 00:00:00|2012-01-04 00:00:00\n prec_4|PERMANENT|2012-01-04 00:00:00|2012-01-05 00:00:00\n prec_5|PERMANENT|2012-01-05 00:00:00|2012-01-06 00:00:00\n prec_6|PERMANENT|2012-01-06 00:00:00|2012-01-07 00:00:00\n t.shift type=strds input=precipitation_daily granularity=\"12 hours\"\n t.info type=strds input=precipitation_daily\n  +-------------------- Space Time Raster Dataset -----------------------------+\n  |                                                                            |\n  +-------------------- Basic information -------------------------------------+\n  | Id: ........................ precipitation_daily@PERMANENT\n  | Name: ...................... precipitation_daily\n  | Mapset: .................... PERMANENT\n  | Creator: ................... soeren\n  | Temporal type: ............. absolute\n  | Creation time: ............. 2014-11-23 19:20:26.004855\n  | Modification time:.......... 2014-11-23 19:21:08.240018\n  | Semantic type:.............. mean\n  +-------------------- Absolute time -----------------------------------------+\n  | Start time:................. 2012-01-01 12:00:00\n  | End time:................... 2012-01-07 12:00:00\n  | Granularity:................ 24 hours\n  | Temporal type of maps:...... interval\n  +-------------------- Spatial extent ----------------------------------------+\n  | North:...................... 80.0\n  | South:...................... 0.0\n  | East:.. .................... 120.0\n  | West:....................... 0.0\n  | Top:........................ 0.0\n  | Bottom:..................... 0.0\n  +-------------------- Metadata information ----------------------------------+\n  | Raster register table:...... raster_map_register_882043e9afaa4e60b845aceb1a1fee2c\n  | North-South resolution min:. 10.0\n  | North-South resolution max:. 10.0\n  | East-west resolution min:... 10.0\n  | East-west resolution max:... 10.0\n  | Minimum value min:.......... 0.0\n  | Minimum value max:.......... 16.0\n  | Maximum value min:.......... 297.0\n  | Maximum value max:.......... 647.0\n  | Aggregation type:........... None\n  | Number of registered maps:.. 6\n  |\n  | Title:\n  | Daily precipitation\n  | Description:\n  | Test dataset with daily precipitation\n  | Command history:\n  | # 2014-11-23 19:20:26 \n  | t.create type=\"strds\" temporaltype=\"absolute\"\n  |     output=\"precipitation_daily\" title=\"Daily precipitation\"\n  |     description=\"Test dataset with daily precipitation\"\n  | # 2014-11-23 19:20:26 \n  | t.register -i type=\"rast\" input=\"precipitation_daily\"\n  |     maps=\"prec_1,prec_2,prec_3,prec_4,prec_5,prec_6\" start=\"2012-01-01\"\n  |     increment=\"1 day\"\n  | # 2014-11-23 19:21:08 \n  | t.shift type=\"strds\" input=\"precipitation_daily\"\n  |     granularity=\"12 hours\"\n  | \n  +----------------------------------------------------------------------------+\n t.rast.list input=precipitation_daily\n name|mapset|start_time|end_time\n prec_1|PERMANENT|2012-01-01 12:00:00|2012-01-02 12:00:00\n prec_2|PERMANENT|2012-01-02 12:00:00|2012-01-03 12:00:00\n prec_3|PERMANENT|2012-01-03 12:00:00|2012-01-04 12:00:00\n prec_4|PERMANENT|2012-01-04 12:00:00|2012-01-05 12:00:00\n prec_5|PERMANENT|2012-01-05 12:00:00|2012-01-06 12:00:00\n prec_6|PERMANENT|2012-01-06 12:00:00|2012-01-07 12:00:00\n ", "see_also": ["t.create", "t.register", "t.snap"], "authors": ["S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.shift"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/t.select.html", "name": "t.select", "definition": "- Select maps from space time datasets by topological relationships to other space time datasets using temporal algebra.", "keywords": ["temporal", "metadata", "time"], "synopsis": "t.select [-sd]  [type=name]  expression=expression  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "s", "flag": "-s", "explanation": "Check the spatial topology of temporally related maps and select only spatially related maps Perform a dry run, compute all dependencies and module calls but don't run them Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Perform a dry run, compute all dependencies and module calls but don't run them Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Type of the input space time dataset", "defaultValue": "strds", "alternatives": ["strds", "stvds", "str3ds"], "isInputFile": false, "isOutputFile": false}, {"parameter": "expression", "flag": "expression", "dataType": "String", "optional": false, "explanation": "The temporal mapcalc expression", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  t.select  performs selection of maps that are registered in \n space time datasets using temporal algebra.\n  PROGRAM USE \n The module expects an  expression  as input parameter in the following form:\n  \"result = expression\" \n The statement structure is similar to r.mapcalc, see  r.mapcalc .\n Where  result  represents the name of a space time dataset \n (STDS)that will contain the result of the calculation that is given as \n  expression  on the right side of the equality sign.\n These expression can be any valid or nested combination of temporal \n operations and functions that are provided by the temporal algebra.  \n The temporal algebra works with space time datasets of any type \n (STRDS, STR3DS and STVDS). The algebra provides methods for map \n selection from STDS based on their temporal relations. It is also \n possible to temporally shift maps, to create temporal buffer and to \n snap time instances to create a valid temporal topology. Furthermore \n expressions can be nested and evaluated in conditional statements (if, \n else statements). Within if-statements the algebra provides temporal \n variables like start time, end time, day of year, time differences or \n number of maps per time interval to build up conditions. These \n operations can be assigned to space time datasets or to the results of \n operations between space time datasets.\n The type of the input space time datasets must be defined with the input\n parameter  type . Possible options are STRDS, STVDS or STR3DS.\n The default is set to space time raster datasets (STRDS).\n As default, topological relationships between space time datasets will be\n evaluated only temporal. Use the  s  flag to activate the\n additionally spatial topology evaluation.\n The expression option must be passed as  quoted \n expression, for example:  \n t.select expression=\"C = A : B\"\n Where  C  is the new space time raster dataset that will contain maps\n from  A  that are selected by equal temporal relationships\n to the existing dataset  B  in this case.\n  TEMPORAL ALGEBRA \n The temporal algebra provides a wide range of temporal operators and\n functions that will be presented in the following section.\n  TEMPORAL RELATIONS \n Several temporal topology relations between registered maps of space\n time datasets are supported:  \n equals            A ------\n                   B ------\n during            A  ----\n                   B ------\n contains          A ------\n                   B  ----\n starts            A ----\n                   B ------\n started           A ------\n                   B ----\n finishs           A   ----\n                   B ------\n finished          A ------\n                   B   ----\n precedes          A ----\n                   B     ----\n follows           A     ----\n                   B ----\n overlapped        A   ------\n                   B ------\n overlaps          A ------\n                   B   ------\n over              booth overlaps and overlapped\n The relations must be read as: A is related to B, like - A equals B - A is\n during B - A contains B  \n Topological relations must be specified in {} parentheses.  \n  TEMPORAL OPERATORS \n The temporal algebra defines temporal operators that can be combined with other \n operators to perform spatio-temporal operations. \n The temporal operators process the time instances and intervals of two temporal \n related maps and calculate the result temporal extent by five different possibilities.\n LEFT REFERENCE     l       Use the time stamp of the left space time dataset\n INTERSECTION       i       Intersection\n DISJOINT UNION     d       Disjoint union\n UNION              u       Union\n RIGHT REFERENCE    r       Use the time stamp of the right space time dataset\n  TEMPORAL SELECTION \n The temporal selection simply selects parts of a space time dataset without\n processing raster or vector data.\n The algebra provides a selection operator  :  that selects parts\n of a space time dataset that are temporally equal to parts of a second one\n by default. The following expression\n C = A : B\n means: Select all parts of space time dataset A that are equal to B and store\n it in space time dataset C. The parts are time stamped maps.  \n In addition the inverse selection operator  !:  is defined as the\n complement of the selection operator, hence the following expression\n C = A !: B\n means: select all parts of space time time dataset A that are not equal to B\n and store it in space time dataset (STDS) C.  \n To select parts of a STDS by different topological relations to other STDS,\n the temporal topology selection operator can be used. The operator consists of\n the temporal selection operator, the topological relations, that must be separated \n by the logical OR operator  |  and the temporal extent operator. \n All three parts are separated by comma and surrounded by curly braces:\n {\"temporal selection operator\", \"topological relations\", \"temporal operator\"}\n Examples:\n C = A {:, equals} B\n C = A {!:, equals} B\n We can now define arbitrary topological relations using the OR operator \"|\"\n to connect them:\n C = A {:,equals|during|overlaps} B\n Select all parts of A that are equal to B, during B or overlaps B.  \n In addition we can define the temporal extent of the result STDS by adding the\n temporal operator.\n C = A {:, during,r} B\n Select all parts of A that are during B and use the temporal extents from B for \n C.  \n The selection operator is implicitly contained in the temporal topology\n selection operator, so that the following statements are exactly the same:\n C = A : B\n C = A {:} B\n C = A {:,equal} B\n C = A {:,equal,l} B\n Same for the complementary selection:\n C = A !: B\n C = A {!:} B\n C = A {!:,equal} B\n C = A {!:,equal,l} B\n  CONDITIONAL STATEMENTS \n Selection operations can be evaluated within conditional statements.\n Note A and B can either be space time datasets or expressions. The temporal \n relationship between the conditions and the conclusions can be defined at the \n beginning of the if statement. The relationship between then and else conclusion \n must be always equal.\n if statement                           decision option                        temporal relations\n   if(if, then, else)\n   if(conditions, A)                    A if conditions are True;              temporal topological relation between if and then is equal.\n   if(conditions, A, B)                 A if conditions are True, B otherwise; temporal topological relation between if, then and else is equal.\n   if(topologies, conditions, A)        A if conditions are True;              temporal topological relation between if and then is explicit specified by topologies.\n   if(topologies, conditions, A, B)     A if conditions are True, B otherwise; temporal topological relation between if, then and else is explicit specified by topologies.\n The conditions are comparison expressions that are used to evaluate\n space time datasets. Specific values of temporal variables are\n compared by logical operators and evaluated for each map of the STDS. \n  Important:  The conditions are evaluated from left to right. \n  Logical operators \n Symbol  description\n   ==    equal\n   !=    not equal\n   >     greater than\n   >=    greater than or equal\n   <     less than\n   <=    less than or equal\n   &&    and\n   ||    or\n  Temporal functions \n The following temporal function are evaluated only for the STDS that must\n be given in parenthesis.\n td(A)                    Returns a list of time intervals of STDS A\n start_time(A)            Start time as HH::MM:SS\n start_date(A)            Start date as yyyy-mm-DD\n start_datetime(A)        Start datetime as yyyy-mm-DD HH:MM:SS\n end_time(A)              End time as HH:MM:SS\n end_date(A)              End date as yyyy-mm-DD\n end_datetime(A)          End datetime as  yyyy-mm-DD HH:MM\n start_doy(A)             Day of year (doy) from the start time [1 - 366]\n start_dow(A)             Day of week (dow) from the start time [1 - 7], the start of the week is Monday == 1\n start_year(A)            The year of the start time [0 - 9999]\n start_month(A)           The month of the start time [1 - 12]\n start_week(A)            Week of year of the start time [1 - 54]\n start_day(A)             Day of month from the start time [1 - 31]\n start_hour(A)            The hour of the start time [0 - 23]\n start_minute(A)          The minute of the start time [0 - 59]\n start_second(A)          The second of the start time [0 - 59]\n end_doy(A)               Day of year (doy) from the end time [1 - 366]\n end_dow(A)               Day of week (dow) from the end time [1 - 7], the start of the week is Monday == 1\n end_year(A)              The year of the end time [0 - 9999]\n end_month(A)             The month of the end time [1 - 12]\n end_week(A)              Week of year of the end time [1 - 54]\n end_day(A)               Day of month from the start time [1 - 31]\n end_hour(A)              The hour of the end time [0 - 23]\n end_minute(A)            The minute of the end time [0 - 59]\n end_second(A)            The second of the end time [0 - 59]\n  Comparison operator \n The conditions are comparison expressions that are used to evaluate\n space time datasets. Specific values of temporal variables are\n compared by logical operators and evaluated for each map of the STDS and \n the related maps.\n For complex relations the comparison operator can be used to combine conditions: \n The structure is similar to the select operator with the extension of an aggregation operator: \n {\"comparison operator\", \"topological relations\", aggregation operator, \"temporal operator\"}\n This aggregation operator (| or &) define the behaviour if a map is related the more \n than one map, e.g for the topological relations 'contains'.\n Should all (&) conditions for the related maps be true or is it sufficient to \n have any (|) condition that is true. The resulting boolean value is then compared \n to the first condition by the comparison operator (|| or &&). \n As default the aggregation operator is related to the comparison operator:  \n Comparison operator -> aggregation operator:\n || -> | and && -> & \n Examples:\n Condition 1 {||, equal, r} Condition 2\n Condition 1 {&&, equal|during, l} Condition 2\n Condition 1 {&&, equal|contains, |, l} Condition 2\n Condition 1 {&&, equal|during, l} Condition 2 && Condition 3\n Condition 1 {&&, equal|during, l} Condition 2 {&&,contains, |, r} Condition 3\n  Hash operator \n Additionally the number of maps in intervals can be computed and used in \n conditional statements with the hash (#) operator.  \n A{#, contains}B\n This expression computes the number of maps from space\n time dataset B which are during the time intervals of maps from\n space time dataset A. \n A list of integers (scalars) corresponding to the maps of A\n that contain maps from B will be returned.  \n C = if({equal}, A {#, contains} B > 2, A {:, contains} B)\n This expression selects all maps from A that temporally contains at least 2 \n maps from B and stores them in space time dataset C. The leading equal statement \n in the if condition specifies the temporal relation between the if and then part \n of the if expression. This is very important, so we do not need to specify a \n global time reference (a space time dataset) for temporal processing.\n Furthermore the temporal algebra allows temporal buffering, shifting\n and snapping with the functions buff_t(), tshift() and tsnap()\n respectively.\n buff_t(A, size)         Buffer STDS A with granule (\"1 month\" or 5)\n tshift(A, size)         Shift STDS A with granule (\"1 month\" or 5)\n tsnap(A)                Snap time instances and intervals of STDS A\n  Single map with temporal extent \n The temporal algebra can also handle single maps with time stamps in the\n map function.\n tmap()\n For example:\n  C = A {:,during} tmap(event)\n This statement select all maps from space time data set A that are during\n the temporal extent of single map 'event'\n  Examples \n Select all maps from space time dataset A which have equal time stamps\n with space time dataset B and C and are earlier that Jan. 1. 2005 and\n store them in space time dataset D.\n D = if(start_date(A) < \"2005-01-01\", A : B : C)\n Select all maps from space time dataset A which contains more than three\n maps of space time dataset B, else select maps from C with time\n stamps that are not equal to A and store them in space time dataset D.\n D = if(A {#, contains} B > 3, A {:, contains} B, C)\n Select all maps from space time dataset B which are during the temporal\n buffered space time dataset A with a map interval of three days, else\n select maps from C and store them in space time dataset D.\n D = if(contains, td(buff_t(A, \"1 days\")) == 3, B, C)\n ", "notes": "", "see_also": ["r.mapcalc"], "authors": ["Thomas Leppelt, S\u00f6ren Gebbert, Th\u00fcnen Institute of Climate-Smart Agriculture"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/temporal/t.select"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.label.sa.html", "name": "v.label.sa", "definition": "- Create optimally placed labels for vector map(s)", "keywords": ["vector", "paint labels"], "synopsis": "v.label.sa map=name  [type=string[,string,...]]   [layer=string]  column=string labels=name font=string  [size=float]   [isize=float]   [charset=string]   [color=string]   [hcolor=string]   [hwidth=float]   [background=string]   [opaque=yes|no]   [border=string]   [width=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,area", "alternatives": ["point", "line", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column to be used for labels", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "labels", "flag": "labels", "dataType": "String", "optional": false, "explanation": "Name for new paint-label file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "font", "flag": "font", "dataType": "String", "optional": false, "explanation": "Name of TrueType font (as listed in the fontcap)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Label size (in map-units)", "defaultValue": "100", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "isize", "flag": "isize", "dataType": "String", "optional": true, "explanation": "Icon size of point features (in map-units)", "defaultValue": "10", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "charset", "flag": "charset", "dataType": "String", "optional": true, "explanation": "Character encoding (default: UTF-8)", "defaultValue": "UTF-8", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Text color", "defaultValue": "black", "alternatives": ["aqua", "black", "blue", "brown", "cyan", "gray", "green", "grey", "indigo", "magenta", "orange", "purple", "red", "violet", "white", "yellow"], "isInputFile": false, "isOutputFile": false}, {"parameter": "hcolor", "flag": "hcolor", "dataType": "String", "optional": true, "explanation": "Highlight color for text", "defaultValue": "none", "alternatives": ["none", "aqua", "black", "blue", "brown", "cyan", "gray", "green", "grey", "indigo", "magenta", "orange", "purple", "red", "violet", "white", "yellow"], "isInputFile": false, "isOutputFile": false}, {"parameter": "hwidth", "flag": "hwidth", "dataType": "String", "optional": true, "explanation": "Width of highlight coloring", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "background", "flag": "background", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "none", "alternatives": ["none", "aqua", "black", "blue", "brown", "cyan", "gray", "green", "grey", "indigo", "magenta", "orange", "purple", "red", "violet", "white", "yellow"], "isInputFile": false, "isOutputFile": false}, {"parameter": "opaque", "flag": "opaque", "dataType": "String", "optional": true, "explanation": "Opaque to vector (only relevant if background color is selected)", "defaultValue": "yes", "alternatives": ["yes", "no"], "isInputFile": false, "isOutputFile": false}, {"parameter": "border", "flag": "border", "dataType": "String", "optional": true, "explanation": "Border color", "defaultValue": "none", "alternatives": ["none", "aqua", "black", "blue", "brown", "cyan", "gray", "green", "grey", "indigo", "magenta", "orange", "purple", "red", "violet", "white", "yellow"], "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Border width (only for ps.map output)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.label.sa  makes a label-file from a GRASS vector map\n with labels created from attributes in the attached table. The labels are\n placed in as optimal place as possible. The label file has the same syntax\n as the one created by  v.label \n  EXAMPLE \n North Carolina example:\n # get font names:\n d.font -L\n v.label.sa roadsmajor labels=roads_labels column=ROAD_NAME color=red \n             background=white size=250 font=Vera\n # set region:\n g.region raster=lsat7_2002_10 -p\n # display:\n d.rgb b=lsat7_2002_10 g=lsat7_2002_20 r=lsat7_2002_30\n d.vect roadsmajor col=yellow\n d.labels roads_labels\n  Road labeling with v.label.sa (Raleigh, North Carolina, USA, area) \n  REFERENCES \n Edmondson, Christensen, Marks and Shieber: A General Cartographic\n Labeling Algorithm, Cartographica, Vol. 33, No. 4, Winter 1996, pp. 13-23\n The algorithm works by the principle of Simulated Annealing.\n ", "notes": "", "see_also": [ "d.labels", "ps.map", "Wikipedia article on simulated annealing"], "authors": ["Wolf Bergenheim"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.label.sa"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.label.html", "name": "v.label", "definition": "- Creates paint labels for a vector map from attached attributes.", "keywords": ["vector", "paint labels"], "synopsis": "v.label [-ac]  [labels=name]  map=name column=name  [type=string[,string,...]]   [layer=string]   [where=sql_query]   [xoffset=float]   [yoffset=float]   [reference=string[,string,...]]   [font=string]   [size=float]   [space=float]   [fontsize=integer]   [color=name]   [rotation=angle]   [width=float]   [highlight_color=name]   [highlight_width=float]   [bgcolor=name]   [border=name]   [opaque=yes|no]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Rotate labels to align with lines Curl labels along lines Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Curl labels along lines Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "labels", "flag": "labels", "dataType": "String", "optional": true, "explanation": "Name for new paint-label file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column to be used for labels", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid", "alternatives": ["point", "line", "boundary", "centroid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "xoffset", "flag": "xoffset", "dataType": "String", "optional": true, "explanation": "Offset label in x-direction", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "yoffset", "flag": "yoffset", "dataType": "String", "optional": true, "explanation": "Offset label in y-direction", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "reference", "flag": "reference", "dataType": "String", "optional": true, "explanation": "Reference position", "defaultValue": "center", "alternatives": ["center", "left", "right", "upper", "lower"], "isInputFile": false, "isOutputFile": false}, {"parameter": "font", "flag": "font", "dataType": "String", "optional": true, "explanation": "Font name", "defaultValue": "standard", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Label size (in map-units)", "defaultValue": "100", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "space", "flag": "space", "dataType": "String", "optional": true, "explanation": "Space between letters for curled labels (in map-units)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "fontsize", "flag": "fontsize", "dataType": "String", "optional": true, "explanation": "Label size (in points)", "defaultValue": null, "alternatives": ["1-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Text color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rotation", "flag": "rotation", "dataType": "String", "optional": true, "explanation": "Rotation angle in degrees (counter-clockwise)", "defaultValue": "0", "alternatives": ["0-360"], "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Border width", "defaultValue": "1", "alternatives": ["0-25"], "isInputFile": false, "isOutputFile": false}, {"parameter": "highlight_color", "flag": "highlight_color", "dataType": "String", "optional": true, "explanation": "Highlight color for text", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "highlight_width", "flag": "highlight_width", "dataType": "String", "optional": true, "explanation": "Width of highlight coloring", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "border", "flag": "border", "dataType": "String", "optional": true, "explanation": "Border color", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "opaque", "flag": "opaque", "dataType": "String", "optional": true, "explanation": "Opaque to vector (only relevant if background color is selected)", "defaultValue": "yes", "alternatives": ["yes", "no"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.label  makes a label-file from a GRASS vector map\n with labels created from attributes in the attached table.\n If no label file name is given, the name of the source map is used.\n ", "notes": "\n If the  fontsize  option is given then the  space  option\n is determined automatically  from the current display window , \n otherwise the  space  option should be set roughly the same\n as the  size  option.\n A description of the labels file follows.  \n The file is located in  $MAPSET/paint/labels/ .\n The file is a plain-text ASCII file containing the following fields:\n  Caution: The following information may be incomplete, out of date, and wrong! \n The label information that must be provided in the  labels  file is:\n  TEXT :\n Lines in multiple line labels will appear one above the next.\n More than one line of text can be specified by notating the end of a \n line with a ' \\n  '. \n (e.g.  SPEARFISH \\n  SOUTH DAKOTA) .\n  LOCATION :\n  Determines where the text will be located on the\n image.  The user specifies the easting and northing, and\n (optionally) specifies a vertical and horizontal \n offset from the specified easting/northing. \n These offsets are provided to allow finer placement of labels and\n are measured in local pixels. Thus in \n  d.labels  the offset is \n measured in screen pixels, and in  ps.map  \n the offset is measured in PostScript points (i.e. 1/72\" steps).\n  PLACEMENT :\n  Determines which part of the label to which the\n location refers.  If placement is unspecified, the label is\n centered ( center ), by default.  Label placement\n may be specified as:\n \tlower left\t(lower left corner of the text)\n \tlower right\t(lower right corner of the text)\n \tlower center\t(bottom center of the text)\n \tupper left\t(upper left corner of the text)\n \tupper right\t(upper right corner of the text)\n \tupper center\t(top center of the text)\n \tcenter\t(center of the text)\n  FONT :\n  This specifies the font to use.\n  The following fonts are available for use with\n    d.labels :\n   cyrilc gothgbt gothgrt gothitt greekc greekcs greekp greeks\n   italicc italiccs italict romanc romancs romand romans romant\n   scriptc scripts\n  Alternatively the path to a FreeType (.ttf) font may be given.\n (for  d.labels  only)\n  The word  standard  can be used to specify the default font \n (which is  romans ).\n  Note  ps.map  can override this setting\n to use other fonts. Its default font is Helvetica.\n  TEXT SIZE :\n  This determines the size of the letters. The  size \n specifies the vertical height of the letters in meters on\n the ground. Thus text will grow or shrink depending on the\n scale at which the map is drawn.\n Alternatively  fontsize  can set the font size in normal font points.\n  TEXT COLOR :\n  This selects the text color.  If unspecified, the\n label's text is drawn in  black , by default.  The\n text color can be specified in one of several ways:\n  By color name:\n  aqua black blue brown cyan gray green grey indigo\n magenta orange purple red violet white yellow \n  As red, green, blue component values. (0-255) \n for example:  128:100:200 \n  Specify \" none \" to suppress the lettering.\n  WIDTH :\n  This determines the line thickness of the border box. \n The maximum value is 25.0.\n  HIGHLIGHT COLOR :\n  The text can be highlighted in another color so that it\n appears to be in two colors. The text is drawn first in\n this color at a wider line width, and then redrawn in the\n text color at the regular line width.  No highlight color\n (\" none \") is used by default, if unspecified by the\n user.  To specify use of no highlight color, specify\n \" none \".\n (See  TEXT COLOR \n above for a list of permissible color names.)\n  HIGHLIGHT WIDTH :\n  Specifies how far from the text lines (in units of\n pixels) the highlight color should extend.  The default\n highlight width is set to  0  (i.e., no highlight\n color).\n  BACKGROUND COLOR :\n  Text may be boxed in a solid color by specifying a background color.\n Specify \" none \" for no background.  The default background color\n setting, if unspecified by the user, is  white .\n (See  TEXT COLOR \n above for a list of permissible color names.)\n  BORDER COLOR :\n  Select a color for the border around the background.\n Specify \" none \" to suppress the border.\n The default border color used, if unspecified, is  black .\n (See  TEXT COLOR \n above for a list of permissible color names.)\n  OPAQUE TO VECTORS :\n  yes|no .  This field only has meaning if a\n background color is selected.   yes  will prevent\n vector lines from entering the background.   no \n will allow vector lines to enter the background.  The\n default setting, if unspecified by the user, is\n  yes .\n  EXAMPLE \n Spearfish example with TrueType font (path may differ):\n v.label -a map=roads column=label labels=lroads \n          font=/usr/X11R6/lib/X11/fonts/TTF/luximri.ttf\n d.vect roads\n d.labels lroads\n Since the label files are simple text files, you can merge them together\n if you like. For example if you set the label colors based on database\n attributes using multiple runs with the  where  option.\n This example uses the standard UNIX  cat  program.\n cd $MAPSET/paint/labels/\n cat file1 file2 file3 file4 > file_all\n ", "see_also": ["d.labels", "ps.map"], "authors": ["Philip Verhagen (original s.label)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.label"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.kernel.html", "name": "v.kernel", "definition": "- Generates a raster density map from vector points map.", "keywords": ["vector", "kernel density", "point density", "heatmap", "hotspot"], "synopsis": "v.kernel [-oqnm] input=name  [net=name]   [output=name]   [net_output=name]  radius=float  [dsize=float]   [segmax=float]   [distmax=float]   [multiplier=float]   [node=string]   [kernel=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "o", "flag": "-o", "explanation": "Try to calculate an optimal radius with given 'radius' taken as maximum (experimental) Only calculate optimal radius and exit (no map is written) In network mode, normalize values by sum of density multiplied by length of each segment. Integral over the output map then gives 1.0 * mult In network mode, multiply the result by number of input points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "q", "flag": "-q", "explanation": "Only calculate optimal radius and exit (no map is written) In network mode, normalize values by sum of density multiplied by length of each segment. Integral over the output map then gives 1.0 * mult In network mode, multiply the result by number of input points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "In network mode, normalize values by sum of density multiplied by length of each segment. Integral over the output map then gives 1.0 * mult In network mode, multiply the result by number of input points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "In network mode, multiply the result by number of input points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map with training points", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "net", "flag": "net", "dataType": "String", "optional": true, "explanation": "Name of input network vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "net_output", "flag": "net_output", "dataType": "String", "optional": true, "explanation": "Name for output vector density map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "radius", "flag": "radius", "dataType": "String", "optional": false, "explanation": "Kernel radius in map units", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dsize", "flag": "dsize", "dataType": "String", "optional": true, "explanation": "Discretization error in map units", "defaultValue": "0.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "segmax", "flag": "segmax", "dataType": "String", "optional": true, "explanation": "Maximum length of segment on network", "defaultValue": "100.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "distmax", "flag": "distmax", "dataType": "String", "optional": true, "explanation": "Maximum distance from point to network", "defaultValue": "100.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "multiplier", "flag": "multiplier", "dataType": "String", "optional": true, "explanation": "Multiply the density result by this number", "defaultValue": "1.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node", "flag": "node", "dataType": "String", "optional": true, "explanation": "Node method", "defaultValue": "none", "alternatives": ["none", "split"], "isInputFile": false, "isOutputFile": false}, {"parameter": "kernel", "flag": "kernel", "dataType": "String", "optional": true, "explanation": "Kernel function", "defaultValue": "gaussian", "alternatives": ["uniform", "triangular", "epanechnikov", "quartic", "triweight", "gaussian", "cosine"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.kernel  generates a raster density map from vector points\n data using a moving\n kernel. Available  kernel\n density functions  are  uniform, triangular, epanechnikov,\n quartic, triweight, gaussian, cosine , default\n is  gaussian .\n  The module can also generate a vector density map on a vector network. \n Conventional kernel functions produce biased estimates by overestimating \n the densities around network nodes, whereas the equal split method of \n Okabe et al. (2009) produces unbiased density estimates. The equal split \n method uses the kernel function selected with the  kernel  option \n and can be enabled with  node=split .\n ", "notes": "\n The  multiplier  option is needed to overcome the limitation that\n the resulting density in case of a vector map output is stored as category\n (integer). The density result stored as category may be multiplied by this number.\n For the  gaussian  kernel, standard deviation for the \n  gaussian function  \n is set to 1/4 of the radius.\n With the  -o  flag (experimental) the command tries to calculate an \n optimal radius. The value of  radius  is taken \n as maximum value. The radius is calculated based on the gaussian function, \n using ALL points, not just those in the current region.\n  EXAMPLES \n Compute density of points (using vector map of schools from North Carolina sample dataset):\n g.region region=wake_30m\n v.kernel input=schools_wake output=schools_density radius=5000 multiplier=1000000\n r.colors map=schools_density color=bcyr\n School density\n  KNOWN ISSUES \n The module only considers the presence of points, but not \n (yet) any attribute values.\n  REFERENCES \n  Okabe, A., Satoh, T., Sugihara, K. (2009).  A kernel density estimation \n method for networks, its computational method and a GIS-based tool .\n  International Journal of Geographical Information Science , Vol 23(1), \n pp. 7-32. \n DOI:  10.1080/13658810802475491 \n ", "see_also": ["v.surf.rst"], "authors": ["Stefano Menegon,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.kernel"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.kcv.html", "name": "v.kcv", "definition": "- Randomly partition points into test/train sets.", "keywords": ["vector", "statistics", "points", "point pattern"], "synopsis": "v.kcv map=name  [layer=string]  npartitions=integer  [column=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "npartitions", "flag": "npartitions", "dataType": "String", "optional": false, "explanation": "Number of partitions", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name for new column to which partition number is written", "defaultValue": "part", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.kcv  randomly divides a points lists into  k  sets of\n test/train data (for  npartitions -fold  c ross  v alidation).\n Test partitions are mutually exclusive. That is, a point will appear in\n only one test partition and  k-1  training partitions.\n The module generates a random point using the selected random number\n generator and then finds the closest point to it. This site is removed\n from the candidate list (meaning that it will not be selected for any\n other test set) and saved in the first test partition file. This is\n repeated until enough points have been selected for the test partition.\n The number of points chosen for test partitions depends upon the number\n of sites available and the number of partitions chosen (this number is\n made as consistent as possible while ensuring that all sites will be\n chosen for testing). This process of filling up a test partition is\n done  k  times.\n ", "notes": "\n An ideal random sites generator will follow a Poisson distribution and \n will only be as random as the original sites. This module simply \n divides vector points up in a random manner.\n Be warned that random number generation occurs over the\n intervals defined by the current region of the map.\n This program may not work properly with Lat-long data.\n  EXAMPLES \n All examples are based on the North Carolina sample dataset.\n g.copy vect=geonames_wake,my_geonames_wake\n v.kcv map=my_geonames_wake column=part npartitions=10\n g.copy vect=geodetic_pts,my_geodetic_pts\n v.kcv map=my_geodetic_pts column=part npartitions=10\n ", "see_also": ["v.random", "g.region"], "authors": ["James Darrell McCauley,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.kcv"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.info.html", "name": "v.info", "definition": "- Outputs basic information about a vector map.", "keywords": ["vector", "metadata", "topology", "extent", "history", "attribute columns", "level1"], "synopsis": "v.info [-hcget] map=name  [layer=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "h", "flag": "-h", "explanation": "Print history instead of info and exit Print types/names of table columns for specified layer instead of info and exit Print region info in shell script style Print extended metadata info in shell script style Print topology info in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Print types/names of table columns for specified layer instead of info and exit Print region info in shell script style Print extended metadata info in shell script style Print topology info in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print region info in shell script style Print extended metadata info in shell script style Print topology info in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Print extended metadata info in shell script style Print topology info in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Print topology info in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.info  reports some basic information (metadata) about a\n user-specified vector map and its topology status.\n  If topology info is not available (i.e., vector map cannot be open on\n level 2), vector map extends and number of features need to be counted\n on the fly which may take some time.\n  EXAMPLE \n  Basic metadata information \n v.info map=geology\n  +----------------------------------------------------------------------------+\n  | Name:            geology                                                   |\n  | Mapset:          PERMANENT                                                 |\n  | Location:        nc_spm_08                                                 |\n  | Database:        /home/martin/grassdata                                    |\n  | Title:           North Carolina geology map (polygon map)                  |\n  | Map scale:       1:1                                                       |\n  | Map format:      native                                                    |\n  | Name of creator: helena                                                    |\n  | Organization:    NC OneMap                                                 |\n  | Source date:     Mon Nov  6 15:48:53 2006                                  |\n  |----------------------------------------------------------------------------|\n  |   Type of map: vector (level: 2)                                           |\n  |                                                                            |\n  |   Number of points:       0               Number of centroids:  1832       |\n  |   Number of lines:        0               Number of boundaries: 3649       |\n  |   Number of areas:        1832            Number of islands:    907        |\n  |                                                                            |\n  |   Map is 3D:              No                                               |\n  |   Number of dblinks:      1                                                |\n  |                                                                            |\n  |   Projection: Lambert Conformal Conic                                      |\n  |                                                                            |\n  |               N:   318117.43741634    S:    10875.82723209                 |\n  |               E:   930172.31282271    W:   123971.19498978                 |\n  |                                                                            |\n  |   Digitization threshold: 0                                                |\n  |   Comment:                                                                 |\n  |                                                                            |\n  +----------------------------------------------------------------------------+\n  Map history \n v.info -h map=geology\n COMMAND: v.in.ogr input=\"geol.shp\" output=\"geology\" min_area=0.0001 snap=-1\n GISDBASE: /bigdata/grassdata05\n LOCATION: ncfromfile MAPSET: PERMANENT USER: helena DATE: Mon Nov  6 15:48:53 2006\n ---------------------------------------------------------------------------------\n 1832 input polygons\n total area: 1.276093e+11 (1832 areas)\n overlapping area: 0.000000e+00 (0 areas)\n area without category: 0.000000e+00 (0 areas)\n ---------------------------------------------------------------------------------\n  Attribute columns for given layer \n v.info -c map=geology\n Displaying column types/names for database connection of layer <1>:\n INTEGER|cat\n DOUBLE PRECISION|onemap_pro\n DOUBLE PRECISION|PERIMETER\n INTEGER|GEOL250_\n INTEGER|GEOL250_ID\n CHARACTER|GEO_NAME\n DOUBLE PRECISION|SHAPE_area\n DOUBLE PRECISION|SHAPE_len\n  Basic metadata information in shell script style \n v.info -get map=geology \n name=geology\n mapset=PERMANENT\n location=nc_spm_08\n database=/home/martin/grassdata\n title=North Carolina geology map (polygon map)\n scale=1:1\n format=native\n creator=helena\n organization=NC OneMap\n source_date=Mon Nov  6 15:48:53 2006\n level=2\n map3d=0\n num_dblinks=1\n projection=Lambert Conformal Conic\n digitization_threshold=0.000000\n comment=\n north=318117.43741634\n south=10875.82723209\n east=930172.31282271\n west=123971.19498978\n top=0.000000\n bottom=0.000000\n nodes=4556\n points=0\n lines=0\n boundaries=3649\n centroids=1832\n areas=1832\n islands=907\n primitives=5481\n v.info -g map=geology\n north=318117.43741634\n south=10875.82723209\n east=930172.31282271\n west=123971.19498978\n top=0.000000\n bottom=0.000000\n  PYTHON \n See  Python\n Scripting Library  for more info.\n Note: The Python tab in the  wxGUI  can be used for entering the\n following code:\n import grass.script as gcore\n     \n gcore.vector_columns('geology')   # for `v.info -c`\n gcore.vector_info_topo('geology') # for `v.info shell=topo`\n ", "notes": "", "see_also": ["r.info", "r3.info", "t.info"], "authors": ["Original author CERL"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.info"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.wfs.html", "name": "v.in.wfs", "definition": "- Imports GetFeature from a WFS server.", "keywords": ["vector", "import", "OGC web services"], "synopsis": "v.in.wfs [-lr] url=string output=name  [name=string[,string,...]]   [srs=string]   [maximum_features=integer]   [start_index=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "Download server capabilities to 'wms_capabilities.xml' in the current directory and exit Restrict fetch to features which touch the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Restrict fetch to features which touch the current region Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "url", "flag": "url", "dataType": "String", "optional": false, "explanation": "Base URL starting with 'http' and ending in '?'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "name", "flag": "name", "dataType": "String", "optional": true, "explanation": "Comma separated names of data layers to download", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "srs", "flag": "srs", "dataType": "String", "optional": true, "explanation": "Specify alternate spatial reference system (example: EPSG:4326)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "maximum_features", "flag": "maximum_features", "dataType": "String", "optional": true, "explanation": "Maximum number of features to download", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_index", "flag": "start_index", "dataType": "String", "optional": true, "explanation": "Skip earlier feature IDs and start downloading at this one", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.in.wfs  imports OGC WFS maps (Web Feature Service) from\n external servers.\n  EXAMPLES \n Import of world cities with population > 1 million:\n # run in Latitude-Longitude location (EPGS code 4326):\n # download geonam_gt1M layer:\n v.in.wfs \n    url=\"http://mapserver.flightgear.org/ms?Service=WFS&request=GetFeature&version=1.0.0\" \n    name=geonam_gt1M output=geonam_gt1M\n Download 25 ship wrecks from LINZ data service:\n (first create yourself a free API key at\n    http://data.linz.govt.nz/p/web-services/ )\n # run in LatLong location:\n URL='http://wfs.data.linz.govt.nz/<PUT YOUR API KEY HERE>/wfs?'\n # download available layers to wms_capabilities.xml\n v.in.wfs -l url=\"$URL\" \n From that file we learn that the shipwreck layer is called \" v:x633 \"\n and that EPSG code 4326 (LatLong WGS84) is a supported SRS for this data layer.\n v.in.wfs url=\"$URL\" output=linz_hydro_25_wrecks name=\"v:x633\" srs=\"EPSG:4326\" max=25\n  REQUIREMENTS \n The OGR library on the system needs to be compiled with Xerces C++ XML\n Parser support (for GML).\n ", "notes": "", "see_also": ["g.region", "r.in.wms", "v.in.ogr"], "authors": ["Markus Neteler, Hamish Bowman"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.in.wfs"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.region.html", "name": "v.in.region", "definition": "- Creates a vector polygon from the current region extent.", "keywords": ["vector", "geometry"], "synopsis": "v.in.region [-d] output=name  [type=string]   [cat=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Densify lines using region resolution Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Select type: line or area", "defaultValue": "area", "alternatives": ["line", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "cat", "flag": "cat", "dataType": "String", "optional": true, "explanation": "Category value", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.in.region  creates a new vector map from current region\n extent.\n If the output of  v.in.region  is to be used for raster\n reprojection, the  -d  flag should be used after setting the\n region to the raster map to be reprojected with\n  r.proj .\n ", "notes": "", "see_also": ["g.region", "d.vect", "r.proj"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.in.region"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.ogr.html", "name": "v.in.ogr", "definition": "- Imports vector data into a GRASS vector map using OGR library.", "keywords": ["vector", "import", "OGR", "topology", "geometry", "snapping", "create location"], "synopsis": "v.in.ogr [-flc2tojrewi] input=string  [layer=string[,string,...]]   [output=name]   [spatial=xmin,ymin,xmax,ymax[,xmin,ymin,xmax,ymax,...]]   [where=sql_query]   [min_area=float]   [type=string[,string,...]]   [snap=float]   [location=name]   [columns=name[,name,...]]   [encoding=string]   [key=string]   [geometry=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "List supported OGR formats and exit List available OGR layers in data source and exit Do not clean polygons (not recommended) Force 2D output even if input is 3D Useful if input is 3D but all z coordinates are identical Do not create attribute table Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Perform projection check only and exit Limit import to the current region Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available OGR layers in data source and exit Do not clean polygons (not recommended) Force 2D output even if input is 3D Useful if input is 3D but all z coordinates are identical Do not create attribute table Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Perform projection check only and exit Limit import to the current region Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Do not clean polygons (not recommended) Force 2D output even if input is 3D Useful if input is 3D but all z coordinates are identical Do not create attribute table Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Perform projection check only and exit Limit import to the current region Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "2", "flag": "-2", "explanation": "Force 2D output even if input is 3D Useful if input is 3D but all z coordinates are identical Do not create attribute table Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Perform projection check only and exit Limit import to the current region Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Perform projection check only and exit Limit import to the current region Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Perform projection check only and exit Limit import to the current region Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "j", "flag": "-j", "explanation": "Perform projection check only and exit Limit import to the current region Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Limit import to the current region Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Extend region extents based on new dataset Also updates the default region if in the PERMANENT mapset Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Change column names to lowercase characters Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of OGR datasource to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "OGR layer name. If not given, all available layers are imported", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "spatial", "flag": "spatial", "dataType": "String", "optional": true, "explanation": "Import subregion only", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "min_area", "flag": "min_area", "dataType": "String", "optional": true, "explanation": "Minimum size of area to be imported (square meters)", "defaultValue": "0.0001", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Optionally change default input type", "defaultValue": null, "alternatives": ["point", "line", "boundary", "centroid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "snap", "flag": "snap", "dataType": "String", "optional": true, "explanation": "Snapping threshold for boundaries (map units)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Name for new location to create", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "List of column names to be used instead of original names, first is used for category column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "encoding", "flag": "encoding", "dataType": "String", "optional": true, "explanation": "Encoding value for attribute data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "key", "flag": "key", "dataType": "String", "optional": true, "explanation": "Name of column used for categories", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "geometry", "flag": "geometry", "dataType": "String", "optional": true, "explanation": "Name of geometry column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.in.ogr  imports vector data from files and database connections\n supported by the  OGR  library) into the\n current location and mapset.\n If the  layer  parameter is not given, all available OGR layers\n are imported as separate GRASS layers into one GRASS vector map. If\n several OGR layer names are given, all these layers are imported as\n separate GRASS layers into one GRASS vector map.\n The optional  spatial  parameter defines spatial query extents.\n This parameter allows the user to restrict the region to a spatial\n subset while importing the data. All vector features completely or\n partially falling into this rectangle subregion are imported.\n The  -r  current region flag is identical, but uses the current\n region settings as the spatial bounds\n (see  g.region ).\n  Supported Vector Formats \n  v.in.ogr  uses the OGR library which supports various vector \n data formats including  ESRI Shapefile ,  Mapinfo File , UK .NTF, \n SDTS, TIGER, IHO S-57 (ENC), DGN, GML, GPX, AVCBin, REC, Memory, OGDI, \n and PostgreSQL, depending on the local OGR installation. For details \n see the  OGR web \n site . The  -f  prints a list of the vector formats supported \n by the system's OGR (Simple Features Library). The OGR (Simple Features \n Library) is part of the  GDAL  library, \n hence GDAL needs to be installed to use  v.in.ogr .\n The list of actually supported formats can be printed by  -f  flag.\n  Topology cleaning \n Topology cleaning on areas is automatically performed, but may fail in\n special cases. In these cases, a  snap  threshold value is \n estimated from the imported vector data and printed out at the end. The \n vector data can then be imported again with the suggested  snap  \n threshold value which is incremented by powers of 10 until either an \n estimated upper limit for the threshold value is reached or the topology \n cleaning on areas was successful. In some cases, manual cleaning might \n be required or areas are truly overlapping, e.g. buffers created with \n non-topological software.\n The  min_area  threshold value is being specified as area size in\n map units with the exception of latitude-longitude locations in which\n it is being specified solely in square meters.\n The  snap  threshold value is used to snap boundary vertices to\n each other if the distance in map units between two vertices is not\n larger than the threshold. Snapping is by default disabled with\n -1. See also the  v.clean  manual.\n  Overlapping polygons \n When importing overlapping polygons, the overlapping parts will become\n new areas with multiple categories, one unique category for each\n original polygon. An original polygon will thus be converted to\n multiple areas with the same shared category. These multiple areas\n will therefore also link to the same entry in the attribute table. A\n single category value may thus refer to multiple non-overlapping areas\n which together represent the original polygon overlapping with another\n polygon. The original polygon can be recovered by\n using  v.extract  with the desired\n category value or  where  statement and the  -d  flag to\n dissolve common boundaries.\n  Location Creation \n  v.in.ogr  attempts to preserve projection information when\n importing datasets if the source format includes projection\n information, and if the OGR driver supports it.  If the projection of\n the source dataset does not match the projection of the current\n location  v.in.ogr  will report an error message\n (\"Projection of dataset does not appear to match current\n location\").\n If the user wishes to ignore the difference between the apparent\n coordinate system of the source data and the current location, they\n may pass the  -o  flag to override the projection check.\n If the user wishes to import the data with the full projection\n definition, it is possible to have  v.in.ogr  automatically\n create a new location based on the projection and extents of the file\n being read. This is accomplished by passing the name to be used for\n the new location via the  location  parameter.  Upon completion\n of the command, a new location will have been created (with only a\n PERMANENT mapset), and the vector map will have been imported with the\n indicated  output  name into the PERMANENT mapset.\n An interesting wrapper command around  v.in.ogr  is\n  v.import  which reprojects (if needed) the\n vector dataset during import to the projection of the current location.\n ", "notes": "\n  Table column names: supported characters \n The characters which are eligible for table column names are limited\n by the SQL standard. Supported are:\n [A-Za-z][A-Za-z0-9_]*\n This means that SQL neither supports '.' (dots) nor '-' (minus) nor\n '#' in table column names. Also a table name must start with a\n character, not a number.\n  v.in.ogr  converts '.', '-' and '#' to '_' (underscore) during\n import. The  -w  flag changes capital column names to\n lowercase characters as a convenience for SQL usage (lowercase column\n names avoid the need to quote them if the attribute table is stored in\n a SQL DBMS such as PostgreSQL). The  columns  parameter is used\n to define new column names during import.\n The DBF database specification limits column names to 10 characters.\n If the default DB is set to DBF and the input data contains longer\n column/field names, they will be truncated. If this results in\n multiple columns with the same name then  v.in.ogr  will\n produce an error.  In this case you will either have to modify the\n input data or use\n  v.in.ogr 's  columns  parameter to rename columns to something\n unique. (hint: copy and modify the list given with the error message).\n Alternatively, change the local DB with\n  db.connect .\n  File encoding \n When importing ESRI Shapefiles the OGR library tries to read the\n LDID/codepage setting from the .dbf file and use it to translate\n string fields to UTF-8. LDID \"87 / 0x57\" is treated as\n ISO8859_1 which may not be appropriate for many\n languages. Unfortunately it is not clear what other values may be\n appropriate (see example below). To change encoding the user can set\n up  SHAPE_ENCODING \n environmental variable or simply to define\n encoding value using  encoding  parameter. Note that recoding\n support is new for GDAL/OGR 1.9.0.\n Value for  encoding  also affects text recoding when importing\n DXF files. For other formats has encoding value no effect.\n  Defining the key column \n Option  key  specifies the column name used for feature\n categories. This column must be integer. If not specified, categories\n numbers are generated starting with 1 and stored in the column named\n \"cat\".\n  Supports of multiple geometry columns \n Starting with GDAL 1.11 the library supports multiple geometry columns\n in OGR. By default  v.in.ogr  reads all geometry columns from\n given layer. The user can choose desired geometry column\n by  geometry  option,\n see  example below .\n  Latitude-longitude data: Vector postprocessing after import \n For vector data like a grid, horizontal lines need to be broken at their\n intersections with vertical lines ( v.clean ... tool=break ).\n  EXAMPLES \n The command imports various vector formats:\n  SHAPE files \n v.in.ogr input=/home/user/shape_data/test_shape.shp output=grass_map \n Alternate method:\n v.in.ogr input=/home/user/shape_data layer=test_shape output=grass_map \n Define encoding value for attribute data (in this example we expect\n attribute data\n in  Windows-1250 \n encoding; ie. in Central/Eastern European languages that\n use Latin script, Microsoft Windows encoding).\n v.in.ogr input=/home/user/shape_data/test_shape.shp output=grass_map encoding=cp1250\n  MapInfo files \n v.in.ogr input=./ layer=mapinfo_test output=grass_map\n  Arc Coverage \n We import the Arcs and Label points, the module takes care to build\n areas.\n v.in.ogr input=gemeinden layer=LAB,ARC type=centroid,boundary output=mymap\n  E00 file \n See also  v.in.e00 .\n First we have to convert the E00 file to an Arc Coverage with\n 'avcimport'\n ( AVCE00\n tools , use  e00conv  first in case that  avcimport \n fails):\n avcimport e00file coverage\n v.in.ogr input=coverage layer=LAB,ARC type=centroid,boundary output=mymap\n  SDTS files \n You have to select the CATD file.\n v.in.ogr input=CITXCATD.DDF output=cities\n  TIGER files \n v.in.ogr input=input/2000/56015/ layer=CompleteChain,PIP output=t56015_all \n  type=boundary,centroid snap=-1\n  PostGIS tables \n Import polygons as areas:\n v.in.ogr input=\"PG:host=localhost dbname=postgis user=postgres\" layer=polymap \n  output=polygons type=boundary,centroid\n If the table containing the polygons are in a specific schema, you can use:\n v.in.ogr input=\"PG:host=localhost dbname=postgis user=postgres\" \n  layer=myschema.polymap \n  output=polygons type=boundary,centroid\n Generally, v.in.ogr just follows the \n  format-specific \n syntax defined by the OGR library.\n  OpenStreetMap (OSM) \n  OSM data  are available in \n .osm (XML based) and .pbf (optimized binary) formats. The .pbf format \n is recommended because file sizes are smaller. The OSM driver will \n categorize features into 5 layers :\n      points : \"node\" features that have significant tags attached. \n      lines : \"way\" features that are recognized as non-area. \n      multilinestrings : \"relation\" features that form a \n multilinestring(type = 'multilinestring' or type = 'route'). \n      multipolygons : \"relation\" features that form a multipolygon (type \n = 'multipolygon' or type = 'boundary'), and \"way\" features that are \n recognized as area.\n      other_relations : \"relation\" features that do \n not belong to any of the above layers.\n It is recommended to import one layer at a time, and to select features \n with the  where  option, e.g. to import roads, use \n v.in.ogr where=\"highway <> ''\"\n i.e. the OSM tag  highway  must be set.\n When importing administrative boundaries from OSM, it is important to \n not only select administrative boundaries, but also the admin level to \n be imported (valid range is 1 - 11), e.g. with\n v.in.ogr where=\"boundary = 'administrative' and admin_level = '1'\"\n The OSM topological model differs from the GRASS topological model. OSM \n topologically correct connections of lines can be on all vertices of a \n line. During import, lines are automatically split at those vertices \n where an OSM connection to another line exists.\n Import of OSM data requires a configuration file, defined with the \n OSM_CONFIG_FILE configuration option. In the data folder of the GDAL \n distribution, you can find a  osmconf.ini file \n that can be customized to fit your needs. See \n  OSM map features  \n for keys and their values. You should set \"other_tags=no\" to \n avoid problems with import or querying the imported vector. Once a \n OSM_CONFIG_FILE has been created, OSM data can be imported with e.g.\n export OSM_CONFIG_FILE=/path/to/osmconf.ini\n v.in.ogr input=name.pbf layer=lines output=osm_data\n  Oracle Spatial \n Note that you have to set the environment-variables  ORACLE_BASE,\n ORACLE_SID, ORACLE_HOME  and  TNS_ADMIN  accordingly.\n v.in.ogr input=OCI:username/password@database_instance output=grasslayer layer=roads_oci\n  Multiple geometry columns \n This example shows how to work with data which contain multiple\n geometry per feature. The number of geometry columns per feature can\n be checked by  v.external \n together with  -t  flag.\n                   \n v.external -t input=20141130_ST_UKSH.xml.gz\n ...\n Okresy,point,1,DefinicniBod\n Okresy,multipolygon,1,OriginalniHranice\n Okresy,multipolygon,1,GeneralizovaneHranice\n ...\n        \n In our example layer \"Okresy\" has three geometry columns:\n \"DefinicniBod\", \"OriginalniHranice\" and\n \"GeneralizovanaHranice\". By default  v.in.ogr  reads data from\n all three geometry columns. The user can specify desired geometry\n column by  geometry  option, in this case the module will read\n geometry only from the specified geometry column. In the example below,\n the output vector map will contain only geometry saved in\n \"OriginalniHranice\" geometry column.\n v.in.ogr input=20141130_ST_UKSH.xml.gz layer=Okresy geometry=OriginalniHranice\n        \n  WARNINGS \n If a message like \"WARNING: Area size 1.3e-06, area not\n imported.\" appears, the  min_area  may be adjusted to a\n smaller value so that all areas are imported. Otherwise tiny areas are\n filtered out during import (useful to polish digitization errors or\n non-topological data).\n If a message like \"Try to import again, snapping with at least\n 1e-008: 'snap=1e-008'\" appears, then the map to be imported\n contains topological errors. The message suggests a value for the\n  snap  parameter to be tried. For more details, see above in\n  Topology Cleaning .\n  ERROR MESSAGES \n  DBMI-DBF driver error: SQL parser error: syntax error,\n unexpected DESC, expecting NAME processing 'DESC' \n  indicates that a column name corresponds to a reserved SQL word (here: 'DESC').\n A different column name should be used. The  columns  parameter can be used\n to assign different column names on the fly. \n  Projection of dataset does not appear to match the current location. \n  You need to create a location whose projection matches the data\n you wish to import. Try using  location  parameter to create a\n new location based upon the projection information in the file. If\n desired, you can then re-project it to another location\n with  v.proj . \n  REFERENCES \n    OGR vector library \n    OGR vector library C API  documentation \n ", "see_also": ["db.connect", "v.clean", "v.extract", "v.build.polylines", "v.edit", "v.external", "v.import", "v.in.db", "v.in.e00", "v.out.ogr"], "authors": ["Original author: Radim Blazek, ITC-irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.in.ogr"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.mapgen.html", "name": "v.in.mapgen", "definition": "- Imports Mapgen or Matlab-ASCII vector maps into GRASS.", "keywords": ["vector", "import"], "synopsis": "v.in.mapgen [-fz] input=name  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Input map is in Matlab format Create a 3D vector points map from 3 column Matlab data Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Create a 3D vector points map from 3 column Matlab data Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file in Mapgen/Matlab format", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map (omit for display to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.in.mapgen  allows the user to import Mapgen or Matlab vector maps \n into GRASS.\n ", "notes": "\n This module only imports data into vector lines.\n  The user can get coastline data in Mapgen or Matlab format from NOAA's Coastline \n Extractor at  http://www.ngdc.noaa.gov/mgg/shorelines/shorelines.html .\n  Matlab vector line maps are simply a series of \"x y\" data points. Lines\n are separated by a row containing  NaN NaN .\n Output from Matlab with this command:\n     save filename.txt arrayname -ASCII\n  The user can import 3D lines from Matlab by exporting a 3 column array and\n using the  -z  flag.\n ", "see_also": ["v.in.ascii"], "authors": ["Based on"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.in.mapgen"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.lines.html", "name": "v.in.lines", "definition": "- Imports ASCII x,y[,z] coordinates as a series of lines.", "keywords": ["vector", "import", "line", "point"], "synopsis": "v.in.lines [-z] input=name output=name  [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Create a 3D line from 3 column data Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file (or \"-\" to read from stdin)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n Imports a stream of ASCII x,y[,z] coordinates as a line or series of lines.\n ", "notes": "\n Input ASCII coordinates are simply a series of \"x\u00a0y\" data points.\n Lines are separated by a row containing \" NaN\u00a0NaN \".\n  The user can import 3D lines by providing 3 columns of data in the input\n stream and using the  -z  flag.\n  This script is a simple wrapper around the  v.in.mapgen  module.\n  EXAMPLE \n v.in.lines in=- out=two_lines separator=, <<EOF\n 167.846717,-46.516653\n 167.846663,-46.516645\n 167.846656,-46.516644\n 167.846649,-46.516644\n 167.846642,-46.516643\n NaN,NaN\n 167.846520,-46.516457\n 167.846528,-46.516461\n 167.846537,-46.516464\n 167.846535,-46.516486\n 167.846544,-46.516489\n 167.846552,-46.516493\n EOF\n ", "see_also": ["v.in.ascii", "v.in.mapgen", "v.out.ascii", "d.graph", "r.in.poly"], "authors": ["Hamish Bowman"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.in.lines"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.lidar.html", "name": "v.in.lidar", "definition": "- Converts LAS LiDAR point clouds to a GRASS vector map with libLAS.", "keywords": ["vector", "import", "LIDAR", "level1"], "synopsis": "v.in.lidar [-pruvetcboi] input=name output=name  [id_layer=string]   [return_layer=string]   [class_layer=string]   [rgb_layer=string]   [spatial=xmin,ymin,xmax,ymax[,xmin,ymin,xmax,ymax,...]]   [zrange=min,max]   [return_filter=string]   [class_filter=integer[,integer,...]]   [mask=name]   [mask_layer=string]   [skip=integer]   [preserve=integer]   [offset=integer]   [limit=integer]   [location=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print LAS file info and exit Limit import to the current region Invert mask when selecting points Use only valid points Points invalid according to APSRS LAS specification will be filtered out Extend region extents based on new dataset Do not create attribute table Do not automatically add unique ID as category to each point Create only requested layers and categories Do not build topology Advantageous when handling a large number of points Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Limit import to the current region Invert mask when selecting points Use only valid points Points invalid according to APSRS LAS specification will be filtered out Extend region extents based on new dataset Do not create attribute table Do not automatically add unique ID as category to each point Create only requested layers and categories Do not build topology Advantageous when handling a large number of points Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "u", "flag": "-u", "explanation": "Invert mask when selecting points Use only valid points Points invalid according to APSRS LAS specification will be filtered out Extend region extents based on new dataset Do not create attribute table Do not automatically add unique ID as category to each point Create only requested layers and categories Do not build topology Advantageous when handling a large number of points Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Use only valid points Points invalid according to APSRS LAS specification will be filtered out Extend region extents based on new dataset Do not create attribute table Do not automatically add unique ID as category to each point Create only requested layers and categories Do not build topology Advantageous when handling a large number of points Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Extend region extents based on new dataset Do not create attribute table Do not automatically add unique ID as category to each point Create only requested layers and categories Do not build topology Advantageous when handling a large number of points Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Do not automatically add unique ID as category to each point Create only requested layers and categories Do not build topology Advantageous when handling a large number of points Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Do not automatically add unique ID as category to each point Create only requested layers and categories Do not build topology Advantageous when handling a large number of points Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Create the location specified by the \"location\" parameter and exit. Do not import the vector data. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "LAS input file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "id_layer", "flag": "id_layer", "dataType": "String", "optional": true, "explanation": "Layer number to store generated point ID as category", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "return_layer", "flag": "return_layer", "dataType": "String", "optional": true, "explanation": "Layer number to store return information as category", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "class_layer", "flag": "class_layer", "dataType": "String", "optional": true, "explanation": "Layer number to store class number as category", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rgb_layer", "flag": "rgb_layer", "dataType": "String", "optional": true, "explanation": "Layer number where RBG colors are stored as category", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "spatial", "flag": "spatial", "dataType": "String", "optional": true, "explanation": "Import subregion only", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zrange", "flag": "zrange", "dataType": "String", "optional": true, "explanation": "Filter range for z data (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "return_filter", "flag": "return_filter", "dataType": "String", "optional": true, "explanation": "Only import points of selected return type", "defaultValue": null, "alternatives": ["first", "last", "mid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "class_filter", "flag": "class_filter", "dataType": "String", "optional": true, "explanation": "Only import points of selected class(es)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mask", "flag": "mask", "dataType": "String", "optional": true, "explanation": "Areas where to import points", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mask_layer", "flag": "mask_layer", "dataType": "String", "optional": true, "explanation": "Layer number or name for mask option", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "skip", "flag": "skip", "dataType": "String", "optional": true, "explanation": "Do not import every n-th point", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "preserve", "flag": "preserve", "dataType": "String", "optional": true, "explanation": "Import only every n-th point", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "offset", "flag": "offset", "dataType": "String", "optional": true, "explanation": "Skip first n points", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "limit", "flag": "limit", "dataType": "String", "optional": true, "explanation": "Import only n points", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": true, "explanation": "Name for new location to create", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.in.lidar  converts LiDAR point clouds in LAS format to a GRASS \n vector, using the  libLAS  library. \n The created vector is true 3D with x, y, z coordinates.\n For larger datasets, it is recommended to not build topology (-b flag).\n Also, creating a table with attributes can take some time for larger datasets.\n The optional  spatial  parameter defines spatial query extents.\n This parameter allows the user to restrict the region to a spatial subset\n while importing the data. All LiDAR points falling into this rectangle \n subregion are imported. The  -r  current region flag is identical, \n but uses the current region settings as the spatial bounds \n (see  g.region ).\n A LiDAR pulse can have multiple returns. The first return values can be \n used to obtain a digital surface model (DSM) where e.g. canopy cover is \n represented. The last return values can be used to obtain a digital \n terrain model (DTM) where e.g. the forest floor instead of canopy \n cover is represented. The  return_filter  option allows selecting one of \n first, mid, or last returns.\n LiDAR points can be already classified into standardized classes. For example,\n class number 2 represents ground (for other classes see LAS format specification\n in references). The  class_filter  option allows selecting one or more \n classes, as numbers (integers) separated by comma.\n Note that proper filtering of the input points in not only critical for\n the analysis itself but it can also speed up the processing\n significantly.\n  Decimation \n Table with selected percentages of points to keep with corresponding\n decimation parameters:\n  percentage parameters \n  0.1% preserve=1000 \n  1% preserve=100 \n  5% preserve=20 \n  10% preserve=10 \n  20% preserve=5 \n  25% preserve=4 \n  50% skip=2 \n  75% skip=4 \n  80% skip=5 \n  90% skip=10 \n Table with selected fractions of points to keep with corresponding\n decimation parameters:\n  ratio parameters \n  1/3 preserve=3 \n  1/4 preserve=4 \n  1/5 preserve=5 \n  1/6 preserve=6 \n Table with selected fractions of points to throw away with corresponding\n decimation parameters:\n  ratio parameters \n  1/3 skip=3 \n  1/4 skip=4 \n  1/5 skip=5 \n  1/6 skip=6 \n  Location Creation \n  v.in.lidar  attempts to preserve projection information when importing\n datasets if the source format includes projection information, and if\n the LAS driver supports it.  If the projection of the source dataset does\n not match the projection of the current location  v.in.lidar  will \n report an error message (\" Projection of dataset does not appear to \n match current location \") and then report the PROJ_INFO parameters of\n the source dataset.\n  If the user wishes to ignore the difference between the apparent coordinate\n system of the source data and the current location, they may pass the \n  -o  flag to override the projection check.\n  If the user wishes to import the data with the full projection definition,\n it is possible to have  v.in.lidar  automatically create a new location based\n on the projection and extents of the file being read.  This is accomplished\n by passing the name to be used for the new location via the  location \n parameter.  Upon completion of the command, a new location will have been\n created (with only a PERMANENT mapset), and the vector map will have been\n imported with the indicated  output  name into the PERMANENT mapset.\n ", "notes": "\n The typical file extensions for the LAS format are .las and .laz (compressed). \n The compressed LAS (.laz) format can be imported only if libLAS has been compiled \n with laszip support. It is also recommended to compile libLAS with GDAL, \n needed to test for matching projections.\n  EXAMPLE \n This example is analogous to the example used in the GRASS wiki page for\n  importing LAS as vector points .\n  The sample LAS data are in the file \"Serpent Mound Model LAS Data.las\", \n available at \n  appliedimagery.com \n   # print LAS file info\n   v.in.lidar -p input=\"Serpent Mound Model LAS Data.las\"\n   # create location with projection information of the LAS data\n   v.in.lidar -i input=\"Serpent Mound Model LAS Data.las\" location=Serpent_Mound\n   # quit and restart GRASS in the newly created location \"Serpent_Mound\"\n   # real import of LiDAR LAS data, without topology and without attribute table\n   v.in.lidar -tb input=\"Serpent Mound Model LAS Data.las\" output=Serpent_Mound_Model_pts\n ", "see_also": ["r.in.lidar", "r3.in.lidar", "g.region", "v.vect.stats", "v.in.ogr"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.in.lidar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.geonames.html", "name": "v.in.geonames", "definition": "- Imports geonames.org country files into a vector points map.", "keywords": ["vector", "import", "gazetteer"], "synopsis": "v.in.geonames input=name output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of uncompressed geonames file (with .txt extension)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.in.geonames  imports Geonames.org country files (Gazetteer\n data) into a GRASS vector points map. The country files can be\n downloaded from the\n  GeoNames Data Dump\n Server . Only original files can be processed (unzip compressed\n file first). These Geonames files are encoded in UTF-8 which is\n maintained in the GRASS database.\n ", "notes": "\n  v.in.geonames \n calls  v.in.ascii  to import data\n into GRASS.\n The current DB connection is used to write the database table\n (see  db.connect ). If importing\n into a  DBF database , the original column\n names longer that 10 characters are shortened to 10 characters to meet\n the DBF column name restrictions. If this is a problem consider\n choosing another database driver\n with  db.connect \n (eg. to  SQLite driver ).\n The main 'geoname' table has the following fields\n geonameid         : integer id of record in geonames database\n name              : name of geographical point (utf8) varchar(200)\n asciiname         : name of geographical point in plain ascii characters, varchar(200)\n alternatenames    : alternatenames, comma separated varchar(4000)\n latitude          : latitude in decimal degrees (wgs84)\n longitude         : longitude in decimal degrees (wgs84)\n feature class     : see http://www.geonames.org/export/codes.html, char(1)\n feature code      : see http://www.geonames.org/export/codes.html, varchar(10)\n country code      : ISO-3166 2-letter country code, 2 characters\n cc2               : alternate country codes, comma separated, ISO-3166 2-letter country code, 60 characters\n admin1 code       : fipscode (subject to change to iso code), isocode for the us and ch, see file admin1Codes.txt for display names of this code; varchar(20)\n admin2 code       : code for the second administrative division, a county in the US, see file admin2Codes.txt; varchar(80) \n admin3 code       : code for third level administrative division, varchar(20)\n admin4 code       : code for fourth level administrative division, varchar(20)\n population        : integer \n elevation         : in meters, integer\n gtopo30           : average elevation of 30'x30' (ca 900mx900m) area in meters, integer\n timezone          : the timezone id (see file http://download.geonames.org/export/dump/timeZones.txt)\n modification date : date of last modification in yyyy-MM-dd format\n  EXAMPLE \n Download and import geonames for Czech Republic.\n wget http://download.geonames.org/export/dump/CZ.zip\n unzip CZ.zip\n v.in.geonames input=CZ.txt output=geonames_cz\n  REFERENCES \n    GeoNames Web site \n    GeoNames Data Dump Server \n ", "see_also": ["db.connect", "v.in.ascii", "v.select"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.in.geonames"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.e00.html", "name": "v.in.e00", "definition": "- Imports E00 file into a vector map.", "keywords": ["vector", "import", "E00"], "synopsis": "v.in.e00 input=name type=string[,string,...] output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input E00 file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": false, "explanation": "Input feature type", "defaultValue": "point", "alternatives": ["point", "line", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.in.e00  imports ASCII and binary E00 vector maps into GRASS.\n ", "notes": "\n Sometimes an .e00 coverage consists of multiple files, where a single\n data set is contained as a series of files named filename.e00, filename.e01,\n filename.e02 etc. The user must take care to download them all, the scripts\n automatically detects the presence of such multiple files.\n  REFERENCES \n  AVCE00 library  (providing 'avcimport' and 'e00conv') \n  OGR vector library \n ", "see_also": ["v.in.ogr"], "authors": ["Markus Neteler, Otto Dassau,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.in.e00"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.dxf.html", "name": "v.in.dxf", "definition": "- Converts file in DXF format to GRASS vector map.", "keywords": ["vector", "import", "DXF", "level1"], "synopsis": "v.in.dxf [-etbfli1] input=name output=name  [layers=string[,string,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Ignore the map extent of DXF file Do not create attribute table Do not build topology Advantageous when handling a large number of points Import polyface meshes as 3D wire frame List available DXF layers and exit Invert selection by DXF layers (don't import layers in list) Import all objects into one layer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Do not build topology Advantageous when handling a large number of points Import polyface meshes as 3D wire frame List available DXF layers and exit Invert selection by DXF layers (don't import layers in list) Import all objects into one layer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Import polyface meshes as 3D wire frame List available DXF layers and exit Invert selection by DXF layers (don't import layers in list) Import all objects into one layer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Import polyface meshes as 3D wire frame List available DXF layers and exit Invert selection by DXF layers (don't import layers in list) Import all objects into one layer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available DXF layers and exit Invert selection by DXF layers (don't import layers in list) Import all objects into one layer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Invert selection by DXF layers (don't import layers in list) Import all objects into one layer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "1", "flag": "-1", "explanation": "Import all objects into one layer Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Path to input DXF file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "layers", "flag": "layers", "dataType": "String", "optional": true, "explanation": "List of DXF layers to import (default: all)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.in.dxf  converts DXF format CAD files to GRASS vector\n format. The following graphical objects (DXF entities) are supported:\n    point\n      \n        DXF POINT \n      \n    \n    line\n      \n        DXF LINE \n        DXF POLYLINE \n        DXF LWPOLYLINE \n        DXF ARC \n        DXF CIRCLE \n        DXF TEXT \n      \n    \n    face\n      \n        DXF POLYFACE MESHES \n        DXF 3DFACE \n    \n    \n Table and column names are changed to lowercase characters for easier\n SQL usage (lowercase table/column names avoid the need to quote them\n if the attribute table is stored in a SQL DBMS such as PostgreSQL).\n  The \"layer\" column will contain the name(s) of the DXF input\n layer(s). The DXF entity type string will be stored in the \"entity\"\n column as uppercase.\n  The \"handle\" column can be used to store small bits of data associated\n with any entity in the DXF file (i.e., entity handle or unique object\n identifiers in the layer). The entity handle is a \"text string of up\n to 16 hexadecimal digits\", which is a 64-bit integer (currently not\n supported by GRASS database drivers).  For text type entities, the\n text value will be stored in the \"label\" column of the GRASS vector\n output map. Neither the \"handle\" nor \"label\" column is mandatory.\n  REFERENCES \n  AutoCad DXF  (from Wikipedia, the free encyclopedia) \n  DXF References  (Autodesk-supplied documentation)\n ", "notes": "", "see_also": ["v.out.dxf", "v.in.ogr", "v.out.ogr"], "authors": ["Original written by Chuck Ehlschlaeger, 6/1989"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.in.dxf"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.db.html", "name": "v.in.db", "definition": "- Creates new vector (points) map from database table containing coordinates.", "keywords": ["vector", "import", "database", "points"], "synopsis": "v.in.db [-t] table=name  [driver=name]   [database=name]  x=name y=name  [z=name]   [key=name]   [where=sql_query]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Use imported table as attribute table for new map Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": false, "explanation": "Input table name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "driver", "flag": "driver", "dataType": "String", "optional": true, "explanation": "Name of database driver", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "database", "flag": "database", "dataType": "String", "optional": true, "explanation": "Name of database", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "x", "flag": "x", "dataType": "String", "optional": false, "explanation": "Name of column containing x coordinate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y", "flag": "y", "dataType": "String", "optional": false, "explanation": "Name of column containing y coordinate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "z", "flag": "z", "dataType": "String", "optional": true, "explanation": "Name of column containing z coordinate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "key", "flag": "key", "dataType": "String", "optional": true, "explanation": "Name of column containing category number", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.in.db  creates a new vector point map from database table or file\n containing coordinates.\n ", "notes": "\n If GRASS comes with  OGR  support\n than  v.in.db  allows importing data from different input\n files, eg. CSV or MS Excel (assuming that GDAL/OGR library is compiled\n with this support).\n  v.in.db  creates key column \"cat\" automatically\n when  key  option is not given. Note that this operation is\n possible to perform only when  -t  flag is not given. Currently,\n automated creation of key column is supported only when default DB\n driver for output vector map is  SQLite\n driver  otherwise  key  option must be specified by the\n user. Default DB driver is defined\n by  db.connect .\n  EXAMPLES \n  Creating a map from PostgreSQL table \n v.in.db driver=pg database=\"host=myserver.itc.it,dbname=mydb\" \n          table=pat_stazioni x=east y=north z=quota key=id output=pat_stazioni\n  If an ID column is not present in the PostgreSQL table, a new\n column should be added. See  PostgreSQL DB\n driver  page for details.\n  Creating a map from PostGIS \n To extract coordinate values from PostGIS, functions have to be used:\n v.in.db driver=pg database=\"host=myserver.itc.it,dbname=mydb\" \n          table=station x=\"x(geom)\" y=\"y(geom)\" z=\"z(geom)\" key=id out=meteostations\n  If an ID column is not present in the PostgreSQL table, a new\n column should be added. See  PostgreSQL DB\n driver  page for details.\n  Alternatively a vector point map can be imported from PostGIS\n database using  v.in.ogr .\n  Creating a map from Open Document spreadsheet (ODS) file \n A new vector point map is created from given sheet in ODS file. The\n  database  option points to the ODS file. Option  table  is the\n name of selected spreadsheet list, the  key  option is the identifier\n column:\n # preview table structure with OGR tool (table name is \"Layer name\" here):\n ogrinfo -al -so meteodata.ods\n # import sheet from ODS into map\n v.in.db key=ID table=mysheet x=long y=lat z=height output=meteodata \n           driver=ogr database=meteodata.ods\n  Creating a map from MS Excel file \n A new vector point map is created from given sheet in MS Excel file. The\n  database  option points to the file in MS Excel\n format. Option  table  is name of the selected spreadsheet \"List1\":\n v.in.db table=List1 x=long y=lat z=height output=meteodata \n           driver=ogr database=meteodata.xls\n Note that in this example the  key  option is omitted. In this case\n  v.in.db  tries to add key column automatically. This\n requires  SQLite  to be a default DB\n driver. \n  Creating a map from DBF table \n A new 3D point vector map is created from DBF table. Column 'idcol'\n contains unique row IDs. The  database  option is the\n directory where the DBF file is stored.\n v.in.db driver=dbf database=/home/user/tables/ table=pointsfile x=x y=y z=z \n          key=idcol out=dtmpoints\n To check result:\n v.info dtmpoints\n v.info -c dtmpoints\n  If DB driver for output vector map is different from SQLite driver\n and an ID column is missing in the DBF file, it has to be added\n beforehand, e.g. with OpenOffice.  Alternatively, import the table\n with  db.in.ogr  into GRASS and\n then with  v.in.db  from the imported table\n ( db.in.ogr  optionally adds an\n unique ID column).\n  Creating a point map from DBF table for selected records only \n  The user can import only selected vector points from a table using\n the  where  parameter (see above for general DBF handling):\n v.in.db driver=dbf  database=/home/user/tables/ table=pointsfile x=x y=y z=z \n          key=idcol out=dtmpoints where=\"x NOT NULL and z > 100\"\n  Creating a map from SQLite table \n A new vector point map is created from table in SQLite database\n file. Column 'idcol' contains unique row IDs. The\n  database  option is the the SQLite database file.\n v.in.db driver=sqlite database=/home/user/tables/mysqlite.db table=pointsfile x=x y=y z=z \n          key=idcol out=dtmpoints\n ", "see_also": ["db.execute", "db.in.ogr", "v.info", "v.in.geonames", "v.in.ogr", "v.to.db"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.in.db"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.in.ascii.html", "name": "v.in.ascii", "definition": "- Creates a vector map from an ASCII points file or ASCII vector file.", "keywords": ["vector", "import", "ASCII", "level1"], "synopsis": "v.in.ascii [-zentbri] input=name output=name  [format=string]   [separator=character]   [text=character]   [skip=integer]   [columns=string]   [x=integer]   [y=integer]   [z=integer]   [cat=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Create 3D vector map Create a new empty vector map and exit. Nothing is read from input. Do not expect a header when reading in standard format Do not create table in points mode Do not build topology Do not build topology in points mode Only import points falling within current region (points mode) Ignore broken line(s) in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Create a new empty vector map and exit. Nothing is read from input. Do not expect a header when reading in standard format Do not create table in points mode Do not build topology Do not build topology in points mode Only import points falling within current region (points mode) Ignore broken line(s) in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Do not expect a header when reading in standard format Do not create table in points mode Do not build topology Do not build topology in points mode Only import points falling within current region (points mode) Ignore broken line(s) in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create table in points mode Do not build topology Do not build topology in points mode Only import points falling within current region (points mode) Ignore broken line(s) in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Do not build topology in points mode Only import points falling within current region (points mode) Ignore broken line(s) in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Only import points falling within current region (points mode) Ignore broken line(s) in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "i", "flag": "-i", "explanation": "Ignore broken line(s) in points mode Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input file to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Input file format", "defaultValue": "point", "alternatives": ["point", "standard"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "text", "flag": "text", "dataType": "String", "optional": true, "explanation": "Text delimiter", "defaultValue": "doublequote", "alternatives": ["doublequote", "singlequote", "none"], "isInputFile": false, "isOutputFile": false}, {"parameter": "skip", "flag": "skip", "dataType": "String", "optional": true, "explanation": "Number of header lines to skip at top of input file (points mode)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Column definition in SQL style (points mode)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "x", "flag": "x", "dataType": "String", "optional": true, "explanation": "Number of column used as x coordinate (points mode)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "y", "flag": "y", "dataType": "String", "optional": true, "explanation": "Number of column used as y coordinate (points mode)", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "z", "flag": "z", "dataType": "String", "optional": true, "explanation": "Number of column used as z coordinate (points mode)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cat", "flag": "cat", "dataType": "String", "optional": true, "explanation": "Number of column used as category (points mode)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.in.ascii  converts a vector map\n in  GRASS ASCII vector format  to a\n vector map in binary format. The module may import two formats:\n  standard  contains all data types, each coordinate on one row \n  point  (default) reads only points, each point defined on\n   one row. Values are separated by a user-definable delimiter. If\n   the  columns  option is not defined, default names are used. It\n   is possible to specify the column order for the x,y,z coordinates\n   and category values. \n  v.out.ascii  performs the\n function of  v.in.ascii  in reverse; i.e., it converts vector\n maps in binary format to GRASS ASCII vector format. These two companion programs\n are useful both for importing and exporting vector maps between GRASS\n and other software, and for transferring data between machines.\n ", "notes": "\n The input is read from the file specified by the  input  option or\n from standard input.\n  The field separator may be a character, the word ' tab '\n (or ' \\t ') for tab, ' space ' (or '\u00a0') for a blank,\n or ' comma ' (or ',') for a comma.\n  An attribute table is only created if it is needed, i.e. when at\n least one attribute column is present in the input file besides\n geometry columns. The attribute column will be auto-scanned for type, but\n may be explicitly declared along with the geometry columns using the\n  columns  parameter.\n  Use the  -z  flag to convert ASCII data into a 3D vector map.\n  In special cases of data import, such as the import of large LIDAR\n datasets (millions of data points), it may be necessary to disable\n topology support (vector level 1) due to memory constraints.  This is\n done with the  -b  flag. As only very few vector modules support\n points data processing at vector level 1, usually topology is required\n (vector level 2). Therefore it is recommended that the user first try\n to import the data without creating a database (the  -t  flag) or\n within a subregion (the  -r  flag) before resorting to the\n disabling of topology.\n  If old version is requested, the  output  files\n from  v.out.ascii  is placed in\n the  $LOCATION/$MAPSET/dig_ascii/ \n and  $LOCATION/$MAPSET/dig_att  directory.\n  Import of files without category column \n If the input file does not contain a category column, there is the\n possibility to auto-generate these IDs (categories). To automatically\n add an additional column named 'cat', the  cat  parameter must be\n set to the virtual column number 0 ( cat=0 ). This is the\n default action if the  cat  parameter is not set.\n  Importing from a spreadsheet \n Data may be imported from many spreadsheet programs by saving the\n spreadsheet as a comma separated variable (.csv) text file, and then\n using the  separator=','  or  separator=comma  option\n with  v.in.ascii  in  points  mode.  If the input file\n contains any header lines, such as column headings, the\n  skip  parameter should be used. These skipped header lines will\n be written to the map's history file for later reference (read with\n  v.info\u00a0-h ). The skip option only works in  points  mode.\n  Any line starting with the hash character (' # ') will be treated as\n a comment and skipped completely if located in the main data file. If located\n in the header, as defined by the  skip  parameter, it will be treated as\n a header line and written to the history file.\n  Import of sexagesimal degree (degree, minutes, seconds, DMS) \n The import of DMS formatted degrees is supported (in this case no sign\n but N/S, E/W characters are used to indicate the hemispheres).  While\n the positions are internally translated into decimal degrees during\n the import, the original DMS values are maintained in the attribute\n table. This requires both the latitude and the longitude columns to be\n defined as  varchar() , not as numbers.  A warning will be\n issued which can be ignored. See  GRASS\n ASCII vector format specification  for details.\n  Importing only selected columns \n Although  v.in.ascii  doesn't have an option to specify which columns\n should be imported, you can use a shell filter to achieve the same effect,\n e.g.:\n # Print out the column number for each field, supposing the file has a header\n head -1 input_file | tr '<the_field_separator_character>' '\\n ' | cat -n\n # From the listing, select the columns you want and feed them to v.in.ascii\n # use input=- to read from stdin\n cut -d<the_field_separator_character> -f<comma-separated_list_of_columns> input_file | v.in.ascii in=- <your_options>\n  EXAMPLES \n  Example 1a) - standard format mode \n Sample ASCII polygon vector map for 'standard' format mode. \n The two areas will be assigned categories 20 and 21. \n echo \"ORGANIZATION: GRASS Development Team\n DIGIT DATE:   1/9/2005\n DIGIT NAME:   -\n MAP NAME:     test\n MAP DATE:     2005\n MAP SCALE:    10000\n OTHER INFO:   Test polygons\n ZONE:  0\n MAP THRESH:   0.500000\n VERTI:\n B  6\n  5958812.48844435 3400828.84221011\n  5958957.29887089 3400877.11235229\n  5959021.65906046 3400930.7458436\n  5959048.47580612 3400973.65263665\n  5959069.92920264 3401032.64947709\n  5958812.48844435 3400828.84221011\n C  1 1\n  5958952.42189184 3400918.23126419\n  1 20\n B  4\n  5959010.9323622 3401338.36037757\n  5959096.7459483 3401370.54047235\n  5959091.38259917 3401450.99070932\n  5959010.9323622 3401338.36037757\n C  1 1\n  5959063.08352122 3401386.98533277\n  1 21\" | v.in.ascii in=- format=standard output=test_polygons\n  Example 1b) - standard format mode \n Sample ASCII 3D line vector map for 'standard' format mode with simplified input\n (note the space field separator).\n Note the  -z  flag indicating 3D vector input, and the  -n  flag\n indicating no vector header should be expected from the input file.\n echo \"L 5 1\n 591336 4927369 1224\n 594317 4925341 1292\n 599356 4925162 1469\n 602396 4926653 1235\n 607524 4925431 1216\n 1 321 \" | v.in.ascii -zn in=- out=line3d format=standard\n This can be used to create a vector line of a GPS track: the GPS points have\n to be stored into a file with a preceding 'L' and the number of points (per line).\n  Example 2 - point format mode \n Generate a 2D points vector map 'coords.txt' as ASCII file:\n 1664619|5103481\n 1664473|5095782\n 1664273|5101919\n 1663427|5105234\n 1663709|5102614\n  Import into GRASS:\n v.in.ascii input=coords.txt output=mymap\n As the  cat  option is set to 0 by default, an extra column 'cat'\n containing the category numbers will be auto-generated.\n  Example 3 - point format mode \n Generate a 2D points vector map 'points.dat' as ASCII file:\n 1|1664619|5103481|studna\n 2|1664473|5095782|kadibudka\n 3|1664273|5101919|hruska\n 4|1663427|5105234|mysi dira\n 5|1663709|5102614|mineralni pramen\n  Import into GRASS:\n cat points.dat | v.in.ascii in=- out=mypoints x=2 y=3 cat=1 \n      columns='cat int, x double precision, y double precision, label varchar(20)'\n  The module is reading from standard input, using the default '|' (pipe) delimiter.\n  Example 4 - point format mode - CSV table \n Import of a 3D points CSV table ('points3d.csv') with attributes:\n \"num\",\"X\",\"Y\",\"Z\",\"T\"\n 1,2487491.643,5112118.33,120.5,18.62\n 2,2481985.459,5109162.78,123.9,18.46\n 3,2478284.289,5105331.04,98.3,19.61\n  Import into GRASS:\n # import: skipping the header line, categories generated automatically,\n # column names defined with type:\n v.in.ascii -z in=points3d.csv out=mypoints3D separator=comma \n    columns=\"num integer, x double precision, y double precision, z double precision, temp double precision\" \n    x=2 y=3 z=4 skip=1\n # verify column types\n v.info -c mypoints3D\n # verify table content\n v.db.select mypoints3D\n  Example 5 - point format mode \n Generating a 3D points vector map from DBMS (idcol must be an integer column): \n echo \"select east,north,elev,idcol from mytable\" | db.select -c | v.in.ascii in=- -z out=mymap\n With  in=- , the module is reading from standard input, using the default '|' (pipe) delimiter.\n The import works for 2D maps as well (no elev column and no '-z' flag).\n  Example 6 - point format mode \n Generate a 3D points vector map 'points3d.dat' with attributes as ASCII file:\n 593493.1|4914730.2|123.1|studna|well\n 591950.2|4923000.5|222.3|kadibudka|outhouse\n 589860.5|4922000.0|232.3|hruska|pear\n 590400.5|4922820.8|143.2|mysi dira|mouse hole\n 593549.3|4925500.7|442.6|mineralni pramen|mineral spring\n 600375.7|4925235.6|342.2|kozi stezka|goat path\n  Import into GRASS:\n #As the 'cat' option is set to 0 by default, an extra column 'cat'\n #containing the IDs will be auto-generated (no need to define that):\n cat points3d.dat | v.in.ascii in=- -z z=3 cat=0 out=mypoints3D \n      columns='x double precision, y double precision, z double precision, \n      label_cz varchar(20), label_en varchar(20)'\n v.info -c mypoints3D\n v.info mypoints3D\n  Example 7 - point format mode \n Generate points file by clicking onto the map:\n #For LatLong locations:\n d.where -d -l | awk '{printf \"%f|%f|point\\n \", $1, $2}' | v.in.ascii in=- out=points \n      columns='x double precision, y double precision, label varchar(20)'\n #For other projections:\n d.where | awk '{printf \"%f|%f|point\\n \", $1, $2}' | v.in.ascii in=- out=points \n      columns='x double precision, y double precision, label varchar(20)'\n The 'point' string (or some similar entry) is required to generate a database table.\n When simply piping the coordinates (and optionally height) without additional column(s) \n into  v.in.ascii , only the vector map geometry will be generated.\n  Example 8 - point format mode \n Convert ground control points into vector points:\n cat $MAPSET/group/$GROUP/POINTS | v.in.ascii in=- out=$GROUP_gcp separator=space skip=3 \n      col='x double precision, y double precision, x_target double precision, \n      y_target double precision, ok int'\n  REFERENCES \n  SQL command notes  for creating databases\n  GRASS ASCII vector format  specification\n ", "see_also": ["db.execute", "r.in.ascii", "r.in.xyz", "v.build", "v.build.polylines", "v.centroids", "v.clean", "v.db.connect", "v.import", "v.info", "v.out.ascii"], "authors": ["Michael Higgins, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.in.ascii"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.import.html", "name": "v.import", "definition": "- Imports vector data into a GRASS vector map using OGR library and reprojects on the fly.", "keywords": ["vector", "import", "projection"], "synopsis": "v.import [-flo] input=string  [layer=string[,string,...]]   [output=name]   [extent=string]   [encoding=string]   [snap=float]   [epsg=integer]   [datum_trans=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "List supported OGR formats and exit List available OGR layers in data source and exit Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available OGR layers in data source and exit Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of OGR datasource to be imported", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "OGR layer name. If not given, all available layers are imported", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map (default: input)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "extent", "flag": "extent", "dataType": "String", "optional": true, "explanation": "Output vector map extent", "defaultValue": "input", "alternatives": ["input", "region"], "isInputFile": false, "isOutputFile": false}, {"parameter": "encoding", "flag": "encoding", "dataType": "String", "optional": true, "explanation": "Encoding value for attribute data", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "snap", "flag": "snap", "dataType": "String", "optional": true, "explanation": "Snapping threshold for boundaries (map units)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "epsg", "flag": "epsg", "dataType": "String", "optional": true, "explanation": "EPSG projection code", "defaultValue": null, "alternatives": ["1-1000000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "datum_trans", "flag": "datum_trans", "dataType": "String", "optional": true, "explanation": "Index number of datum transform parameters", "defaultValue": null, "alternatives": ["-1-100"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.import  imports vector data from files and database connections\n supported by the  OGR  library) into the\n current location and mapset. If the projection of the input\n does not match the projection of the location, the input is reprojected\n into the current location. In case that the projection of the input map\n does match the projection of the location, the input is imported directly.\n  Supported Vector Formats \n  v.import  uses the OGR library which supports various vector data\n formats including  ESRI\n Shapefile ,  Mapinfo\n File , UK .NTF, SDTS, TIGER, IHO S-57 (ENC), DGN, GML, GPX, AVCBin, REC,\n Memory, OGDI, and PostgreSQL, depending on the local OGR installation.\n For details see the  OGR web\n site . The OGR (Simple Features Library) is part of the\n  GDAL  library, hence GDAL needs to be\n installed to use  v.in.ogr .\n The list of actually supported formats can be printed by  -f  flag.\n ", "notes": "\n  v.import  checks the projection metadata of the dataset to be\n imported against the current location's projection. If not identical a\n related error message is shown.\n To override this projection check (i.e. to use current location's projection)\n by assuming that the dataset has the same projection as the current location\n the  -o  flag can be used. This is also useful when geodata to be\n imported do not contain any projection metadata at all. The user must be\n sure that the projection is identical in order to avoid to introduce data\n errors.\n  Topology cleaning \n When importing polygons, non-topological polygons are converted to \n topological areas. If the input polygons contain errors (unexpected \n overlapping areas, small gaps between polygons, or warnings about being \n unable to calculate centroids), the import might need to be repeated \n using a  snap  value as suggested in the output messages.\n The  snap  threshold defines the maximal distance from one to another\n vertex in map units (for latitude-longitude locations in degree). If there\n is no other vertex within  snap  distance, no snapping will be done.\n Note that a too large value can severely damage area topology, beyond repair.\n  Post-processing:  Snapped boundaries may need to be cleaned with\n  v.clean , using its tools  break,rmdupl,rmsa . For details,\n refer to the  v.clean  manual page.\n  EXAMPLE \n # import SHAPE file at full extent and reproject to current location projection\n v.import input=research_area.shp output=research_area extent=input\n ", "see_also": ["v.clean", "v.in.ogr", "v.proj"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.import"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.hull.html", "name": "v.hull", "definition": "- Produces a 2D/3D convex hull for a given vector map.", "keywords": ["vector", "geometry", "3D"], "synopsis": "v.hull [-rf] input=name  [layer=string]  output=name  [cats=range]   [where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Limit to current region Create a 'flat' 2D hull even if the input is 3D points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Create a 'flat' 2D hull even if the input is 3D points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.hull  computes the convex hull of a vector map and outputs\n the convex hull polygon as a vector area map. The convex hull, or\n convex envelope, for an object or a set of objects is the minimal\n convex set containing the given objects. This module creates a vector\n polygon containing all vector points or lines of the input map.\n  In the case of 3D input points, the hull will be a 3D hull as well,\n unless the user specifies the  -f  flag. The 3D hull will be\n composed of triangular faces.\n Fig: Convex hull polygon created with  v.hull \n ", "notes": "\n In order to use the  where  option the  layer  option must\n be set to a positive number (the default is '-1' for 'all layers'), otherwise\n all points from all layers will be used and the  cats  and  where \n options will be ignored.\n  EXAMPLE \n Example of  v.hull  3D output (using two random 3D point \n clouds, North Carolina sample data set):\n g.region rural_1m -p\n r.mapcalc \"zero = 0\"\n v.random -z output=random3d_a n=10 zmin=0 zmax=200\n v.random -z output=random3d_b n=15 zmin=400 zmax=600\n v.hull input=random3d_a output=random3d_a_hull\n v.hull input=random3d_b output=random3d_b_hull\n d.mon wx0\n d.vect random3d_a_hull\n d.vect random3d_a color=red\n d.vect random3d_b_hull\n d.vect random3d_b color=red\n # 3D view in wxGUI (g.gui)\n Fig: Convex hull in 3D from 3D points created with  v.hull \n  REFERENCES \n    M. de Berg, M. van Kreveld, M. Overmars, O. Schwarzkopf,\n     (2000). Computational geometry, chapter 1.1, 2-8.\n    J. O'Rourke, (1998). Computational Geometry in C (Second\n   Edition), chapter 4.\n ", "see_also": ["v.delaunay"], "authors": ["Andrea Aime, Modena, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.hull"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.generalize.html", "name": "v.generalize", "definition": "- Performs vector based generalization.", "keywords": ["vector", "generalization", "simplification", "smoothing", "displacement", "network generalization", "topology", "geometry"], "synopsis": "v.generalize [-lt] input=name  [layer=string]   [type=string[,string,...]]  output=name  [error=name]  method=string threshold=float  [look_ahead=integer]   [reduction=float]   [slide=float]   [angle_thresh=float]   [degree_thresh=integer]   [closeness_thresh=float]   [betweeness_thresh=float]   [alpha=float]   [beta=float]   [iterations=integer]   [cats=range]   [where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "Disable loop support Do not modify end points of lines forming a closed loop Do not copy attributes Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not copy attributes Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "line,boundary,area", "alternatives": ["line", "boundary", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "error", "flag": "error", "dataType": "String", "optional": true, "explanation": "Error map with failed generalizations", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Generalization algorithm", "defaultValue": null, "alternatives": ["douglas", "douglas_reduction", "lang", "reduction", "reumann", "boyle", "sliding_averaging", "distance_weighting", "chaiken", "hermite", "snakes", "network", "displacement"], "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": false, "explanation": "Maximal tolerance value", "defaultValue": null, "alternatives": ["0-1000000000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "look_ahead", "flag": "look_ahead", "dataType": "String", "optional": true, "explanation": "Look-ahead parameter", "defaultValue": "7", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "reduction", "flag": "reduction", "dataType": "String", "optional": true, "explanation": "Percentage of the points in the output of 'douglas_reduction' algorithm", "defaultValue": "50", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "slide", "flag": "slide", "dataType": "String", "optional": true, "explanation": "Slide of computed point toward the original point", "defaultValue": "0.5", "alternatives": ["0-1"], "isInputFile": false, "isOutputFile": false}, {"parameter": "angle_thresh", "flag": "angle_thresh", "dataType": "String", "optional": true, "explanation": "Minimum angle between two consecutive segments in Hermite method", "defaultValue": "3", "alternatives": ["0-180"], "isInputFile": false, "isOutputFile": false}, {"parameter": "degree_thresh", "flag": "degree_thresh", "dataType": "String", "optional": true, "explanation": "Degree threshold in network generalization", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "closeness_thresh", "flag": "closeness_thresh", "dataType": "String", "optional": true, "explanation": "Closeness threshold in network generalization", "defaultValue": "0", "alternatives": ["0-1"], "isInputFile": false, "isOutputFile": false}, {"parameter": "betweeness_thresh", "flag": "betweeness_thresh", "dataType": "String", "optional": true, "explanation": "Betweeness threshold in network generalization", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "alpha", "flag": "alpha", "dataType": "String", "optional": true, "explanation": "Snakes alpha parameter", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "beta", "flag": "beta", "dataType": "String", "optional": true, "explanation": "Snakes beta parameter", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "iterations", "flag": "iterations", "dataType": "String", "optional": true, "explanation": "Number of iterations", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.generalize \n is a module for the generalization of GRASS vector maps. This module\n consists of algorithms for line simplification, line smoothing,\n network generalization and displacement (new methods may be added later).\n  If  type=area  is selected, boundaries of selected areas will be \n generalized, and the options  cats ,  where , and \n  layer  will be used to select areas. \n ", "notes": "\n (Line) simplification is a process of reducing the complexity of vector \n features. The module transforms a line into another line consisting of \n fewer vertices, that still approximate the original line. Most of the \n algorithms described below select a subset of points on the original line.\n  (Line) smoothing is a \"reverse\" process which takes as input a line and \n produces a smoother approximate of the original. In some cases, this is \n achieved by inserting new vertices into the original line, and can total \n up to 4000% of the number of vertices in the original. In such an instance, \n it is always a good idea to simplify the line after smoothing.\n  Smoothing and simplification algorithms implemented in this module \n work line by line, i.e. simplification/smoothing of one line does not \n affect the other lines; they are treated separately. For isolated loops \n formed by a single line/boundary, he first and the last point of each \n line/boundary can be translated and/or deleted, unless the  -l  \n flag is used to disable loop support.\n  Lines and boundaries are not translated if they would collapse to a \n single point. Boundaries are not translated if they would intersect \n with themselves or other boundaries. Such erroneous features are written \n to an optional  error  vector map. Overlaying the  error  \n map over the generalized map indicates the kind of error. \n Lines/boundaries collapsing to a point are written out as points, \n boundaries violating topology are written out as boundaries. The \n  error  map can be overlaid over the generalized map to \n understand why some features were not generalized.\n  SIMPLIFICATION \n Simplification can fail for many boundaries if the simplification \n parameters would result in a large reduction of vertices. If many \n lines/boundaries could not be simplified, try different parameters that \n would cause a lower degree of simplification.\n  v.generalize  contains following line simplification algorithms:\n  Douglas-Peucker Algorithm \n  Douglas-Peucker Reduction Algorithm \n  Lang Algorithm \n  Vertex Reduction \n  Reumann-Witkam Algorithm \n  Remove Small Lines/Areas \n Different algorithms require different parameters, but all the algorithms \n have one parameter in common: the  threshold  parameter, given in map\n units (for latitude-longitude locations: in decimal degree). In general,\n the degree of simplification increases with the increasing value of\n  threshold .\n  ALGORITHM DESCRIPTIONS \n    Douglas-Peucker  - \"Quicksort\" of line simplification, the \n      most widely used algorithm. Input parameters:  input , \n       threshold . For more information, see:  \n       http://geomalgorithms.com/a16-_decimate-1.html . \n    Douglas-Peucker Reduction Algorithm  is essentially the same \n      algorithm as the algorithm above, the difference being that it takes \n      an additional  reduction  parameter which denotes the percentage \n      of the number of points on the new line with respect to the number \n      of points on the original line. Input parameters:  input , \n       threshold ,  reduction .      \n    Lang  - Another standard algorithm. Input parameters: \n       input ,  threshold ,  look_ahead . \n      For an excellent description, see:   \n       http://www.sli.unimelb.edu.au/gisweb/LGmodule/LGLangVisualisation.htm . \n    Vertex Reduction  - Simplest among the algorithms. Input \n      parameters:  input ,  threshold .\n      Given a line, this algorithm removes the points of this line which \n      are closer to each other than  threshold . More precisely, if \n      p1 and p2 are two consecutive points, and the distance between p2 \n      and p1 is less than  threshold , it removes p2 and repeats the \n      same process on the remaining points. \n    Reumann-Witkam  - Input parameters:  input , \n       threshold . \n      This algorithm quite reasonably preserves the global characteristics \n      of the lines. For more information, see for example:  \n       http://psimpl.sourceforge.net/reumann-witkam.html . \n  Douglas-Peucker  and  Douglas-Peucker Reduction Algorithm  \n use the same method to simplify the lines. Note that \n v.generalize input=boundary_county output=boundary_county_dp20 method=douglas threshold=20\n is equivalent to\n v.generalize input=boundary_county output=boundary_county_dp_red20_100 \n               method=douglas_reduction threshold=20 reduction=100\n However, in this case, the first method is faster. Also observe that\n  douglas_reduction  never outputs more vertices than  douglas ,\n and that, in general,  douglas  is more efficient than \n  douglas_reduction . More importantly, the effect of\n v.generalize input=boundary_county output=boundary_county_dp_red0_30 \n               method=douglas_reduction threshold=0 reduction=30\n is that 'out' contains approximately only 30% of points of 'in'.\n  SMOOTHING \n The following smoothing algorithms are implemented in  v.generalize :\n  Boyle's Forward-Looking Algorithm  - The position of each point \n     depends on the position of the previous points and the point \n      look_ahead  ahead.  look_ahead  consecutive points. Input \n     parameters:  input ,  look_ahead . \n  McMaster's Sliding Averaging Algorithm  - Input Parameters: \n      input ,  slide ,  look_ahead .\n     The new position of each point is the average of the  look_ahead  \n     points around. Parameter  slide  is used for linear interpolation \n     between old and new position (see below).      \n  McMaster's Distance-Weighting Algorithm  - Takes the weighted \n     average of  look_ahead  consecutive points where the weight is \n     the reciprocal of the distance from the point to the currently \n     smoothed point. The parameter  slide  is used for linear \n     interpolation between the original position of the point and newly \n     computed position where value 0 means the original position.\n     Input parameters:  input ,  slide ,  look_ahead .\n      \n  Chaiken's Algorithm  - \"Inscribes\" a line touching the original \n     line such that the points on this new line are at least \n      threshold  apart. Input parameters:  input , \n      threshold . This algorithm approximates the given line very \n     well. \n    Hermite Interpolation  - This algorithm takes the points of \n      the given line as the control points of hermite cubic spline and \n      approximates this spline by the points approximately \n       threshold  apart. This method has excellent results for small \n      values of  threshold , but in this case it produces a huge \n      number of new points and some simplification is usually needed. \n      Input parameters:  input ,  threshold ,  angle_thresh .\n       Angle_thresh  is used for reducing the number of the points. \n      It denotes the minimal angle (in degrees) between two consecutive \n      segments of a line.      \n    Snakes  is the method of minimisation of the \"energy\" of a \n      line. This method preserves the general characteristics of the lines \n      but smooths the \"sharp corners\" of a line. Input parameters \n       input ,  alpha ,  beta .\n      This algorithm works very well for small values of  alpha  and \n       beta  (between 0 and 5). These parameters affect the \n      \"sharpness\" and the curvature of the computed line.                           \n One of the key advantages of  Hermite Interpolation  is the fact \n that the computed line always passes through the points of the original \n line, whereas the lines produced by the remaining algorithms never pass \n through these points. In some sense, this algorithm outputs a line which \n \"circumscribes\" the input line.\n  On the other hand,  Chaiken's Algorithm  outputs a line which \n \"inscribes\" a given line. The output line always touches/intersects the \n centre of the input line segment between two consecutive points. For \n more iterations, the property above does not hold, but the computed \n lines are very similar to the Bezier Splines. The disadvantage of the \n two algorithms given above is that they increase the number of points. \n However,  Hermite Interpolation  can be used as another \n simplification algorithm. To achieve this, it is necessary to set \n  angle_thresh  to higher values (15 or so). \n  One restriction on both McMasters' Algorithms is that  look_ahead  \n parameter must be odd. Also note that these algorithms have no effect if \n  look_ahead = 1 . \n  Note that  Boyle's ,  McMasters'  and  Snakes  algorithm \n are sometimes used in the signal processing to smooth the signals.\n More importantly, these algorithms never change the number of points on \n the lines; they only translate the points, and do not insert any new points. \n  Snakes  Algorithm is (asymptotically) the slowest among the \n algorithms presented above. Also, it requires quite a lot of memory. \n This means that it is not very efficient for maps with the lines\n consisting of many segments.\n  DISPLACEMENT \n The displacement is used when the lines overlap and/or are close to each \n other at the current level of detail. In general, displacement methods \n move the conflicting features apart so that they do not interact and can \n be distinguished.   \n  This module implements an algorithm for displacement of linear features \n based on the  Snakes  approach. This method generally yields very \n good results; however, it requires a lot of memory and is not very efficient.\n  Displacement is selected by  method=displacement . It uses the \n following parameters:\n  threshold  - specifies critical distance. Two features interact if \n they are closer than  threshold  apart.\n  alpha ,  beta  - These parameters define the rigidity of lines. \n For larger values of  alpha ,  beta  (>=1), the algorithm \n does a better job at retaining the original shape of the lines, possibly \n at the expense of displacement distance. If the values of  alpha ,\n  beta  are too small (<=0.001), then the lines are moved \n sufficiently, but the geometry and topology of lines can be destroyed. \n Most likely the best way to find the good values of  alpha ,  beta \n is by trial and error.\n  iterations  - denotes the number of iterations the interactions \n between the lines are resolved. Good starting points for values of \n  iterations  are between 10 and 100.\n The lines affected by the algorithm can be specified by the  layer ,\n  cats  and  where  parameters.\n  NETWORK GENERALIZATION \n Used for selecting \"the most important\" part of the network. This is based\n on the graph algorithms. Network generalization is applied if method=network.\n The algorithm calculates three centrality measures for each line in the\n network and only the lines with the values greater than thresholds are selected.\n The behaviour of algorithm can be altered by the following parameters:\n  degree_thresh  - algorithm selects only the lines which share a point\n with at least  degree_thresh  different lines.\n  closeness_thresh  - is always in the range (0, 1]. Only the lines \n with the closeness centrality value at least  closeness_thresh  apart \n are selected. The lines in the centre of a network have greater values of \n this measure than the lines near the border of a network. This means that \n this parameter can be used for selecting the centre(s) of a network. Note \n that if closeness_thresh=0 then everything is selected.\n  betweeness_thresh  - Again, only the lines with a betweeness \n centrality measure at least  betweeness_thresh  are selected. This \n value is always positive and is larger for large networks. It denotes to \n what extent a line is in between the other lines in the network. This \n value is large for the lines which lie between other lines and lie on \n the paths between two parts of a network. In the terminology of road \n networks, these are highways, bypasses, main roads/streets, etc.\n All three parameters above can be presented at the same time. In that \n case, the algorithm selects only the lines which meet each criterion. \n  Also, the outputed network may not be connected if the value of \n  betweeness_thresh  is too large.\n  EXAMPLES \n  SIMPLIFICATION EXAMPLE \n Simplification of county boundaries with DP method (North Carolina sample dataset),\n threshold given in mapset units (here: meters):\n v.generalize input=boundary_county output=boundary_county_dp20 \n    method=douglas threshold=20 error=boundary_county_dp20_leftover\n  Figure: Vector simplification example (spatial subset:\n    original map shown in black, simplified map with 26% remaining vertices shown in red) \n  SMOOTHING EXAMPLE \n Smoothing of road network with Chaiken method (North Carolina sample dataset),\n threshold given in mapset units (here: meters):\n v.generalize input=roads output=roads_chaiken method=chaiken \n    threshold=1 error=roads_chaiken_leftover\n  Figure: Vector smoothing example (spatial subset:\n    original map shown in black, smoothed map with 500% increased number of vertices shown in red) \n ", "see_also": ["v.clean", "v.dissolve"], "authors": ["Daniel Bundala, Google Summer of Code 2007, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.generalize"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.extrude.html", "name": "v.extrude", "definition": "- Extrudes flat vector features to 3D vector features with defined height.", "keywords": ["vector", "geometry", "sampling", "3D"], "synopsis": "v.extrude [-t] input=name  [layer=string]   [cats=range]   [where=sql_query]   [type=string[,string,...]]  output=name  [zshift=float]   [height=float]   [height_column=name]   [elevation=name]   [method=string]   [scale=float]   [null_value=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Trace elevation Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,area", "alternatives": ["point", "line", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "zshift", "flag": "zshift", "dataType": "String", "optional": true, "explanation": "Shifting value for z coordinates", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "height", "flag": "height", "dataType": "String", "optional": true, "explanation": "Fixed height for 3D vector features", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "height_column", "flag": "height_column", "dataType": "String", "optional": true, "explanation": "Name of attribute column with feature height", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Elevation raster map for height extraction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Sampling interpolation method", "defaultValue": "nearest", "alternatives": ["nearest", "bilinear", "bicubic"], "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Scale factor sampled raster values", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "Height for sampled raster NULL values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.extrude  creates faces, kernels or 3D lines based on input\n 2D vector features. Points are converted to 3D vertical lines, lines\n to faces and areas to volumes (composition of closed set of faces and\n kernel).\n If  elevation  parameter is used then 3D vector features follow\n the elevation model by using individual elevation values for the\n vertices. Height for vertices is interpolated from elevation raster\n map using given interpolation  method .\n ", "notes": "\n  v.extrude  extrudes vector features which means that points\n are converted to vertical lines. Lines and area boundaries are\n extruded to a set of faces, each segment defines one face. Area\n centroids are written as kernels. Area as a composition of boundaries\n and centroid is stored as a closed set of faces and kernel which\n define a volume.\n For conversion of 2D points or lines to 3D can be\n used  v.to.3d \n or  v.drape . In opposite\n to  v.extrude , these modules do not extrude vector features,\n they defines z-coordinate for the features from given parameters or by\n sampling elevation raster map values. It means that no feature type\n conversion is applied, points remain still points in the output vector\n map. Same applies for the lines.\n  v.extrude  modifies only features geometry. Feature categories\n remain untouched and attribute data is copied from input vector map to\n the output.\n By default, all features (including features without category) from\n input vector map are processed ( layer=-1 ). Feature selection\n can be applied by  layer ,  cats  or  where \n parameter.\n  EXAMPLES \n  3D houses with fixed height \n v.extrude input=houses output=houses3D height=5 type=area\n  3D houses with individual height \n v.extrude input=houses output=houses3D elevation=dem height_column=height type=area\n  Convert 2D points to 3D vertical lines with fixed height \n v.extrude input=geodetic_pts output=points3D height=200 type=point\n ", "see_also": ["v.transform", "v.extrude", "v.drape", "v.to.3d"], "authors": ["Jachym Cepicky,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.extrude"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.extract.html", "name": "v.extract", "definition": "- Selects vector features from an existing vector map and creates a new vector map containing only the selected features.", "keywords": ["vector", "extract", "select", "dissolve", "random"], "synopsis": "v.extract [-dtr] input=name  [layer=string]   [type=string[,string,...]]   [cats=range]   [where=sql_query]  output=name  [file=name]   [random=integer]   [new=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Dissolve common boundaries (default is no) Do not copy attributes (see also 'new' parameter) Reverse selection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not copy attributes (see also 'new' parameter) Reverse selection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Reverse selection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Types to be extracted", "defaultValue": "point,line,boundary,centroid,area,face", "alternatives": ["point", "line", "boundary", "centroid", "area", "face"], "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Input text file with category numbers/number ranges to be extracted", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "random", "flag": "random", "dataType": "String", "optional": true, "explanation": "Number of random categories matching vector objects to extract", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "new", "flag": "new", "dataType": "String", "optional": true, "explanation": "Desired new category value (enter -1 to keep original categories)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.extract  allows a user to select vector objects from an existing \n vector map and creates a new map containing only the selected objects. \n Database tables can be queried with SQL statements, if a connection is\n established. \n Dissolving (optional) is based on the output categories. If 2 adjacent\n areas have the same output category, the boundary is removed.\n If  cats ,  file ,  random  or  where  options are not\n specified, all features of given type and layer are\n extracted. Categories are not changed in that case.\n ", "notes": "\n Only features with a category number will be extracted. So if you want to \n extract boundaries (which are usually without category, as that information\n is normally held in the area's centroid) you must first use \n  v.category  to add them.\n  EXAMPLES \n The examples are intended for the North Carolina sample dataset:\n  Extract areas by category number with dissolving #1: \n v.extract -d cats=1,2,3,4 input=soils_wake output=soil_groupa type=area new=0\n produces a new vector  soil_groupa , containing those areas from vector\n  soils  which have category numbers  1 thru 4 ; any common boundaries are\n dissolved, and all areas in the new map will be assigned category number 0.\n  Extract areas by category number with dissolving #2: \n v.extract -d cats=1-4 input=soils_wake output=soil_groupa type=area new=-1\n produces a new vector map  soil_groupa  containing the areas from vector\n  soils  which have categories  1 thru 4 . Any common boundaries are\n dissolved, all areas in the new map will retain their original category\n numbers 1 thru 4, since  new  was set to -1.\n  Extract all areas and assign the same category to all: \n v.extract input=soils_wake output=soil_groupa type=area new=1\n produces a new vector map  soil_groupa  containing all areas from\n  soils . No common boundaries are dissolved, all areas of the new\n map will be assigned category number 1.\n  Extract vectors with SQL: \n v.extract input=markveggy.shp output=markveggy.1 new=13 \n    where=\"(VEGTYPE = 'Wi') or (VEGTYPE = 'PS') or (PRIME_TYPE='Wi')\"\n produces a new vector map with category number 13 if the SQL statement is\n fulfilled.\n  Extract vector features which have the given field empty: \n v.extract input=lakes output=lakes_gaps where=\"FTYPE is NULL\"                    \n  Extract vector features which have the given field not empty: \n v.extract input=lakes output=lakes_ftype where=\"FTYPE not NULL\"\n  Reverse extracting (behaves like selective vector objects deleting): \n Remove meteorological stations from map which are located above 1000m:\n # check what to delete:\n v.db.select precip_30ynormals where=\"elev > 1000\"\n # perform reverse selection\n v.extract -r input=precip_30ynormals output=precip_30ynormals_lowland \n    where=\"elev > 1000\"\n # verify\n v.db.select precip_30ynormals_lowland\n  Dissolving based on column attributes: \n # check column names:\n v.info -c zipcodes_wake\n # reclass based on desired column:\n v.reclass input=zipcodes_wake output=zipcodes_wake_recl_nam column=ZIPNAME\n # verify:\n v.info -c zipcodes_wake_recl_nam\n v.db.select zipcodes_wake_recl_nam\n # dissolve:\n v.extract -d input=zipcodes_wake_recl_nam output=zipcodes_wake_regions\n This produces a new vector map with common boundaries dissolved where the reclassed\n attributes of adjacent (left/right) areas are identical.\n  Extract 3 random areas from geology map \n v.extract input=geology output=random_geology type=area random=3\n This creates a new map with three random categories matching areas.\n Note that there may be more than one feature with the same category.\n ", "see_also": ["v.category", "v.dissolve", "v.reclass", "GRASS SQL interface"], "authors": ["R.L. Glenn, USDA, SCS, NHQ-CGIS"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.extract"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.external.out.html", "name": "v.external.out", "definition": "- Defines vector output format.", "keywords": ["vector", "export", "output", "external", "OGR", "PostGIS"], "synopsis": "v.external.out [-frpg]  [output=string]   [format=string]   [options=string[,string,...]]   [loadsettings=name]   [savesettings=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "List supported formats and exit Cease using OGR/PostGIS, revert to native output and exit Print current status Print current status in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Cease using OGR/PostGIS, revert to native output and exit Print current status Print current status in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print current status Print current status in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print current status in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name of output directory or OGR or PostGIS data source", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": true, "explanation": "Format for output vector data", "defaultValue": "ESRI_Shapefile", "alternatives": ["BNA", "CSV", "CouchDB", "DGN", "DXF", "ESRI_Shapefile", "ElasticSearch", "GFT", "GML", "GMT", "GPSBabel", "GPSTrackMaker", "GPX", "GeoJSON", "GeoRSS", "Geoconcept", "Interlis_1", "Interlis_2", "KML", "LIBKML", "MSSQLSpatial", "MapInfo_File", "Memory", "MySQL", "ODBC", "ODS", "PCIDSK", "PDF", "PGDump", "PostgreSQL", "S57", "SQLite", "TIGER", "XLSX"], "isInputFile": false, "isOutputFile": false}, {"parameter": "options", "flag": "options", "dataType": "String", "optional": true, "explanation": "Creation options", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "loadsettings", "flag": "loadsettings", "dataType": "String", "optional": true, "explanation": "Name of input file to read settings from", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "savesettings", "flag": "savesettings", "dataType": "String", "optional": true, "explanation": "Name for output file where to save current settings", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.external.out  instructs GRASS to write vector maps in\n external data format (e.g. ESRI Shapefile, Mapinfo, and others)\n using  OGR library . PostGIS data can\n be also written by\n built-in  GRASS-PostGIS\n data provider .\n ", "notes": "\n Number of available output formats ( v.external.out -f )\n depends on OGR installation. 'PostgreSQL' format is presented also\n when GRASS comes with PostgreSQL support (check for '--with-postgres'\n in  g.version -b  output).\n To store geometry and attribute data in PostGIS database ('PostgreSQL'\n format) GRASS uses built-in  GRASS-PostGIS data\n provider . PostGIS data can be written also by OGR library\n when  GRASS_VECTOR_OGR  environmental variable is defined or\n GRASS is not compiled with PostgreSQL support.\n Creation  options  refer to the output format specified\n by  format  option. See the list of valid creation options\n at  OGR formats\n specification page , example\n for  ESRI\n Shapefile \n or  PostgreSQL/PostGIS \n format (section \"Layer Creation Options\"). Options are\n comma-separated pairs ( key=value ), the options are\n case-insensitive,\n eg.  options=\"SCHEMA=myschema,FID=cat\" .\n  PostgreSQL/PostGIS Creation Options \n Note that built-in  GRASS-PostGIS data provider \n ( format=PostgreSQL ) supports different creation  options \n compared to PostgreSQL/PostGIS driver from OGR library:\n    SCHEMA=<name>  - name of schema where to create\n   feature tables. If schema doesn't exists, it's automatically created\n   when writing PostGIS data. \n    FID=<column>  - name of column which will be used as\n   primary key (feature id), default:  fid \n    GEOMETRY_NAME=<column>  name of column which will\n   be used for storing geometry data in feature table, default:  geom \n    SPATIAL_INDEX=YES|NO  - enable/disable spatial index on geometry column, default: YES \n    PRIMARY_KEY=YES|NO  - enable/disable primary key on FID column, default: YES \n    SRID=<value>  - spatial reference identifier,\n   default: not defined \n    TOPOLOGY=YES|NO  - enable/disable\n   native  PostGIS\n   topology , default: NO \n Options relevant only to topological output ( TOPOLOGY=YES ):\n    TOPOSCHEMA_NAME=<schema name>  - name of PostGIS\n   Topology schema (relevant only for  TOPOLOGY=YES ),\n   default:  topo_<input> \n    TOPOGEOM_NAME=<column>  - name of column which\n   will be used for storing topogeometry data in feature table,\n   default:  topo \n    TOPO_TOLERANCE=<value>  - tolerance for PostGIS\n   Topology schema,\n   see  CreateTopology \n   function for defails, default:  0 \n    TOPO_GEO_ONLY=YES|NO  - store in PostGIS Topology schema\n   only data relevant to Topo-Geo data model, default:  NO \n    SIMPLE_FEATURE=YES|NO  - build simple features geometry\n   in  GEOMETRY_NAME  column from topogeometry data, default:\n   NO \n Note that topological output requires  PostGIS version 2 or later .\n  EXAMPLES \n  ESRI Shapefile \n  v.external.out  can be used along with\n  v.external  to process external\n geodata in GRASS while writing out the results directly eg. in ESRI\n Shapefile format:\n # register Shapefile in GRASS mapset:\n v.external input=/path/to/shapefiles layer=cities\n # define output directory for GRASS calculation results:\n v.external.out output=$HOME/gisoutput\n # do something (here: spatial query), write output directly as Shapefile\n v.select ainput=cities atype=point binput=forests btype=area operator=within output=fcities\n Current settings can be printed using  -p  or  -g  flag.\n v.external.out -p\n output: /path/to/home/gisoutput\n format: ESRI Shapefile\n  PostGIS (simple features) \n PostGIS data can be accessed directly using  GRASS-PostGIS data\n provider  (GRASS must be compiled with PostgreSQL support).\n # register PostGIS table in GRASS mapset:\n v.external output=PG:dbname=gisdb layer=cities\n # define output PostGIS database for GRASS calculation results stored as simple features:\n v.external.out output=PG:dbname=gisdb format=PostgreSQL\n # do some processing...\n  Note:  If the environment variable  GRASS_VECTOR_OGR \n is defined, or GRASS is compiled without PostgreSQL support then GRASS\n will use PostgreSQL driver from OGR library for reading and writing\n PostGIS data.\n  PostGIS Topology \n # define output PostGIS database for GRASS calculation results stored as topological elements:\n v.external.out output=PG:dbname=gisdb format=PostgreSQL options=topology=YES\n # do some processing...\n  Note:  PostGIS topological access is supported only in\n built-in  GRASS-PostGIS data provider .\n  GRASS native format \n To restore original settings, ie. use the GRASS native format, type:\n v.external.out -r\n  Restore settings \n Current settings can be stored to file by specifying  output  option.\n # define output PostGIS database for GRASS calculation with\n # results stored as topological elements:\n v.external.out output=PG:dbname=gisdb format=PostgreSQL \n    options=topology=YES savesettings=gisdb_topo.txt\n # ... and do some processing in PostGIS Topology\n Back to native format:\n v.external.out -r\n # do some processing in native format\n Restore previous settings from \"gisdb_topo.txt\" file by \n specifying  loadsettings  option.\n v.external.out loadsettings=gisdb_topo.txt\n # ... and do some processing in PostGIS Topology\n  REFERENCES \n    GRASS-OGR data provider \n    OGR vector library C API  documentation \n    GRASS-PostGIS data provider \n    libpq - C Library \n ", "see_also": ["v.external", "v.in.ogr", "v.out.ogr", "v.out.postgis"], "authors": ["Martin Landa, Czech Technical University in Prague, Czech Republic (development supported by Fondazione Edmund Mach and Comune di Trento, Italy)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.external.out"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.external.html", "name": "v.external", "definition": "- Creates a new pseudo-vector map as a link to an OGR-supported layer or a PostGIS feature table.", "keywords": ["vector", "import", "external", "OGR", "PostGIS", "level1"], "synopsis": "v.external [-ojfltb] input=string  [layer=name]   [where=sql_query]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has the same projection as the current location Perform projection check only and exit List supported formats and exit List available layers in data source and exit List available layers including feature type in data source and exit Format: layer name,type,projection check,geometry Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "j", "flag": "-j", "explanation": "Perform projection check only and exit List supported formats and exit List available layers in data source and exit List available layers including feature type in data source and exit Format: layer name,type,projection check,geometry Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "List supported formats and exit List available layers in data source and exit List available layers including feature type in data source and exit Format: layer name,type,projection check,geometry Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List available layers in data source and exit List available layers including feature type in data source and exit Format: layer name,type,projection check,geometry Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "List available layers including feature type in data source and exit Format: layer name,type,projection check,geometry Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input OGR or PostGIS data source", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Name of OGR layer or PostGIS feature table to be linked", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output GRASS vector map (default: input layer)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.external  creates new vector map as a link to external OGR\n layer or PostGIS feature table. OGR (Simple Features Library) is part\n of the\n  GDAL  library, so you need to install\n GDAL to use  v.external  for external OGR layers. Note that a\n PostGIS feature table can be linked also using built-in  GRASS-PostGIS\n data driver  (requires GRASS to be built with PostgreSQL support).\n ", "notes": "\n  The simple feature data model used by OGR (or PostGIS) is very\n different from the topological format used by GRASS. Instead of true\n topology, so called 'pseudo topology' is created for data linked by\n  v.external . User should learn the difference between those\n two formats, because  some modules  working correctly with GRASS native\n data,  can produce wrong results  with input vector maps created\n by  v.external .\n  Limitations: \n Due to these data model differences  v.external  does not work\n with all data formats. In general, for all formats that do not have a\n key column (e.g. SHAPE file), attributes are not accessible, and attributes\n would get lost when modifying the geometries. Therefore it is generally\n not safe to link vector data with  v.external . In many cases it\n does not make sense to use  v.external  linked data with simple\n features, instead vector data should be imported with  v.import \n or  v.in.ogr  to get true topology support. Importantly, point\n cloud data which do not have topology, can be linked with  v.external \n as long as there are no attributes attached to these point cloud data, or\n if the format of the point cloud data has a key column that allows linking\n vector geometries to attributes.\n  See  v.db.connect  for an\n example of maintaining attributes in external DBMS in also writable\n mode.\n  Supported OGR vector formats \n To list supported OGR formats, type\n v.external -f\n For details see\n  GDAL web site .\n  EXAMPLES \n  ESRI Shapefile \n Assuming that 'test_shape.shp' is located in directory\n '/home/user/shape_data'.\n v.external input=/home/user/shape_data layer=test_shape output=grass_map \n  PostGIS layers \n By default, PostGIS links are created by built-in PostGIS support,\n ie. using  GRASS-PostGIS data driver . If the environment\n variable  GRASS_VECTOR_OGR  exists, or GRASS is compiled\n without PostgreSQL support then GRASS will use OGR-PostgreSQL driver\n for creating a link.\n  List of layers for given data source can be printed by  -l \n flag.\n v.external input=\"PG:host=localhost user=postgres dbname=postgis\" -l\n ...\n polymap\n ...\n v.external input=\"PG:host=localhost user=postgres dbname=postgis\" layer=polymap\n Note: Authentication details (user password) can be preferably defined\n by  db.login .\n  MapInfo files \n Assuming that 'mapinfo_test' MapInfo file is located in the current\n directory (\".\").\n v.external input=./ layer=mapinfo_test output=grass_map\n  SDTS files \n Note: you have to select the CATD file\n v.external input=CITXCATD.DDF output=cities\n  TIGER files \n v.external input=input/2000/56015/ layer=CompleteChain,PIP output=t56015_all\n  Linking subset of features \n By  where  option only subset of features can be linked. In the\n example below only one feature (in this case a vector tile) will be\n linked as a new GRASS vector map.\n v.external in=\"PG:dbname=tiles\" layer=wrs2_descending where=\"pr=191026\" \n ...\n Number of areas: 1\n ...\n  REFERENCES \n  OGR vector library C\n API  documentation\n ", "see_also": ["v.external.out", "v.clean", "v.db.connect", "v.import", "v.in.db", "v.in.ogr", "v.out.ogr"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.external"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.edit.html", "name": "v.edit", "definition": "- Edits a vector map, allows adding, deleting and modifying selected vector features.", "keywords": ["vector", "geometry", "editing", "line", "node", "point", "vertex", "level1"], "synopsis": "v.edit [-rcnb1p] map=name  [layer=string]   [type=string[,string,...]]  tool=string  [input=name]   [move=x,y,z]   [threshold=float[,float,...]]   [ids=range]   [cats=range]   [coords=x,y[,x,y,...]]   [bbox=x1,y1,x2,y2]   [polygon=x,y[,x,y,...]]   [where=sql_query]   [query=string]   [bgmap=name[,name,...]]   [snap=string]   [zbulk=value,step]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Reverse selection Close added boundaries (using threshold distance) Do not expect header of input data Do not build topology Advantageous when handling a large number of points Modify only first found feature in bounding box Connect parallel lines (using extend tools and threshold distance) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Close added boundaries (using threshold distance) Do not expect header of input data Do not build topology Advantageous when handling a large number of points Modify only first found feature in bounding box Connect parallel lines (using extend tools and threshold distance) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Do not expect header of input data Do not build topology Advantageous when handling a large number of points Modify only first found feature in bounding box Connect parallel lines (using extend tools and threshold distance) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Modify only first found feature in bounding box Connect parallel lines (using extend tools and threshold distance) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "1", "flag": "-1", "explanation": "Modify only first found feature in bounding box Connect parallel lines (using extend tools and threshold distance) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Connect parallel lines (using extend tools and threshold distance) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map to edit", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid", "alternatives": ["point", "line", "boundary", "centroid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "tool", "flag": "tool", "dataType": "String", "optional": false, "explanation": "Tool", "defaultValue": null, "alternatives": ["create", "add", "delete", "copy", "move", "flip", "catadd", "catdel", "merge", "break", "snap", "connect", "extend", "extendstart", "extendend", "chtype", "vertexadd", "vertexdel", "vertexmove", "areadel", "zbulk", "select"], "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of file containing data in GRASS ASCII vector format", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "move", "flag": "move", "dataType": "String", "optional": true, "explanation": "Difference in x,y,z direction for moving feature or vertex", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Threshold distance (coords,snap,query)", "defaultValue": "-1,0,0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ids", "flag": "ids", "dataType": "String", "optional": true, "explanation": "Feature ids", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "coords", "flag": "coords", "dataType": "String", "optional": true, "explanation": "List of point coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "bbox", "flag": "bbox", "dataType": "String", "optional": true, "explanation": "Bounding box for selecting features", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "polygon", "flag": "polygon", "dataType": "String", "optional": true, "explanation": "Polygon for selecting features", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "query", "flag": "query", "dataType": "String", "optional": true, "explanation": "Query tool", "defaultValue": null, "alternatives": ["length", "dangle"], "isInputFile": false, "isOutputFile": false}, {"parameter": "bgmap", "flag": "bgmap", "dataType": "String", "optional": true, "explanation": "Name of background vector map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "snap", "flag": "snap", "dataType": "String", "optional": true, "explanation": "Snap added or modified features in the given threshold to the nearest existing feature", "defaultValue": "no", "alternatives": ["no", "node", "vertex"], "isInputFile": false, "isOutputFile": false}, {"parameter": "zbulk", "flag": "zbulk", "dataType": "String", "optional": true, "explanation": "Starting value and step for z bulk-labeling", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The module  v.edit  allows the user to edit a vector map\n via command line interface. \n  v.edit  supports only \"simple\" vector features: points,\n centroids, lines and boundaries. Currently, only 2D vector features\n (except of tool  zbulk ) are supported.\n  Provides editing features' geometry. Attribute data connected to the\n vector map are not modified at all.\n  Vector features can be selected either by internal  id , category\n number  cats , coordinates  coords , bounding\n box  bbox ,  polygon ,  where  statement (attribute\n data) or by  query . Selecting features by coordinates is\n affected by the current 2D resolution or by the threshold distance\n given by  threshold . The options are  orthogonal , i.e. can\n be used in various combinations. For example:\n v.edit map=roads tool=select \n    coord=599505,4921010,603389.0625,4918292.1875 \n    threshold=10000 where=\"label='interstate'\"\n selects all features (and prints their id's to standard output)\n covered by two bounding boxes (center at 599505,4921010 and\n 603389.0625,4918292.1875, size 2*10000) with attribute\n  label='interstate' .\n ", "notes": "\n If no vector features are selected or the flag  -t  is\n used, topology is not build at the end.\n  USAGE \n  Feature selection \n Vector features can be selected in several ways:\n      ids  - using internal (unique) feature id's \n      cats  - using category numbers \n      coords  - using x,y coordinate pairs (center of bounding\n     box, size defined by  threshold ) \n      bbox  - using bounding box \n      polygon  - using polygon (at least 3 coordinate pairs have to be set) \n      where  - using where statement (attribute data)\n      query  - special query (e.g. minimal vector line length)\n Additional parameters for vector feature specification are:\n      layer  - layer number (currently used only\n     with  cats  or  where  option) \n      threshold  - threshold distance used for selecting vector\n     features by coordinates \n  Tool description \n      create  - Create new (empty) vector map (see\n     also  v.in.ascii ). Optionally\n     vector features (in  GRASS ASCII vector\n     format ) can be read from standard input ( input=- ) or\n     from the text file given by the  input  option. \n      add  - Add new vector features (defined\n     in  GRASS ASCII vector format ) to\n     existing vector map. Features can be read from standard input or\n     from the given text file ( input  option). If no header is\n     given, the  -n  flag must be used. Added features can be\n     snapped (defined by  snap  parameter) to nodes or vertices\n     based on threshold distance  threshold . \n      delete  - Delete selected vector features from existing\n     vector map. \n    \n      copy  - Make identical copy of selected vector\n     features. If background map  bgmap  is given copy features\n     from background map, not from currently modified vector map. \n      move  - Move selected features of existing vector map\n     relatively to their current location. This tool requires\n      move  option. The option defines coordinates of the movement\n     direction. Moved features can be snapped (defined by  snap \n     parameter) to nodes or vertices based on threshold\n     distance  threshold . \n      flip  - Flip direction of selected vector lines\n     (lines or boundaries). \n      catadd  - Add new layer category(ies) to selected vector\n     feature(s). Category can be later used for new database\n     entry. \n      catdel  - Delete layer category(ies) of selected vector\n     feature(s). \n      merge  - Merge (at least two) selected vector lines or\n     boundaries. The geometry of the merged vector lines can be\n     changed. If the second line from two selected lines is in opposite\n     direction to the first, it will be flipped. See also\n     module  v.build.polylines . \n      break  - Split given vector line or boundary into two\n     lines on location given by  coords . If  coords  not\n     given, breaks all selected lines at each intersection (based\n     on  v.clean ,  tool=break ). \n     \n      snap  - Snap vector features in given threshold. See\n     also module  v.clean . Note that this\n     tool supports only snapping to nodes. Parameters  snap  and\n      bgmap  are ignored. \n      connect  - Connect selected lines or boundaries, the\n     first given line is connected to the second one. The second line\n     is broken if necessary. The lines are connected only if distance\n     between them is not greater than snapping threshold\n     distance  threshold . \n      extend  - Extend selected lines or boundaries without changing\n     the current shape. Similar to  connect , but the first and second\n     lines are both extended until they intersect. The second line is broken if\n     necessary. The lines are extended only if distance between them is not\n     greater than snapping threshold distance  threshold . If the first and\n     second lines are parallel and do not intersect, no lines are extended. Use\n     the  -p  flag to extend the first line across the parallel gap. \n      extendstart  - Similar to  extend , but extend at start\n     nodes only. Start nodes are used to select the second line and the end node\n     of that line can also be extended if it is within the snapping threshold\n     distance given by  threshold . \n      extendend  - Similar to  extend , but extend at end nodes\n     only. \n      chtype  - Change feature type of selected geometry\n     objects. Points are converted to centroids, centroids to points,\n     lines to boundaries and boundaries to lines.\n      vertexadd  - Add vertex(ces) to the given vector lines\n     or boundaries. Location of the new vertex is given by  coord \n     option. If -1 is given only first found line or boundary in bounding\n     box is modified. \n      vertexdel  - Remove vertex(ces) specified by\n      coords  option. If -1 is given only first found line or\n     boundary in bounding box is modified. \n      vertexmove  - Move vertex(ces) specified\n     by  coords  option. Direction of the movement is specified by\n     the  move  option. If -1 is given only first found\n     line or boundary in bounding box is modified. Moved vertex can be\n     snapped (defined  snap ) to nodes or vertices based on\n     threshold distance  threshold . \n     \n      zbulk  - Assign z coordinate to 3D vector lines in given\n     bounding box. The first found line will get z coordinate based on\n     value given by  zbulk  parameter. Z coordinate of other\n     selected lines will be increased by step given by  zbulk \n     parameter. This tool strictly requires  bbox \n     and  zbulk  parameter. Also input vector map must be 3D. \n      select  - Print comma separated list of selected line\n       id's. No editing is done.\n  EXAMPLES \n  Create new vector map \n Create new (empty) vector map:\n v.edit tool=create map=vectmap\n Create new vector map and read data from file 'roads.txt':\n v.out.ascii in=roads format=standard > roads.txt;\n v.edit tool=create map=vectmap input=roads.txt\n or alternatively\n cat roads.txt | v.edit tool=create map=vectmap input=-\n  Add new features to existing vector map \n Add a new point to the vector map (without header):\n echo \"P 1 1\n  640794 214874\n  1 1\" | v.edit -n tool=add map=vectmap input=-\n # insert new row for each category in attribute table if doesn't exist yet\n v.to.db map=vectmap option=cat\n The input must be in  GRASS ASCII vector\n format .\n Add new features read from standard input:\n v.out.ascii in=railroads format=standard | v.edit tool=add map=vectmap input=-\n  Delete selected features from vector map layer \n Remove all vector features with category number 1 or 2:\n v.edit tool=delete map=roads cats=1,2\n Remove all vector features except of those with category number 1 or 2\n (reverse selection):\n v.edit -r tool=delete map=roads cats=1,2\n Remove features with category 1 or 2 located on coordinates\n 600952.625,4926107 (bounding box based on the current 2D resolution):\n g.region -d;\n v.edit tool=delete map=roads cats=1,2 coords=600952.625,4926107\n Remove all features with category 1 and 2 covered by two bounding boxes\n (center coordinates 592542.892,4924766.996 and 603389.062,4918292.187, \n size 1000 map units):\n v.edit map=roads tool=delete \n    coord=592542.892,4924766.996,603389.062,4918292.187 \n    threshold=1000 cat=1,2\n  Copy selected features from background map \n Copy all features with category number 1 from background map:\n v.edit map=roads tool=copy bgmap=archsites cat=1\n  Move features \n Move feature (vector point) located on coordinates 602580,4918480 to\n coordinates 603580,4919480:\n v.edit tool=move map=archsites coord=602580,4918480 th=1e-2 move=1000,1000\n Move all features with category 1 1000 map units to the west and 1000\n map units to the south. Moved features snap to nodes in threshold\n distance 10 map units:\n v.edit tool=move map=roads cat=1 move=1000,-1000 snap=node threshold=-1,10\n Move all features defined by bounding box\n 601530,4921560,602520,4922310 (W,S,E,N) 1000 map units to the\n east and 1000 map units to the north:\n v.edit tool=move map=roads bbox=601530,4921560,602520,4922310 move=-1000,1000\n  Flip direction of vector lines \n Flip direction of all vector lines:\n v.edit tool=flip map=streams cats=1-9999 type=line\n  Add / delete layer category number \n Add new layer/category 2/1, 2/3, 2/4, 2/5 to features covered by given polygon:\n v.edit tool=catadd map=roads \n    polygon=599877.75,4925088.375,597164.812,4922524.5,601338.562,4920914.625 \n    layer=2 cat=1,3-5\n Delete layer/category 1/1, line id 1:\n v.edit tool=catdel map=roads id=1 cats=5\n  Merge lines \n Merge two lines with given category number:\n v.edit map=roads tool=merge cat=4\n  Split line on given point \n Split line id 810 on coordinates 604268,4923570 in threshold 50 map units:\n v.edit map=roads tool=break coords=604268,4923570 id=810 threshold=50\n  Break selected lines at each intersection \n Break selected lines (with category number 1) at each intersection:\n v.edit map=roads tool=break cat=1\n  Snap lines \n Snap all lines using threshold distance 20 map units:\n v.edit map=roads id=1-9999 tool=snap threshold=-1,20 type=line\n  Connect lines \n Connect line id 48 to line id 565:\n v.edit map=roads tool=connect id=48,565\n Connect line id 48 to line id 565; line id 60 to line id\n 50. Maximum threshold distance is 700 map units:\n v.edit map=roads tool=connect id=48,565,60,50 threshold=-1,700\n  Add vertex \n Add new vertex to the line located at 600952,4926107, threshold is\n set to 1 map unit:\n v.edit tool=vertexadd map=roads coords=600952,4926107 threshold=1\n  Delete vertices \n Delete vertex located at 593191.608,4925684.849 (threshold set to 0.1 map units).\n Modify only lines with category 1:\n v.edit tool=vertexdel map=roads coord=593191.608,4925684.849 \n    threshold=1-e1 cats=1\n  Move vertices \n Move vertices located at 604441,4921088 (threshold set to 100 map units).\n Modify only lines with categories 1-10:\n v.edit tool=vertexmove map=roads cats=1-10 coord=604441,4921088 \n    threshold=100 move=1000,1000\n  Select features and print their id's \n Print id's of selected features, e.g.:\n v.edit map=soils@PERMANENT tool=select \n    bbox=595733.8125,4919781.75,598536.1875,4917396.75 --q\n Example with  d.vect :\n d.erase;\n d.vect roads;\n d.vect -i map=roads cats=`v.edit map=roads tool=select \n    coord=592542.89243878,4924766.99622811,603389.0625,4918292.1875 \n    threshold=1000 --q` col=red\n Select all lines shorter (or equal) than 10 map units:\n v.edit map=roads tool=select query=length threshold=-1,0,-10\n Select from given bounding box all lines longer then 200 map units:\n v.edit map=roads tool=select bbox=598260,4919730,605100,4926240 query=length threshold=-1,0,200\n  Fix height of contours \n Intput vector map contains 2D lines representing contours. Height can\n be assign to the contours using tool  zbulk . First of all 2D\n lines need to be converted to 3D lines:\n v.extrude input=line2 output=line3 height=0 type=line\n All lines which intersect with the line given by coordinates will be\n modified. First found line will get height 1000 map units, height of\n other selected lines will be increased by 10 map units.\n v.edit a2 tool=zbulk bbox=586121.25049368,4911970.21547109,603092.60466035,4927071.25713776 \n     zbulk=1000,10\n ", "see_also": ["v.in.ascii", "v.info", "v.build", "v.build.polylines", "v.clean", "v.extrude", "v.split"], "authors": ["Original author: Wolf Bergenheim - independent developer"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.edit"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.drape.html", "name": "v.drape", "definition": "- Converts 2D vector features to 3D by sampling of elevation raster map.", "keywords": ["vector", "geometry", "sampling", "3D", "surface information"], "synopsis": "v.drape input=name  [layer=string]   [cats=range]   [where=sql_query]   [type=string[,string,...]]  output=name elevation=name  [method=string]   [scale=float]   [null_value=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid", "alternatives": ["point", "line", "boundary", "centroid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": false, "explanation": "Elevation raster map for height extraction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Sampling interpolation method", "defaultValue": "nearest", "alternatives": ["nearest", "bilinear", "bicubic"], "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Scale factor sampled raster values", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "Height for sampled raster NULL values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.drape  converts 2D/3D vector data into 3D vector format via\n sampling of an elevation surface. Three sampling algorithms adapted\n from  v.sample  were incorporated\n into this module: nearest neighbor, bilinear, and cubic convultion.\n  v.drape  will skip vector features outside of current\n computational region or where raster map has NULL value. It's possible\n to include all vector features by specifying height value that will be\n assigned to verticles whose values can not be determined from raster\n map.\n ", "notes": "\n Additional vertices can be added to the input 2D vector map\n with  v.split .\n The module can be used in conjunction\n with  v.out.pov  and\n  r.out.pov  to export a complete\n set of vector and raster data for display\n in  POVRAY .\n  EXAMPLES \n Spearfish example:\n v.drape in=roads elevation=elevation.10m method=bilinear out=roads3d\n v.info roads3d\n Create 3D vector roads map containing only \"unimproved\" roads. Set\n road height to 1000 m for all parts without height information.\n v.drape input=roads type=line elevation=elevation.dem output=roads_3d \n          method=nearest scale=1.0 where='cat=5' layer=1 null_value=1000\n  POVRAY example \n #export the vector data\n v.drape in=roads out=roads3d elevation=elevation.10m\n v.out.pov roads3d out=roads3d.pov\n #export the raster data\n r.out.pov elevation.10m tga=elevation.tga\n r.out.png landcover.30m out=landcover30m.png\n # now write a complete povray-script and launch povray\n ", "see_also": ["v.extrude", "v.to.3d", "r.out.pov", "v.in.region", "v.out.pov", "v.overlay", "v.split", "v.what.rast"], "authors": ["Dylan Beaudette, University of California at Davis."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.drape"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.distance.html", "name": "v.distance", "definition": "- Finds the nearest element in vector map 'to' for elements in vector map 'from'.", "keywords": ["vector", "distance", "database", "attribute table"], "synopsis": "v.distance [-pa] from=name  [from_layer=string]   [from_type=string[,string,...]]  to=name  [to_layer=string]   [to_type=string[,string,...]]   [output=name]   [dmax=float]   [dmin=float]   [upload=string[,string,...]]   [column=name[,name,...]]   [to_column=name]   [table=name]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print output to stdout, don't update attribute table First column is always category of 'from' feature called from_cat Calculate distances to all features within the threshold Output may be written to stdout using the '-p' flag or uploaded to a new table created by the 'table' option; multiple 'upload' options may be used. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Calculate distances to all features within the threshold Output may be written to stdout using the '-p' flag or uploaded to a new table created by the 'table' option; multiple 'upload' options may be used. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "from", "flag": "from", "dataType": "String", "optional": false, "explanation": "Name of existing vector map (from)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "from_layer", "flag": "from_layer", "dataType": "String", "optional": true, "explanation": "Layer number or name (from)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "from_type", "flag": "from_type", "dataType": "String", "optional": true, "explanation": "Feature type (from)", "defaultValue": "point,line,area", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "to", "flag": "to", "dataType": "String", "optional": false, "explanation": "Name of existing vector map (to)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "to_layer", "flag": "to_layer", "dataType": "String", "optional": true, "explanation": "Layer number or name (to)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "to_type", "flag": "to_type", "dataType": "String", "optional": true, "explanation": "Feature type (to)", "defaultValue": "point,line,area", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map containing lines connecting nearest elements", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "dmax", "flag": "dmax", "dataType": "String", "optional": true, "explanation": "Maximum distance or -1 for no limit", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dmin", "flag": "dmin", "dataType": "String", "optional": true, "explanation": "Minimum distance or -1 for no limit", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "upload", "flag": "upload", "dataType": "String", "optional": true, "explanation": "Values describing the relation between two nearest features", "defaultValue": null, "alternatives": ["cat", "dist", "to_x", "to_y", "to_along", "to_angle", "to_attr"], "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Column name(s) where values specified by 'upload' option will be uploaded", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "to_column", "flag": "to_column", "dataType": "String", "optional": true, "explanation": "Column name of nearest feature (used with upload=to_attr)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": true, "explanation": "Name for new attribute table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator for printing output to stdout", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.distance  finds the nearest element in vector map ( to )\n for elements in vector map ( from ). Various information about\n the vectors' relationships (distance, category, etc.) may be uploaded to\n the attribute table attached to the first vector map, or printed to\n 'stdout'. A new vector map may be created where lines connecting\n nearest points on features are written.  dmin  and/or\n  dmax  can be used to limit the search radius (in lat-long locations\n to be given in meters since they are calculated as geodesic distances on\n a sphere).\n For lines to lines, say line A to line B,  v.distance  calculates\n the shortest distance of each vertex in A with each segment (not vertex)\n in B. The module then calculates the shortest distance of each vertex in\n B to each segment in A. The overall shortest distance of A points to B\n segments and B points to A segments is used. Additionally,\n  v.distance  checks for intersections. In case of intersections,\n the first intersection found is used and the distance set to zero.\n For lines to areas, the distance is set to zero if a line is (partially)\n inside an area. The first point of the line that is inside the area is\n used as common point. The distance is also set to zero if the line\n intersects with the outer ring or any of the inner rings (isles), in\n which case the fist intersection is used as common point.\n For areas to areas, the module checks first for overlap or if one area\n is (partially) inside the other area. This is computationally quite\n intensive. If the outer rings of the two areas do not overlap, the\n distance is calculated as above for lines to lines, treating the outer\n rings as two lines. Again, the first point encountered falling into an\n area is used as common point, or the first intersection point.\n For anything else than points to lines, there can be several common\n locations with zero distance, and the common location would then be the\n result of an overlay consisting of several points, lines, or areas.\n  v.distance  selects in these cases a single point, and does\n not create an overlay\n like  v.overlay . In this\n implementation, any shared point is as good as any other. Calculating\n an intersection is costlier than to check if a vertex is inside a\n polygon. For example, if a vertex of the boundary of the 'to' area is\n inside the 'from' area, it is a common location. For speed reasons,\n the distance is then set to zero and no further tests are done.\n ", "notes": "\n If a nearest feature does not have a category, the attribute column is\n updated to NULL.\n  The upload  column (s) must already exist. Create one with\n  v.db.addcolumn .\n  In lat-long locations  v.distance  gives distances\n ( dist ,  from_along , and  to_along ) not in\n degrees but in meters calculated as geodesic distances on a sphere.\n If one or both of the input vector maps are 3D, the user is notified\n accordingly.\n  EXAMPLES \n  Find nearest lines \n Find  nearest lines  in vector map \"ln\" for points from\n vector map \"pnt\" within the given threshold and write related\n line categories to column \"linecat\" in an attribute table attached\n to vector map \"pnt\":\n v.distance from=pnt to=ln upload=cat column=linecat\n  Find nearest area \n For each point from vector map \"pnt\", find the  nearest area \n from map \"ar\" within the given threshold and write the related\n area categories to column \"areacat\" in an attribute table attached\n to vector map \"pnt\" (in the case that a point falls into an area,\n the distance is zero):\n v.distance from=pnt to=ar upload=cat column=areacat\n  Create a new vector map \n Create a new vector map which contains  lines connecting nearest\n features  of maps \"pnt\" and map \"ln\". The resulting\n vector map can be used for example to connect points to a network as\n needed for network analysis:\n v.distance from=pnt to=ln out=connections upload=dist column=dist\n  Create a new vector map with from and to categories in the attribute table \n Create a new vector map that contains  lines connecting nearest\n features  of maps \"pnt\" and map \"ln\", and a new\n attribute table that contains distances, from and to categories from the\n input maps:\n v.distance from=pnt to=ln out=connections upload=cat,dist column=to_cat,dist table=connections\n  Query information \n Query information from selected point(s).  v.distance  takes\n points from a vector map as input instead of stdin. A new vector map\n with query points has to be created before the map can be analysed.\n Create query map (if not present):\n echo \"123456|654321|1\" | v.in.ascii output=pnt\n Find nearest features:\n v.distance -p from=pnt to=map_to_query upload=cat\n  Point-in-polygon \n The option  dmax=0  is here important because otherwise for\n points not falling into any area, the category of the nearest area is\n recorded.\n For each point from vector map \"pnt\", find the  area  from\n vector map \"ar\" in which the individual point falls, and\n write the related area categories to column \"areacat\" into\n the attribute table attached to vector map \"pnt\":\n v.distance from=pnt to=ar dmax=0 upload=cat column=areacat\n  Univariate statistics on results \n Create a vector map containing connecting lines and investigate mean\n distance to targets. An alternative solution is to use\n the  v.distance upload=dist  option to upload distances into\n the  bugs  vector directly, then run v.univar on that. Also note\n you can upload two columns at a time, e.g.  v.distance\n upload=cat,dist column=nearest_id,dist_to_nr .\n # create working copy\n g.copy vect=bugsites,bugs\n # add new attribute column to hold nearest archsite category number\n v.db.addcolumn map=bugs column=\"nrst_arch INTEGER\"\n v.distance from=bugs to=archsites to_type=point upload=to_attr \n    to_column=cat column=nrst_arch out=vdistance_vectors_raw\n # we need to give the lines category numbers, create a table, and create\n #  a column in that table to hold the distance data.\n v.category vdistance_vectors_raw out=vdistance_vectors type=line op=add\n g.remove -f type=vector name=vdistance_vectors_raw\n v.db.addtable map=vdistance_vectors column=\"length DOUBLE\"\n v.to.db map=vdistance_vectors option=length column=length\n # calculcate statistics. Use v.univar.sh for extended statistics.\n v.univar vdistance_vectors column=length\n  Print distance between points \n Example for a Latitude-longitude location (EPSG 4326):\n # points along the equator\n echo \"0|-61|1\" | v.in.ascii output=pnt1 input=-\n echo \"0|-58|1\" | v.in.ascii output=pnt2 input=-\n # here, distances are in degree units\n v.distance -p --q from=pnt1 to=pnt2 upload=dist\n from_cat|distance\n 1|3\n  Print distance matrix \n Note: Matrix-style output is enabled only for flag  -a  and one\n given upload option.\n Spearfish sample data location:\n v.distance -pa from=archsites to=archsites upload=dist\n North Carolina sample data location:\n v.distance -pa from=hospitals to=hospitals upload=dist separator=tab\n from_cat to_cat       dist\n               1          2          3          4          5 ...\n 1             0    7489.10  339112.17   70900.39   70406.23 ...\n 2       7489.10          0  345749.12   76025.46   75538.87 ...\n 3     339112.17  345749.12          0  274153.19  274558.98 ...\n 4      70900.39   76025.46  274153.19          0     501.11 ...\n 5      70406.23   75538.87  274558.98     501.11          0 ...\n ...\n ", "see_also": ["r.distance", "v.db.addcolumn", "v.what.vect"], "authors": ["Janne Soimasuo 1994, University of Joensuu, Faculty of Forestry, Finland"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.distance"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.dissolve.html", "name": "v.dissolve", "definition": "- Dissolves boundaries between adjacent areas sharing a common category number or attribute.", "keywords": ["vector", "dissolve", "area", "line"], "synopsis": "v.dissolve input=name  [layer=string]   [column=name]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name.", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of attribute column used to dissolve common boundaries", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n The  v.dissolve  module is used to merge adjacent areas in a vector\n map which share the same category value. The resulting merged area(s) retains\n this category value. Alternatively an integer or string column can be defined\n which is used to find adjacent polygons with identical attribute for common\n boundary dissolving. In this case the categories are not retained, only the\n values of the new key column. See the  v.reclass  help page for details.\n ", "notes": "\n GRASS defines a vector area as composite entity consisting of a set of\n closed boundaries and a centroid. The centroids must contain a\n category number\n (see  v.centroids ), this number is linked to area attributes and\n database links.\n  Multiple attributes may be linked to a single vector entity through\n numbered fields referred to as layers. Refer to  v.category  for\n more details.\n  Merging of areas can also be accomplished using\n  v.extract -d  which provides some additional options.\n In fact,  v.dissolve  is simply a\n front-end to that module. The use of the  column  parameter\n adds a call to  v.reclass  before.\n  EXAMPLES \n  Basic use \n v.dissolve input=undissolved output=dissolved\n  Dissolving based on column attributes \n North Carolina data set:\n g.copy vect=soils_general,mysoils_general\n v.dissolve mysoils_general output=mysoils_general_families column=GSL_NAME\n  Dissolving adjacent SHAPE files to remove tile boundaries \n If tile boundaries of adjacent maps (e.g. CORINE Landcover SHAPE files)\n have to be removed, an extra step is required to remove duplicated\n boundaries:\n # patch tiles after import:\n v.patch -e `g.list type=vector pat=\"clc2000_*\" separator=\",\"` out=clc2000_patched\n # remove duplicated tile boundaries:\n v.clean clc2000_patched out=clc2000_clean tool=snap,break,rmdupl thresh=.01\n # dissolve based on column attributes:\n v.dissolve input=clc2000_clean output=clc2000_final col=CODE_00\n ", "see_also": ["v.category", "v.centroids", "v.extract", "v.reclass"], "authors": ["module: M. Hamish Bowman, Dept. Marine Science, Otago University, New Zealand"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.dissolve"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.delaunay.html", "name": "v.delaunay", "definition": "- Creates a Delaunay triangulation from an input vector map containing points or centroids.", "keywords": ["vector", "geometry", "triangulation"], "synopsis": "v.delaunay [-rl] input=name  [layer=string]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Use only points in current region Output triangulation as a graph (lines), not areas Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Output triangulation as a graph (lines), not areas Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.delaunay  uses an existing vector points map ( input )\n to create a Delaunay triangulation vector map ( output ).\n Delaunay triangulation example (red-yellow points are the data points from which the triangulation was generated):\n  EXAMPLE \n Commands used with the North Carolina dataset to create the above figure (subset shown in figure).\n g.region n=220750 s=219950 w=638300 e=639000 -p\n v.delaunay input=elev_lid792_randpts output=elev_lid792_randpts_delaunay\n  REFERENCES \n  Leonid Guibas and Jorge Stolfi, (1985). Primitives for the \n Manipulation of General Subdivisions and the Computation of\n Voronoi Diagrams, ACM Transactions on Graphics, Vol 4, No. 2, \n April 1985, Pages 74-123\n ", "notes": "", "see_also": ["v.voronoi", "v.hull"], "authors": ["Martin Pavlovsky, Google Summer of Code 2008, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.delaunay"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.decimate.html", "name": "v.decimate", "definition": "- Decimates a point cloud", "keywords": ["vector", "LIDAR", "generalization", "decimation", "extract", "select", "points", "level1"], "synopsis": "v.decimate [-gfczxb] input=name  [layer=string]  output=name  [zrange=min,max]   [cats=range]   [skip=integer]   [preserve=integer]   [offset=integer]   [limit=integer]   [zdiff=float]   [cell_limit=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Apply grid-based decimation Use only first point in grid cell during grid-based decimation Only one point per cat in grid cell Use z in grid decimation Store only the coordinates, throw away categories Do not story any categories even if they are present in input data Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Use only first point in grid cell during grid-based decimation Only one point per cat in grid cell Use z in grid decimation Store only the coordinates, throw away categories Do not story any categories even if they are present in input data Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Only one point per cat in grid cell Use z in grid decimation Store only the coordinates, throw away categories Do not story any categories even if they are present in input data Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Use z in grid decimation Store only the coordinates, throw away categories Do not story any categories even if they are present in input data Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "x", "flag": "-x", "explanation": "Store only the coordinates, throw away categories Do not story any categories even if they are present in input data Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "zrange", "flag": "zrange", "dataType": "String", "optional": true, "explanation": "Filter range for z data (min,max)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "skip", "flag": "skip", "dataType": "String", "optional": true, "explanation": "Throw away every n-th point", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "preserve", "flag": "preserve", "dataType": "String", "optional": true, "explanation": "Preserve only every n-th point", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "offset", "flag": "offset", "dataType": "String", "optional": true, "explanation": "Skip first n points", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "limit", "flag": "limit", "dataType": "String", "optional": true, "explanation": "Copy only n points", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zdiff", "flag": "zdiff", "dataType": "String", "optional": true, "explanation": "Minimal difference of z values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cell_limit", "flag": "cell_limit", "dataType": "String", "optional": true, "explanation": "Preserve only n points per grid cell", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.decimate  reduces number of points in the input vector map\n and copies them over to the output vector map. Different point decimation\n techniques can be applied to reduce the number of points.\n Two main decimation techniques are:\n  count-based decimation ( skip ,  preserve ,  offset \n     and  limit  options)\n  grid-based decimation ( -g  flag)\n The grid-based decimation will remove points based on:\n  similar z coordinates ( -z  flag and  zdiff  option)\n  same categories ( -c  flag)\n  count of points ( -f  flag and  cell_limit  option)\n The grid-based decimation is currently using a 2D grid, so the points\n are placed and compared within this 2D grid. The comparison can happen\n using z coordinates or categories.\n Note that although the grid is only 2D, the module works with 3D points.\n The grid-based decimation extent and resolution depend on the current\n computational region as set by  g.region .\n As a consequence, the output is limited only to computational region\n in this case.\n TODO: Currently, any output is limited by the region.\n The count-based decimation result highly depends on how the data are\n ordered in the input. This applies especially to  offset  and\n  limit  options where the resulting shape and densities can be\n surprising. The options  skip  and  preserve  are influenced\n by order of points in a similar way but they usually keep relative\n density of points (which may or may not be desired).\n On the other hand, the grid-based decimation will generally result in\n more even density of output points (see Figure 1).\n Besides decimation, point count can be reduced by applying different\n selections or filters, these are:\n  selection by category ( cats  option)\n  selection by z values ( zrange  option)\n ", "notes": "\n The grid-based decimation requires all points which will be saved in output\n to fit into the computer's memory (RAM).\n It is advantageous to have the region only in the area\n with the points, otherwise unnecessary memory is allocated.\n Higher (finer) resolutions and higher amount of preserved points\n per cell require more memory.\n The count-based decimation has no limitation regarding the available memory.\n Significant speed up can be gained using  -b  flag which disables\n building of topology for the output vector map. This may limit the use\n of the vector map by some modules, but for example, this module works\n without topology as well.\n  EXAMPLES \n Keep only every forth point, throw away the rest:\n v.decimate input=points_all output=points_decimated_every_4 preserve=4\n Keep only points within a grid cell (given by the current computational\n region) which has unique categories (e.g. LIDAR classes):\n v.decimate input=points_all output=points_decimated_unique_cats layer=1 -g -c\n      \n      \n      \n      \n         Figure 1: Comparison of original points, decimation result\n         with every forth point preserved, and grid-based decimation\n         result with points with unique categories in each grid cell\n      \n Keep only points with category 2 and keep only approximately 80% of the points:\n v.decimate input=points_all output=points_decimated_ skip=5 cats=2 layer=1\n ", "see_also": ["v.extract", "v.outlier", "v.select", "v.category", "v.build", "v.in.lidar", "g.region"], "authors": ["Vaclav Petras,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.decimate"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.update.html", "name": "v.db.update", "definition": "- Updates a column in the attribute table connected to a vector map.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.db.update map=name layer=string column=name  [value=string]   [query_column=name]   [where=sql_query]   [sqliteextra=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": false, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column to update", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "value", "flag": "value", "dataType": "String", "optional": true, "explanation": "Literal value to update the column with", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "query_column", "flag": "query_column", "dataType": "String", "optional": true, "explanation": "Name of other attribute column to query, can be combination of columns (e.g. co1+col2)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sqliteextra", "flag": "sqliteextra", "dataType": "String", "optional": true, "explanation": "Name of SQLite extension file for extra functions (SQLite backend only)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.update  assigns a new value to a column in the\n attribute table connected to a given map. The  value  parameter allows updating with a literal value. Alternatively, with the  qcol  parameter values can be\n copied from another column in the table or be the result of a combination or transformation of other columns.\n ", "notes": "\n  v.db.update  is just a front-end to  db.execute  to\n allow easier usage.\n  For complex SQL UPDATE statements,  db.execute  should be used.\n  EXAMPLES \n  Replacing of NULL values \n In this example, selectively display lakes without (blue) and with\n NULL (red) are shown to find out which type is undefined. In the\n original map there are lakes missing FTYPE attribute which are\n wetlands along streams. These NULL attributes are replaced with the\n landuse type WETLAND:\n g.copy vect=lakes,mylakes\n v.db.select mylakes\n v.db.select mylakes where=\"FTYPE IS NULL\"\n # display the lakes, show undefined FTYPE lakes in red\n g.region vector=mylakes\n d.mon wx0\n d.vect mylakes where=\"FTYPE NOT NULL\" type=area col=blue\n d.vect mylakes where=\"FTYPE IS NULL\" type=area col=red\n # replace NULL with FTYPE WETLAND\n v.db.update mylakes col=FTYPE value=WETLAND \n              where=\"FTYPE IS NULL\"\n v.db.select mylakes\n  Updating of columns with on the fly calculation \n Spearfish example: adding new column, copying values from another table\n column with on the fly calculation:\n g.copy vect=fields,myfields\n v.db.addcolumn myfields col=\"polynum integer\"\n v.db.update myfields col=polynum qcol=\"cat*2\"\n v.db.select myfields\n  Type casting \n Type cast (type conversion) of strings to double precision\n (unsupported by DBF driver):\n g.copy vect=geodetic_pts,mygeodetic_pts\n v.db.update mygeodetic_pts col=zval qcol=\"CAST(z_value AS double precision)\" \n              where=\"z_value <> 'N/A'\"\n  Updating of columns with on the fly calculation (SQLite extended functions) \n Note: this requires SQLite extended functions. For details see the GRASS GIS Wiki\n (compilation of  libsqlitefunctions.so \n and  libsqlitefunctions.dll ).\n North Carolina data set example: adding new column, copying values from\n another table column with on the fly calculation:\n g.copy vect=precip_30ynormals,myprecip_30ynormals\n v.db.addcolumn myprecip_30ynormals column=\"logjuly double precision\"\n v.db.update myprecip_30ynormals column=\"logjuly\" query_column=\"log(jul)\" \n    sqliteextra=$HOME/sqlite_extensions/libsqlitefunctions.so\n v.db.select myprecip_30ynormals columns=jul,logjuly\n jul|logjuly\n 132.842|4.88916045210132\n 127|4.84418708645859\n 124.206|4.82194147751127\n 104.648|4.65060233738593\n 98.298|4.58800368106618\n ...\n ", "see_also": ["db.execute", "v.db.addcolumn", "v.db.addtable", "v.db.connect", "v.db.droptable", "v.db.join", "v.db.select", "GRASS SQL interface"], "authors": ["Moritz Lennert (mlennert@club.worldonline.be)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.update"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.univar.html", "name": "v.db.univar", "definition": "- Calculates univariate statistics on selected table column for a GRASS vector map.", "keywords": ["vector", "statistics", "attribute table"], "synopsis": "v.db.univar [-eg] map=name  [layer=string]  column=name  [where=sql_query]   [percentile=float[,float,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Extended statistics (quartiles and 90th percentile) Print stats in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print stats in shell script style Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column on which to calculate statistics (must be numeric)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "percentile", "flag": "percentile", "dataType": "String", "optional": true, "explanation": "Percentile to calculate (requires extended statistics flag)", "defaultValue": "90", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.univar  calculates basic univariate statistics for numeric\n attributes in a vector attribute table. It will calculate minimum, \n maximum, range, mean, standard deviation, variance, coefficient of \n variation, quartiles, median, and 90th percentile. \n  v.db.univar  uses  db.univar  which in turn uses\n  db.select  to get the attribute values on which it calculates the\n statistics.  This means that statistics are calculated based on the entries in\n the attribute table, not based on the features in the map. One attribute value\n is read from each line in the attribute table, whether there are no, one or\n several features with the category value referenced by that line, or whether any\n features have more than one category value.  For feature-based, instead of\n attribute table-based, univariate statistics on attributes see  v.univar .\n  NOTES \n A database connection must be defined for the selected vector layer.\n  EXAMPLES \n  Univariate statistics on attribute table column \n In this example, the 30 years precipitation data table is statistically\n analysed (North Carolina sample dataset) and univariate statistics performed:\n # show columns of attribute table connected to precipitation map\n v.info -c precip_30ynormals\n # univariate statistics on 30 years annual precipitation in NC\n v.db.univar precip_30ynormals column=annual\n  Number of values: 136\n  Minimum: 947.42\n  Maximum: 2329.18\n  Range: 1381.76\n  Mean: 1289.31147058823\n  [...]\n  Univariate statistics on randomly sampled data points \n In this example, random points are sampled from the elevation map\n (North Carolina sample dataset) and univariate statistics performed:\n g.region raster=elevation -p\n v.random output=samples n=100\n v.db.addtable samples column=\"heights double precision\"\n v.what.rast samples raster=elevation column=heights\n v.db.select samples\n v.db.univar samples column=heights\n ", "notes": "", "see_also": ["db.univar", "r.univar", "v.univar", "db.select", "d.vect.thematic"], "authors": ["Michael Barton, Arizona State University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.univar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.select.html", "name": "v.db.select", "definition": "- Prints vector map attributes.", "keywords": ["vector", "attribute table", "database", "SQL"], "synopsis": "v.db.select [-rcvf] map=name  [layer=string]   [columns=name[,name,...]]   [where=sql_query]   [group=string]   [separator=character]   [vertical_separator=character]   [null_value=string]   [file=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Print minimal region extent of selected vector features instead of attributes Do not include column names in output Vertical output (instead of horizontal) Exclude attributes not linked to features Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Do not include column names in output Vertical output (instead of horizontal) Exclude attributes not linked to features Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "v", "flag": "-v", "explanation": "Vertical output (instead of horizontal) Exclude attributes not linked to features Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Exclude attributes not linked to features Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Name of attribute column(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": true, "explanation": "GROUP BY conditions of SQL statement without 'group by' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vertical_separator", "flag": "vertical_separator", "dataType": "String", "optional": true, "explanation": "Output vertical record separator", "defaultValue": null, "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "null_value", "flag": "null_value", "dataType": "String", "optional": true, "explanation": "String representing NULL value", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Name for output file (if omitted or \"-\" output to stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.db.select  prints attributes of a vector map from one or several\n user selected attribute table columns.\n  EXAMPLES \n All examples are based on the North Carolina sample dataset.\n  Select and show entire table \n v.db.select map=roadsmajor\n cat|MAJORRDS_|ROAD_NAME|MULTILANE|PROPYEAR|OBJECTID|SHAPE_LEN\n 1|1|NC-50|no|0|1|4825.369405\n 2|2|NC-50|no|0|2|14392.589058\n 3|3|NC-98|no|0|3|3212.981242\n 4|4|NC-50|no|0|4|13391.907552\n ...\n  Select and show single column from table \n Note: multiple columns can be specified as comma separated list.\n v.db.select map=roadsmajor column=ROAD_NAME\n NC-50\n NC-50\n NC-98\n NC-50\n NC-98\n ...\n  Print region extent of selected vector features \n v.db.select -r map=roadsmajor where=\"ROAD_NAME = 'NC-98'\"\n n=248425.389891\n s=245640.640081\n w=635906.517653\n e=661979.801880\n  Select empty vector features (no data entries) \n v.db.select geonames_wake where=\"ALTERNATEN IS NULL\"\n cat|GEONAMEID|NAME|ASCIINAME|ALTERNATEN|FEATURECLA|FEATURECOD|...\n 8|4498303|West Raleigh|West Raleigh||P|PPL|US||NC|338759|123|...\n 14|4459467|Cary|Cary||P|PPL|US||NC|103945|146|152|America/Iqaluit|...\n 31|4452808|Apex|Apex||P|PPL|US||NC|30873|167|134|America/Iqaluit|...\n ...\n  Select not empty vector features (no data entries) \n v.db.select geonames_wake where=\"ALTERNATEN IS NOT NULL\"\n cat|GEONAMEID|NAME|ASCIINAME|ALTERNATEN|FEATURECLA|FEATURECOD|...\n 9|4487042|Raleigh|Raleigh|Raleigh,...\n 31299|4487056|Raleigh-Durham Airport|Raleigh-Durham Airport|...\n ...\n  Select features with distinct road names \n v.db.select map=roadsmajor columns=ROAD_NAME group=ROAD_NAME\n ROAD_NAME\n I-40\n I-440\n I-540\n NC-231\n NC-39\n NC-42\n ...\n It is also possible to combine with  where  option\n v.db.select map=roadsmajor columns=ROAD_NAME,MULTILANE group=ROAD_NAME where='ROAD_NAME is not null'\n ROAD_NAME|MULTILANE\n I-40|yes\n I-440|yes\n I-540|yes\n NC-231|no\n NC-39|no\n NC-42|no\n NC-50|no\n NC-54|no\n NC-55|no\n NC-96|no\n NC-97|no\n NC-98|no\n US-1|\n US-401|no\n US-64|yes\n US-70|yes\n It can also use more columns in  group  option\n v.db.select map=roadsmajor columns=ROAD_NAME,MULTILANE group=ROAD_NAME,MULTILANE where='ROAD_NAME is not null'\n ROAD_NAME|MULTILANE\n I-40|yes\n I-440|yes\n I-540|yes\n NC-231|no\n NC-39|no\n NC-42|no\n NC-50|no\n NC-54|no\n NC-55|no\n NC-96|no\n NC-97|no\n NC-98|no\n US-1|\n US-1|yes\n US-401|no\n US-401|yes\n US-64|yes\n US-70|yes\n ", "notes": "", "see_also": ["db.select"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.db.select"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.renamecolumn.html", "name": "v.db.renamecolumn", "definition": "- Renames a column in the attribute table connected to a given vector map.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.db.renamecolumn map=name  [layer=string]  column=oldcol,newcol  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Old and new name of the column (old,new)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.renamecolumn  renames a column in the attribute table connected\n to a given vector map. It automatically checks the connection for the specified\n layer.\n ", "notes": "\n If the map table is connected through the DBF or SQLite drivers, the renaming\n is internally done by adding a new column with new name, transferring the contents\n of the old column to the new column and dropping the old column. This is needed\n as DBF or SQLite do not support \"ALTER TABLE\" command to rename columns. Due to\n this the renamed column is found as last column of the table, it's original position\n cannot be maintained.\n  The SQLite driver will exit with an error if the column rename involves only a change of \n case, i.e., upper-to-lowercase, or lower-to-uppercase. The SQLite protocol considers \"NAME\"\n and \"name\" to be identical column names. In cases like these, the user should rename the original\n column to an intermediary name, then rename the intermediary to the final name.\n  EXAMPLES \n Renaming a column: \n g.copy vect=roadsmajor,myroads\n v.info -c myroads\n v.db.renamecolumn myroads column=ROAD_NAME,roadname\n v.info -c myroads\n ", "see_also": ["db.execute", "v.db.addcolumn", "v.db.addtable", "v.db.connect", "v.db.dropcolumn", "v.db.droptable", "v.db.select", "v.db.update", "GRASS SQL interface"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.renamecolumn"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.reconnect.all.html", "name": "v.db.reconnect.all", "definition": "- Reconnects attribute tables for all vector maps from the current mapset to a new database.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.db.reconnect.all [-cd]  [old_database=name]   [old_schema=name]   [new_driver=string]   [new_database=name]   [new_schema=name]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Copy attribute tables to the target database if not exist Delete attribute tables from the source database Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Delete attribute tables from the source database Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "old_database", "flag": "old_database", "dataType": "String", "optional": true, "explanation": "Name of source database", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "old_schema", "flag": "old_schema", "dataType": "String", "optional": true, "explanation": "Name of source database schema", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "new_driver", "flag": "new_driver", "dataType": "String", "optional": true, "explanation": "Name for target driver", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "new_database", "flag": "new_database", "dataType": "String", "optional": true, "explanation": "Name for target database", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "new_schema", "flag": "new_schema", "dataType": "String", "optional": true, "explanation": "Name for target database schema", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.reconnect.all  changes database connection of all layers\n of all vector maps in the current mapset from the source\n ( old_database ) to the target ( new_database ) database. If\n a link does not match the  old_database  it is left untouched.\n If no new database is given, the default datase of the mapset is used as \n printed by  db.connect -g . If no old database is given, all \n layers without a link in the new database will be liniked to the new \n database. If an old database is given, only links in the old database \n will be changed.\n Optionally attribute tables in  new_database  can be created if\n not exist by  -c  flag. In this case  v.db.reconnect.all \n also tries to create an index on key column (usually \"cat\"\n column).\n ", "notes": "\n The value of the  old_database  option needs to be the exact\n string which appears as the fourth field printed by\n  v.db.connect -g . \n v.db.connect -g map=census \n 1/census|census|cat|/home/user/grassdata/nc_spm_base/PERMANENT/dbf/|dbf\n  v.db.reconnect.all  respect also variables to be\n substituted. In the example above,\n database  /home/user/grassdata/nc_spm_base/PERMANENT/dbf/  can\n be also defined as  '$GISDBASE/$LOCATION_NAME/$MAPSET/dbf/' \n (see examples).\n Attribute tables from  old_database  are after reconnecting left\n untouched.  v.db.reconnect.all  deletes those tables\n automatically only when  -d  flag is given.\n Also note that  v.db.reconnect.all  doesn't change default\n database driver or database ( db.connect -p ). Default database\n connection settings for newly created attribute data can be defined\n by  db.connect .\n  EXAMPLES \n In the examples below are assumed, that attribute tables are linked to\n the vector maps through  DBF  database\n driver.\n  Reconnect DBF attribute tables to SQLite database \n Reconnect  DBF  attribute tables linked to\n the vector maps in the current mapset\n to  SQLite  database:\n v.db.reconnect.all old_database='$GISDBASE/$LOCATION_NAME/$MAPSET/dbf/' \n   new_driver=sqlite new_database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'\n If attribute table doesn't exist in the target database\n ( new_database ) then the module prints an error message.\n  Convert DBF attribute tables to SQLite database \n For coping DBF tables to SQLite database and reconnecting them for all\n vector maps in the current mapset must be defined also  -c  flag.\n v.db.reconnect.all -c old_database='$GISDBASE/$LOCATION_NAME/$MAPSET/dbf/' \n   new_driver=sqlite new_database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'\n or alternatively\n # set default connection (sqlite)\n db.connect -d\n # verify default connection\n db.connect -g\n # reconnect\n v.db.reconnect.all -c old_database='$GISDBASE/$LOCATION_NAME/$MAPSET/dbf/'\n To automatically remove original DBF attribute tables after\n reconnecting the vector maps use  -d  flag. Note that attribute\n tables will be deleted  permanently  from the source\n database. This option should be used very carefully!\n  Convert GRASS 6 vector map to GRASS 7 including attribute transfer from DBF to SQLite \n To become usable in GRASS 7, all vector maps in a mapset need to be updated:\n # first rebuild topology for all vector maps\n v.build.all\n # set new default db connection (to SQLite default)\n db.connect -d\n # copy attribute tables from old DB to new SQLite DB, delete old tables in DBF format\n v.db.reconnect.all -cd\n ", "see_also": ["v.db.connect", "db.connect", "db.copy", "db.createdb", "db.droptable"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.reconnect.all"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.join.html", "name": "v.db.join", "definition": "- Joins a database table to a vector map table.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.db.join map=name  [layer=string]  column=name other_table=name other_column=name  [subset_columns=name[,name,...]]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Identifier column (e.g.: cat) in the vector table to be used for join", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "other_table", "flag": "other_table", "dataType": "String", "optional": false, "explanation": "Other table name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "other_column", "flag": "other_column", "dataType": "String", "optional": false, "explanation": "Identifier column (e.g.: id) in the other table used for join", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "subset_columns", "flag": "subset_columns", "dataType": "String", "optional": true, "explanation": "Subset of columns from the other table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.join  joins the content of another table into the connected\n attribute table of a vector map.\n ", "notes": "\n  v.db.join  is a front-end to  db.execute  to allow easier usage.\n The vector attribute table must be stored in a SQL database (SQLite, PostgreSQL,\n MySQL, ODBC, ...). The DBF backend is not supported. Tables can be\n imported with  db.in.ogr .\n  The vector map-database connection(s) can be verified with  v.db.connect .\n  EXAMPLES \n Exercise to join North Carolina geological classes from a CSV table to\n the \"geology\" map of the North Carolina sample dataset (requires download\n of legend CSV file  nc_geology.csv \n from  External data for NC sample dataset ):\n # check original map attributes\n v.db.select geology column=GEO_NAME,SHAPE_area\n # import of CSV table\n db.in.ogr input=nc_geology.csv output=nc_geology\n # work on copy of geology map in current mapset\n g.copy vector=geology,mygeology\n # check column names of vector map attributes\n v.info -c mygeology\n # check column names of legend table\n db.describe -c nc_geology\n # join table using key columns (map: \"GEO_NAME\"; table: \"geol_id\")\n v.db.join map=mygeology column=GEO_NAME other_table=nc_geology other_column=geol_id\n # verify result (here abbreviated)\n v.db.select mygeology | head -3\n cat|onemap_pro|PERIMETER|GEOL250_|GEOL250_ID|GEO_NAME|SHAPE_area|SHAPE_len|geol_id|longname|comment\n 1|963738.75|4083.97998|2|1|Zml|963738.608571|4083.979839|Zml|Metagraywacke|Interlayered with metaconglomerate, ...\n 2|22189124|26628.261719|3|2|Zmf|22189123.2296|26628.261112|Zmf|Metafelsite|Light-colored porphyritic extrusive rock\n ...\n  Soil map table join \n Joining the soil type explanations from table  soils_legend \n into the Spearfish soils map ( download legend ):\n g.copy vect=soils,mysoils\n # import legend table\n db.in.ogr soils_legend.csv out=soils_legend\n # get join column names\n v.info -c mysoils\n db.describe -c soils_legend\n # look at original table\n v.db.select mysoils\n cat|label\n 1|Aab\n 2|Ba\n 3|Bb\n 4|BcB\n 5|BcC\n ...\n # look at legend\n db.select table=soils_legend\n db.select table=soils_legend | head -7\n id|shortname|longname\n 0|no data|no data\n 0|AaB|Alice fine sandy loam, 0 to 6\n 0|Ba|Barnum silt loam\n 0|Bb|Barnum silt loam, channeled\n 0|BcB|Boneek silt loam, 2 to 6\n 0|BcC|Boneek silt loam, 6 to 9\n ...\n # join soils_legend into mysoils attribute table\n v.db.join mysoils col=label other_table=soils_legend ocol=shortname\n # verification of join\n v.db.select mysoils\n cat|label|id|shortname|longname\n 1|Aab|||\n 2|Ba|2|Ba|Barnum silt loam\n 3|Bb|3|Bb|Barnum silt loam, channeled\n 4|BcB|4|BcB|Boneek silt loam, 2 to 6\n 5|BcC|5|BcC|Boneek silt loam, 6 to 9\n ...\n ", "see_also": ["db.execute", "db.in.ogr", "db.select", "v.db.update", "GRASS SQL interface"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.join"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.droptable.html", "name": "v.db.droptable", "definition": "- Removes existing attribute table of a vector map.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.db.droptable [-f] map=name  [table=name]   [layer=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "f", "flag": "-f", "explanation": "Force removal (required for actual deletion of table) Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "table", "flag": "table", "dataType": "String", "optional": true, "explanation": "Table name (default: vector map name)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.db.droptable  removes an existing attribute table from a \n given vector map linked at given layer. If the  -f  force flag is not\n given then nothing is removed.\n ", "notes": "\n  v.db.droptable  is a front-end to  db.execute  to allow easier usage.\n  The existing database connection(s) can be verified with  v.db.connect .\n  EXAMPLE \n Removing attribute table connected to layer 1: \n g.copy vect=roadsmajor,myroads\n v.db.droptable myroads\n v.db.droptable myroads -f\n v.db.connect -p myroads\n ", "see_also": ["db.connect", "db.execute", "v.db.addtable", "v.db.connect", "v.db.dropcolumn", "v.db.select", "v.db.update", "GRASS SQL interface"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.droptable"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.db.droprow.html", "name": "v.db.droprow", "definition": "- Removes a vector feature from a vector map through attribute selection.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.db.droprow input=name  [layer=string]  where=sql_query output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": false, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.db.droprow  removes vector object(s) (point, line, area, face etc.) \n from a vector map through attribute selection in the table connected\n to the given vector map. It automatically checks the connection for the specified\n layer.\n ", "notes": "\n v.db.droprow is a front-end to  v.extract  (reverse selection)\n to allow easier usage.\n The existing database connection(s) can be verified with  v.db.connect .\n  EXAMPLES \n Dropping all vector points without elevation attribute (North Carolina data set): \n g.region raster=elevation -p\n v.random output=rand5k_elev n=5000 \n v.db.addtable map=rand5k_elev column=\"elevation double precision\"\n v.what.rast vect=rand5k_elev rast=elevation column=elevation\n # verify absence of some elevation attributes (\"number of NULL attributes\"):\n v.univar rand5k_elev type=point column=elevation\n # Remove all vector points lacking elevation attribute\n v.db.droprow rand5k_elev output=rand5k_elev_filt where=\"elevation IS NULL\"\n # verify:\n v.univar rand5k_elev_filt type=point column=elevation\n ", "see_also": ["db.droptable", "db.execute", "v.db.addcolumn", "v.db.addtable", "v.db.connect", "v.db.dropcolumn", "v.db.droptable", "v.db.select", "v.db.update"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.db.droprow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.patch.html", "name": "v.patch", "definition": "- Creates a new vector map by combining other vector maps.", "keywords": ["vector", "geometry", "level1"], "synopsis": "v.patch [-nzeab] input=name[,name,...] output=name  [bbox=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Do not expect input with topology Applicable when input is points without topology Expect z coordinate even when not using topology Applicable when input is points with z coordinate but without topology Copy also attribute table Only the table of layer 1 is currently supported Append files to existing file (overwriting existing files must be activated) Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Expect z coordinate even when not using topology Applicable when input is points with z coordinate but without topology Copy also attribute table Only the table of layer 1 is currently supported Append files to existing file (overwriting existing files must be activated) Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Copy also attribute table Only the table of layer 1 is currently supported Append files to existing file (overwriting existing files must be activated) Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Append files to existing file (overwriting existing files must be activated) Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map(s)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "bbox", "flag": "bbox", "dataType": "String", "optional": true, "explanation": "Name for output vector map where bounding boxes of input vector maps are written to", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.patch  allows the user to combine any number of\n vector maps together to create one composite vector\n map. If the table structures are identical, attributes are\n transferred to the new table.\n ", "notes": "\n Any vectors that are duplicated among the maps being\n patched together (e.g., border lines) will have to be\n edited or removed after  v.patch  is run. Such\n editing can be done automatically using\n  v.clean .\n  Lines may need to be\n snapped with  v.clean \n tool=snap,break,rmdupl .\n  Boundaries may need to be cleaned with\n  v.clean  tool=break,rmdupl,rmsa \n repeatedly until the  rmsa  tool (Remove small angles at nodes)\n no longer modifies any boundaries. If vector topology is still not\n clean, boundaries may also need to be snapped with\n  v.clean  tool=snap,break,rmdupl .\n  When using the  -a  flag, the user has to make sure that the\n features in the different maps added to the output map do not have\n overlapping category numbers, unless identical category numbers\n reflect identical attributes, otherwise the attributes of the added\n maps are lost. To avoid this, the user can use  v.category\n option=sum  to change category values of some of the maps before\n patching.\n  EXAMPLES \n Patch together two maps with mixed feature types:\n    v.patch input=geology,streams out=geol_streams\n Append one map to another:\n    g.copy vect=roads,transport\n    v.patch -a input=railroads output=transport --overwrite\n ", "see_also": ["v.clean", "v.build", "v.select", "v.overlay"], "authors": ["Dave Gerdes, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.patch"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.parallel.html", "name": "v.parallel", "definition": "- Creates parallel line to input vector lines.", "keywords": ["vector", "geometry", "buffer", "line"], "synopsis": "v.parallel [-rb] input=name  [layer=string]  output=name distance=float  [minordistance=float]   [angle=float]  side=string  [tolerance=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Make outside corners round Create buffer-like parallel lines Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Create buffer-like parallel lines Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": false, "explanation": "Offset along major axis in map units", "defaultValue": null, "alternatives": ["0-100000000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "minordistance", "flag": "minordistance", "dataType": "String", "optional": true, "explanation": "Offset along minor axis in map units", "defaultValue": null, "alternatives": ["0-100000000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "angle", "flag": "angle", "dataType": "String", "optional": true, "explanation": "Angle of major axis in degrees", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "side", "flag": "side", "dataType": "String", "optional": false, "explanation": "Side", "defaultValue": "right", "alternatives": ["left", "right", "both"], "isInputFile": false, "isOutputFile": false}, {"parameter": "tolerance", "flag": "tolerance", "dataType": "String", "optional": true, "explanation": "Tolerance of arc polylines in map units", "defaultValue": null, "alternatives": ["0-100000000"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.parallel  creates parallel lines to the input vector lines which\n can be used as half-buffers.\n ", "notes": "\n Usage of  -b  flag will overrule the  side  parameter.\n  KNOWN ISSUES \n There is a problem with side-offset parallel line generation for inside corners.\n To avoid this problem, the  -b  flag might be used.\n ", "see_also": ["v.buffer"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.parallel"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.pack.html", "name": "v.pack", "definition": "- Exports a vector map as GRASS GIS specific archive file", "keywords": ["vector", "export", "copying"], "synopsis": "v.pack [-c] input=name  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Switch the compression off Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of vector map to pack up", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output file (default is <input>.pack)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.pack  collects (packs) vector map elements and support files\n in GRASS Database and creates an compressed file using  gzip \n algorithm. This file can be used to copy the vector map to another\n machine. The packed file can be afterwards unpacked\n by  v.unpack .\n ", "notes": "\n Name of the pack file is determined by default from  input \n parameter. Optionally the name can be given by  output  parameter.\n  EXAMPLE \n Pack up vector map  random_point  into  random_point.pack  file.\n v.pack input=random_point\n the vector map can be afterwards unpacked by\n v.unpack input=random_point.pack\n ", "see_also": ["v.unpack", "v.in.ogr", "g.copy", "v.proj", "r.unpack"], "authors": ["Luca Delucchi, Fondazione E. Mach (Italy), based on the"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.pack"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.overlay.html", "name": "v.overlay", "definition": "- Overlays two vector maps offering clip, intersection, difference, symmetrical difference, union operators.", "keywords": ["vector", "geometry", "spatial query", "clip", "difference", "intersection", "union"], "synopsis": "v.overlay [-t] ainput=name  [alayer=string]   [atype=string[,string,...]]  binput=name  [blayer=string]   [btype=string[,string,...]]  operator=string output=name  [olayer=string[,string,...]]   [snap=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "ainput", "flag": "ainput", "dataType": "String", "optional": false, "explanation": "Name of input vector map (A)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "alayer", "flag": "alayer", "dataType": "String", "optional": true, "explanation": "Layer number or name (vector map A)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "atype", "flag": "atype", "dataType": "String", "optional": true, "explanation": "Feature type (vector map A)", "defaultValue": "auto", "alternatives": ["line", "area", "auto"], "isInputFile": false, "isOutputFile": false}, {"parameter": "binput", "flag": "binput", "dataType": "String", "optional": false, "explanation": "Name of input vector map (B)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "blayer", "flag": "blayer", "dataType": "String", "optional": true, "explanation": "Layer number or name (vector map B)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "btype", "flag": "btype", "dataType": "String", "optional": true, "explanation": "Feature type (vector map B)", "defaultValue": "area", "alternatives": ["area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "operator", "flag": "operator", "dataType": "String", "optional": false, "explanation": "Operator defines features written to output vector map", "defaultValue": null, "alternatives": ["and", "or", "not", "xor"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "olayer", "flag": "olayer", "dataType": "String", "optional": true, "explanation": "Output layer for new category, ainput and binput", "defaultValue": "1,0,0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "snap", "flag": "snap", "dataType": "String", "optional": true, "explanation": "Snapping threshold for boundaries", "defaultValue": "1e-8", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.overlay  allows the user to overlay two vector maps. Features \n in  ainput  can be lines or areas and are cut with areas in \n  binput . Simple  clipping  can be performed with the  and  \n operator.\n If areas in  ainput  are overlaid with areas in  binput , \n it is sometimes necessary to snap areas of  binput  to those of \n  ainput , otherwise areas can go missing or many sliver areas \n can be created. Snapping is enabled by default and can be disabled by \n setting the  snap  option to a negative value. Recommended values \n are between 0.00000001 and 0.0001. Using larger values for snapping can \n have undesired side-effects, but may sometimes be necessary to get a \n clean output (see example below). In general, it is recommended to start \n with a small snapping threshold, gradually increasing the threshold until \n the result is reasonably clean. Snapping modifies only boundaries in \n binput, which are snapped to boundaries in ainput. Boundaries in  ainput  \n are not modified.\n ", "notes": "\n Currently only areas in  ainput  are supported for the operators \n  or  and  xor ! See also  v.select .\n The operator defines what kind of operation will be done. Features are \n written to output, if the result of an operation  ainput  operator  binput  \n is true.\n If the  first  number of the  olayer  option is greater than 0, then the \n resulting output map has a merged attribute table in the given layer \n number. The original column names have a prefix ( a_  and \n  b_ ) corresponding to  ainput  and  binput  map.\n If the  second  number of the  olayer  option is greater than 0, then the \n categories of  ainput  in layer  alayer  are transferred to\n the output layer with the second number.\n If the  third  number of the  olayer  option is greater than 0, then the \n categories of  binput  in layer  blayer  are transferred to\n the output layer with the third number.\n If  atype =auto is given than  v.overlay  determines\n feature type for  ainput  from the first found feature.\n  EXAMPLES \n Preparation of example data (North Carolina sample dataset):\n # Create an empty box for overlaying to ZIP code vector map\n v.mkgrid map=box grid=1,1 position=coor coordinates=584037,201970 box=50000,50000\n # set region to ZIP codes and box vector maps\n g.region vector=zipcodes_wake,box -p res=100 -a\n # enlarge region a bit for \"white border\" around map in monitor\n g.region n=n+1000 s=s-1000 w=w-1000 e=e+1000 -p\n d.mon wx0\n  AND operator \n Clipping example (no attribute table is generated here):\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=box fill_color=85:130:176\n v.overlay -t ainput=box binput=zipcodes_wake operator=and output=v_overlay_AND\n d.vect map=v_overlay_AND\n  Figure: v.overlay with AND operator (selected polygons in grey color) \n  OR operator \n Union example of areas:\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=box fill_color=85:130:176\n v.overlay -t ainput=box binput=zipcodes_wake operator=or output=v_overlay_OR\n d.vect map=v_overlay_OR\n  Figure: v.overlay with OR operator (selected polygons in grey color) \n  XOR operator \n Symmetrical difference example:\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=box fill_color=85:130:176\n v.overlay -t ainput=box binput=zipcodes_wake operator=xor output=v_overlay_XOR\n d.vect map=v_overlay_XOR\n  Figure: v.overlay with XOR operator (selected polygons in grey color) \n  NOT operator \n Difference example:\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=box fill_color=85:130:176\n v.overlay -t ainput=box binput=zipcodes_wake operator=not output=v_overlay_NOT\n d.vect map=v_overlay_NOT\n  Figure: v.overlay with NOT operator (selected polygon in grey color) \n  Overlay operations: AND, OR, NOT, XOR \n ZIP code examples, based on North Carolina sample dataset:\n # creation of simple dataset\n v.extract input=zipcodes_wake output=poly1 where=\"cat = 42\"\n v.extract input=urbanarea output=poly2 where=\"cat = 55\"\n v.overlay ainput=poly1 binput=poly2 operator=and output=poly_1_2_and\n v.overlay ainput=poly1 binput=poly2 operator=or  output=poly_1_2_or\n v.overlay ainput=poly1 binput=poly2 operator=not output=poly_1_2_not\n v.overlay ainput=poly1 binput=poly2 operator=xor output=poly_1_2_xor\n  \n  Figure: v.overlay operations: original input polygons \n  Figure: v.overlay results of AND, OR, NOT, XOR operations \n  Polygons overlaid with polygons \n v.overlay ainput=lake binput=province output=lakeXprovince operator=or\n Polygon union of urban area and Census 2000 areas (North Carolina dataset):\n # input maps\n d.vect urbanarea\n d.vect census_wake2000\n # union\n v.overlay ain=census_wake2000 bin=urbanarea out=urban_census2000 operator=or\n # show result, graphically zooming a subset\n g.region n=230400 s=223800 w=655800 e=662400\n d.erase\n d.vect urban_census2000\n # show merged attribute table\n v.db.select urban_census2000 where=\"cat=108\" -v\n cat|108\n a_cat|98\n a_AREA|231001264\n a_PERIMETE|67804.305\n a_TRACT_|98\n a_TRACT_ID|98\n a_RINGS_OK|1\n a_RINGS_NO|0\n a_ID|98\n a_FIPSSTCO|37183\n a_TRT2000|054108\n a_STFID|37183054108\n a_TRACTID|541.08\n a_TRACT|541.08\n b_cat|55\n b_OBJECTID|55\n b_UA|73261\n b_NAME|Raleigh\n b_UA_TYPE|UA\n  Figure: v.overlay: Polygon union (right) of urban area (left) and Census 2000 (middle) areas (North Carolina dataset) \n As can be seen by the resulting large number of centroids on boundaries, \n the urban areas do not match exactly the Census 2000 areas. In this case \n a clean result can be obtained by snapping with a threshold of 0.1 m.\n  Lines overlaid with polygons \n Using the North Carolina sample dataset, we clip the roads map to the area\n of city of Raleigh, preserving road attributes in layer 1:\n g.region vector=zipcodes_wake\n # extract Raleigh city:\n v.extract in=zipcodes_wake out=raleigh where=\"ZIPNAME = 'RALEIGH'\"\n # clip road network to city polygon:\n v.overlay ainput=roadsmajor atype=line binput=raleigh out=roadsmajor_raleigh operator=and olayer=0,1,0\n  Figure: v.overlay: Line to polygon clipping \n ", "see_also": ["v.clip", "v.db.connect", "v.select", "g.copy"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.overlay"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.outlier.html", "name": "v.outlier", "definition": "- Removes outliers from vector point data.", "keywords": ["vector", "statistics", "extract", "select", "filter", "LIDAR"], "synopsis": "v.outlier [-e] input=name output=name outlier=name  [qgis=name]   [ew_step=float]   [ns_step=float]   [lambda=float]   [threshold=float]   [filter=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Estimate point density and distance Estimate point density and distance for the input vector points within the current region extends and quit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "outlier", "flag": "outlier", "dataType": "String", "optional": false, "explanation": "Name for output outlier vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "qgis", "flag": "qgis", "dataType": "String", "optional": true, "explanation": "Name for vector map for visualization in QGIS", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ew_step", "flag": "ew_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the east-west direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ns_step", "flag": "ns_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the north-south direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lambda", "flag": "lambda", "dataType": "String", "optional": true, "explanation": "Tykhonov regularization weight", "defaultValue": "0.1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Threshold for the outliers", "defaultValue": "50", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "filter", "flag": "filter", "dataType": "String", "optional": true, "explanation": "Filtering option", "defaultValue": "both", "alternatives": ["both", "positive", "negative"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.outlier  removes outliers in a 3D point cloud. By default, the outlier\n identification is done by a bicubic spline interpolation of the\n observation with a high regularization parameter and a low resolution\n in south-north and east-west directions. Those points that differ in\n an absolute value more than the given threshold from a fixed value,\n reckoned from its surroundings by the interpolation, are considered as\n an outlier, and hence are removed.\n The  filter  option specifies if all outliers will be removed\n (default), or only positive or only negative outliers. Filtering out\n only positive outliers can be useful to filter out vegetation returns\n (e.g. from forest canopies) from LIDAR point clouds, in order to\n extract Digital Terrain Models. Filtering out only negative outliers\n can be useful to estimate vegetation height.\n There is a flag to create a vector that can be visualizated by\n qgis. That means that topology is build and the z coordinate is\n considered as a category.\n  EXAMPLES \n  Basic outlier removal \n v.outlier input=vector_map output=vector_output outlier=vector_outlier thres_O=25\n In this case, a basic outlier removal is done with a threshold of 25 m.\n  Basic outlier removal \n v.outlier input=vector_map output=vector_output outlier=vector_outlier qgis=vector_qgis\n Now, the outlier removal uses the default threshold and there is also\n an output vector available for visualizaton in QGIS\n  ( http://www.qgis.org ).\n  North carolina location example \n v.outlier input=elev_lid792_bepts output=elev_lid792_bepts_nooutliers \n    outlier=elev_lid792_bepts_outliers ew_step=5 ns_step=5 thres_o=0.1\n ", "notes": "\n This module is designed to work with LIDAR data, so not topology is\n built but in the QGIS output.\n ", "see_also": ["v.surf.bspline"], "authors": ["Original version of the program in GRASS 5.4:"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.outlier"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.out.vtk.html", "name": "v.out.vtk", "definition": "- Converts a vector map to VTK ASCII output.", "keywords": ["vector", "export", "VTK"], "synopsis": "v.out.vtk [-cn] input=name  [layer=string]   [output=name]   [type=string[,string,...]]   [precision=integer]   [zscale=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Correct the coordinates to fit the VTK-OpenGL precision Export numeric attribute table fields as VTK scalar variables Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Export numeric attribute table fields as VTK scalar variables Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output VTK file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,kernel,centroid,line,boundary,area,face", "alternatives": ["point", "kernel", "centroid", "line", "boundary", "area", "face"], "isInputFile": false, "isOutputFile": false}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Number of significant digits (floating point only)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Scale factor for elevation", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.out.vtk  \n converts a GRASS vector map in binary format to the VTK ASCII \n output. \n  If the  output  parameter is not given, the output will be send to stdout.\n ", "notes": "\n The following vector types can be exported together in one VTK ascii file:\n \t point \n \t line \n \t centroid \n \t boundary \n \t area \n \t face \n Category data (cat) for the selected vector type and layer will be written as scalar\n data with name \"cat_{vectorname}\". If no cat exists, the value will set to -1 as normal cat's are\n always positive.\n If a vector has more categories in one layer, only the first category\n will be exported.\n 3d vectors are supported by default. The created VTK data always includes x, y and z coordinates \n (z = 0 if not a 3d vector map).\n Note that you can easily convert your 2d vectors into 3d vectors with v.drape.\n Because of the 32bit limits of OpenGL which is used by VTK, visualisation errors may occur if\n the grass region contains coordinates greater than 1.000.000 and vector coordinates\n with 0.01 - 0.001 meters precisison. For this reason, the flag \"-c\" was added. The coordinates are \n transformed to smaller coordinates (by decreasing the coordinates with the region center).\n If the \"-c\" flag is used and the data should be visualised together with other data exported via *.out.vtk\n modules, be sure the \"-c\" flag was also set in these modules. \n But this will only work with data from the SAME location \n (The reference point for the coordinates transformation is based on the default region).\n The GRASS vector data is converted into the polydata format of VTK: \n   vtk Vertices  -- representing points and centroids  \n   vtk lines  -- representing lines and boundaries   \n   vtk polygons  -- representing areas and faces  \n  The VTK file can be visualized with\n  VTK Toolkit ,\n  Paraview  and\n  MayaVi .\n  Attention \n  If areas or faces are exported, the data have to be triangulated within Paraview or\n MayaVi.\n  EXAMPLE \n Spearfish example:\n  Export the soils with cats in layer 1:\n v.out.vtk input=soils type=area layer=1 output=/tmp/soils.vtk\n Export the streams with cats in layer 1:\n v.out.vtk input=streams type=line layer=1 output=/tmp/streams.vtk\n Write the archsite vtk output to stdout with cats in layer 1:\n v.out.vtk input=archsites type=point layer=1\n ", "see_also": ["v.out.ascii", "r.out.vtk", "r3.out.vtk"], "authors": ["Soeren Gebbert"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.out.vtk"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.out.svg.html", "name": "v.out.svg", "definition": "- Exports a vector map to SVG file.", "keywords": ["vector", "export"], "synopsis": "v.out.svg input=name  [layer=string]  output=name type=string  [precision=integer]   [attribute=name[,name,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for SVG output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": false, "explanation": "Output type", "defaultValue": "poly", "alternatives": ["poly", "line", "point"], "isInputFile": false, "isOutputFile": false}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Coordinate precision", "defaultValue": "6", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "attribute", "flag": "attribute", "dataType": "String", "optional": true, "explanation": "Attribute(s) to include in output SVG", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.out.svg  converts GRASS vector data to SVG (Scalable Vector Graphics) code notation.\n In particular, it\n  converts GRASS line, boundary, area, point, centroid objects to SVG \n   <path />, <circle /> elements, \n  reduces coordinate precision in SVG-output to save bandwidth, \n  extracts GRASS attributes to gg:name=\"value\" attributes. \n The  precision  parameter controls the number of decimals for coordinates\n output ( precision=0  corresponds to integer precision in the output SVG file).\n  EXAMPLE \n  Export  polygons  from GRASS vector map soils (Spearfish sample data) to SVG format:\n v.out.svg input=soils output=/tmp/output.svg type=poly\n  Export  lines  from GRASS vector map t_hydro (Spearfish sample\n data) to SVG format, set coordinate precision to 0:\n v.out.svg input=t_hydro output=/tmp/output.svg type=line precision=0\n  Export  points  from GRASS vector map archsites (Spearfish sample\n data) to SVG format, include attribute  str1  (name):\n v.out.svg input=archsites output=/tmp/output.svg type=point precision=0 attrib=str1\n  REFERENCES \n  Modul v.out.svg at svg.cc \n  SVG (Scalable Vector Graphics) at w3c.org \n ", "notes": "", "see_also": ["v.out.ogr"], "authors": ["Klaus Foerster (klaus svg.cc), Innsbruck, Austria"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.out.svg"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.out.pov.html", "name": "v.out.pov", "definition": "- Converts GRASS x,y,z points to POV-Ray x,z,y format.", "keywords": ["vector", "export"], "synopsis": "v.out.pov input=name  [layer=string]   [type=string[,string,...]]  output=name  [size=string]   [zmod=string]   [objmod=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,area,face", "alternatives": ["point", "line", "boundary", "centroid", "area", "face", "kernel"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output POV file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Radius of sphere for points and tube for lines", "defaultValue": "10", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zmod", "flag": "zmod", "dataType": "String", "optional": true, "explanation": "This string is appended to each z coordinate. Examples: '*10', '+1000', '*10+100', '*exaggeration'", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "objmod", "flag": "objmod", "dataType": "String", "optional": true, "explanation": "Object modifier (OBJECT_MODIFIER in POV-Ray documentation)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.out.pov  converts GRASS vector data to POV-Ray format (www.povray.com)\n  EXAMPLE \n v.out.pov input=vector3d output=vector3d.pov objmod=\"pigment { color red 0 green 1 blue 0 }\"\n The generated file can be included in an existing .pov file with the following statement:\n #include \"vector3d.pov\"\n  REFERENCES \n  POV-Ray \n ", "notes": "", "see_also": ["r.out.pov"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.out.pov"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.out.postgis.html", "name": "v.out.postgis", "definition": "- Exports a vector map layer to PostGIS feature table.", "keywords": ["vector", "export", "PostGIS", "simple features", "topology", "3D"], "synopsis": "v.out.postgis [-tl2] input=name  [type=string[,string,...]]   [layer=string]  output=string  [output_layer=name]   [output_link=name]   [options=key=value[,key=value,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Do not export attribute table Export PostGIS topology instead of simple features Force 2D output even if input is 3D  Useful if input is 3D but all z coordinates are identical Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Export PostGIS topology instead of simple features Force 2D output even if input is 3D  Useful if input is 3D but all z coordinates are identical Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "2", "flag": "-2", "explanation": "Force 2D output even if input is 3D  Useful if input is 3D but all z coordinates are identical Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "auto", "alternatives": ["point", "line", "boundary", "centroid", "area", "face", "kernel", "auto"], "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output PostGIS datasource", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "output_layer", "flag": "output_layer", "dataType": "String", "optional": true, "explanation": "Name for output PostGIS layer", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "output_link", "flag": "output_link", "dataType": "String", "optional": true, "explanation": "Name for output vector map defined as a link to the PostGIS feature table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "options", "flag": "options", "dataType": "String", "optional": true, "explanation": "Creation options", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.out.postgis  exports an existing GRASS vector map layer to\n PostGIS feature table. Features without category are skipped.\n By default GRASS GIS topological features are converted into simple\n features\n (see  OGC Simple\n Feature Access  specification for details). Flag  -l  allows\n to export vector features as topological elements stored\n in  PostGIS\n Topology  schema. Note that topological export requires PostGIS\n version 2 or later.\n Additional creation options can be defined by  options  parameter:\n    FID=<column>  - name of column which will be used as\n   primary key (feature id), default:  fid \n    GEOMETRY_NAME=<column>  name of column which will\n   be used for storing geometry data in feature table, default:  geom \n    SPATIAL_INDEX=YES|NO  - enable/disable creating spatial\n   index on geometry column, default:  YES \n    PRIMARY_KEY=YES|NO  - enable/disable adding primary key\n   on FID column, default:  YES \n    SRID=<value>  - spatial reference identifier,\n   default: not defined \n PostGIS Topology related options (relevant only for  -l  flag):\n    TOPOSCHEMA_NAME=<schema name>  - name of PostGIS\n   Topology schema, default:  topo_<input> \n    TOPOGEOM_NAME=<column>  - name of column which\n   will be used for storing topogeometry data in feature table,\n   default:  topo \n    TOPO_TOLERANCE=<value>  - tolerance for PostGIS\n   Topology schema,\n   see  CreateTopology \n   function for defails, default:  0 \n    TOPO_GEO_ONLY=YES|NO  - store in PostGIS Topology schema\n   only data relevant to Topo-Geo data model,\n   default:  NO \n Creation  options  are comma-separated pairs\n ( key=value ), the options are case-insensitive. Note\n that  options  defined\n by  v.external.out  are\n ignored by  v.out.postgis .\n  v.out.postgis  optionally also creates a new vector map in the\n current mapset if  output_link  is defined.\n ", "notes": "\n By default  v.out.postgis  exports vector data as  simple\n features , ie. boundaries and centroids (forming topological\n areas) become polygons, isles become holes. Geometry of simple feature\n elements is stored in PostGIS feature table in the column named\n \"geom\". Name of the geometry column can be changed\n by  options= GEOMETRY_NAME=<column> . Note that for\n exporting vector features as simple features can be alternatively\n used  PostgreSQL driver \n from  OGR  library\n through  v.out.ogr  module.\n Also note that it's allowed to store in the feature table only\n features of the same type, ie. mixing of points and lines is not\n currently possible. The feature type is determined for output feature\n table from the first vector feature accessing data sequentially\n ( type=auto ). Vector features of other types are during export\n skipped. User can choose preferable feature type by  type \n parameter. Only single type is currently allowed (see TODO section for\n details).\n  v.out.postgis  currently supports only three basic output\n simple feature types: Points, Linestrings and Polygons. Also 3D\n features of the same type are supported, eg. 3D points are exported\n as  PointZ  simple feature. Faces are exported as 3D\n polygons. 3D features are written to the output automatically if input\n vector map is 3D. If  -2  flag is given then the output is always\n 2D (z-coordinate is silently ignored for 3D input vector maps).\n Multigeometries are not currently supported. Features with the same\n category are exported as multiple singe features.\n  v.out.postgis  also allows exporting vector features as\n  topological elements \n in  PostGIS\n Topology  schema. PostGIS Topology extension uses three tables to\n store basic topological elements which forms topological objects like\n areas or isles in GRASS terminology.  Nodes  (0-dimensional\n topological elements) are stored in \"node\"\n table,  edges  (1-dimensional elements) in \"edge\"\n table and  faces  (2-dimensional elements) in \"face\"\n table.\n    GRASS nodes are stored in  node  table \n    GRASS points are stored in  node  table as regular nodes \n    GRASS centroids are stored in  node  table as regular nodes\n     (\"containing_face\" refers to related area) \n    GRASS lines are stored in  edge  table \n    GRASS boundaries are stored in  edge  table \n    GRASS areas are stored in  face  table \n Tables  node ,  edge  and  face  are stored in given\n topological schema. By default  v.out.postgis  defines its name\n as  topo_<input> . Alternatively, the name for topology\n schema can be defined\n by  options= TOPOSCHEMA_NAME=<name> .\n  EXAMPLES \n  Export Simple Features \n Export vector map \"urbanarea\" as feature table \"urbanarea\"\n located in database \"grass\", schema \"public\". Note that this\n database schema is automatically used when not defined by the user.\n v.out.postgis input=urbanarea output=\"PG:dbname=grass\"\n GRASS areas are converted into polygons, isles into holes. We can\n check the number or created polygons by simple SQL query below.\n db.select driver=pg database=grass \n   sql=\"SELECT ST_GeometryType(geom) as geom_type, count(*) from urbanarea group by geom_type\"\n geom_type|count\n ST_Polygon|657\n  Note:  same procedure can be done\n by  v.out.ogr  module, eg.\n v.out.ogr input=urbanarea output=\"PG:dbname=grass\" format=PostgreSQL\n In this case GRASS vector data are exported to PostGIS database using\n OGR library, namely using PostgreSQL driver. Contrary to\n the  v.out.ogr \n module,  v.out.postgis  is using directly PostGIS data provider\n which is part of GRASS vector engine. Beside\n that,  v.out.postgis  is optimized for PostGIS export including\n topological access to the data.\n  Export data into specific database schema \n Database schema for storing exported data can be defined\n by  output_layer  as\n  <schema_name>.<table_name> . If the specified\n schema doesn't exist in the database, then it's automatically created.\n Export vector map \"bridges\" as feature table in database\n schema \"grassout\".\n v.out.postgis input=bridges output=\"PG:dbname=grass\" output_layer=grassout.bridges\n  Export data with creation options \n Example below demonstrates how to define name for geometry column and\n disable building spatial index. Spatial reference system is defined\n by  srid  identifier which corresponds in this case with EPSG\n 3358 (North Carolina dataset).\n v.out.postgis input=roadsmajor output=\"PG:dbname=grass\" options=\"GEOMETRY_NAME=wkb_geometry,SPATIAL_INDEX=NO,SRID=3358\"\n  Link exported data \n Exported data can be linked as vector map created in the current\n mapset by specifying  output_link  parameter. In the example below\n vector map \"busstopsall\" from PERMANENT mapset is exported\n into \"grass\" PostGIS database.  v.out.postgis  after\n successful export also creates in the current mapset GRASS vector map\n as a link to the PostGIS feature table.\n v.out.postgis input=busstopsall@PERMANENT output=\"PG:dbname=grass\" output_link=busstopsall_pg\n Created link can be checked\n by  v.info :\n  v.info busstopsall_pg\n ...\n  |----------------------------------------------------------------------------|\n  | Map format:      PostGIS (PostgreSQL)                                      |\n  | DB table:        public.busstopsall                                        |\n  | DB name:         grass                                                     |\n  | Geometry column: geom                                                      |\n  | Feature type:    point                                                     |\n  | Topology:        pseudo (simple features)                                  |\n  |----------------------------------------------------------------------------|\n ...\n  Export data without attributes \n  v.out.postgis  allows ignoring attributes when exporting\n vector features by specifying  -t  flag.\n Command below exports vector features without attributes. The feature\n will contain only two columns, the fid and geometry column.\n v.out.postgis -t input=railroads output=\"PG:dbname=grass\"\n  Export topological data \n By default  v.out.postgis  exports data as simple\n features. Flag  -l  allows exporting data as topological elements\n instead of simple features. Export topological elements is stored in\n  PostGIS\n Topology  schema.\n v.out.postgis -l input=busroutesall output=\"PG:dbname=grass\"\n For more info about PostGIS Topology implementation in GRASS see\n the  wiki\n page .\n  TODO \n    Multi-feature export \n    Allow mixed features (points, lines) \n    Support other simple feature types like GeometryCollection and others \n    Implement missing options\n   from  v.out.ogr :  -a ,  -s ,  -c ,  -p ,  -n \n    Add options:  cats ,  where \n  REQUIREMENTS \n    PostGIS 2.x or later for topological export (flag  -l )\n  REFERENCES \n    OGC Simple Feature Access  specification \n    PostGIS Topology  documentation \n    GRASS-PostGIS data provider \n ", "see_also": ["v.out.ogr", "v.external", "v.external.out", "v.in.ogr"], "authors": ["Martin Landa, Czech Technical University in Prague, Czech Republic (development supported by Fondazione Edmund Mach and Comune di Trento, Italy)"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.out.postgis"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.out.ogr.html", "name": "v.out.ogr", "definition": "- Exports a vector map layer to any of the supported OGR vector formats.", "keywords": ["vector", "export", "OGR"], "synopsis": "v.out.ogr [-uasce2mnl] input=name  [layer=string]   [type=string[,string,...]]  output=name format=string  [output_layer=string]   [output_type=string[,string,...]]   [dsco=string[,string,...]]   [lco=string[,string,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "u", "flag": "-u", "explanation": "Open an existing OGR datasource for update Append to existing layer A new OGR layer is created if it does not exist Skip export of GRASS category ID ('cat') attribute Also export features without category (not labeled). Otherwise only features with category are exported. Use ESRI-style .prj file format (applies to Shapefile output only) Force 2D output even if input is 3D (applies to Shapefile output only) Useful if input is 3D but all z coordinates are identical Export vector data as multi-features Create a new empty layer in defined OGR datasource and exit. Nothing is read from input. List supported output formats and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Append to existing layer A new OGR layer is created if it does not exist Skip export of GRASS category ID ('cat') attribute Also export features without category (not labeled). Otherwise only features with category are exported. Use ESRI-style .prj file format (applies to Shapefile output only) Force 2D output even if input is 3D (applies to Shapefile output only) Useful if input is 3D but all z coordinates are identical Export vector data as multi-features Create a new empty layer in defined OGR datasource and exit. Nothing is read from input. List supported output formats and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Skip export of GRASS category ID ('cat') attribute Also export features without category (not labeled). Otherwise only features with category are exported. Use ESRI-style .prj file format (applies to Shapefile output only) Force 2D output even if input is 3D (applies to Shapefile output only) Useful if input is 3D but all z coordinates are identical Export vector data as multi-features Create a new empty layer in defined OGR datasource and exit. Nothing is read from input. List supported output formats and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Also export features without category (not labeled). Otherwise only features with category are exported. Use ESRI-style .prj file format (applies to Shapefile output only) Force 2D output even if input is 3D (applies to Shapefile output only) Useful if input is 3D but all z coordinates are identical Export vector data as multi-features Create a new empty layer in defined OGR datasource and exit. Nothing is read from input. List supported output formats and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Use ESRI-style .prj file format (applies to Shapefile output only) Force 2D output even if input is 3D (applies to Shapefile output only) Useful if input is 3D but all z coordinates are identical Export vector data as multi-features Create a new empty layer in defined OGR datasource and exit. Nothing is read from input. List supported output formats and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "2", "flag": "-2", "explanation": "Force 2D output even if input is 3D (applies to Shapefile output only) Useful if input is 3D but all z coordinates are identical Export vector data as multi-features Create a new empty layer in defined OGR datasource and exit. Nothing is read from input. List supported output formats and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Export vector data as multi-features Create a new empty layer in defined OGR datasource and exit. Nothing is read from input. List supported output formats and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "n", "flag": "-n", "explanation": "Create a new empty layer in defined OGR datasource and exit. Nothing is read from input. List supported output formats and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "List supported output formats and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map to export", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Feature type(s)", "defaultValue": "auto", "alternatives": ["point", "line", "boundary", "centroid", "area", "face", "kernel", "auto"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name of output OGR datasource", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": false, "explanation": "Data format to write", "defaultValue": "ESRI_Shapefile", "alternatives": ["BNA", "CSV", "CouchDB", "DGN", "DXF", "ESRI_Shapefile", "ElasticSearch", "GFT", "GML", "GMT", "GPSBabel", "GPSTrackMaker", "GPX", "GeoJSON", "GeoRSS", "Geoconcept", "Interlis_1", "Interlis_2", "KML", "LIBKML", "MSSQLSpatial", "MapInfo_File", "Memory", "MySQL", "ODBC", "ODS", "PCIDSK", "PDF", "PGDump", "PostgreSQL", "S57", "SQLite", "TIGER", "XLSX"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output_layer", "flag": "output_layer", "dataType": "String", "optional": true, "explanation": "Name for output OGR layer. If not specified, input name is used", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "output_type", "flag": "output_type", "dataType": "String", "optional": true, "explanation": "Optionally change default output type", "defaultValue": null, "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "dsco", "flag": "dsco", "dataType": "String", "optional": true, "explanation": "OGR dataset creation option (format specific, NAME=VALUE)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lco", "flag": "lco", "dataType": "String", "optional": true, "explanation": "OGR layer creation option (format specific, NAME=VALUE)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.out.ogr  converts GRASS vector map layer to any of the\n supported  OGR  vector formats\n (including OGC GeoPackage, ESRI Shapefile, SpatiaLite or GML).\n OGR (Simple Features Library) is part of the\n  GDAL  library, so you need to\n install this library to use  v.out.ogr . \n The OGR library supports many various formats including:\n    OGC GeoPackage \n    ESRI Shapefile \n    PostGIS \n    SpatiaLite \n    CSV \n    GML \n    KML \n    Mapinfo File \n    TIGER \n    ... and many others \n The list of supported formats is printed with the  -l  flag.\n For further available other supported formats go \n  here .\n ", "notes": "\n By default, islands will appear as holes inside surrounding areas. To\n export polygons with holes into, e.g., a Esri Shapefile, and make the\n holes appear as filled areas, the flag  -c  has to be used.\n  v.out.ogr  exports 3D vector data as 2.5D simple features if\n possible (not supported by all formats). For exporting 3D vector data\n as 2D simple features, use  -2  flag.\n By default,  v.out.ogr  converts GRASS vector data to single\n simple features. If GRASS feature has more categories defined in the\n given  layer , then this feature is exported multiple\n times. GRASS features without category are skipped by default. To\n export features also without category, the  -c  flag must be\n given.\n When  -m  flag is given,  v.out.ogr  export GRASS vector\n data as multi-features. Multi-feature is formed by GRASS features with\n the same category. When  -c  flag is given, the module also\n export GRASS features without category as one multi-feature. Note that\n multi-features are not supported by all formats.\n ESRI Shapefile export: note that due to the DBF table specifications\n column names may not be longer than 10 characters.\n  EXAMPLES \n  Export to OGC GeoPackage \n Export lines from a GRASS vector map to OGC GeoPackage format:\n v.out.ogr input=roadsmajor type=line output=roadsmajor.gpkg\n Export areas from GRASS vector map to OGC GeoPackage format, converting\n islands (holes) to filled polygons:\n v.out.ogr -c input=areas_islands type=area output=areas_islands.gpkg\n Export mixed geometry type GRASS vector map to OGC GeoPackage format:\n v.out.ogr input=generic_vector output=mixed_geometry.gpkg\n  Export to ESRI Shapefile \n Export lines from GRASS vector map to Shapefile format:\n v.out.ogr input=roadsmajor type=line format=ESRI_Shapefile output=lines.shp\n Export areas from GRASS vector map to Shapefile format, converting\n islands (holes) to filled polygons:\n v.out.ogr -c input=areas_islands type=area format=ESRI_Shapefile output=areas_islands.shp\n Export 3D lines from GRASS vector map to Shapefile format:\n v.out.ogr input=lines_3d type=line format=ESRI_Shapefile output=lines_3d.shp lco=\"SHPT=ARCZ\"\n Export 3D points (e.g., Lidar points) from GRASS vector map to Shapefile format\n v.out.ogr points_3d type=point format=ESRI_Shapefile output=points_3d.shp lco=\"SHPT=POINTZ\"\n Export 3D faces from GRASS vector map to Shapefile format:\n v.out.ogr input=objects_3d type=face format=ESRI_Shapefile output=faces_3d.shp lco=\"SHPT=POLYGONZ\"\n Export 3D faces from GRASS vector map to Shapefile format, automatic 3D setting:\n v.out.ogr input=objects_3d type=face format=ESRI_Shapefile output=faces_3d.shp\"\n  Export to GML \n Export lines from GRASS vector map to GML format\n  (generates '/tmp/testogr.gml' file with layer 'testogr'):\n v.out.ogr input=multi type=line output=/tmp/testogr.gml output_layer=testogr format=GML \n  Export to PostgreSQL/PostGIS \n Export areas from GRASS vector map to PostGIS database:\n v.out.ogr input=polygons type=area output=\"PG:host=localhost dbname=postgis user=postgres\" output_layer=polymap format=PostgreSQL\n  Note:  For exporting GRASS vector data to PostGIS database can\n be also used  v.out.postgis \n module. This module is not based on OGR library and supports beside\n simple features also topological format (PostGIS Topology).\n  Export to KML (Google Earth) \n Export faces (3D vectors) from GRASS vector map to KML format for Google Earth:\n v.out.ogr input=buildings_3d output=buildings_3d.kml output_layer=buildings_3d format=KML type=face\n Generate and export GRASS vector \"asteroid\" map (faces, 3D vectors) to\n KML format for Google Earth:\n # near Raleigh (NC, USA)\n g.region n=35.73952587 s=35.73279182 w=-78.68263928 e=-78.67499517\n # two layers of random points\n v.random -z output=random3d_a n=10 zmin=0 zmax=200\n v.random -z output=random3d_b n=15 zmin=400 zmax=600\n # merge into one 3D points map\n v.patch input=random3d_a,random3d_b output=random3d\n # generate 3D convex hull\n v.hull input=random3d output=\"random3d_hull\"\n # export to KML 3D\n v.out.ogr input=random3d_hull output=random3d_hull.kml format=KML type=face dsco=\"AltitudeMode=absolute\"\n # now open KML file 'random3d_hull.kml' in Google Earth or NASA WorldWind or ...\n  REFERENCES \n  OGR vector library \n  OGR vector library C API \n   documentation \n ", "see_also": ["v.out.postgis", "db.out.ogr", "v.external", "v.external.out", "v.in.ogr", "v.pack"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.out.ogr"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.out.lidar.html", "name": "v.out.lidar", "definition": "- Exports vector points as LAS point cloud", "keywords": ["vector", "export", "LIDAR", "points"], "synopsis": "v.out.lidar [-rw] input=name  [layer=string]  output=name  [cats=range]   [where=sql_query]   [id_layer=string]   [return_layer=string]   [class_layer=string]   [rgb_layer=string]   [return_column=name]   [n_returns_column=name]   [class_column=name]   [rgb_column=name]   [red_column=name]   [green_column=name]   [blue_column=name]  las_xyscale=float las_zscale=float  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Limit export to the current region Ignore color table Ignore color table even when set and not other options are present Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Ignore color table Ignore color table even when set and not other options are present Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "id_layer", "flag": "id_layer", "dataType": "String", "optional": true, "explanation": "Layer number to store generated point ID as category", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "return_layer", "flag": "return_layer", "dataType": "String", "optional": true, "explanation": "Layer number to store return number as category", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "class_layer", "flag": "class_layer", "dataType": "String", "optional": true, "explanation": "Layer number to store class number as category", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rgb_layer", "flag": "rgb_layer", "dataType": "String", "optional": true, "explanation": "Layer number where RGB color is stored as category", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "return_column", "flag": "return_column", "dataType": "String", "optional": true, "explanation": "Column with return number", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "n_returns_column", "flag": "n_returns_column", "dataType": "String", "optional": true, "explanation": "Column with return number", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "class_column", "flag": "class_column", "dataType": "String", "optional": true, "explanation": "Column with return number", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rgb_column", "flag": "rgb_column", "dataType": "String", "optional": true, "explanation": "RGB color definition column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "red_column", "flag": "red_column", "dataType": "String", "optional": true, "explanation": "Column with red color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "green_column", "flag": "green_column", "dataType": "String", "optional": true, "explanation": "Column with green color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "blue_column", "flag": "blue_column", "dataType": "String", "optional": true, "explanation": "Column with blue color", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "las_xyscale", "flag": "las_xyscale", "dataType": "String", "optional": false, "explanation": "Internal scale to apply to X and Y values", "defaultValue": "0.01", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "las_zscale", "flag": "las_zscale", "dataType": "String", "optional": false, "explanation": "Internal scale to apply to z values", "defaultValue": "0.01", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.out.lidar  converts GRASS vector map to a LiDAR point clouds\n in LAS format using the  libLAS  library.\n The  -r  flag limits the export to the current computational region\n extent (see  g.region ).\n The  where  option limits the export by attributes (applied only\n when the columns are used for export).\n LAS format stores the coordinates as integers rounding the decimal places.\n Before that a scale is applied to preserve a certain number of decimal\n places. This scale can be set using  las_xyscale  and  las_xscale \n options. For example, the scale value 0.01 will preserve two decimal\n places while the value 1.0 will preserve none.\n ", "notes": "", "see_also": [], "authors": ["Vaclav Petras"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.out.lidar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.out.dxf.html", "name": "v.out.dxf", "definition": "- Exports vector map to DXF file format.", "keywords": ["vector", "export", "DXF"], "synopsis": "v.out.dxf input=name  [layer=string]  output=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for DXF output file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n The GRASS program  v.out.dxf  conversion program\n generates an ASCII DXF (AutoCAD) file from a GRASS vector.\n The output file is placed in the user's current\n working directory unless the user specifies a full pathname\n for the  output .\n ", "notes": "\n DXF files output by AutoCAD have the suffix  .dxf \n  REFERENCES \n  AutoCad DXF  (from Wikipedia, the free encyclopedia)\n ", "see_also": ["v.in.dxf", "Introduction to GRASS vector map processing"], "authors": ["Charles Ehlschlaeger, U.S. Army Construction Engineering Research Laboratory,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.out.dxf"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.out.ascii.html", "name": "v.out.ascii", "definition": "- Exports a vector map to a GRASS ASCII vector representation.", "keywords": ["vector", "export", "ASCII"], "synopsis": "v.out.ascii [-ocr] input=name  [layer=string]   [type=string[,string,...]]   [output=name]   [columns=name[,name,...]]   [cats=range]   [where=sql_query]  format=string  [separator=character]   [precision=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "o", "flag": "-o", "explanation": "Create old (version 4) ASCII file Include column names in output (points mode) Only export points falling within current 3D region (points mode) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Include column names in output (points mode) Only export points falling within current 3D region (points mode) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Only export points falling within current 3D region (points mode) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid,area,face,kernel", "alternatives": ["point", "line", "boundary", "centroid", "area", "face", "kernel"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output ASCII file or ASCII vector name if '-o' is defined", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Name of attribute column(s) to be exported (point mode)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "format", "flag": "format", "dataType": "String", "optional": false, "explanation": "Output format", "defaultValue": "point", "alternatives": ["point", "standard", "wkt"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "precision", "flag": "precision", "dataType": "String", "optional": true, "explanation": "Number of significant digits (floating point only)", "defaultValue": "8", "alternatives": ["0-32"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.out.ascii  converts a GRASS vector map in binary format to a\n GRASS vector map in  ASCII format . Using\n flag  -o   v.out.ascii  output will be in old (version 4)\n ASCII format.\n  If the  output  parameter is not given then the data is sent\n to standard output.\n ", "notes": "\n The  v.in.ascii  module performs\n the function of  v.out.ascii  in reverse; i.e. it converts\n vector maps in ASCII format to their binary format. These two\n companion modules are useful both for importing and exporting vector\n maps between GRASS and other software, and for transferring data\n between machines.\n  If old version is requested, the  output  files\n from  v.out.ascii  is placed in\n the  $LOCATION/$MAPSET/dig_ascii/ \n and  $LOCATION/$MAPSET/dig_att  directory.\n  If  layer > 0  then only features with a category number\n will be exported. Use  v.category  to add\n them if needed or define  layer=-1  to export also features without category.\n  v.out.ascii  in the old version mode ( -o ) does not\n copy the  dig_cats  file associated with the binary\n vector  input  map to the new  output  file name. The user\n must copy the  dig_cats  file to the new  output  name if\n this is desired (e.g. using the UNIX  cp  command).\n  It is possible to output the coordinates of vertices in a non-points vector\n feature by first converting the vector feature to a points map with \n  v.to.points  and then exporting\n with  v.out.ascii  in\n  points  mode.\n  EXAMPLES \n  Standard mode \n See  ASCII format  specification.\n v.out.ascii input=quads format=standard\n ORGANIZATION: US Army Const. Eng. Rsch. Lab\n DIGIT DATE:   May 1987\n DIGIT NAME:   grass\n MAP NAME:     Quads\n MAP DATE:     May 1987\n MAP SCALE:    24000\n OTHER INFO:\n ZONE:         13\n MAP THRESH:   18.288000\n VERTI:\n B  4\n  599587.1820962 4914067.53414294\n  589639.15126831 4913922.5687301\n  589440.96838162 4927803.62500018\n  599375.87959179 4927959.83330436\n B  2\n  599375.87959179 4927959.83330436\n  599587.1820962 4914067.53414294\n B  4\n  599587.1820962 4914067.53414294\n  609541.5508239 4914236.0597482\n  609316.10665227 4928116.8490555\n  599375.87959179 4927959.83330436\n C  1 1\n  594125.63    4921115.58\n  1     1\n C  1 1\n  604433.84    4921087.1\n  1     2\n  Point mode \n v.out.ascii input=quads format=point\n 594125.63|4921115.58|1\n 604433.84|4921087.1|2\n Print also selected attributes:\n v.out.ascii input=geodetic_pts format=point where=\"cat > 5 and cat <= 8\" columns=GEOD_NAME\n 573638.06289275|271623.25042595|6|27 WC 6\n 574416.81289275|274116.65542595|7|27 WC 7\n 575301.31189275|275303.81342595|8|27 WC 8\n To print all attributes type  columns=* :\n v.out.ascii input=geodetic_pts format=point where=\"cat > 5 and cat <= 8\" columns=*\n 573638.06289275|271623.25042595|6|6|0.00000000|0.00000000|6|6|27 WC 6|573638.09200000|271623.24100000|0.00|0|1.00000000|1.00000000\n 574416.81289275|274116.65542595|7|7|0.00000000|0.00000000|7|7|27 WC 7|574416.84100000|274116.64900000|0.00|0|1.00000000|1.00000000\n 575301.31189275|275303.81342595|8|8|0.00000000|0.00000000|8|8|27 WC 8|575301.30600000|275303.82600000|0.00|0|1.00000000|1.00000000\n  WKT mode \n WKT is abbreviation\n for  Well-known\n text .\n v.out.ascii input=quads format=wkt\n POLYGON((599587.18209620 4914067.53414294, 589639.15126831 4913922.56873010,\n          589440.96838162 4927803.62500018, 599375.87959179 4927959.83330436,\n          599587.18209620 4914067.53414294))\n POLYGON((599587.18209620 4914067.53414294, 599375.87959179 4927959.83330436,\n          609316.10665227 4928116.84905550, 609541.55082390 4914236.05974820,\n          599587.18209620 4914067.53414294))\n ", "see_also": ["v.category", "v.in.ascii", "v.to.points"], "authors": ["Michael Higgins, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.out.ascii"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.normal.html", "name": "v.normal", "definition": "- Tests for normality for vector points.", "keywords": ["vector", "statistics", "points", "point pattern"], "synopsis": "v.normal [-rl] map=name  [layer=string]  tests=range[,range,...] column=name  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Use only points in current region Lognormality instead of normality Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Lognormality instead of normality Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tests", "flag": "tests", "dataType": "String", "optional": false, "explanation": "Lists of tests (1-15)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.normal \n computes tests of normality on vector points.\n ", "notes": "\n The tests that  v.normal  performs are indexed\n below.  The tests that are performed are specified by\n giving an index, ranges of indices, or multiple thereof.\n   Sample skewness and kurtosis\n   Geary's a-statistic and an approximate normal transformation\n   Extreme normal deviates\n   D'Agostino's D-statistic \n   Modified Kuiper V-statistic \n   Modified Watson U^2-statistic \n   Durbin's Exact Test (modified Kolmogorov)\n   Modified Anderson-Darling statistic \n   Modified Cramer-Von Mises W^2-statistic \n   Kolmogorov-Smirnov D-statistic (modified for normality testing)\n   Chi-Square test statistic (equal probability classes) and \n      the number of degrees of freedom\n   Shapiro-Wilk W Test\n   Weisberg-Binghams W'' (similar to Shapiro-Francia's W')\n   Royston's extension of W for large samples\n   Kotz Separate-Families Test for Lognormality vs. Normality\n  EXAMPLE \n Compute the sample skewness and kurtosis, Geary's\n a-statistic and an approximate normal transformation,\n extreme normal deviates, and Royston's W for the\n  random  vector points:\n g.region raster=elevation -p\n v.random random n=200\n v.db.addtable random column=\"elev double precision\"\n v.what.rast random rast=elevation column=elev\n v.normal random tests=1-3,14 column=elev\n ", "see_also": ["v.univar"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.normal"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.visibility.html", "name": "v.net.visibility", "definition": "- Performs visibility graph construction.", "keywords": ["vector", "network", "shortest path", "visibility"], "synopsis": "v.net.visibility input=name output=name  [coordinates=east,north]   [visibility=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "visibility", "flag": "visibility", "dataType": "String", "optional": true, "explanation": "Name of input vector map containing visible points", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}], "description": "\n  v.net.visibility  computes the visibility graph of a vector\n map containing lines, areas (boundaries) and points. The visibility\n graph is the graph where the nodes are the end point of the lines,\n boundaries or simply points. There is an edge between two nodes if they\n are 'visible' to each other. Two nodes are visibible if there are no segments\n in between of them, i.e. the edge does not intersect any line or boundary\n in the vector map. This is useful to compute the shortest path in a\n vector map from any two points. To do this, first you need to compute\n the visibility graph and from that to compute the shortest path using\n  v.net.path \n or  d.path .\n  IMPORTANT: the algorithm doesn't work well with intersecting lines\n (that includes overlapping) \n ", "notes": "\n If you compute a shortest path after computing the visibility graph\n you will notice that this path might go through a vertex of a line. If\n this is not what you wanted you might need to process the map\n in  v.buffer , initially with a\n small value. Example:\n v.buffer input=map output=bufferedmap buffer=1 type=point,line,area,boundary\n The first argument is the input map. It supports lines, boundaries \n (so, areas) and points. For the algorithm  was written to work with lines\n and boundaries not intersecting each other (that includes overlapping).\n The resulting map containing the visibility graph is given in the output map.\n If you need to add additional points to compute a shortest path \n between them afterwards you can use the  coordinates  parameter, e.g.:\n coordinates=25556200,6686400,25556400,6686600\n where 25556200,6686400 are the coordinate of the first point and \n 25556400,6686600 are the coordinates of the second point. Of course \n you can give as many points as you need. They will be added to the \n visibility graph and edges from them will be computed. You can \n always add those points after computing the visibility graph. Simply \n use the  visibility  parameter. The input will be the original \n vector map, the vis will be the computed visibility graph and the \n output the new visibility graph which will be the vis + the new \n points given with coordinate (edges will be computed as well).\n v.net.visibility input=map visibility=vis_map output=new_vis_map \n        coordinates=25556200,6686400,25556400,6686600\n  EXAMPLES \n  Example 1 \n A simple example (North Carolina sample data) showing how to use the module:\n v.extract input=zipcodes_wake output=areas_7_11_25 cats=7,11,25\n g.region vector=zipcodes_wake\n d.mon wx0\n d.vect areas_7_11_25\n v.net.visibility input=areas_7_11_25 output=graph\n d.vect graph\n d.vect areas_7_11_25 color=red type=boundary\n  Example 2 \n An example on how to use  v.buffer \n along with the module:\n v.buffer input=lines output=buffered_lines buffer=1\n v.net.visibility input=buffered_lines output=graph\n d.vect graph\n d.vect lines col=red\n  Example 3 \n An example on how to use the coordinate parameter. This will compute the\n visibility graph of the vector map lines with the point 2555678,6686343:\n v.net.visibility input=lines output=graph coordinates=2555678,6686343\n d.vect graph\n d.vect lines col=red\n  Example 4 \n An example (North Carolina sample data) on how to use the coordinate\n parameter with the vis parameter.\n Here the vector map graph is computed then a new visibility graph is computed\n from it with the point 669547.97,208348.20 extra:\n v.extract input=zipcodes_wake output=areas_7_11_25 cats=7,11,25\n g.region vector=zipcodes_wake\n d.mon wx0\n d.vect areas_7_11_25\n v.net.visibility input=areas_7_11_25 output=graph\n v.net.visibility input=areas_7_11_25 visibility=graph output=new_graph \n        coordinates=669547.97,208348.20\n d.erase\n d.vect areas_7_11_25\n echo \"symbol basic/star 20 669547.97 208348.20 black red\" | d.graph -m\n d.vect new_graph\n d.vect areas_7_11_25 color=red type=boundary\n  Example 5 \n An example for connections of points (Spearfish):\n v.net.visibility input=archsites output=graph\n g.region vector=archsites\n d.mon wx0\n d.vect graph\n d.vect archsites col=red\n  Example 6 \n Here is an example with artificial data.\n Load data using here document syntax (Bash and unix-like commands lines only):\n v.in.ascii input=- output=simple format=standard <<EOF\n VERTI:\n B  6\n  82.19908257  75.21788991\n  81.67889908  71.40321101\n  83.58623853  71.72522936\n  84.3293578   75.21788991\n  82.24862385  76.06009174\n  82.19908257  75.21788991\n C  1 1\n  82.88897401  73.66318782\n  1     1\n C  1 1\n  90.72645705  75.61248675\n  1     2\n C  1 1\n  89.37944702  69.51012912\n  1     3\n C  1 1\n  81.60108979  67.78669725\n  1     4\n B  5\n  89.92752294  73.95458716\n  92.37981651  75.11880734\n  91.56238532  77.29862385\n  88.96146789  75.88669725\n  89.92752294  73.95458716\n B  10\n  88.54036697  70.70963303\n  87.92192518  70.04087417\n  87.89633028  69.00045872\n  88.66460807  68.13372867\n  90.15108904  68.23290821\n  90.9426344   68.97588202\n  90.86880734  70.11513761\n  90.00144697  70.78336312\n  89.06055046  70.95733945\n  88.54036697  70.70963303\n B  9\n  78.73119266  71.35366972\n  80.76238532  68.90137615\n  84.20550459  66.91972477\n  89.87798165  65.35917431\n  83.23494031  66.27685175\n  80.34278748  68.00837238\n  78.38484005  71.40292009\n  78.40917431  72.27018349\n  78.73119266  71.35366972\n EOF\n Compute the graph:\n v.net.visibility input=simple output=graph\n  KNOWN ISSUES \n In some cases when 3 points or nodes are collinear, some wrong edges \n are added. This happens only really rarly and shouldn't be a big \n problem. When two points have the exact same x coordinate and are \n visible, some wrong edges are added.\n ", "see_also": ["d.path", "v.net", "v.net.alloc", "v.net.iso", "v.net.salesman", "v.net.steiner", "v.to.db"], "authors": ["Maximilian Maldacker"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.visibility"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.timetable.html", "name": "v.net.timetable", "definition": "- Finds shortest path using timetables.", "keywords": ["vector", "network", "shortest path"], "synopsis": "v.net.timetable input=name  [layer=string]  output=name  [arc_layer=string]   [node_layer=string]   [arc_column=string]   [arc_backward_column=string]   [node_column=string]   [walk_layer=string]  route_id=name stop_time=name to_stop=name walk_length=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "walk_layer", "flag": "walk_layer", "dataType": "String", "optional": true, "explanation": "Layer number or name with walking connections or -1", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "route_id", "flag": "route_id", "dataType": "String", "optional": false, "explanation": "Name of column with route ids", "defaultValue": "route_id", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stop_time", "flag": "stop_time", "dataType": "String", "optional": false, "explanation": "Name of column with stop timestamps", "defaultValue": "stop_time", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "to_stop", "flag": "to_stop", "dataType": "String", "optional": false, "explanation": "Name of column with stop ids", "defaultValue": "to_stop", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "walk_length", "flag": "walk_length", "dataType": "String", "optional": false, "explanation": "Name of column with walk lengths", "defaultValue": "length", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.timetable  finds the shortest path between two points \n using timetables.  v.net.timetable  reads input, one query per line,\n from the standard input and writes output to the standard output as well as \n to the  output  map and to tables linked to layers 1 and 2. \n Each line of input must follow one of the following formats:\n PATH_ID FROM_X FROM_Y TO_X TO_Y START_TIME MIN_CHANGE MAX_CHANGES WALK_CHANGE\n PATH_ID FROM_STOP TO_STOP START_TIME MIN_CHANGE MAX_CHANGES WALK_CHANGE\n where PATH_ID is the identificator of a query that is used in the \n output map to differentiate between queries. Search begins at \n START_TIME. MIN_CHANGE gives the minimum number of time \n (inclusively) for a change from one route to another. MAX_CHANGES \n denotes the maximum number of changes allowed or -1 if infinity. \n WALK_CHANGE is 1 or 0 depending whether walking from a stop to \n another stop is considered a change or not. Finally, the path is \n found from FROM_STOP to TO_STOP in latter case and from the stop \n closest to (FROM_X, FROM_Y) coordinates to the stop closest to \n (TO_X, TO_Y) coordinates in former case.\n For each input query, module outputs a description of the shortest \n path to the standard output. For example, using the tables given \n below, for the following input:\n 47 130 300 0 1 5 0\n the following output is produced:\n Route 15, from 130 leaving at 15 arriving to 250 at 22\n Walk from 250 leaving at 22 arriving to 300 at 24\n Moreover, the module writes the path to the  output  map and \n stores all the information necessary to reconstruct the path to the \n tables. Table corresponding to stops/points is linked to layer 1 and \n looks, after the query, as follows:\n cat|path_id|stop_id|index|arr_time|dep_time\n 1|47|130|1|0|15\n 2|47|250|2|22|22\n 3|47|300|3|24|24\n    \n where CAT is the category of a point in the map, PATH_ID is the path \n identificator, STOP_ID is the identificator of the stop as used in \n the input map, INDEX is the index of the stop on the path (i.e, \n index=1 is the first stop visited, ...) and ARR_TIME and DEP_TIME \n denote the arrival time and departure time respectively. Arrival \n time for the first stop on the path is always equal to START_TIME \n and departure time for the last stop is always equal to the arrival \n time.\n The table linked to the second layer corresponds to subroutes taken \n between stops. The following table is obtainedd for the above query:\n cat|path_id|from_id|to_id|route_id|index|from_time|to_time\n 1|47|130|250|15|1|15|22\n 2|47|250|300|-1|2|22|24\n where CAT is the category of lines of subroute between stops FROM_ID \n to TO_ID, ROUTE_ID is the identificator of the route taken or -1 if \n walking, INDEX and PATH_ID are as above and FROM_TIME and TO_TIME \n denote the times between which the route is taken.\n The  output  map contains the points on the positions of used \n stops. If a subroute is taken between two stops then a line segment \n is added between two corresponding points. Finally, instead of \n straight line segment, the actual paths of routes can be given in  \n paths  layer. If this parameter is used then each line in the \n input map must contain identificators as category numbers of all \n routes passing through the line. The module then finds the path \n between two stops and writes this path instead. In case of walking \n from one stop to another, straight line between the stops is used.\n ", "notes": "\n Timetables are stored in a table linked to the given  layer  of \n the  input  map. Timetable consists of routes and each route is \n just a sequence of stops with specified arrival times. If two \n sequences of stops differ only in times then they still correspond \n to two routes. For example, if there is a bus line that leaves every \n 20 minutes and follow exactly the same path every time then there \n still needs to be a separate route for every time. For each stop \n (given by the category number of the point) the table storing \n information about the routes must contain the list of all routes \n stopping at the stop(given by route identificators) together with \n arrival times. That is, the table must contain three columns: stop - \n which is the key of the table,  route_id  and  stop_time  \n where each triple corresponds to a route arriving to a stop and a \n certain time. For example, a valid table might look as \n follows:\n cat|route_id|stop_time\n 100|5|0\n 130|5|10\n 150|5|20\n 250|5|30\n 300|5|40\n 260|15|5\n 130|15|15\n 250|15|22\n 150|35|17\n 250|35|27\n 300|35|37\n 100|35|50\n Note that  stop_time  is an integer and so you can use any \n units and offest to specify arrival times.  Also, walking \n connections between stops can be given by a table linked to  \n walking  layer of the  input  map. If this parameter is -1 \n then walking between stops is not allowed. The table must contain \n three columns: stop - which is the key of the table,  to_stop  \n and  length . A record in the table says that it takes  length\n   units of time to walk from stop to  to_stop . The \n following is a valid table:\n cat|length|to_stop\n 250|2|300\n Beware that this only means that it is possible to walk from stop \n 250 to stop 300 but not the other way round.\n  EXAMPLES \n To find a path from stop with identificator 130 to stop with \n category 300, starting at time 0, with one time unit for change, \n maximum of 5 changes and with walking not considered a change of \n route, we use the following command:\n echo \"47 130 300 0 1 5 0\" | v.net.timetable \n       input=buses output=path layer=5 walking=6 path=7\n If, on the other hand, we know the coordinates of the places then the \n following command might be used: \n echo \"47 10.31 54.31 90.21 28.21 0 1 5 0\" | v.net.timetable \n       input=buses output=path layer=5 walking=6 path=7\n ", "see_also": ["v.net", "v.net.path", "v.net.distance"], "authors": ["Daniel Bundala, Google Summer of Code 2009, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.timetable"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.steiner.html", "name": "v.net.steiner", "definition": "- Creates Steiner tree for the network and given terminals.", "keywords": ["vector", "network", "steiner tree"], "synopsis": "v.net.steiner [-g] input=name output=name  [arc_type=string[,string,...]]   [arc_layer=string]   [node_layer=string]   [acolumn=string]  terminal_cats=range  [npoints=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "arc_type", "flag": "arc_type", "dataType": "String", "optional": true, "explanation": "Arc type", "defaultValue": "line,boundary", "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer (used for terminals)", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "acolumn", "flag": "acolumn", "dataType": "String", "optional": true, "explanation": "Arcs' cost column (for both directions)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "terminal_cats", "flag": "terminal_cats", "dataType": "String", "optional": false, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "npoints", "flag": "npoints", "dataType": "String", "optional": true, "explanation": "Number of Steiner points (-1 for all possible)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.steiner  calculates the optimal connection of nodes on a\n vector network.\n  A Steiner tree is used to calculate the minimum-cost vector network\n connecting some number of end nodes in a network framework.\n For example it could be used to find the path following a road system\n which will minimize the amount of fibre optic cable needed to connect\n a series of satellite offices.\n  Costs may be either line lengths, or attributes saved in a database \n table. These attribute values are taken as costs of whole segments, not \n as costs to traverse a length unit (e.g. meter) of the segment. \n For example, if the speed limit is 100 km / h, the cost to traverse a \n 10 km long road segment must be calculated as \n length / speed = 10 km / (100 km/h) = 0.1 h.\n Supported are cost assignments for both arcs and nodes. \n For areas, costs will be calculated along boundary lines.\n  Points representing nodes must be exactly on network nodes, and the \n input vector map needs to be prepared with  v.net operation=connect .\n ", "notes": "\n Current implementation of obtaining Steiner tree is not memory efficient.\n An attempt to run module on a network with large number of intersections thus\n might result in failure to allocate memory or out of memory condition.\n  EXAMPLE \n Steiner tree for 6 digitized nodes (Spearfish):\n  Shortest path, along unimproved roads:\n  Fastest path, along highways:\n # Spearfish\n g.copy vect=roads,myroads\n # we have 6 locations to allocate\n echo \"1|601653.5|4922869.2|a\n 2|608284|4923776.6|b\n 3|601845|4914981.9|c\n 4|596270|4917456.3|d\n 5|593330.8|4924096.6|e\n 6|598005.5|4921439.2|f\" | v.in.ascii in=- cat=1 x=2 y=3 out=centers col=\"cat integer, \n                           east double precision, north double precision, label varchar(43)\"\n v.db.select centers\n v.category centers op=report\n # type       count        min        max\n # point          6          1          6\n # create lines map connecting points to network (on layer 2)\n v.net myroads points=centers out=myroads_net op=connect thresh=500\n # set up costs as traveling time\n # create unique categories for each road in layer 3\n v.category in=myroads_net out=myroads_net_time opt=add cat=1 layer=3 type=line\n # add new table for layer 3\n v.db.addtable myroads_net_time layer=3 col=\"cat integer,label varchar(43),length double precision,speed double precision,cost double precision\"\n # copy road type to layer 3\n v.to.db myroads_net_time layer=3 qlayer=1 opt=query qcolumn=label columns=label\n # upload road length in miles\n v.to.db myroads_net_time layer=3 type=line option=length col=length unit=miles\n # set speed limits in miles / hour\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='interstate'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='primary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"50.0\" where=\"label='secondary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"25.0\" where=\"label='light-duty road, improved surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\" where=\"label='unimproved road'\"\n # define traveling costs as traveling time in minutes:\n v.db.update myroads_net_time layer=3 col=cost val=\"length / speed * 60\"\n # shortest path\n v.net.steiner myroads_net_time arc_layer=3 node_layer=2 terminal_cats=1-6 out=mysteiner_distance\n # fastest path\n v.net.steiner myroads_net_time arc_layer=3 node_layer=2 acol=cost terminal_cats=1-6 out=mysteiner_time\n To display the result, run for example:\n # display the results\n g.region vector=myroads_net\n # shortest path\n d.mon x0\n d.vect myroads_net\n d.vect -c centers icon=basic/triangle\n d.font Vera\n d.vect centers col=red disp=attr attrcol=label lsize=12\n d.vect mysteiner_distance col=blue width=2\n # fastest path\n d.mon x1\n d.vect myroads_net\n d.vect -c centers icon=basic/triangle\n d.font Vera\n d.vect centers col=red disp=attr attrcol=label lsize=12\n d.vect mysteiner_time col=blue width=2\n ", "see_also": ["d.path", "v.net", "v.net.alloc", "v.net.iso", "v.net.path", "v.net.salesman"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.steiner"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.spanningtree.html", "name": "v.net.spanningtree", "definition": "- Computes minimum spanning tree for the network.", "keywords": ["vector", "network", "spanning tree"], "synopsis": "v.net.spanningtree [-g] input=name output=name  [arc_layer=string]   [node_layer=string]   [arc_column=name]   [node_column=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.spanningtree  finds the minimum spanning tree in a \n network. \n ", "notes": "\n A spanning tree is a minimum cost subnetwork connecting all nodes in an \n undirected network (same forward and backward costs). If a network is \n disconnected then the module computes the minimum spanning tree for \n each (weakly) connected component. So, strictly speaking, \n  v.net.spanningtree  does not compute spanning tree but a \n spanning forest. As the name suggests, a spanning tree is a tree. That \n is, it contains no cycles and if a component has N nodes then the tree \n has N-1 edges connecting all nodes.  Accol  is used to specify the \n costs of the edges. The  output  consists of the edges in the \n spanning tree.\n  EXAMPLES \n Find cheapest set of pipelines connecting all nodes.\n v.net.spanningtree input=projected_pipelines output=spanningtree accol=cost \n ", "see_also": ["v.net", "v.net.steiner"], "authors": ["Daniel Bundala, Google Summer of Code 2009, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.spanningtree"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.salesman.html", "name": "v.net.salesman", "definition": "- Creates a cycle connecting given nodes (Traveling salesman problem).", "keywords": ["vector", "network", "salesman"], "synopsis": "v.net.salesman [-tg] input=name output=name center_cats=range arc_layer=string arc_type=string[,string,...] node_layer=string  [arc_column=string]   [arc_backward_column=string]   [turn_layer=string]   [turn_cat_layer=string]   [sequence=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Use turntable Use geodesic calculation for longitude-latitude locations Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "center_cats", "flag": "center_cats", "dataType": "String", "optional": false, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": false, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_type", "flag": "arc_type", "dataType": "String", "optional": false, "explanation": "Arc type", "defaultValue": "line,boundary", "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": false, "explanation": "Node layer (used for cities)", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "EXPERIMENTAL: Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "turn_layer", "flag": "turn_layer", "dataType": "String", "optional": true, "explanation": "Layer with turntable", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "turn_cat_layer", "flag": "turn_cat_layer", "dataType": "String", "optional": true, "explanation": "Layer with unique categories used in turntable", "defaultValue": "4", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sequence", "flag": "sequence", "dataType": "String", "optional": true, "explanation": "Name for output file holding node sequence (\"-\" for stdout)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.net.salesman  calculates the optimal route to visit nodes on a\n vector network.\n  Costs may be either line lengths, or attributes saved in a database \n table. These attribute values are taken as costs of whole segments, not \n as costs to traverse a length unit (e.g. meter) of the segment. \n For example, if the speed limit is 100 km / h, the cost to traverse a \n 10 km long road segment must be calculated as\n length / speed = 10 km / (100 km/h) = 0.1 h.\n Supported are cost assignments for arcs, \n and also different costs for both directions of a vector line. \n For areas, costs will be calculated along boundary lines.\n  The input vector needs to be prepared with  v.net operation=connect  \n in order to connect points representing center nodes to the network.\n  Points specified by category must be exactly on network nodes, and the \n input vector map needs to be prepared with  v.net operation=connect .\n  Application of flag  -t  enables a turntable support. \n This flag requires additional parameters  turn_layer  and  turn_cat_layer  \n that are otherwise ignored.\n  The turntable allows \n to model e.g. traffic code, where some turns may be prohibited. \n This means that the input layer is expanded by \n turntable with costs of every possible turn on any possible node \n (intersection) in both directions. \n  Turntable can be created by \n  the  v.net  module. \n For more information about turns in the vector network analyses see\n  wiki page .\n ", "notes": "\n Arcs can be closed using cost = -1. \n Turns support: The costs of turns on visiting nodes are not taken in account.\n  EXAMPLE \n Traveling salesman for 6 digitized nodes (Spearfish):\n  Shortest path, along unimproved roads:\n  Fastest path, along highways:\n  Searching for the shortest path using distance and the fastest path using \n traveling time according to the speed limits of different road types:\n # Spearfish\n g.copy vect=roads,myroads\n # we have 6 locations to visit on our trip\n echo \"1|601653.5|4922869.2|a\n 2|608284|4923776.6|b\n 3|601845|4914981.9|c\n 4|596270|4917456.3|d\n 5|593330.8|4924096.6|e\n 6|598005.5|4921439.2|f\" | v.in.ascii in=- cat=1 x=2 y=3 out=centers col=\"cat integer, \n                           east double precision, north double precision, label varchar(43)\"\n # verify data preparation\n v.db.select centers\n v.category centers op=report\n # type       count        min        max\n # point          6          1          6\n # create lines map connecting points to network (on layer 2)\n v.net myroads points=centers out=myroads_net op=connect thresh=500\n v.category myroads_net op=report\n # Layer / table: 1 / myroads_net\n # type       count        min        max\n # line         837          1          5\n #\n # Layer: 2\n # type       count        min        max\n # point          6          1          5\n # find the shortest path\n v.net.salesman myroads_net center_cats=1-6 out=mysalesman_distance\n # set up costs as traveling time\n # create unique categories for each road in layer 3\n v.category in=myroads_net out=myroads_net_time opt=add cat=1 layer=3 type=line\n # add new table for layer 3\n v.db.addtable myroads_net_time layer=3 col=\"cat integer,label varchar(43),length double precision,speed double precision,cost double precision,bcost double precision\"\n # copy road type to layer 3\n v.to.db myroads_net_time layer=3 qlayer=1 opt=query qcolumn=label columns=label\n # upload road length in miles\n v.to.db myroads_net_time layer=3 type=line option=length col=length unit=miles\n # set speed limits in miles / hour\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='interstate'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='primary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"50.0\" where=\"label='secondary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"25.0\" where=\"label='light-duty road, improved surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\" where=\"label='unimproved road'\"\n # define traveling costs as traveling time in minutes:\n # set forward costs\n v.db.update myroads_net_time layer=3 col=cost val=\"length / speed * 60\"\n # set backward costs\n v.db.update myroads_net_time layer=3 col=bcost val=\"length / speed * 60\"\n # find the fastest path\n v.net.salesman myroads_net_time arc_layer=3 node_layer=2 arc_column=cost arc_backward_column=bcost center_cats=1-6 out=mysalesman_time\n To display the result, run for example:\n # Display the results\n g.region vector=myroads_net\n # shortest path\n d.mon x0\n d.vect myroads_net\n d.vect centers -c icon=basic/triangle\n d.vect mysalesman_distance col=green width=2\n d.font Vera\n d.vect centers col=red disp=attr attrcol=label lsize=12\n # fastest path\n d.mon x1\n d.vect myroads_net\n d.vect centers -c icon=basic/triangle\n d.vect mysalesman_time col=green width=2\n d.font Vera\n d.vect centers col=red disp=attr attrcol=label lsize=12\n ", "see_also": ["d.path", "v.net", "v.net.alloc", "v.net.iso", "v.net.path", "v.net.steiner"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.salesman"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.path.html", "name": "v.net.path", "definition": "- Finds shortest path on vector network.", "keywords": ["vector", "network", "shortest path"], "synopsis": "v.net.path [-tgs] input=name output=name arc_layer=string arc_type=string[,string,...] node_layer=string  [file=name]   [arc_column=string]   [arc_backward_column=string]   [node_column=string]   [dmax=float]   [turn_layer=string]   [turn_cat_layer=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Use turntable Use geodesic calculation for longitude-latitude locations Write output as original input segments, not each path as one line. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Write output as original input segments, not each path as one line. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Write output as original input segments, not each path as one line. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": false, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_type", "flag": "arc_type", "dataType": "String", "optional": false, "explanation": "Arc type", "defaultValue": "line,boundary", "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": false, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Name of file containing start and end points. If not given, read from stdin", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dmax", "flag": "dmax", "dataType": "String", "optional": true, "explanation": "Maximum distance to the network", "defaultValue": "1000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "turn_layer", "flag": "turn_layer", "dataType": "String", "optional": true, "explanation": "Layer with turntable", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "turn_cat_layer", "flag": "turn_cat_layer", "dataType": "String", "optional": true, "explanation": "Layer with unique categories used in turntable", "defaultValue": "4", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.path  determines least costly, e.g. shortest or fastest \n path(s) on a vector network.\n Costs may be either line lengths, or attributes saved in a database \n table. These attribute values are taken as costs of whole segments, not \n as costs to traverse a length unit (e.g. meter) of the segment. \n For example, if the speed limit is 100 km / h, the cost to traverse a \n 10 km long road segment must be calculated as \n length / speed = 10 km / (100 km/h) = 0.1 h.\n Supported are cost assignments for both arcs and nodes, \n and also different costs for both directions of a vector line. \n For areas, costs will be calculated along boundary lines.\n The input vector needs to be prepared with  v.net operation=connect  \n in order to connect points representing center nodes to the network.\n  Nodes and arcs can be closed using  cost = -1 . \n  Least cost paths are written to the output vector map with an \n attached attribute table.\n  Nodes can be\n   piped into the program from file or from stdin, or\n   defined in the graphical user interface (\"enter values interactively\").\n The syntax is as follows:\n id start_point_category end_point_category\n (Example: 1 1 2)\n or\n id start_point_x start_point_y end_point_x end_point_y\n Points specified by category must be exactly on network nodes, and the \n input vector map needs to be prepared with  v.net operation=connect .\n When specifying coordinates, the next network node to a given coordinate \n pair is used.\n The attribute table will contain the following attributes:\n      cat   - path unique category assigned by module \n      id    - path id (read from input) \n      fcat  - from point category \n      tcat  - to point category \n      sp  - result status:\n      \n               0 - OK, path found \n               1 - node is not reachable \n               2 - point of given category does not exist \n      \n      cost  - travelling costs (on the network, not to/from network) \n      fdist  - the distance from first point to the network \n      tdist  - the distance from the network to second point \n Application of flag  -t  enables a turntable support. \n This flag requires additional parameters  turn_layer  and  turn_cat_layer  \n that are otherwise ignored.\n  The turntable allows \n to model e.g. traffic code, where some turns may be prohibited. \n This means that the input layer is expanded by \n turntable with costs of every possible turn on any possible node \n (intersection) in both directions. \n  Turntable can be created by \n  the  v.net  module. \n For more information about turns in the vector network analyses see\n  wiki page .\n ", "notes": "\n Nodes and arcs can be closed using  cost = -1 . \n  If the cost columns  arc_column ,  arc_backward_column  and  node_column  are not\n specified, the length of network segments is measured and \n zero costs are assumed for nodes.\n  When using attributes, the length of segments is not used. To get\n accurate results, the line length must be taken into account when \n assigning costs as attributes. For example, to get the  fastest path , \n the columns 'max_speed' and 'length' are required. The correct fastest \n path can then be found by specifying  arc_column=length/max_speed . If not yet\n existing, the column containing the line length (\"length\") has to added to the\n attributes table using  v.to.db .\n  EXAMPLE \n Shortest (red) and fastest (blue) path between two digitized nodes (Spearfish):\n # Spearfish\n echo \"1|601955.1|4916944.9|start\n 2|594385.6|4921565.2|end\" | v.in.ascii in=- cat=1 x=2 y=3 out=startend col=\"cat integer, \n                           east double precision, north double precision, label varchar(6)\"\n v.db.select startend\n g.copy vect=roads,myroads\n # create lines map connecting points to network\n v.net myroads points=startend out=myroads_net op=connect thresh=500 arc_layer=1 node_layer=2\n # set up costs\n # create unique categories for each road in layer 3\n v.category in=myroads_net out=myroads_net_time opt=add cat=1 layer=3 type=line\n # add new table for layer 3\n v.db.addtable myroads_net_time layer=3 col=\"cat integer,label varchar(43),length double precision,speed double precision,cost double precision,bcost double precision\"\n # copy road type to layer 3\n v.to.db myroads_net_time layer=3 qlayer=1 opt=query qcolumn=label columns=label\n # upload road length in miles\n v.to.db myroads_net_time layer=3 type=line option=length col=length unit=miles\n # set speed limits in miles / hour\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='interstate'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='primary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"50.0\" where=\"label='secondary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"25.0\" where=\"label='light-duty road, improved surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\" where=\"label='unimproved road'\"\n # define traveling costs as traveling time in minutes:\n # set forward costs\n v.db.update myroads_net_time layer=3 col=cost val=\"length / speed * 60\"\n # set backward costs\n v.db.update myroads_net_time layer=3 col=bcost val=\"length / speed * 60\"\n # ... the 'start' and 'end' nodes have category number 1 and 2\n # Shortest path: ID as first number, then cat1 and cat2\n echo \"1 1 2\" | v.net.path myroads_net_time arc_layer=3 node_layer=2 out=mypath\n # Fastest path: ID as first number, then cat1 and cat2\n echo \"1 1 2\" | v.net.path myroads_net_time arc_layer=3 node_layer=2 arc_column=cost arc_backward_column=bcost out=mypath_time\n To display the result, run for example:\n g.region vector=myroads_net\n d.mon x0\n d.vect myroads_net\n # show shortest path\n d.vect mypath col=red width=2\n # show fastest path\n d.vect mypath_time col=blue width=2\n # start and end point\n d.vect myroads_net icon=basic/triangle fcol=green size=12 layer=2\n d.font font=Vera\n d.vect startend disp=cat type=point lsize=14 layer=2\n ", "see_also": ["d.path", "v.net", "v.net.alloc", "v.net.iso", "v.net.salesman", "v.net.steiner", "v.to.db"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.path"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.iso.html", "name": "v.net.iso", "definition": "- Splits subnets for nearest centers by cost isolines.", "keywords": ["vector", "network", "cost allocation", "isolines"], "synopsis": "v.net.iso [-tgu] input=name output=name  [method=string]  center_cats=range costs=integer[,integer,...] arc_layer=string arc_type=string[,string,...] node_layer=string  [arc_column=name]   [arc_backward_column=name]   [node_column=name]   [turn_layer=string]   [turn_cat_layer=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Use turntable Use geodesic calculation for longitude-latitude locations Create unique categories and attribute table Default: one category for each iso-band Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Create unique categories and attribute table Default: one category for each iso-band Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "u", "flag": "-u", "explanation": "Create unique categories and attribute table Default: one category for each iso-band Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Use costs from centers or costs to centers", "defaultValue": "from", "alternatives": ["from", "to"], "isInputFile": false, "isOutputFile": false}, {"parameter": "center_cats", "flag": "center_cats", "dataType": "String", "optional": false, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "costs", "flag": "costs", "dataType": "String", "optional": false, "explanation": "Costs for isolines", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": false, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_type", "flag": "arc_type", "dataType": "String", "optional": false, "explanation": "Arc type", "defaultValue": "line,boundary", "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": false, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "turn_layer", "flag": "turn_layer", "dataType": "String", "optional": true, "explanation": "Layer with turntable", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "turn_cat_layer", "flag": "turn_cat_layer", "dataType": "String", "optional": true, "explanation": "Layer with unique categories used in turntable", "defaultValue": "4", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.iso  splits a network into bands between cost isolines \n (distance from center). Center nodes must be opened (costs >= 0). The \n costs of center nodes are used in the calculation. \n  Costs may be either line lengths, or attributes saved in a database \n table. These attribute values are taken as costs of whole segments, not \n as costs to traverse a length unit (e.g. meter) of the segment. \n For example, if the speed limit is 100 km / h, the cost to traverse a \n 10 km long road segment must be calculated as \n length / speed = 10 km / (100 km/h) = 0.1 h.\n Supported are cost assignments for both arcs and nodes, \n and also different costs for both directions of a vector line. \n For areas, costs will be calculated along boundary lines.\n The input vector needs to be prepared with  v.net operation=connect  \n in order to connect points representing center nodes to the network.\n The nearest center can be determined using either costs from the \n nearest center or costs to the nearest center with option \n  method . \n By default, the iso band number is used as category value for output \n lines. With the  -u  flag, output lines become unique categories \n and an attribute table is created with the fields  cat, ocat, \n center, isonr, isolbl . The  ocat  field holds the original \n line category in  arc_layer , the  center  field holds the \n center category in  node_layer , the  isonr  field holds \n the iso band number and the  isolbl  field holds a label for the \n isoband. Additionally, original line categories are copied from the \n input  arc_layer  to layer 2 in the output, together with any \n attribute table.\n Application of flag  -t  enables a turntable support. This flag \n requires additional parameters  turn_layer  and \n  turn_cat_layer  that are otherwise ignored. The turntable allows \n to model e.g. traffic code, where some turns may be prohibited. This \n means that the input layer is expanded by turntable with costs of every \n possible turn on any possible node (intersection) in both directions. \n Turntable can be created by the  v.net  \n module. For more information about turns in the vector network analyses \n see\n  wiki page .\n ", "notes": "\n Nodes and arcs can be closed using cost = -1. \n Nodes must be on the isolines.\n  EXAMPLES \n The map must contain at least one center (point) on the vector network \n which can be patched into with  v.net .\n Isonetwork using distance:\n Isonetwork using time:\n  Subdivision of a network using distance: \n # Spearfish\n # start node:\n echo \"591280.5|4926396.0|1\" | v.in.ascii in=- out=startnode\n g.copy vect=roads,myroads\n # connect point to network\n v.net myroads points=startnode out=myroads_net op=connect thresh=200\n # define iso networks using distance:\n v.net.iso input=myroads_net output=myroads_net_iso center_cats=1-100000 costs=1000,2000,5000\n The network is divided into 4 categories:\n v.category myroads_net_iso option=report\n # ... reports 4 categories:\n #cat | distance from point in meters\n #1          0 - < 1000\n #2       1000 - < 2000\n #3       2000 - < 5000\n #4             >= 5000\n To display the result, run for example:\n g.region n=4928200 s=4922300 w=589200 e=596500\n d.mon x0\n d.vect myroads_net_iso col=blue   cats=1\n d.vect myroads_net_iso col=green  cats=2\n d.vect myroads_net_iso col=orange cats=3\n d.vect myroads_net_iso col=magenta  cats=4\n d.vect myroads_net col=red icon=basic/triangle fcol=green size=12 layer=2\n  Subdivision of a network using traveling time: \n Prepare the network as above:\n # Spearfish\n # start node:\n echo \"591280.5|4926396.0|1\" | v.in.ascii in=- out=startnode\n g.copy vect=roads,myroads\n # connect point to network\n v.net myroads points=startnode out=myroads_net op=connect thresh=200\n Define costs as traveling time dependent on speed limits:\n # set up costs\n # create unique categories for each road in layer 3\n v.category in=myroads_net out=myroads_net_time opt=add cat=1 layer=3 type=line\n # add new table for layer 3\n v.db.addtable myroads_net_time layer=3 col=\"cat integer,label varchar(43),length double precision,speed double precision,cost double precision,bcost double precision\"\n # copy road type to layer 3\n v.to.db myroads_net_time layer=3 qlayer=1 opt=query qcolumn=label columns=label\n # upload road length in miles\n v.to.db myroads_net_time layer=3 type=line option=length col=length unit=miles\n # set speed limits in miles / hour\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='interstate'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='primary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"50.0\" where=\"label='secondary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"25.0\" where=\"label='light-duty road, improved surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\" where=\"label='unimproved road'\"\n # define traveling costs as traveling time in minutes:\n # set forward costs\n v.db.update myroads_net_time layer=3 col=cost val=\"length / speed * 60\"\n # set backward costs\n v.db.update myroads_net_time layer=3 col=bcost val=\"length / speed * 60\"\n # define iso networks using traveling time:\n v.net.iso input=myroads_net_time output=myroads_net_iso_time arc_layer=3 node_layer=2 arc_column=cost arc_backward_column=bcost center_cats=1-100000 costs=1,2,5\n To display the result, run for example:\n # add table with labels and coloring\n v.db.addtable myroads_net_iso_time columns=\"cat integer,trav_time varchar(20),GRASSRGB varchar(11)\"\n # labels\n v.db.update map=myroads_net_iso_time layer=1 column=trav_time value=\"0 - 1\" where=\"cat = 1\"\n v.db.update map=myroads_net_iso_time layer=1 column=trav_time value=\"1 - 2\" where=\"cat = 2\"\n v.db.update map=myroads_net_iso_time layer=1 column=trav_time value=\"2 - 5\" where=\"cat = 3\"\n v.db.update map=myroads_net_iso_time layer=1 column=trav_time value=\"> 5\" where=\"cat = 4\"\n # colors\n # cats=1: blue\n v.db.update map=myroads_net_iso_time layer=1 column=GRASSRGB value=\"000:000:255\" where=\"cat = 1\"\n # cats=2: green\n v.db.update map=myroads_net_iso_time layer=1 column=GRASSRGB value=\"000:255:000\" where=\"cat = 2\"\n # cats=3: orange\n v.db.update map=myroads_net_iso_time layer=1 column=GRASSRGB value=\"255:128:000\" where=\"cat = 3\"\n # cats=4: magenta\n v.db.update map=myroads_net_iso_time layer=1 column=GRASSRGB value=\"255:000:255\" where=\"cat = 4\"\n # show results\n g.region n=4928200 s=4922300 w=589200 e=596500\n d.mon x0\n d.vect myroads_net_iso_time layer=1 -a rgb_col=GRASSRGB\n d.vect myroads_net col=red icon=basic/triangle fcol=green size=12 layer=2\n ", "see_also": ["d.path", "v.net", "v.net.alloc", "v.net.path", "v.net.salesman", "v.net.steiner", "v.patch"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.iso"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.html", "name": "v.net", "definition": "- Performs network maintenance.", "keywords": ["vector", "network", "network maintenance"], "synopsis": "v.net [-cs]  [input=name]   [points=name]   [output=name]  operation=string  [arc_layer=string]   [arc_type=string[,string,...]]   [node_layer=string]   [threshold=float]   [file=name]   [turn_layer=string]   [turn_cat_layer=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Assign unique categories to new points For operation 'nodes' Snap points to network For operation 'connect'. By default, a new line from the point to the network is created. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Snap points to network For operation 'connect'. By default, a new line from the point to the network is created. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input vector line map (arcs)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "points", "flag": "points", "dataType": "String", "optional": true, "explanation": "Name of input vector point map (nodes)", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "operation", "flag": "operation", "dataType": "String", "optional": false, "explanation": "Operation to be performed", "defaultValue": null, "alternatives": ["nodes", "connect", "arcs", "report", "nreport", "turntable"], "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_type", "flag": "arc_type", "dataType": "String", "optional": true, "explanation": "Arc type", "defaultValue": "line,boundary", "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Threshold", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Name of input file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "turn_layer", "flag": "turn_layer", "dataType": "String", "optional": true, "explanation": "Turntable layer", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "turn_cat_layer", "flag": "turn_cat_layer", "dataType": "String", "optional": true, "explanation": "Layer with unique categories used in turntable", "defaultValue": "4", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net  is used for network preparation and maintenance. Its \n main use is to create a vector network from vector lines ( arcs\n  ) and points ( nodes ) by creating nodes from \n intersections in a map of vector lines ( node  operator), by \n connecting a vector lines map with a points map ( connect  \n operator), and by creating new lines between pairs of vector points\n ( arcs  operator).\n A GIS network consists of topologically correct lines (arcs). That is, \n the lines must be connected by shared vertices where real connections exist.\n In GRASS GIS you also can add nodes to the network. These are specially \n designated vertices used for analyzing network properties or computing \n cost/distance measures. That is,  not all vertices are treated as nodes by\n default . Only  v.net.path  can use a \n network without nodes, they are required  for all the other network modules.\n In GRASS, network arcs are stored in one data layer (normally layer 1) and\n nodes are stored in a different data layer (normally layer 2). \n  v.net  offers two ways to add nodes to a network of arcs and one \n method to add arcs to a set of nodes:\n  Use the  connect  operation to create nodes from a vector \n points file and add these nodes to an existing vector network of \n arcs (i.e., lines/boundaries). This is useful when the goal is to \n analyze a set of places (points) in relation to a network--for \n example travel costs between places. Only points within the\n  thresh  (threshold) distance to a line/boundary will be \n connected as network nodes. There are two ways to connect nodes. By \n default,  v.net  will create new lines connecting each point \n to the closest line of the network. If you use the  -s  flag, \n however, the new nodes will be added on the closest line of the \n network at the point closest to the point you wish to add. When using \n the  connect  operation, some lines will share the same \n category. In order to assign unique costs to each line, a new layer \n needs to be created with \n  v.category map=yourmap option=add cat=1 step=1 layer=3 output=newmap \n followed by \n  v.db.addtable map=newmap layer=3 table=tablename . \n  Create nodes and arcs from a vector line/boundary file using the \n  node  operation. This is useful if you are mostly interested \n in the network itself and thus you can use intersections of the \n network as start and end points. Nodes will be created at all \n intersections of two or more lines. For an  arc  that \n consists of several segments connected by vertices (the typical \n case), only the starting and ending vertices are treated as network \n nodes. \n  Create straight-line arcs between pairs of nodes with the\n  arcs  option. This produces networks like those of airline \n flights between airports. It is also similar to the kind of network \n created with social networking software, making it possible to \n create georeferenced social networks.  \n      \n     \n While the arcs created with v.net will retain any attribute information\n associated with the input vector line/boundary file in data layer 1, nodes\n created and stored in data layer 2 will not have any associated attribute\n information. \n For nodes created using the  connect  and  arcs  \n operations (methods 1 and 3 above), the nodes can be reconnected to \n the attribute table of the input vector points file using the \n attribute table manager (\"manage layers\" tab) or by running\n  v.db.connect .\n For nodes created using the  nodes  operation (method 2 \n above), it is possible to create an attribute table for the new \n nodes in layer 2 using the attribute table manager and connect it to \n layer 2 (\"manage layers\" tab) or to create a table with\n  v.db.addtable , \n connect it to layer 2 with  v.db.connect ,\n and update the new table with cat values with  v.to.db . \n The  turntable  operation creates a turntable  \n with the costs for every possible \n turn on every possible node (intersection, crossroad) in given layer (arc_layer). \n U-turns are taken in account too.\n Turntable is created in  turn_layer  and  turn_cat_layer .\n Building the turntable allows you to model e.g. traffic code, where some turns \n may be prohibited.\n If features in analyzed network are changed, the turntable must be created again\n (e.g. it includes v.net connect operation).\n Turntable name consists of output vector map name + \"_turntable_\" + \"t\" + \"_\" + turn_layer +\n  \"_\" + \"tuc\" + \"_\" + turn_cat_layer + \"_\" + \"a\" + \"_\" + arc_layer  e. g. roads_turntable_t_3_tuc_4_a_1\n  These modules are able to work with the turntable: \n  v.net.alloc ,\n  v.net.iso ,\n  v.net.path ,\n  v.net.salesman \n For more information about turns in the vector network analyses see \n  wiki page .\n Once a vector network has been created, it can be analyzed in a \n number of powerful ways using the suite of  v.net .* modules. \n The shortest route between two nodes, following arcs, can be computed\n ( v.net.path ), as can the \n shortest route that will pass through a set of nodes and return to the \n starting node ( v.net.salesman ).\n Least cost routes through the network can be calculated on the basis of\n distance only or on the basis of distance weighted by an attribute\n associated with each arc (for example, travel speed along a network segment).\n A network can be divided into concentric zones of equal travel cost around \n one or more nodes ( v.net.iso ) or\n subdivided so that each node is surrounded by a zone in which all arcs\n can be reached with the same travel costs as all arcs surrounding each\n other node ( v.net.alloc ).\n In addition to the modules listed above, the GRASS vector networking suite\n includes numerous other modules for analysis of network costs and \n connectivity. These include: \n  v.net.allpairs , \n  v.net.bridge , \n  v.net.centrality , \n  v.net.components , \n  v.net.distance , \n  v.net.flow , \n  v.net.spanningtree , \n  v.net.steiner , \n  v.net.timetable , and \n  v.net.visibility .\n     \n ", "notes": "\n For a vector map prepared for network analysis in GRASS, nodes are \n represented by the grass-internal geometry type  node  and arcs \n by the geometry type  line . \n If vector editing is required to modify the\n graph,  g.gui.vdigit \n or  v.edit  can be used.  See also\n the  Linear Referencing System  available in\n GRASS GIS.\n  EXAMPLES \n The examples are  North Carolina dataset  based.\n  Create nodes globally for all line ends and intersections \n v.net input=streets_wake output=streets_node operation=nodes\n # verify result\n v.category streets_node option=report\n  Merge in nodes from a separate map within given threshold \n v.net input=streets_wake points=firestations out=streets_net \n        operation=connect threshold=500\n # verify result\n v.category streets_net option=report\n The nodes are stored in layer 2 unless  node_layer=1  is used.\n  Generating network for vector point map \n For generating network for given vector point map an input file in the\n following format is required:\n [category of edge] [category of start node] [category of end node]\n Option 1: Save the file (e.g. \"points.txt\") and generate the map:\n v.net points=geodetic_swwake_pts output=geodetic_swwake_pts_net \n        operation=arcs file=points.txt\n # verify result\n v.category geodetic_swwake_pts_net option=report\n Option 2: Read in from command line:\n v.net points=geodetic_swwake_pts output=geodetic_swwake_pts_net \n        operation=arcs file=- << EOF\n 1 28000 28005\n 2 27945 27958\n 3 27886 27897\n EOF\n # verify result\n v.category geodetic_swwake_pts_net option=report\n  Generating network with turntable for vector point map \n Following example generates a vector map with turntable:\n v.net operation=turntable in=railroads out=railroads_ttb\n ", "see_also": ["g.gui.vdigit", "v.edit"], "authors": ["Radim Blazek, ITC-irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.flow.html", "name": "v.net.flow", "definition": "- Computes the maximum flow between two sets of nodes in the network.", "keywords": ["vector", "network", "flow"], "synopsis": "v.net.flow input=name  [arc_layer=string]   [node_layer=string]  output=name cut=name  [arc_column=name]   [arc_backward_column=name]   [node_column=name]   [source_cats=range]   [source_where=sql_query]   [sink_cats=range]   [sink_where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "cut", "flag": "cut", "dataType": "String", "optional": false, "explanation": "Name for output vector map containing a minimum cut", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "source_cats", "flag": "source_cats", "dataType": "String", "optional": true, "explanation": "Source category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "source_where", "flag": "source_where", "dataType": "String", "optional": true, "explanation": "Source WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sink_cats", "flag": "sink_cats", "dataType": "String", "optional": true, "explanation": "Sink category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sink_where", "flag": "sink_where", "dataType": "String", "optional": true, "explanation": "Sink WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.flow  computes the maximum flow and minimum cut \n between two sets of nodes.\n ", "notes": "\n The two sets of nodes are called  sources  and  sink  \n and  v.net.flow  finds the maximum flow from the former to \n the latter ones. Edge capacities can be specified by  arc_column  \n for forward direction and  arc_backward_column  for backward direction. If \n the latter parameter is omitted then the same capacity is used in \n either direction. The sets are given by the respective  cats , \n  layer  and  where  parameters. Maximum flow corresponds \n to the maximum amount of water possibly flowing through the network \n preserving the capacity constraints and minimum cut to the set of edges \n of minimum total capacity completely separating sources from sinks. \n The cut produced by this module corresponds to the first fully \n saturated edges from sources to sinks. An attribute table containing \n the flow information is linked to the  output  map. The table \n consists of two columns:  cat  and  flow  and stores \n the flow along each line. Negative flow means that \"water\" is \n flowing in the backward direction.  Cut  map contains the edges \n in the minimum cut.\n A famous  result  \n says that the total amount of water flowing is equal to the minimum \n cut.\n  EXAMPLES \n Find maximum flow from factories to stores using SPEED for the capacities.\n v.net.flow input=roads output=roads_flow cut=roads_cut arc_column=SPEED \n             source_where=\"type=factory\" sink_where=\"type=store\"\n If all the capacties are one then the minimum cut corresponds to the \n minimum number of edges separating sources from sinks. \n v.net.flow input=network output=flow cut=cut arc_column=ones \n             source_cats=1-10 sink_cats=100-100\n ", "see_also": ["v.net", "v.net.connectivity"], "authors": ["Daniel Bundala, Google Summer of Code 2009, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.flow"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.distance.html", "name": "v.net.distance", "definition": "- Computes shortest distance via the network between the given sets of features.", "keywords": ["vector", "network", "shortest path"], "synopsis": "v.net.distance [-gl] input=name output=name  [arc_layer=string]   [arc_type=string[,string,...]]   [node_layer=string]   [from_layer=string]   [from_cats=range]   [from_where=sql_query]   [to_layer=string]   [to_type=string[,string,...]]   [to_cats=range]   [to_where=sql_query]   [arc_column=name]   [arc_backward_column=name]   [node_column=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Write each output path as one line, not as original input segments. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Write each output path as one line, not as original input segments. Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_type", "flag": "arc_type", "dataType": "String", "optional": true, "explanation": "Arc type", "defaultValue": "line,boundary", "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "from_layer", "flag": "from_layer", "dataType": "String", "optional": true, "explanation": "From layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "from_cats", "flag": "from_cats", "dataType": "String", "optional": true, "explanation": "From category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "from_where", "flag": "from_where", "dataType": "String", "optional": true, "explanation": "From WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "to_layer", "flag": "to_layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "to_type", "flag": "to_type", "dataType": "String", "optional": true, "explanation": "To feature type", "defaultValue": "point", "alternatives": ["point", "line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "to_cats", "flag": "to_cats", "dataType": "String", "optional": true, "explanation": "To category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "to_where", "flag": "to_where", "dataType": "String", "optional": true, "explanation": "To WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.distance  finds the nearest element in set  to  \n for every point in set  from . \n ", "notes": "\n These two sets are given by the respective  layer ,  where \n and  cats  parameters. The type of  to  features is \n specified by  to_type  parameter. All  from  features \n are  points . A table is linked to  output  map \n containing various information about the relation. More \n specifically, the table has three columns:  cat ,  tcat \n and  dist  storing category of each  from  \n feature, category of the nearest  to  feature and the \n distance between them respectively.\n Furthemore, the  output  map contains the shortest path between \n each  cat ,  tcat  pair. Each path consists of several \n lines. If a line is on the shortest path from a point then the category \n of this point is assigned to the line. Note that every line may contain \n more than one category value since a single line may be on the shortest \n path for more than one  from  feature. And so the shortest paths \n can be easily obtained by querying lines with corresponding category \n number. Alternatively, unique paths can be created with the  -l  \n flag where each path will be a separate single line in the output.\n The costs of arcs in forward and backward direction are specified by \n  arc_column  and  arc_backward_column  columns respectively. \n If  arc_backward_column  is not given, the same cost is used in \n both directions.  \n  v.net.distance  will not work if you are trying to find the \n nearest neighbors within a group of nodes, i.e. where  to  \n and  from  are the same set of nodes, as the closest node \n will be the node itself and the result will be zero-length paths. In \n order to find nearest neighbors within a group of nodes, you can \n either loop through each node as  to  and all other nodes as \n  from  or create a complete distance matrix with\n  v.net.allpairs  and select the\n lowest non-zero distance for each node.\n  EXAMPLES \n  Shortest path and distance between school and nearest hospital \n Find shortest path and distance from every school to the nearest hospital \n and show all paths.\n Streets are grey lines, schools are green circles, hospitals are red \n crosses, shortest paths are blue lines:\n # connect schools to streets as layer 2\n v.net input=streets_wake points=schools_wake output=streets_net1 \n        operation=connect thresh=400 arc_layer=1 node_layer=2\n # connect hospitals to streets as layer 3\n v.net input=streets_net1 points=hospitals output=streets_net2 \n        operation=connect thresh=400 arc_layer=1 node_layer=3\n # inspect the result\n v.category in=streets_net2 op=report\n # shortest paths from schools (points in layer 2) to nearest hospitals (points in layer 3)\n v.net.distance in=streets_net2 out=schools_to_hospitals flayer=2 to_layer=3\n # visualization\n g.region vector=streets_wake\n d.mon wx0\n d.vect streets_wake color=220:220:220\n d.vect schools_wake color=green size=10\n d.vect map=hospitals icon=basic/cross3 size=15 color=black fcolor=red\n d.vect schools_to_hospitals\n  Distance between point source of pollution and sample points along streams \n Example with streams of the NC sample data set.\n # add coordinates of pollution point source of pollution as vector\n pollution.txt:\n 634731.563206905|216390.501834892\n v.in.ascii input=pollution.txt output=pollution\n # add table to vector\n v.db.addtable map=pollution\n # add coordinates of sample points as vector\n samples.txt:\n 634813.332814905|216333.590706166\n 634893.462007813|216273.763350851\n 634918.660011082|216254.949609689\n v.in.ascii input=samples.txt output=samples\n # add table to vector\n v.db.addtable map=samples\n # connect samples and pollution to streams\n v.net -c input=streams points=samples output=streams_samples \n           operation=connect node_layer=3 threshold=10 \n  v.net -c input=streams_samples points=pollution \n          output=streams_samples_pollution operation=connect \n           node_layer=4 threshold=10\n # check vector layers\n v.category input=streams_samples_pollution option=report               \n Layer/table: 1/streams_samples_pollution\n type       count        min        max\n point          0          0          0\n line        8562      40102     101351\n boundary       0          0          0\n centroid       0          0          0\n area           0          0          0\n face           0          0          0\n kernel         0          0          0\n all         8562      40102     101351\n Layer: 3\n type       count        min        max\n point          3          1          3\n line           0          0          0\n boundary       0          0          0\n centroid       0          0          0\n area           0          0          0\n face           0          0          0\n kernel         0          0          0\n all            3          1          3\n Layer: 4\n type       count        min        max\n point          1          1          1\n line           0          0          0\n boundary       0          0          0\n centroid       0          0          0\n area           0          0          0\n face           0          0          0\n kernel         0          0          0\n all            1          1          1\n # calculate distance between sample points and pollution point source\n v.net.distance input=streams_samples_pollution \n        output=distance_samples_to_pollution from_layer=3 to_layer=4\n # check results\n v.report map=distance_samples_to_pollution@vnettest option=length               \n cat|tcat|dist|length\n 1|1|100.0|100.0\n 2|1|200.0|200.0\n 3|1|231.446|231.446\n ", "see_also": ["v.net.path", "v.net.allpairs", "v.net.distance", "v.net.alloc"], "authors": ["Daniel Bundala, Google Summer of Code 2009, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.distance"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.connectivity.html", "name": "v.net.connectivity", "definition": "- Computes vertex connectivity between two sets of nodes in the network.", "keywords": ["vector", "network", "connectivity"], "synopsis": "v.net.connectivity input=name  [arc_layer=string]   [node_layer=string]   [arc_column=name]   [arc_backward_column=name]  output=name  [node_column=name]   [set1_cats=range]   [set1_where=sql_query]   [set2_cats=range]   [set2_where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "set1_cats", "flag": "set1_cats", "dataType": "String", "optional": true, "explanation": "Set1 category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "set1_where", "flag": "set1_where", "dataType": "String", "optional": true, "explanation": "Set1 WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "set2_cats", "flag": "set2_cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "set2_where", "flag": "set2_where", "dataType": "String", "optional": true, "explanation": "Set2 WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.connectivity  computes vertex connectivity between two sets,\n  i.e. the minimum number of vertices whose removal would separate two \n  given sets. \n ", "notes": "\n Two sets ( set1  and  set2 ) are specified by respective\n  layer ,  where  and  cats  parameters. Similarly to\n  v.net.flow  module, capacities of nodes can\n be given by  node_column  option.  v.net.connectivity  finds the\n set of nodes of minimum total capacitiy separating the two given sets and\n outputs map containing points on the positions of these nodes. Default\n capacity, which is used when no column is specified, is one.\n  EXAMPLES \n The following command finds the minimum number of intersections separating\n roads on the left bank from roads on the right bank. \n v.net.connectivity input=roads output=roads_conn set1_where=\"bank=left\" \n        set2_where=\"bank=right\"\n v.net.connectivity input=airtraffic output=connectivity \n        set1_where=\"name=JFK\" set2_where=\"name=Heathrow\" node_column=capacity\n ", "see_also": ["v.net", "v.net.flow", "v.net.bridge"], "authors": ["Daniel Bundala, Google Summer of Code 2009, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.connectivity"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.components.html", "name": "v.net.components", "definition": "- Computes strongly and weakly connected components in the network.", "keywords": ["vector", "network", "components"], "synopsis": "v.net.components [-a] input=name  [arc_layer=string]   [node_layer=string]   [arc_column=name]   [arc_backward_column=name]   [node_column=string]  output=name method=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Add points on nodes Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Type of components", "defaultValue": null, "alternatives": ["weak", "strong"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.components  computes the weakly and strongly connected \n components in a network.\n ", "notes": "\n Two nodes,  u  and  v  are in the same strongly connected \n component if there are directed paths from  u  to  v  and \n from  v  to  u . The nodes are in the same weakly \n connected component if, ignoring edge directions, there is a path \n between them.\n The type of components is specified by  method  parameter. \n  v.net.components  creates a table and links it to layer 1. This \n table contains only two integer columns:  cat  and \n  comp . If a point or both endpoints of a line belong to the \n same component then the point/line is written to the output map and \n appropriate information is stored in the table. If  -a  flag is \n set then new points are added on the nodes without points. These points \n have category numbers larger than any category used in the input map.\n One-way roads can be defined by assigning a cost of -1 to the \n appropriate cost column ( arc_column  or \n  arc_backward_column ). This affects only strongly connected \n components. Network nodes can be closed by assigning a cost of -1 to \n the node cost column. All nodes with a cost < 0 can not be traversed \n and are end points, while all nodes with a cost \u2265 0 can be traversed. \n This affects both weakly and strongly connected components.\n  EXAMPLES \n Any road network should form a single strongly connected component. \n Otherwise, it is impossible to travel between some places.\n v.net.components input=roads output=roads_components method=strong\n ", "see_also": ["v.net", "v.category"], "authors": ["Daniel Bundala, Google Summer of Code 2009, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.components"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.centrality.html", "name": "v.net.centrality", "definition": "- Computes degree, centrality, betweeness, closeness and eigenvector centrality measures in the network.", "keywords": ["vector", "network", "centrality measures"], "synopsis": "v.net.centrality [-ga] input=name  [arc_layer=string]   [node_layer=string]  output=name  [cats=range]   [where=sql_query]   [arc_column=name]   [arc_backward_column=name]   [node_column=string]   [degree=name]   [closeness=name]   [betweenness=name]   [eigenvector=name]   [iterations=integer]   [error=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Add points on nodes Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Add points on nodes Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "degree", "flag": "degree", "dataType": "String", "optional": true, "explanation": "Name of degree centrality column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "closeness", "flag": "closeness", "dataType": "String", "optional": true, "explanation": "Name of closeness centrality column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "betweenness", "flag": "betweenness", "dataType": "String", "optional": true, "explanation": "Name of betweenness centrality column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "eigenvector", "flag": "eigenvector", "dataType": "String", "optional": true, "explanation": "Name of eigenvector centrality column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "iterations", "flag": "iterations", "dataType": "String", "optional": true, "explanation": "Maximum number of iterations to compute eigenvector centrality", "defaultValue": "1000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "error", "flag": "error", "dataType": "String", "optional": true, "explanation": "Cumulative error tolerance for eigenvector centrality", "defaultValue": "0.1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.centrality  computes degree, closeness, betweenness \n and eigenvector centrality measures. \n ", "notes": "\n The module computes various centrality measures for each node and \n stores them in the given columns of an attribute table, which is \n created and linked to the output map. For the description of these, \n please check the following\n  wikipedia article .\n If the column name is not given for a measure then that measure is not \n computed. If  -a  flag is set then points are added on nodes \n without points. Also, the points for which the output is computed \n can be specified by  cats ,  layer  and  where  \n parameters. However, if any of these parameters is present then\n  -a  flag is ignored and no new points are added.\n Betweenness measure is not normalised. In order to get the normalised \n values (between 0 and 1), each number needs to be divided by  N \n choose 2=N*(N-1)/2  where N is the number of nodes in the \n connected component. Computation of eigenvector measure terminates \n if the given number of iterations is reached or the cumulative  \n squared  error between the successive iterations is less than  \n error .\n  EXAMPLES \n Compute closeness and betweenness centrality measures for each node \n and produce a map containing not only points already present in the \n input map but a map with point on every node.\n v.net.centrality input=roads output=roads_cent closeness=closeness \n        betweenness=betweenness -a\n ", "see_also": ["v.net", "v.generalize"], "authors": ["Daniel Bundala, Google Summer of Code 2009, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.centrality"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.bridge.html", "name": "v.net.bridge", "definition": "- Computes bridges and articulation points in the network.", "keywords": ["vector", "network", "articulation points"], "synopsis": "v.net.bridge input=name output=name  [arc_layer=string]   [node_layer=string]   [arc_column=name]   [arc_backward_column=name]   [node_column=string]  method=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Feature type", "defaultValue": null, "alternatives": ["bridge", "articulation"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.bridge  finds bridges and articulation points in a network.\n ", "notes": "\n Bridge in a network is an edge/line whose removal would disconnect \n the (sub-)network. A node is an articulation point if its removal \n would disconnect the (sub-)network. For more information and formal \n definitions check the wikipedia entries:\n  bridge  \n and  articulation \n point .\n The output of the module contains the selected \n features. For  method=bridge , lines corresponding to \n bridges are copied from the input map to the output map. On the \n other hand, for  method=articulation , points are created on \n the positions of articulation points.\n  In GRASS GIS,  line  is not always a single line \n segment. It might be, and often is, a sequence of line segments \n between two intersections. Also, articulation point is a standard \n graph theoretic terminology which is slightly misleading in GRASS. \n An articulation point in graph theory is an articulation\n  node  in GRASS terminology. \n  EXAMPLES \n \tTBD\n ", "see_also": ["v.net", "v.category"], "authors": ["Daniel Bundala, Google Summer of Code 2009, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.bridge"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.allpairs.html", "name": "v.net.allpairs", "definition": "- Computes the shortest path between all pairs of nodes in the network.", "keywords": ["vector", "network", "shortest path"], "synopsis": "v.net.allpairs [-g] input=name output=name  [arc_layer=string]   [node_layer=string]   [cats=range]   [where=sql_query]   [arc_column=name]   [arc_backward_column=name]   [node_column=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": true, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": true, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.allpairs  computes the shortest path between each selected \n node and all other selected nodes. The output is a vector with the \n selected nodes and the shortest paths. \n ", "notes": "\n An attribute table is created and linked to layer  arc_layer . The \n table contains four columns:  cat ,  from_cat , \n  to_cat ,  cost . \n Each  cat  entry denotes the category of the shortest path from \n the node with category  from_cat  to the node with category \n  to_cat . If points are specified by  cats, layer  or \n  where  parameters then the table is filled only for the selected \n points.\n If  arc_backward_column  is not given then then the same costs are used for \n forward and backward arcs.\n  EXAMPLE \n Find shortest path along roads from selected archsites (Spearfish sample \n dataset):\n # prepare network: connect archsites to roads with threshold 200\n v.net input=roads@PERMANENT points=archsites@PERMANENT \n  output=roads_net operation=connect thresh=200\n # verify result\n v.category input=roads_net option=report\n # only lines should have a category in layer 1\n # only points should have a category in layer 2\n # shortest path between all points with categories 1 - 5 in layer 2\n v.net.allpairs input=roads_net cats=1-5 out=roads_net_all\n v.db.select roads_net_all\n Result in matrix form:\n from\\to\t1\t\t3\t\t4\t\t5\n 1\t0\t\t18820.386\t17206.651\t17373.274\n 3\t18820.386\t0\t\t1739.079\t9040.575\n 4\t17206.651\t1739.079\t0\t\t7426.84\n 5\t17373.274\t9040.575\t7426.84\t\t0\n ", "see_also": ["v.net.path", "v.net.distance"], "authors": ["Daniel Bundala, Google Summer of Code 2009, Student"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.allpairs"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.net.alloc.html", "name": "v.net.alloc", "definition": "- Allocates subnets for nearest centers.", "keywords": ["vector", "network", "cost allocation"], "synopsis": "v.net.alloc [-tgu] input=name output=name  [method=string]  center_cats=range arc_layer=string arc_type=string[,string,...] node_layer=string  [arc_column=name]   [arc_backward_column=name]   [node_column=name]   [turn_layer=string]   [turn_cat_layer=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Use turntable Use geodesic calculation for longitude-latitude locations Create unique categories and attribute table Default: same category like nearest center Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Use geodesic calculation for longitude-latitude locations Create unique categories and attribute table Default: same category like nearest center Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "u", "flag": "-u", "explanation": "Create unique categories and attribute table Default: same category like nearest center Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Use costs from centers or costs to centers", "defaultValue": "from", "alternatives": ["from", "to"], "isInputFile": false, "isOutputFile": false}, {"parameter": "center_cats", "flag": "center_cats", "dataType": "String", "optional": false, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_layer", "flag": "arc_layer", "dataType": "String", "optional": false, "explanation": "Arc layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_type", "flag": "arc_type", "dataType": "String", "optional": false, "explanation": "Arc type", "defaultValue": "line,boundary", "alternatives": ["line", "boundary"], "isInputFile": false, "isOutputFile": false}, {"parameter": "node_layer", "flag": "node_layer", "dataType": "String", "optional": false, "explanation": "Node layer", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_column", "flag": "arc_column", "dataType": "String", "optional": true, "explanation": "Arc forward/both direction(s) cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "arc_backward_column", "flag": "arc_backward_column", "dataType": "String", "optional": true, "explanation": "Arc backward direction cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "node_column", "flag": "node_column", "dataType": "String", "optional": true, "explanation": "Node cost column (number)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "turn_layer", "flag": "turn_layer", "dataType": "String", "optional": true, "explanation": "Layer with turntable", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "turn_cat_layer", "flag": "turn_cat_layer", "dataType": "String", "optional": true, "explanation": "Layer with unique categories used in turntable", "defaultValue": "4", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.net.alloc  allocates subnets for nearest centers. Center \n nodes must be opened (costs >= 0). Costs of center nodes are used in \n the calculation. \n Costs may be either line lengths, or attributes saved in a \n database table. These attribute values are taken as costs of whole \n segments, not as costs to traverse a length unit (e.g. meter) of the \n segment. For example, if the speed limit is 100 km / h, the cost to \n traverse a 10 km long road segment must be calculated as\n length / speed = 10 km / (100 km/h) = 0.1 h.\n Supported are cost assignments for both arcs and nodes, \n and also different costs for both directions of a vector line. \n For areas, costs will be calculated along boundary lines.\n The input vector needs to be prepared with  v.net operation=connect  \n in order to connect points representing center nodes to the network.\n The nearest center can be determined using either costs from the \n nearest center or costs to the nearest center with option \n  method . See example below.\n By default, the category value of the nearest center is used as \n category value for output lines. With the  -u  flag, output lines \n become unique categories and an attribute table is created with the \n fields  cat, ocat, center . The  ocat  field holds the \n original line category in  arc_layer  and the  center  \n field holds the center category in  node_layer . Additionally, \n original line categories are copied from the input  arc_layer  to \n layer 2 in the output, together with any attribute table.\n Application of flag  -t  enables a turntable support. This flag \n requires additional parameters  turn_layer  and \n  turn_cat_layer  that are otherwise ignored. The turntable allows \n to model e.g. traffic code, where some turns may be prohibited. This \n means that the input layer is expanded by turntable with costs of every \n possible turn on any possible node (intersection) in both directions. \n Turntable can be created by the  v.net  \n module. For more information about turns in the vector network analyses \n see\n  wiki page .\n ", "notes": "\n Nodes and arcs can be closed using cost = -1. \n Center nodes can also be assigned to vector nodes using \n  wxGUI vector digitizer . \n  EXAMPLES \n  1. Subnetwork allocation using distance:\n  2. Subnetwork allocation using traveling time:\n  Example 1:  Calculating subnets for 3 center nodes using distances \n # Spearfish\n # center nodes:\n echo \"591235.5|4926306.62|1\n 596591.8|4917042.5|2\n 602722.9|4923544.2|3\" | v.in.ascii in=- out=centernodes\n g.copy vect=roads,myroads\n # connect points to network\n v.net myroads points=centernodes out=myroads_net op=connect thresh=200\n # allocate, specifying range of center cats (easier to catch all):\n v.net.alloc myroads_net out=myroads_net_alloc center_cats=1-100000 node_layer=2\n # report categories\n v.category myroads_net_alloc option=report\n To display the result, run for example:\n # show result\n g.region vector=myroads_net\n d.mon x0\n d.vect myroads_net layer=1\n # the result has to be selected by category number of the relevant node:\n d.vect myroads_net_alloc cat=1 col=red layer=1\n d.vect myroads_net_alloc cat=2 col=green layer=1\n d.vect myroads_net_alloc cat=3 col=yellow layer=1\n # center nodes\n d.vect myroads_net col=red icon=basic/triangle fcol=green size=12 layer=2\n  Example 2:  Calculating subnets for 3 center nodes using traveling time \n # Spearfish\n # center nodes:\n echo \"591235.5|4926306.62|1\n 596591.8|4917042.5|2\n 602722.9|4923544.2|3\" | v.in.ascii in=- out=centernodes\n g.copy vect=roads,myroads\n # create lines map connecting points to network\n v.net myroads points=centernodes out=myroads_net op=connect thresh=500 arc_layer=1 node_layer=2\n # set up costs\n # create unique categories for each road in layer 3\n v.category in=myroads_net out=myroads_net_time opt=add cat=1 layer=3 type=line\n # add new table for layer 3\n v.db.addtable myroads_net_time layer=3 col=\"cat integer,label varchar(43),length double precision,speed double precision,cost double precision,bcost double precision\"\n # copy road type to layer 3\n v.to.db myroads_net_time layer=3 qlayer=1 opt=query qcolumn=label columns=label\n # upload road length in miles\n v.to.db myroads_net_time layer=3 type=line option=length col=length unit=miles\n # set speed limits in miles / hour\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='interstate'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"75.0\" where=\"label='primary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"50.0\" where=\"label='secondary highway, hard surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"25.0\" where=\"label='light-duty road, improved surface'\"\n v.db.update myroads_net_time layer=3 col=speed val=\"5.0\" where=\"label='unimproved road'\"\n # define traveling costs as traveling time in minutes:\n # set forward costs\n v.db.update myroads_net_time layer=3 col=cost val=\"length / speed * 60\"\n # set backward costs\n v.db.update myroads_net_time layer=3 col=bcost val=\"length / speed * 60\"\n # subnetwork allocation with fastest paths\n v.net.alloc in=myroads_net_time arc_layer=3 node_layer=2 arc_column=cost arc_backward_column=bcost out=myroads_net_alloc_time center_cats=1-3\n To display the result, run for example:\n # show result\n g.region vector=myroads_net\n d.mon x0\n d.vect myroads_net type=line layer=1\n # the result has to be selected by category number of the relevant node:\n d.vect myroads_net_alloc_time cat=1 col=red layer=1\n d.vect myroads_net_alloc_time cat=2 col=green layer=1\n d.vect myroads_net_alloc_time cat=3 col=yellow layer=1\n # center nodes\n d.vect myroads_net_time col=red icon=basic/triangle fcol=green size=12 type=point layer=2\n  Example 3:  Differences between costs from centers and costs to centers \n Each lane of the two-lane road is a one-way road.\n  1. Subnetwork allocation from centers:\n A center reaches any point following the one-way lanes.\n  2. Subnetwork allocation to centers:\n Any node reaches reaches the nearest center following the one-way lanes.\n In case of an accident, the ambulance should come from the nearest \n 'from' hospital and go to the nearest 'to' hospital.\n # North Carolina\n # center nodes are hospitals:\n # connect hospitals to streets as layer 2\n v.net input=streets_wake points=hospitals output=streets_hospitals operation=connect thresh=400 arc_layer=1 node_layer=2\n v.to.db map=streets_hospitals layer=1 type=line option=cat columns=cat\n # close oneway roads\n v.db.update map=streets_hospitals column=TF_COST value=-1 where=\"ONE_WAY = 'FT'\"\n v.db.update map=streets_hospitals column=FT_COST value=-1 where=\"ONE_WAY = 'TF'\"\n # add costs to newly created lines\n v.db.update map=streets_hospitals column=TF_COST value=0 where=\"cat > 49746\"\n v.db.update map=streets_hospitals column=FT_COST value=0 where=\"cat > 49746\"\n # from centers\n v.net.alloc in=streets_hospitals out=streets_hospitals_alloc_from center_cats=1-10000 arc_column=FT_COST arc_backward_column=TF_COST\n # to centers\n v.net.alloc in=streets_hospitals out=streets_hospitals_alloc_to method=to center_cats=1-10000 arc_column=FT_COST arc_backward_column=TF_COST\n ", "see_also": ["d.path", "v.net", "v.net.iso", "v.net.path", "v.net.steiner", "v.net.salesman"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.net.alloc"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.neighbors.html", "name": "v.neighbors", "definition": "- Neighborhood analysis tool for vector point maps.", "keywords": ["vector", "algebra", "statistics", "raster", "aggregation"], "synopsis": "v.neighbors input=name  [layer=string]  output=name method=string size=float  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": false, "explanation": "Neighborhood operation", "defaultValue": "count", "alternatives": ["count"], "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": false, "explanation": "Neighborhood diameter in map units", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n Makes each cell value a function of the attribute values assigned to the\n vector points or centroids around it, and stores new cell values in\n an output raster map layer.\n  EXAMPLE \n Count the number of schools for a given grid (North Carolina sample\n dataset):\n g.region vector=schools_wake res=100 -p -a\n v.neighbors input=schools_wake output=schools_wake_3000m method=count size=3000\n d.mon wx0\n d.rast schools_wake_3000m\n d.vect schools_wake\n The result gives for each grid cell the number of points (here: schools)\n not farther than 1500 meter away (half of the given  size  value)\n from the respective cell center.\n ", "notes": "", "see_also": ["r.neighbors"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.neighbors"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.mkgrid.html", "name": "v.mkgrid", "definition": "- Creates a vector map of a user-defined grid.", "keywords": ["vector", "geometry", "grid", "point pattern", "hexagon"], "synopsis": "v.mkgrid [-ha] map=name  [grid=rows,columns]   [position=string]   [coordinates=east,north]   [box=width,height]   [angle=float]   [breaks=integer]   [type=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "h", "flag": "-h", "explanation": "Create hexagons (default: rectangles) Allow asymmetric hexagons Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Allow asymmetric hexagons Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "grid", "flag": "grid", "dataType": "String", "optional": true, "explanation": "Number of rows and columns in grid", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "position", "flag": "position", "dataType": "String", "optional": true, "explanation": "Where to place the grid", "defaultValue": "region", "alternatives": ["region", "coor"], "isInputFile": false, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Lower left easting and northing coordinates of map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "box", "flag": "box", "dataType": "String", "optional": true, "explanation": "Width and height of boxes in grid", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "angle", "flag": "angle", "dataType": "String", "optional": true, "explanation": "Angle of rotation (in degrees counter-clockwise)", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "breaks", "flag": "breaks", "dataType": "String", "optional": true, "explanation": "Number of vertex points per grid cell", "defaultValue": "0", "alternatives": ["0-60"], "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Output feature type", "defaultValue": "area", "alternatives": ["point", "line", "area"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.mkgrid  creates a vector map representation of a regular \n coordinate grid. Point, line, and area vector grids can be created.\n ", "notes": "\n Grid points created with the  type=point  option will be placed at \n the  center  of each grid cell, like centroids with the default \n  type=area  option. \n Grid lines created with the  type=line  option will be identical to \n the edges of each grid cell, like boundaries with the default \n  type=area  option. \n The resultant grid can be rotated around the origin (center of the \n grid) with the  angle  option.\n Optionally hexagons can be created with the  -h  flag. Hexagons \n are by default symmetric. Asymmetric hexagons can be allowed with the \n  -a  flag.\n This module is NOT to be used to generate a vector map of USGS \n quadrangles, because USGS quads are not exact rectangles.\n  EXAMPLES \n  Creating a global grid in a latitude-longitude \n To be run in a latitude-longitude location (WGS84)\n # set the region:\n g.region n=90 s=-90 w=-180 e=180 res=10 -p\n projection: 3 (Latitude-Longitude)\n zone:       0\n datum:      wgs84\n ellipsoid:  wgs84\n north:      90N\n south:      90S\n west:       180W\n east:       180E\n nsres:      10\n ewres:      10\n rows:       18\n cols:       36\n cells:      648\n # create 10 degree size grid:\n v.mkgrid map=grid_10deg\n # create 20 degree size grid:\n v.mkgrid map=grid_20deg box=20,20\n  Creating a grid in a metric projection \n Creating a 4x3 grid, cells 20km a side, with lower left corner at 2716500,6447000:\n v.mkgrid map=coro_grid grid=4,3 position=coor coordinates=2716500,6447000 box=20000,20000\n  Creating a positioned grid in a latitude-longitude \n Creating a 10x12 lat/lon grid, cells 2 arc-min a side, with lower left corner\n at 167deg 52min east, 47deg 6min south. For use with e.g. QGIS you can then\n pull this grid into a projected location with  v.proj  before\n exporting as a Shapefile with  v.out.ogr  (within GRASS GIS you could\n just use  d.grid -w  from the projected location for the same effect):\n v.mkgrid map=p2min_grid grid=10,12 position=coor coordinates=167:52E,47:06S box=0:02,0:02\n  Creating a simple point pattern \n North Carolina sample dataset example, creating a 1km spaced point grid\n based on the current region extent defined by the \"elevation\" map:\n g.region raster=elevation res=1000 -pa\n v.mkgrid type=point map=pointpattern\n  Creating a regular point pattern \n North Carolina sample dataset example, creating a regular spaced point grid\n based on the current region extent defined by the \"elevation\" map, using\n a two-step approach:\n # create first set of points, covering extent of \"elevation\" raster map\n g.region raster=elevation res=1000 -pa\n v.mkgrid type=point map=pointpattern1\n # shift grid by half point distance (map units)\n g.region n=n+500 w=w+500 e=e+500 s=s+500 -p\n # create second set of points\n v.mkgrid type=point map=pointpattern2\n # merge into final point pattern\n v.patch input=pointpattern1,pointpattern2 output=pointpattern3\n Different point patterns for sampling design\n  Creating hexagons in a metric projection \n North Carolina sample dataset example, creating regular hexagons\n based on the current region extent defined by the \"elevation\" map and\n raster resolution for the hexagon size:\n g.region raster=elevation res=5000 -pa\n v.mkgrid map=hexagons -h\n d.grid 5000\n Hexagon map\n  Using hexagons for point density \n To compute point density in a hexagonal grid for the vector map\n  points_of_interest  in the basic North Carolina sample dataset,\n the vector map itself is used to set extent of the computational region.\n The resolution is based on the desired size of hexagons.\n g.region vector=points_of_interest res=2000 -pa\n The hexagonal grid is created as a vector map based on the previously\n selected extent and size of the grid.\n v.mkgrid map=hexagons -h\n The following counts the number of points per hexagon using the\n  v.vect.stats  module.\n v.vect.stats points=points_of_interest areas=hexagons count_column=count\n User should note that some of the points may be outside the grid\n since the hexagons cannot cover all the area around the edges\n (the computational region extent needs to be enlarged if all points\n should be considered).\n The last command sets the vector map color table to  viridis \n based on the  count  column.\n v.colors map=hexagons use=attr column=count color=viridis\n  \n Point density in a hexagonal grid\n ", "see_also": ["d.grid", "v.in.region", "v.patch", "v.vect.stats"], "authors": ["Michael Higgins, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.mkgrid"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.lrs.where.html", "name": "v.lrs.where", "definition": "- Finds line id and real km+offset for given points in vector map using linear reference system.", "keywords": ["vector", "linear reference system", "network"], "synopsis": "v.lrs.where lines=name points=name  [llayer=string]   [player=string]   [rsdriver=string]   [rsdatabase=string]  rstable=string  [threshold=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "lines", "flag": "lines", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "points", "flag": "points", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "llayer", "flag": "llayer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "player", "flag": "player", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rsdriver", "flag": "rsdriver", "dataType": "String", "optional": true, "explanation": "Driver name for reference system table", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "rsdatabase", "flag": "rsdatabase", "dataType": "String", "optional": true, "explanation": "Database name for reference system table", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rstable", "flag": "rstable", "dataType": "String", "optional": false, "explanation": "Name of the reference system table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Maximum distance to nearest line", "defaultValue": "1000", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.lrs.where  identifies line id and real milepost+offset for\n points in vector map using linear reference system.\n  EXAMPLE \n This example is written for the Spearfish dataset (it continues the example\n from  v.lrs.create ).\n In this example, the 'route_lrs' shall be queried for unknown\n positions (points, stored in the map  newpoints ) along the LRS:\n # generate query points\n echo \"590866.15|4926737.0\n 590933|4927133\" | v.in.ascii out=newpoints\n v.lrs.where lines=route_lrs points=newpoints rstable=route_lrs\n pcat|lid|mpost|offset\n pcat|lid|mpost|offset\n 1|22|4.000000+212.091461\n 2|22|6.000000+188.112093\n # verification\n g.region vector=route_lrs n=n+100 s=s-100 -p\n d.erase\n d.vect route_lrs\n d.vect busstops disp=attr attr=cat size=10 bg=white lcol=blue yref=bottom\n d.vect busstops icon=basic/circle fcol=blue\n d.vect newpoints col=red\n # measure distance to previous bus stop:\n # use measuring tool in graphical user interface\n ", "notes": "", "see_also": ["LRS tutorial", "Introducing the Linear Reference System in GRASS", "v.lrs.where", "v.lrs.segment", "v.lrs.label"], "authors": ["Radim Blazek, ITC-irst/MPA Solutions"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.lrs/v.lrs.where"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.lrs.segment.html", "name": "v.lrs.segment", "definition": "- Creates points/segments from input lines, linear reference system and positions read from stdin or a file.", "keywords": ["vector", "linear reference system", "network"], "synopsis": "v.lrs.segment input=name output=name  [llayer=string]   [rsdriver=string]   [rsdatabase=string]  rstable=string  [file=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output vector map where segments will be written", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "llayer", "flag": "llayer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rsdriver", "flag": "rsdriver", "dataType": "String", "optional": true, "explanation": "Driver name for reference system table", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "rsdatabase", "flag": "rsdatabase", "dataType": "String", "optional": true, "explanation": "Database name for reference system table", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rstable", "flag": "rstable", "dataType": "String", "optional": false, "explanation": "Name of the reference system table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "file", "flag": "file", "dataType": "String", "optional": true, "explanation": "Name of file containing segment rules. If not given, read from stdin.", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.lrs.segment  creates points/segments from input lines,\n linear reference system and positions read from  standard in \n or a file.\n The format is as follows: \n P <point_id> <line_id> <milepost>+<offset> [<side offset>]\n L <segment_id> <line_id> <milepost>+<offset> <milepost>+<offset> [<side offset>]\n ", "notes": "\n For more information and examples see the help page for  v.lrs.segment 's\n sister module,  v.segment .\n  EXAMPLE \n This example is written for the Spearfish dataset (it continues the example\n from  v.lrs.create ).\n In this example, the 'route_lrs' shall be extended for a new\n position (point) along the LRS after bus stop 4:\n # new point on LRS\n echo \"P 7 22 4+180\" | v.lrs.segment route_lrs out=route_lrs_new rstable=route_lrs\n g.region vector=route_lrs n=n+100 s=s-100 -p\n d.erase\n # existing LRS\n d.vect route_lrs\n d.vect busstops disp=attr attr=cat size=10 bg=white lcol=blue yref=bottom\n d.vect busstops icon=basic/circle fcol=blue\n db.select table=route_lrs\n # show modified map\n d.vect route_lrs_new col=red\n  TODO \n Figure out how to merge result into existing LRS map and table.\n ", "see_also": ["LRS tutorial", "Introducing the Linear Reference System in GRASS", "v.lrs.create", "v.lrs.where", "v.lrs.label", "v.segment"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.lrs/v.lrs.segment"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.lrs.label.html", "name": "v.lrs.label", "definition": "- Creates stationing from input lines, and linear reference system.", "keywords": ["vector", "linear reference system", "network"], "synopsis": "v.lrs.label input=name output=name  [llayer=string]   [rsdriver=string]   [rsdatabase=string]  rstable=string  [labels=string]   [offset=string[,string,...]]   [xoffset=float]   [yoffset=float]   [reference=string]   [font=string]   [size=integer]   [color=name]   [width=integer]   [highlight_color=name]   [highlight_width=integer]   [bgcolor=name]   [border=name]   [opaque=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output vector map where stationing will be written", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "llayer", "flag": "llayer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rsdriver", "flag": "rsdriver", "dataType": "String", "optional": true, "explanation": "Driver name for reference system table", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "rsdatabase", "flag": "rsdatabase", "dataType": "String", "optional": true, "explanation": "Database name for reference system table", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rstable", "flag": "rstable", "dataType": "String", "optional": false, "explanation": "Name of the reference system table", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "labels", "flag": "labels", "dataType": "String", "optional": true, "explanation": "Label file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "offset", "flag": "offset", "dataType": "String", "optional": true, "explanation": "PM left, MP right, stationing left, stationing right offset", "defaultValue": "50,100,25,25", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "xoffset", "flag": "xoffset", "dataType": "String", "optional": true, "explanation": "Offset label in label x-direction in map units", "defaultValue": "25", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "yoffset", "flag": "yoffset", "dataType": "String", "optional": true, "explanation": "Offset label in label y-direction in map units", "defaultValue": "5", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "reference", "flag": "reference", "dataType": "String", "optional": true, "explanation": "Reference position", "defaultValue": "center", "alternatives": ["center", "left", "right", "upper", "lower"], "isInputFile": false, "isOutputFile": false}, {"parameter": "font", "flag": "font", "dataType": "String", "optional": true, "explanation": "Font", "defaultValue": "standard", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "size", "flag": "size", "dataType": "String", "optional": true, "explanation": "Label size (in map-units)", "defaultValue": "100", "alternatives": ["1-1000"], "isInputFile": false, "isOutputFile": false}, {"parameter": "color", "flag": "color", "dataType": "String", "optional": true, "explanation": "Text color", "defaultValue": "black", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "width", "flag": "width", "dataType": "String", "optional": true, "explanation": "Line width of text", "defaultValue": "1", "alternatives": ["1-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "highlight_color", "flag": "highlight_color", "dataType": "String", "optional": true, "explanation": "Highlight color for text", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "highlight_width", "flag": "highlight_width", "dataType": "String", "optional": true, "explanation": "Line width of highlight color", "defaultValue": "0", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}, {"parameter": "bgcolor", "flag": "bgcolor", "dataType": "String", "optional": true, "explanation": "Background color", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "border", "flag": "border", "dataType": "String", "optional": true, "explanation": "Border color", "defaultValue": "none", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "opaque", "flag": "opaque", "dataType": "String", "optional": true, "explanation": "Opaque to vector", "defaultValue": "yes", "alternatives": ["yes", "no"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.lrs.label  generates LRS labels for pretty-printing of a LRS.\n This example is written for the Spearfish dataset (it continues the example\n from  v.lrs.create ).\n v.lrs.label route_lrs rstable=route_lrs output=route_lrs_labels \n              labels=labels col=red size=50 xoffset=100\n g.region vector=route_lrs n=n+100 s=s-100 -p\n d.erase\n d.vect route_lrs\n d.vect route_lrs_labels col=grey type=line\n d.vect busstops disp=attr attr=cat size=10 bg=white lcol=green yref=bottom\n  d.vect busstops icon=basic/circle fcol=green\n  d.labels labels\n   \n ", "notes": "", "see_also": ["LRS tutorial", "Introducing the Linear Reference System in GRASS", "v.lrs.create", "v.lrs.segment", "v.lrs.where"], "authors": ["Radim Blazek, ITC-irst/MPA Solutions"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.lrs/v.lrs.label"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.lrs.create.html", "name": "v.lrs.create", "definition": "- Creates a linear reference system.", "keywords": ["vector", "linear reference system", "network"], "synopsis": "v.lrs.create in_lines=name out_lines=name  [err=name]  points=name  [llayer=string]   [player=string]  lidcol=string pidcol=string  [start_mp=string]   [start_off=string]   [end_mp=string]   [end_off=string]   [rsdriver=string]   [rsdatabase=string]  rstable=string  [threshold=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "in_lines", "flag": "in_lines", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "out_lines", "flag": "out_lines", "dataType": "String", "optional": false, "explanation": "Output vector map where oriented lines are written", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "err", "flag": "err", "dataType": "String", "optional": true, "explanation": "Output vector map of errors", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "points", "flag": "points", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "llayer", "flag": "llayer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "player", "flag": "player", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lidcol", "flag": "lidcol", "dataType": "String", "optional": false, "explanation": "Column containing line identifiers for lines", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "pidcol", "flag": "pidcol", "dataType": "String", "optional": false, "explanation": "Column containing line identifiers for points", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_mp", "flag": "start_mp", "dataType": "String", "optional": true, "explanation": "Column containing milepost position for the beginning of next segment", "defaultValue": "start_mp", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "start_off", "flag": "start_off", "dataType": "String", "optional": true, "explanation": "Column containing offset from milepost for the beginning of next segment", "defaultValue": "start_off", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "end_mp", "flag": "end_mp", "dataType": "String", "optional": true, "explanation": "Column containing milepost position for the end of previous segment", "defaultValue": "end_mp", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "end_off", "flag": "end_off", "dataType": "String", "optional": true, "explanation": "Column containing offset from milepost for the end of previous segment", "defaultValue": "end_off", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rsdriver", "flag": "rsdriver", "dataType": "String", "optional": true, "explanation": "Driver name for reference system table", "defaultValue": "sqlite", "alternatives": ["dbf", "mysql", "odbc", "ogr", "pg", "sqlite"], "isInputFile": false, "isOutputFile": false}, {"parameter": "rsdatabase", "flag": "rsdatabase", "dataType": "String", "optional": true, "explanation": "Database name for reference system table", "defaultValue": "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rstable", "flag": "rstable", "dataType": "String", "optional": false, "explanation": "Name of table where the reference system will be written", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Maximum distance of point to line allowed", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.lrs.create  generates a LRS (Linear Reference System) from\n vector line and point data.\n It is highly recommended to work with polylines instead of segmented vector\n lines. The command  v.build.polylines  creates this map structure.\n ", "notes": "\n The mileposts (point) vector map columns  start_mp ,  start_off ,\n  end_mp ,  end_off  must be of 'double precision' type. For\n milepost ordering, it is sufficient to enter increasing numbers into the\n  start_mp  column indicating the order along the vector line.\n The  lidcol  and  pidcol  columns contain the line IDs which\n relate mileposts and vector line(s) to each other.\n When creating a LRS with this module, any existing  rstable  will be\n replaced.\n  EXAMPLE \n This example is written for the Spearfish dataset.\n As first step, bus route data are prepared. \n # break into segments for correct route selection\n v.clean roads_net out=busroute_tmp tool=break\n # make polyline for easier line selection by coordinate pairs\n v.build.polylines busroute_tmp out=busroute_tmp2\n # reverse delete: reduce route map to bus route (enter in one line)\n v.edit -r busroute_tmp2 tool=delete coords=590273,4927304,\n  590346,4927246,590414,4927210,590438,4927096,590468,4926966,\n  590491,4926848,590566,4926798,590637,4926753,590701,4926698,\n  590830,4926726,590935,4926751,590993,4926830,590972,4926949,\n  590948,4927066,590922,4927182,590957,4927251 threshold=5\n # vector line needs to be polyline\n v.build.polylines busroute_tmp2 out=busroute_tmp3\n v.category busroute_tmp3 out=busroute op=add\n g.remove -f type=vector name=busroute_tmp,busroute_tmp2,busroute_tmp3\n The result can be visualized:\n g.region vector=busroute n=n+100 s=s-100 w=w-100 e=e+100\n d.mon x0\n d.vect roads_net\n d.vect busroute col=red width=2\n The vector map 'busroute' needs have an attribute table which contain an integer column\n  lidcol  with value be '22' for this example (bus route):\n v.db.addtable busroute col=\"lid integer\"\n v.db.update busroute col=lid value=22\n v.db.select busroute\n cat|lid\n 1|22\n A new point map 'busstops' shall contain mileposts (bus stops) along\n this line (use  thresh  to define maximal accepted deviation from this line):\n # generate points map\n echo \"590263|4927361\n 590432|4927120\n 590505|4926776\n 590660|4926687\n 590905|4926742\n 590972|4926949\n 591019|4927263\" | v.in.ascii out=busstops\n d.vect busstops icon=basic/triangle col=blue\n d.vect busstops disp=cat lcol=blue\n The milepost attributes table needs to be created with specific columns:\n v.db.addtable busstops col=\"lid integer, start_mp double precision, \n              start_off double precision, end_mp double precision, \n              end_off double precision\"\n v.db.update busstops col=lid value=22\n Since the digitizing order of v.in.ascii above reflects the bus stop\n order along the route, we can simply copy the category number as milepost\n order number in column  start_mp :\n v.db.update busstops col=start_mp qcol=cat\n # verify table\n v.db.select busstops\n cat|lid|start_mp|start_off|end_mp|end_off\n 1|22|1|||\n 2|22|2|||\n 3|22|3|||\n 4|22|4|||\n 5|22|5|||\n 6|22|6|||\n 7|22|7|||\n # visualize with start_mp to check order\n d.erase\n d.vect roads_net\n d.vect busroute col=red width=2\n d.vect busstops icon=basic/triangle col=blue\n d.vect busstops disp=attr attrcol=start_mp lcol=blue\n Offsets ( start_off ,  end_off ) can be later used in case the route or\n mileposts get modified.\n As second step, the linear reference network is created:\n v.lrs.create busroute points=busstops out=route_lrs err=lrs_error \n               lidcol=lid pidcol=lid rstable=route_lrs threshold=50\n This creates the maps 'route_lrs' containing the LRS and 'lrs_error'\n containing the errors if any. The resulting LRS table and map can\n be shown:\n # show LRS table\n db.select table=route_lrs\n d.vect route_lrs col=blue width=2\n ", "see_also": ["LRS tutorial", "Introducing the Linear Reference System in GRASS"], "authors": ["Radim Blazek, ITC-irst/MPA Solutions"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.lrs/v.lrs.create"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.lidar.growing.html", "name": "v.lidar.growing", "definition": "- Building contour determination and Region Growing algorithm for determining the building inside", "keywords": ["vector", "LIDAR"], "synopsis": "v.lidar.growing input=name output=name first=name  [tj=float]   [td=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "first", "flag": "first", "dataType": "String", "optional": false, "explanation": "Name of the first pulse vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tj", "flag": "tj", "dataType": "String", "optional": true, "explanation": "Threshold for cell object frequency in region growing", "defaultValue": "0.2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "td", "flag": "td", "dataType": "String", "optional": true, "explanation": "Threshold for double pulse in region growing", "defaultValue": "0.6", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.lidar.growing  is the second of three steps to filter LiDAR data. \n The filter aims to recognize and extract attached and detached object \n (such as buildings, bridges, power lines,  trees, etc.) in order to create \n a Digital Terrain Model. \n The modules identifies which is the internal area of every object on a \n LiDAR point surface. The classification categories from \n  v.lidar.edgedetection  are now rasterized. For each cell, it is \n evaluated if it (the cell) contains a point with double impulse (difference \n between the first and last pulse greater than a given threshold). Starting \n from cells classified as OBJECT and with only one pulse all linked cells \n are selected and a convex hull algorithm is applied to them. Simultaneously, \n the mean of the corresponding heights (mean edge height) are computed. \n Points inside the convex hull are classified as OBJECT if their height is \n greater than or equal to the previously mean computed edge height. This \n last step is done only in case of high planimetric resolution.\n ", "notes": "\n The input data should be the output result of the  v.lidar.edgedetection ,\n module. Otherwise, it goes to error! The output of this module will be \n the input of  v.lidar.correction  module. The output will be a vector \n map which points are pre-classified as:\n TERRAIN SINGLE PULSE (cat = 1, layer = 2)\n TERRAIN DOUBLE PULSE (cat = 2, layer = 2)\n OBJECT SINGLE PULSE (cat = 3, layer = 2)\n OBJECT DOUBLE PULSE (cat = 4, layer = 2)\n The final result of the whole procedure ( v.lidar.edgedetection , \n  v.lidar.growing ,  v.lidar.correction ) will be a point \n classification in the same categories as above.\n  EXAMPLES \n  Basic region growing procedure \n v.lidar.growing input=edge output=growing first=firstpulse\n ", "see_also": ["v.lidar.edgedetection", "v.lidar.correction", "v.surf.bspline", "v.surf.rst", "v.in.lidar", "v.in.ascii"], "authors": ["Original version of program in GRASS 5.4:"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.lidar.growing"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.lidar.edgedetection.html", "name": "v.lidar.edgedetection", "definition": "- Detects the object's edges from a LIDAR data set.", "keywords": ["vector", "LIDAR", "edges"], "synopsis": "v.lidar.edgedetection [-e] input=name output=name  [ew_step=float]   [ns_step=float]   [lambda_g=float]   [tgh=float]   [tgl=float]   [theta_g=float]   [lambda_r=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Estimate point density and distance and quit Estimate point density and distance in map units for the input vector points within the current region extents and quit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "ew_step", "flag": "ew_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the east-west direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ns_step", "flag": "ns_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the north-south direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lambda_g", "flag": "lambda_g", "dataType": "String", "optional": true, "explanation": "Regularization weight in gradient evaluation", "defaultValue": "0.01", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tgh", "flag": "tgh", "dataType": "String", "optional": true, "explanation": "High gradient threshold for edge classification", "defaultValue": "6", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tgl", "flag": "tgl", "dataType": "String", "optional": true, "explanation": "Low gradient threshold for edge classification", "defaultValue": "3", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "theta_g", "flag": "theta_g", "dataType": "String", "optional": true, "explanation": "Angle range for same direction detection", "defaultValue": "0.26", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lambda_r", "flag": "lambda_r", "dataType": "String", "optional": true, "explanation": "Regularization weight in residual evaluation", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.lidar.edgedetection  is the first of three steps to filter\n LiDAR data. The filter aims to recognize and extract attached and \n detached object (such as buildings, bridges, power lines,  trees, etc.) \n in order to create a Digital Terrain Model. \n In particular, this module detects the edge of each single feature over \n the terrain surface of a LIDAR point surface. First of all, a bilinear \n spline interpolation with a Tychonov regularization parameter is \n performed. The gradient is minimized and the low Tychonov regularization \n parameter brings the interpolated functions as close as possible to the \n observations. Bicubic spline interpolation with Tychonov regularization \n is then performed. However, now the curvature is minimized and the \n regularization parameter is set to a high value. For each point, an \n interpolated value is computed from the bicubic surface and an interpolated \n gradient is computed from the bilinear surface. At each point the gradient \n magnitude and the direction of the edge vector are calculated, and the \n residual between interpolated and observed values is computed. Two thresholds \n are defined on the gradient, a high threshold  tgh  and a low one \n  tgl . For each point, if the gradient magnitude is greater than or \n equal to the high threshold and its residual is greater than or equal to \n zero, it is labeled as an EDGE point. Similarly a point is labeled as \n being an EDGE point if the gradient magnitude is greater than or equal to \n the low threshold, its residual is greater than or equal to zero, and the \n gradient to two of eight neighboring points is greater than the high \n threshold. Other points are classified as TERRAIN.\n The length (in mapping units) of each spline step is defined by \n  ew_step  for the east-west direction and  ns_step  for the \n north-south direction.\n The output will be a vector map in which points has been classified as \n TERRAIN, EDGE or UNKNOWN. This vector map should be the input of \n  v.lidar.growing  module.\n ", "notes": "\n In this module, an external table will be created which will be useful for \n the next module of the procedure of LiDAR data filtering. In this table \n the interpolated height values of each point will be recorded. Also points \n in the output vector map will be classified as:\n TERRAIN (cat = 1, layer = 1)\n EDGE (cat = 2, layer = 1)\n UNKNOWN (cat = 3, layer = 1)\n The final result of the whole procedure ( v.lidar.edgedetection ,\n  v.lidar.growing ,\n  v.lidar.correction )\n will be a point classification in four categories:\n TERRAIN SINGLE PULSE (cat = 1, layer = 2)\n TERRAIN DOUBLE PULSE (cat = 2, layer = 2)\n OBJECT SINGLE PULSE (cat = 3, layer = 2)\n OBJECT DOUBLE PULSE (cat = 4, layer = 2)\n  EXAMPLES \n  Basic edge detection \n v.lidar.edgedetection input=vector_last output=edge ew_step=8 ns_step=8 lambda_g=0.5\n  Complete workflow \n # region settings (using an existing raster)\n g.region raster=elev_lid792_1m\n # import\n v.in.lidar -tr input=points.las output=points\n v.in.lidar -tr input=points.las output=points_first return_filter=first\n # detection\n v.lidar.edgedetection input=points output=edge ew_step=8 ns_step=8 lambda_g=0.5\n v.lidar.growing input=edge output=growing first=points_first\n v.lidar.correction input=growing output=correction terrain=only_terrain\n # visualization of selected points\n # zoom somewhere first, to make it faster\n d.rast map=orthophoto\n d.vect map=correction layer=2 cats=2,3,4 color=red size=0.25\n d.vect map=correction layer=2 cats=1 color=0:128:0 size=0.5\n # interpolation (this may take some time)\n v.surf.rst input=only_terrain elevation=terrain\n # get object points for 3D visualization\n v.extract input=correction layer=2 cats=2,3,4 output=objects\n  \n      \n      Figure 1: Example output from complete workflow (red: objects, green: terrain) \n      \n      \n         Figure 2: 3D visualization of filtered object points (red)\n         and terrain created from terrain points (gray)\n      \n  REFERENCES \n  Antolin, R. et al., 2006. Digital terrain models determination by LiDAR \n technology: Po basin experimentation. Bolletino di Geodesia e Scienze \n Affini, anno LXV, n. 2, pp. 69-89. \n  Brovelli M. A., Cannata M., Longoni U.M., 2004. LIDAR Data Filtering and \n DTM Interpolation Within GRASS, Transactions in GIS, April 2004,  vol. 8, \n iss. 2, pp. 155-174(20), Blackwell Publishing Ltd. \n  Brovelli M. A., Cannata M., 2004. Digital Terrain model reconstruction in \n urban areas from airborne laser scanning data: the method and an  example \n for Pavia (Northern Italy). Computers and Geosciences 30 (2004) pp.325-331 \n  Brovelli M. A. and Longoni U.M., 2003. Software per il filtraggio di dati \n LIDAR, Rivista dell'Agenzia del Territorio, n. 3-2003, pp. 11-22 (ISSN 1593-2192). \n  Brovelli M. A., Cannata M. and Longoni U.M., 2002. DTM LIDAR in area urbana, \n Bollettino SIFET N.2, pp. 7-26. \n  Performances of the filter can be seen in the\n  ISPRS WG III/3 Comparison of Filters  \n report by Sithole, G. and Vosselman, G., 2003. \n ", "see_also": ["v.lidar.growing", "v.lidar.correction", "v.surf.bspline", "v.surf.rst", "v.in.lidar", "v.in.ascii"], "authors": ["Original version of program in GRASS 5.4:"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.lidar.edgedetection"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.lidar.correction.html", "name": "v.lidar.correction", "definition": "- Corrects the v.lidar.growing output. It is the last of the three algorithms for LIDAR filtering.", "keywords": ["vector", "LIDAR"], "synopsis": "v.lidar.correction [-e] input=name output=name terrain=name  [ew_step=float]   [ns_step=float]   [lambda_c=float]   [tch=float]   [tcl=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "e", "flag": "-e", "explanation": "Estimate point density and distance and quit Estimate point density and distance in map units for the input vector points within the current region extents and quit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Output classified vector map name", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "terrain", "flag": "terrain", "dataType": "String", "optional": false, "explanation": "Name for output only 'terrain' points vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "ew_step", "flag": "ew_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the east-west direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ns_step", "flag": "ns_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the north-south direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "lambda_c", "flag": "lambda_c", "dataType": "String", "optional": true, "explanation": "Regularization weight in reclassification evaluation", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tch", "flag": "tch", "dataType": "String", "optional": true, "explanation": "High threshold for object to terrain reclassification", "defaultValue": "2", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tcl", "flag": "tcl", "dataType": "String", "optional": true, "explanation": "Low threshold for terrain to object reclassification", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.lidar.correction  is the last of three steps to filter LiDAR\n data. The filter aims to recognize and extract attached and \n detached object (such as buildings, bridges, power lines,  trees, etc.) \n in order to create a Digital Terrain Model. \n The module, which could be iterated several times, makes a comparison \n between the LiDAR observations and a bilinear spline interpolation with \n a Tychonov regularization parameter performed on the TERRAIN SINGLE PULSE \n points only. The gradient is minimized by the regularization parameter. \n Analysis of the residuals between the observations and the interpolated \n values results in four cases (the next classification is referred to that \n of the v.lidar.growing output vector):\n  a)  Points classified as TERRAIN differing more than a threshold\n     value are interpreted and reclassified as OBJECT, for both single and \n     double pulse points.\n  b)  Points classified as OBJECT and closed enough to the\n     interpolated surface are interpreted and reclassified as TERRAIN, for\n     both single and double pulse points.\n The length (in mapping units) of each spline step is defined by \n  ew_step  for the east-west direction and  ns_step  for the \n north-south direction.\n ", "notes": "\n The input should be the output of  v.lidar.growing  module or the \n output of this  v.lidar.correction  itself. That means, this module \n could be applied more times (although, two are usually enough) for a better \n filter solution. The outputs are a vector map with a final point classification \n as as TERRAIN SINGLE PULSE, TERRAIN DOUBLE PULSE, OBJECT SINGLE PULSE or \n OBJECT DOUBLE PULSE; and an vector map with only the points classified as \n TERRAIN SINGLE PULSE or TERRAIN DOUBLE PULSE.\n The final result of the whole procedure ( v.lidar.edgedetection ,\n  v.lidar.growing ,  v.lidar.correction ) will be a point\n classification in four categories:\n TERRAIN SINGLE PULSE (cat = 1, layer = 2)\n TERRAIN DOUBLE PULSE (cat = 2, layer = 2)\n OBJECT SINGLE PULSE (cat = 3, layer = 2)\n OBJECT DOUBLE PULSE (cat = 4, layer = 2)\n  EXAMPLES \n  Basic correction procedure \n v.lidar.correction input=growing output=correction out_terrain=only_terrain\n  Second correction procedure \n v.lidar.correction input=correction output=correction_bis terrain=only_terrain_bis\n ", "see_also": ["v.lidar.edgedetection", "v.lidar.growing", "v.surf.bspline", "v.surf.rst", "v.in.lidar", "v.in.ascii"], "authors": ["Original version of program in GRASS 5.4:"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.lidar.correction"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.what.rast.html", "name": "v.what.rast", "definition": "- Uploads raster values at positions of vector points to the table.", "keywords": ["vector", "sampling", "raster", "position", "querying", "attribute table", "surface information"], "synopsis": "v.what.rast [-ip] map=name  [layer=string]   [type=string[,string,...]]  raster=name  [column=name]   [where=sql_query]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Interpolate values from the nearest four cells Print categories and values instead of updating the database Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print categories and values instead of updating the database Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector points map for which to edit attributes", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point", "alternatives": ["point", "centroid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": false, "explanation": "Name of existing raster map to be queried", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of attribute column to be updated with the query result", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.what.rast  retrieves raster value from a given raster map for each point\n or centroid stored in a given vector map. It can update a  column  in the linked\n vector attribute table with the retrieved raster cell value or print it.\n  The column type needs to be numeric (integer, float, double,\n ...). If the column doesn't exist in the vector attribute table than\n the module will create the new column of type corresponding with the\n input raster map.\n If the  -p  flag is used, then the attribute table is not updated\n and the results are printed to standard output.\n If the  -i  flag is used, then the value to be uploaded to the database\n is interpolated from the four nearest raster cells values using an inverse\n distance weighting method (IDW). This is useful for cases when the vector\n point density is much higher than the raster cell size.\n ", "notes": "\n Points and centroid with shared category number cannot be processed.\n To solved this, unique categories may be added\n with  v.category  in a separate\n layer.\n If multiple points have the same category, the attribute value is set to NULL.\n If the raster value is NULL, then attribute value is set to NULL.\n  v.what.rast  operates on the attribute table. To modify the vector\n geometry instead, use  v.drape .\n Categories and values are output unsorted with the print flag. To sort them\n pipe the output of this module into the UNIX  sort  tool\n ( sort\u00a0-n ). If you need coordinates, after sorting use\n  v.out.ascii  and the UNIX  paste  tool\n ( paste\u00a0-d'|' ). In the case of a NULL result, a \" * \"\n will be printed in lieu of the value.\n The interpolation flag is only useful for continuous value raster maps,\n if a categorical raster is given as input the results will be nonsense.\n Since the search window is limited to four raster cells there may still\n be raster cell-edge artifacts visible in the results, this compromise\n has been made for processing speed. If one or more of the nearest four\n raster cells is NULL, then only the raster cells containing values will\n be used in the weighted average.\n  EXAMPLES \n  Transferring raster values into existing attribute table of vector points map \n Reading values from raster map at position of vector points,\n writing these values into a column of the attribute table\n connected to the vector map:\n # work on copy of original geodetic points map\n g.copy vector=geodetic_pts,mygeodetic_pts\n # set computational region to raster map to be queried\n g.region raster=elev_state_500m -p\n # query raster cells (a new column will be added to existing table)\n v.what.rast map=mygeodetic_pts raster=elev_state_500m column=height\n # compare official geodetic heights to those of elevation model\n v.db.select map=mygeodetic_pts columns=Z_VALUE,height separator=comma\n  Transferring raster values into new vector points map \n In case of a vector map without attached attribute table, first add\n a new attribute table. This table is then populated with values\n queried from the raster map:\n # create new random vector points map\n v.random pnts n=100\n # add new table, link to map\n v.db.addtable map=pnts column=\"height double precision\"\n # set computational region to raster map to be queried\n g.region raster=elevation -p\n # query raster map and upload values to vector table into specified column\n v.what.rast map=pnts raster=elevation column=height\n # verify new attribute table:\n v.db.select pnts\n # verify statistics of uploaded values:\n v.univar map=pnts column=height type=point\n ", "see_also": ["v.category", "v.db.addtable", "v.db.select", "v.drape", "v.univar", "v.rast.stats", "v.what.vect"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.what.rast"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.what.html", "name": "v.what", "definition": "- Queries a vector map at given locations.", "keywords": ["vector", "querying", "position"], "synopsis": "v.what [-dagjm] map=name[,name,...]  [layer=string[,string,...]]   [type=string[,string,...]]  coordinates=east,north  [distance=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Print topological information (debugging) Print attribute information Print the stats in shell script style Print the stats in JSON Print multiple features if overlapping features are found Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Print attribute information Print the stats in shell script style Print the stats in JSON Print multiple features if overlapping features are found Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "g", "flag": "-g", "explanation": "Print the stats in shell script style Print the stats in JSON Print multiple features if overlapping features are found Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "j", "flag": "-j", "explanation": "Print the stats in JSON Print multiple features if overlapping features are found Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "m", "flag": "-m", "explanation": "Print multiple features if overlapping features are found Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map(s)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,area,face", "alternatives": ["point", "line", "boundary", "centroid", "area", "face", "kernel"], "isInputFile": false, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": false, "explanation": "Coordinates for query", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "distance", "flag": "distance", "dataType": "String", "optional": true, "explanation": "Query threshold distance", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.what  outputs the category number value(s) associated with \n user-specified location(s) in user-specified vector map layer(s).  \n This module was derived from the  d.what.vect  module by \n removing all interactive code and modification of the output for \n easy parsing. Using the  -g  flag generates script-style \n output which is easily parsable.\n  EXAMPLE \n North Carolina sample dataset example:\n Query polygon at given position:\n v.what zipcodes_wake coordinates=637502.25,221744.25\n Find closest hospital to given position within given distance (search radius):\n v.what hospitals coordinates=542690.4,204802.7 distance=2000000\n ", "notes": "", "see_also": ["d.what.rast", "d.what.vect", "v.rast.stats", "v.vect.stats", "v.what.rast", "v.what.rast3", "v.what.vect"], "authors": ["Trevor Wiens"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.what"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.voronoi.html", "name": "v.voronoi", "definition": "- Creates a Voronoi diagram constrained to the extents of the current region from an input vector map containing points or centroids.", "keywords": ["vector", "geometry", "triangulation", "skeleton"], "synopsis": "v.voronoi [-aslt] input=name  [layer=string]  output=name  [smoothness=float]   [thin=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "a", "flag": "-a", "explanation": "Create Voronoi diagram for input areas Extract skeletons for input areas Output tessellation as a graph (lines), not areas Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Extract skeletons for input areas Output tessellation as a graph (lines), not areas Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "l", "flag": "-l", "explanation": "Output tessellation as a graph (lines), not areas Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "smoothness", "flag": "smoothness", "dataType": "String", "optional": true, "explanation": "Factor for output smoothness", "defaultValue": "0.25", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "thin", "flag": "thin", "dataType": "String", "optional": true, "explanation": "Maximum dangle length of skeletons", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.voronoi  creates a Voronoi diagram (Thiessen polygons) from \n points or centroids. \n  The bounds of the output map are limited by the current region \n (see  g.region ).\n The  -a  flag can be used to create a Voronoi diagram for areas.\n The  -s  flag can be used to extract the center line of areas or \n skeletons of areas with  thin  >= 0. Smaller values for the \n  thin  option will preserve more detail, while negative values \n will extract only the center line.\n ", "notes": "\n Voronoi diagrams may be used for nearest-neighbor flood filling.\n Give the centroids attributes (start with\n  v.db.addcolumn ),\n then optionally convert the result to a raster map with\n  v.to.rast .\n The extraction of skeletons and center lines with the  -s  flag \n is a brute force approach. Faster and more accurate algorithms to \n extract skeletons from areas exist but are not yet implemented. In the \n meantime, skeletons and center lines can be simplified with the \n Douglas-Peucker algorithm: \n  v.generalize method=douglas .\n  EXAMPLE \n  Voronoi diagram for points \n This example uses the hospitals in the North Carolina dataset.\n g.region -p raster=elev_state_500m\n v.voronoi input=hospitals output=hospitals_voronoi\n Result:\n  Voronoi diagram for hospitals in North Carolina \n  Voronoi diagram for areas \n This example uses urban areas in the North Carolina dataset.\n g.region -p n=162500 s=80000 w=727000 e=846000 res=500\n v.voronoi input=urbanarea output=urbanarea_voronoi -a\n Result:\n  Voronoi diagram for urban areas in North Carolina \n  Skeletons and center lines of areas \n This example uses urban areas in the North Carolina dataset.\n g.region -p n=161000 s=135500 w=768500 e=805500 res=500\n v.voronoi input=urbanarea output=urbanarea_centerline -s\n v.voronoi input=urbanarea output=urbanarea_skeleton -s thin=2000\n Result:\n  Skeleton (blue) and center line (red) for urban areas in North Carolina \n  REFERENCES \n  Steve J. Fortune,  (1987).  A Sweepline Algorithm for\n     Voronoi Diagrams, Algorithmica 2, 153-174\n     ( DOI ). \n ", "see_also": ["g.region", "v.delaunay", "v.hull"], "authors": ["James Darrell McCauley, Purdue University"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.voronoi"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.vol.rst.html", "name": "v.vol.rst", "definition": "- Interpolates point data to a 3D raster map using regularized spline with tension (RST) algorithm.", "keywords": ["vector", "voxel", "surface", "interpolation", "RST"], "synopsis": "v.vol.rst [-c] input=name  [cross_input=name]   [wcolumn=name]   [tension=float]   [smooth=float]   [smooth_column=name]   [where=sql_query]   [deviations=name]   [cvdev=name]   [maskmap=name]   [segmax=integer]   [npmin=integer]   [npmax=integer]   [dmin=float]   [wscale=float]   [zscale=float]   [cross_output=name]   [elevation=name]   [gradient=name]   [aspect_horizontal=name]   [aspect_vertical=name]   [ncurvature=name]   [gcurvature=name]   [mcurvature=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Perform a cross-validation procedure without volume interpolation Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input 3D vector points map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "cross_input", "flag": "cross_input", "dataType": "String", "optional": true, "explanation": "Name of input surface raster map for cross-section", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "wcolumn", "flag": "wcolumn", "dataType": "String", "optional": true, "explanation": "Name of column containing w-values attribute to interpolate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tension", "flag": "tension", "dataType": "String", "optional": true, "explanation": "Tension parameter", "defaultValue": "40.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "smooth", "flag": "smooth", "dataType": "String", "optional": true, "explanation": "Smoothing parameter", "defaultValue": "0.1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "smooth_column", "flag": "smooth_column", "dataType": "String", "optional": true, "explanation": "Name of column with smoothing parameters", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "deviations", "flag": "deviations", "dataType": "String", "optional": true, "explanation": "Name for output deviations vector point map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "cvdev", "flag": "cvdev", "dataType": "String", "optional": true, "explanation": "Name for output cross-validation errors vector point map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "maskmap", "flag": "maskmap", "dataType": "String", "optional": true, "explanation": "Name of input raster map used as mask", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "segmax", "flag": "segmax", "dataType": "String", "optional": true, "explanation": "Maximum number of points in a segment", "defaultValue": "50", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "npmin", "flag": "npmin", "dataType": "String", "optional": true, "explanation": "Minimum number of points for approximation in a segment (>segmax)", "defaultValue": "200", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "npmax", "flag": "npmax", "dataType": "String", "optional": true, "explanation": "Maximum number of points for approximation in a segment (>npmin)", "defaultValue": "700", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dmin", "flag": "dmin", "dataType": "String", "optional": true, "explanation": "Minimum distance between points (to remove almost identical points)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "wscale", "flag": "wscale", "dataType": "String", "optional": true, "explanation": "Conversion factor for w-values used for interpolation", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Conversion factor for z-values", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cross_output", "flag": "cross_output", "dataType": "String", "optional": true, "explanation": "Name for output cross-section raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Name for output elevation 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "gradient", "flag": "gradient", "dataType": "String", "optional": true, "explanation": "Name for output gradient magnitude 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "aspect_horizontal", "flag": "aspect_horizontal", "dataType": "String", "optional": true, "explanation": "Name for output gradient horizontal angle 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "aspect_vertical", "flag": "aspect_vertical", "dataType": "String", "optional": true, "explanation": "Name for output gradient vertical angle 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "ncurvature", "flag": "ncurvature", "dataType": "String", "optional": true, "explanation": "Name for output change of gradient 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "gcurvature", "flag": "gcurvature", "dataType": "String", "optional": true, "explanation": "Name for output Gaussian curvature 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "mcurvature", "flag": "mcurvature", "dataType": "String", "optional": true, "explanation": "Name for output mean curvature 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.vol.rst  interpolates values to a 3-dimensional raster map from\n 3-dimensional point data (e.g. temperature, rainfall data from climatic\n stations, concentrations from drill holes etc.) given in a 3-D vector\n point file named  input .\u00a0 The size of the output \n 3D raster map  elevation  is given by the current 3D region. Sometimes, the\n user\n may want to get a 2-D map showing a modelled phenomenon at a\n crossection surface. In that case,  cross_input  and  cross_output \n options must be specified, with the output 2D raster map  cross_output \n containing the crossection of the interpolated volume with a surface \n defined by  cross_input \n 2D raster map. As an option, simultaneously with interpolation, \n geometric parameters of the interpolated\n phenomenon can be computed (magnitude of gradient, direction of\n gradient defined by horizontal and vertical angles), change of gradient,\n Gauss-Kronecker curvature, or mean curvature). These geometric\n parameteres are saved as\n 3D raster maps  gradient, aspect_horizontal, aspect_vertical, ncurvature, gcurvature, mcurvature ,\n respectively. Maps  aspect_horizontal  and  aspect_vertical  are in degrees.\n  At first, data points are checked for identical positions and points\n that are closer to each other than given  dmin  are removed.\n Parameters  wscale  and  zscale  allow the user to re-scale \n the w-values and z-coordinates of the point data (useful e.g. for \n transformation of elevations given in feet to meters, so that the \n proper values of gradient and curvatures can be computed).\n Rescaling of z-coordinates ( zscale ) is also needed when the distances\n in vertical direction are much smaller than the horizontal\n distances; if that is the case, the value of  zscale \n should be selected so that the vertical and horizontal distances\n have about the same magnitude.\n  Regularized spline with tension method is used in the interpolation.\n The  tension  parameter controls the distance over which \n each given point influences the resulting volume (with very high tension, \n each point influences only its close neighborhood and the volume goes\n rapidly to trend between the points).\n Higher values of tension parameter reduce the overshoots that\n can appear in volumes with rapid change of gradient. For noisy data, it\n is possible to define a global smoothing parameter,  smooth .\n With the\n smoothing parameter set to zero ( smooth=0 ) the resulting volume\n passes exactly through the data points. \n When smoothing is used, it is possible to output a vector map  deviations \n containing deviations of the resulting volume from the given data. \n  The user can define a 2D raster map named  maskmap , which will\n be used as a mask. The interpolation is skipped for 3-dimensional cells\n whose 2-dimensional projection has a zero value in the mask. Zero values will\n be assigned to these cells in all output 3D raster maps. \n  If the number of given points is greater than 700, segmented\n processing is used. The region is split into 3-dimensional \"box\"\n segments, each having less than  segmax  points and interpolation\n is performed on each segment of the region. To ensure the smooth\n connection of segments, the interpolation function for each segment is\n computed using the points in the given segment\n and the points in its neighborhood. The minimum number of points taken\n for interpolation is controlled by  npmin  , the value of which\n must be larger than  segmax  and less than 700. This limit of 700 was\n selected to ensure the numerical stability and efficiency of the\n algorithm. \n  SQL support \n Using the  where  parameter, the interpolation can be limited to use\n only a subset of the input vectors.\n # preparation as in above example\n v.vol.rst elevrand_3d wcol=soilrange elevation=soilrange zscale=100 where=\"soilrange > 3\"\n  Cross validation procedure \n Sometimes it can be difficult to figure out the proper values of\n interpolation parameters. In this case, the user can use a\n crossvalidation procedure using  -c  flag (a.k.a. \"jack-knife\"\n method) to find optimal parameters for given data. In this method,\n every point in the input point file is temporarily excluded from the\n computation and interpolation error for this point location is\n computed.  During this procedure no output grid files can be\n simultanuously computed.  The procedure for larger datasets may take a\n very long time, so it might be worth to use just a sample data\n representing the whole dataset.\n  Example \n  (based on  Slovakia3d dataset ): \n v.info -c precip3d\n g.region n=5530000 s=5275000 w=4186000 e=4631000 res=500 -p\n v.vol.rst -c input=precip3d wcolumn=precip zscale=50 segmax=700 cvdev=cvdevmap tension=10\n v.db.select cvdevmap\n v.univar cvdevmap col=flt1 type=point\n Based on these results, the parameters will have to be optimized. It is\n recommended to plot the CV error as curve while modifying\n the parameters.\n  The best approach is to start with  tension ,  smooth \n and  zscale  with rough steps, or to set  zscale  to a\n constant somewhere between 30-60. This helps to find minimal RMSE\n values while then finer steps can be used in all parameters. The\n reasonable range is  tension =10...100,\n  smooth =0.1...1.0,  zscale =10...100.\n  In  v.vol.rst  the tension parameter is much more sensitive to\n changes than in  v.surf.rst , \n therefore the user should always check the\n result by visual inspection. Minimizing CV does not always provide the best\n result, especially when the density of data are insufficient. Then\n the optimal result found by CV is an oversmoothed surface.\n ", "notes": "\n The vector points map must be a 3D vector map (x, y, z as geometry).\n The module  v.in.db  can be used to generate\n a 3D vector map from a table containing x,y,z columns.\n Also, the input data should be in a projected coordinate system, such as\n Universal Transverse Mercator. The module does not appear to have support for \n geographic (Lat/Long) coordinates as of May 2009.\n  v.vol.rst  uses regularized spline with tension for\n interpolation from point data (as described in Mitasova and Mitas,\n 1993). The implementation has an improved segmentation procedure based\n on Oct-trees which enhances the efficiency for large data sets. \n  Geometric parameters - magnitude of gradient ( gradient ),\n horizontal ( aspect_horizontal ) and vertical ( aspect_vertical) aspects,\n change of gradient ( ncurvature ), Gauss-Kronecker ( gcurvature ) and\n mean curvatures ( mcurvature ) are computed directly from the\n interpolation function so that the important relationships between\n these parameters are preserved. More information on these parameters\n can be found in Mitasova et al., 1995 or Thorpe, 1979.\n  The program gives warning when significant overshoots appear and\n higher tension should be used. However, with tension too high the\n resulting volume will have local maximum in each given point\n and everywhere else the volume goes rapidly to trend. With a smoothing\n parameter greater than zero, the volume will not pass through the data \n points and the higher the parameter the closer the volume will be to the \n trend. For theory on smoothing with splines see Talmi and Gilat, 1977 or Wahba, 1990. \n  If a visible connection of segments appears, the program should be\n rerun with higher  npmin  to get more points from the\n neighborhood of given segment. \n  If the number of points in a vector map is less than 400,  segmax \n should be set to 400 so that segmentation is not performed when it is\n not necessary. \n  The program gives a warning when the user wants to interpolate outside the\n \"box\" given by minimum and maximum coordinates in the input vector map. \n To remedy this, zoom into the area encompassing the input vector data points.\n  For large data sets (thousands of data points), it is suggested to\n zoom into a smaller representative area and test whether the parameters\n chosen (e.g. defaults) are appropriate. \n  The user must run  g.region  before the program to set the\n 3D region for interpolation. \n  EXAMPLES \n Spearfish example (we first simulate 3D soil range data):\n g.region -dp\n # define volume\n g.region res=100 tbres=100 res3=100 b=0 t=1500 -ap3\n ### First part: generate synthetic 3D data (true 3D soil data preferred)\n # generate random positions from elevation map (2D)\n r.random elevation.10m vector_output=elevrand n=200\n # generate synthetic values\n v.db.addcolumn elevrand col=\"x double precision, y double precision\"\n v.to.db elevrand option=coor col=x,y\n v.db.select elevrand\n # create new 3D map\n v.in.db elevrand out=elevrand_3d x=x y=y z=value key=cat\n v.info -c elevrand_3d\n v.info -t elevrand_3d\n # remove the now superfluous 'x', 'y' and 'value' (z) columns\n v.db.dropcolumn elevrand_3d col=x\n v.db.dropcolumn elevrand_3d col=y\n v.db.dropcolumn elevrand_3d col=value\n # add attribute to have data available for 3D interpolation\n # (Soil range types taken from the USDA Soil Survey)\n d.mon wx0\n d.rast soils.range\n d.vect elevrand_3d\n v.db.addcolumn elevrand_3d col=\"soilrange integer\"\n v.what.rast elevrand_3d col=soilrange rast=soils.range\n # fix 0 (no data in raster map) to NULL:\n v.db.update elevrand_3d col=soilrange value=NULL where=\"soilrange=0\"\n v.db.select elevrand_3d\n # optionally: check 3D points in Paraview\n v.out.vtk input=elevrand_3d output=elevrand_3d.vtk type=point dp=2\n paraview --data=elevrand_3d.vtk\n ### Second part: 3D interpolation from 3D point data\n # interpolate volume to \"soilrange\" voxel map\n v.vol.rst input=elevrand_3d wcol=soilrange elevation=soilrange zscale=100\n # visualize I: in GRASS GIS wxGUI\n g.gui\n # load: 2D raster map: elevation.10m\n #       3D raster map: soilrange\n # visualize II: export to Paraview\n r.mapcalc \"bottom = 0.0\"\n r3.out.vtk -s input=soilrange top=elevation.10m bottom=bottom dp=2 output=volume.vtk\n paraview --data=volume.vtk\n  KNOWN ISSUES \n  deviations  file is written as 2D and deviations are not written as attributes.\n  REFERENCES \n  Hofierka J., Parajka J., Mitasova H., Mitas L., 2002, Multivariate\n Interpolation of Precipitation Using Regularized Spline with Tension.\n Transactions in\n GIS\u00a0 6, pp. 135-150. \n  Mitas, L.,\n Mitasova, H. , 1999, Spatial Interpolation. In: P.Longley, M.F.\n Goodchild, D.J. Maguire, D.W.Rhind (Eds.), Geographical Information\n Systems: Principles, Techniques, Management and Applications, Wiley,\n pp.481-492 \n  Mitas L., Brown W. M., Mitasova H., 1997,\n  Role\n of dynamic cartography in simulations of landscape processes based on\n multi-variate fields.  Computers and Geosciences, Vol. 23, No. 4,\n pp. 437-446 (includes CDROM and WWW: www.elsevier.nl/locate/cgvis) \n  Mitasova H., Mitas L.,\u00a0 Brown W.M.,\u00a0 D.P. Gerdes, I.\n Kosinovsky, Baker, T.1995, Modeling spatially and temporally\n distributed phenomena:\n New methods and tools for GRASS GIS. International Journal of GIS, 9\n (4),\n special issue on Integrating GIS and Environmental modeling, 433-446. \n   Mitasova, H., Mitas, L., Brown, B., Kosinovsky, I., Baker, T.,\n Gerdes, D. (1994):\n  Multidimensional\n interpolation and visualization in GRASS GIS  \n  Mitasova\n H. and Mitas L. 1993 : Interpolation by Regularized Spline with\n Tension: I. Theory and Implementation,  Mathematical Geology  25,\n 641-655. \n  Mitasova\n H. and Hofierka J. 1993 : Interpolation by Regularized Spline with\n Tension: II. Application to Terrain Modeling and Surface Geometry\n Analysis,  Mathematical Geology  25, 657-667. \n  Mitasova, H., 1992 : New capabilities for interpolation and\n topographic analysis in GRASS, GRASSclippings 6, No.2 (summer), p.13. \n  Wahba, G., 1990 : Spline Models for Observational Data, CNMS-NSF\n Regional Conference series in applied mathematics, 59, SIAM,\n Philadelphia, Pennsylvania. \n  Mitas, L., Mitasova H., 1988 : General variational approach to the\n interpolation problem, Computers and Mathematics with Applications 16,\n p. 983 \n  Talmi, A. and Gilat, G., 1977 : Method for Smooth Approximation of\n Data, Journal of Computational Physics, 23, p.93-123. \n  Thorpe, J. A. (1979): Elementary Topics in Differential Geometry.\n Springer-Verlag, New York, pp. 6-94.\n ", "see_also": ["g.region", "v.in.ascii", "r3.mask", "v.in.db", "v.surf.rst", "v.univar"], "authors": ["Original version of program (in FORTRAN) and GRASS enhancements:"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.vol.rst"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.vect.stats.html", "name": "v.vect.stats", "definition": "- Count points in areas, calculate statistics from point attributes.", "keywords": ["vector", "attribute table", "database", "univariate statistics", "zonal statistics"], "synopsis": "v.vect.stats [-p] points=name areas=name  [type=string[,string,...]]   [points_layer=string]   [points_cats=range]   [points_where=sql_query]   [areas_layer=string]   [areas_cats=range]   [areas_where=sql_query]   [method=string]   [points_column=name]   [count_column=string]   [stats_column=string]   [separator=character]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print output to stdout, do not update attribute table First column is always area category Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "points", "flag": "points", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "areas", "flag": "areas", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Feature type", "defaultValue": "point", "alternatives": ["point", "centroid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "points_layer", "flag": "points_layer", "dataType": "String", "optional": true, "explanation": "Layer number for points map", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "points_cats", "flag": "points_cats", "dataType": "String", "optional": true, "explanation": "Category values for points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "points_where", "flag": "points_where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword for points map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "areas_layer", "flag": "areas_layer", "dataType": "String", "optional": true, "explanation": "Layer number for area map", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "areas_cats", "flag": "areas_cats", "dataType": "String", "optional": true, "explanation": "Category values for area map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "areas_where", "flag": "areas_where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword for area map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Method for aggregate statistics", "defaultValue": null, "alternatives": ["sum", "average", "median", "mode", "minimum", "min_cat", "maximum", "max_cat", "range", "stddev", "variance", "diversity"], "isInputFile": false, "isOutputFile": false}, {"parameter": "points_column", "flag": "points_column", "dataType": "String", "optional": true, "explanation": "Column name of points map to use for statistics", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "count_column", "flag": "count_column", "dataType": "String", "optional": true, "explanation": "Column name to upload points count", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "stats_column", "flag": "stats_column", "dataType": "String", "optional": true, "explanation": "Column name to upload statistics", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.vect.stats  counts the number of points in vector map\n  points  falling into each area in vector map  areas .\n Optionally statistics on point attributes in  points  are\n calculated for each area. The results are either uploaded to the\n attribute table of the vector map  areas  or printed to stdout.\n  Statistical Methods: \n Using numeric attribute values of all points falling into a given area,\n a new value is detmined with the selected method.\n  v.vect.stats  can perform the following operations:\n  sum  \n  The sum of values.\n  average  \n  The average value of all point attributes (sum / count).\n  median  \n  The value found half-way through a list of the\n attribute values, when these are ranged in numerical order.\n  mode  \n  The most frequently occurring value.\n  minimum  \n  The minimum observed value.\n  min_cat  \n  The point category corresponding to the minimum observed value.\n  maximum  \n  The maximum observed value.\n  max_cat  \n  The point category corresponding to the maximum observed value.\n  range  \n  The range of the observed values.\n  stddev  \n  The statistical standard deviation of the attribute values.\n  variance  \n  The statistical variance of the attribute values.\n  diversity  \n  The number of different attribute values.\n ", "notes": "\n Points not falling into any area are ignored. Areas without category\n (no centroid attached or centroid without category) are ignored. \n If no points are falling into a given area, the point count is set to 0\n (zero) and the statistics result to \"null\".\n  The columns  count_column  and  stats_column  are created if not\n existing. If they do already exist, the  count_column  must be of\n type integer and the  stats_column  of type double precision.\n  EXAMPLES \n  Preparation for examples \n The subsequent examples are based on randomly sampled\n elevation data (North Carolina sample database):\n # work on map copy for attribute editing\n g.copy vector=zipcodes_wake,myzipcodes_wake\n # set computational region: extent of ZIP code map, raster pixels\n # aligned to raster map\n g.region vector=myzipcodes_wake align=elev_state_500m -p\n #  generate random elevation points\n r.random elev_state_500m vector=rand5000 n=5000\n v.colors rand5000 color=elevation\n # visualization\n d.mon wx0\n d.vect myzipcodes_wake -c\n d.vect rand5000\n These vector maps are used for the examples below.\n  Count points per polygon with printed output \n  See above for the creation of the input maps. \n Counting points per polygon, print results to terminal:\n v.vect.stats points=rand5000 area=myzipcodes_wake -p\n  Count points per polygon with column update \n  See above for the creation of the input maps. \n Counting of points per polygon, with update of \"num_points\" column\n (will be automatically created):\n v.vect.stats points=rand5000 area=myzipcodes_wake count_column=num_points\n # verify result\n v.db.select myzipcodes_wake column=ZIPCODE_,ZIPNAME,num_points\n  Average values of points in polygon with printed output \n  See above for the creation of the input maps. \n Calculation of average point elevation per ZIP code\n polygon, printed to terminal in comma separated style:\n # check name of point map column:\n v.info -c rand5000\n v.vect.stats points=rand5000 area=myzipcodes_wake \n    method=average points_column=value separator=comma -p\n  Average values of points in polygon with column update \n  See above for the creation of the input maps. \n Calculation of average point elevation per ZIP code polygon,\n with update of \"avg_elev\" column and counting of points per polygon,\n with update of \"num_points\" column (new columns will be automatically\n created):\n # check name of point map column:\n v.info -c rand5000\n v.vect.stats points=rand5000 area=myzipcodes_wake count_column=num_points \n    method=average points_column=value stats_column=avg_elev\n # verify result\n v.db.select myzipcodes_wake column=ZIPCODE_,ZIPNAME,avg_elev\n  Point statistics in a hexagonal grid \n The grid extent and size is influenced by the current computational\n region. The extent is based on the vector map\n  points_of_interest  from the basic North Carolina sample dataset.\n g.region vector=points_of_interest res=2000 -pa\n The hexagonal grid is created using\n the  v.mkgrid  module\n as a vector map based on the previously\n selected extent and size of the grid.\n v.mkgrid map=hexagons -h\n The  v.vect.stats  module\n counts the number of points and does one statistics on a selected\n column (here:  elev_m ).\n v.vect.stats points=points_of_interest areas=hexagons method=average \n    points_column=elev_m count_column=count stats_column=average\n User should note that some of the points may be outside the grid\n since the hexagons cannot cover all the area around the edges\n (the computational region extent needs to be enlarged if all points\n should be considered).\n The last command sets the vector map color table to  viridis \n based on the  count  column.\n v.colors map=hexagons use=attr column=average color=viridis\n  \n Point statistics in a hexagonal grid (count of points, average of values\n associated with point, standard deviation)\n ", "see_also": ["v.distance", "r.distance", "v.rast.stats", "v.what.vect", "v.mkgrid"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.vect.stats"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.unpack.html", "name": "v.unpack", "definition": "- Imports a GRASS GIS specific vector archive file (packed with v.pack) as a vector map", "keywords": ["vector", "import", "copying"], "synopsis": "v.unpack [-op] input=name.pack  [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "o", "flag": "-o", "explanation": "Override projection check (use current location's projection) Assume that the dataset has same projection as the current location Print projection information of input pack file and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Print projection information of input pack file and exit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input pack file", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.unpack  allows unpacking vector maps packed by  v.pack .\n ", "notes": "\n Name of the vector map is determined by default from pack file\n internals. Optionally the name can be given by  output  parameter.\n  EXAMPLE \n Pack up vector map  random_point  into  random_point.pack  file.\n v.pack input=random_point\n the vector map can be afterwards unpacked by\n v.unpack input=random_point.pack\n ", "see_also": ["v.pack", "v.in.ogr", "r.pack"], "authors": ["Luca Delucchi, Fondazione E. Mach (Italy), based on the"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.unpack"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.univar.html", "name": "v.univar", "definition": "- Calculates univariate statistics of vector map features.", "keywords": ["vector", "statistics", "univariate statistics", "attribute table", "geometry"], "synopsis": "v.univar [-gewd] map=name  [layer=string]   [type=string[,string,...]]   [column=name]   [where=sql_query]   [percentile=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print the stats in shell script style Calculate extended statistics Weigh by line length or area size Calculate geometric distances instead of attribute statistics Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Calculate extended statistics Weigh by line length or area size Calculate geometric distances instead of attribute statistics Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Weigh by line length or area size Calculate geometric distances instead of attribute statistics Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Calculate geometric distances instead of attribute statistics Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,area", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of attribute column", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "percentile", "flag": "percentile", "dataType": "String", "optional": true, "explanation": "Percentile to calculate (requires extended statistics flag)", "defaultValue": "90", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.univar  calculates univariate statistics on (by default) an attribute\n of, or, through the  -d  flag on distance between, vector map features.\n Attributes are read per feature and per category value. This means that if the \n map contains several features with the same category value, the attribute is \n read as many times as there are features. On the other hand, if a feature has \n more than one category value, each attribute value linked to each of the \n category values of the feature is read. For statistics on one attribute \n per category value, instead of one attribute per feature and per category,\n see  v.db.univar .\n  Extended statistics ( -e ) adds median, 1st and 3rd quartiles, and 90th\n percentile to the output.\n ", "notes": "\n When using the  -d  flag, univariate statistics of distances \n between vector features are calculated. The distances from all features \n to all other features are used. Since the distance from feature A to \n feature B is the same like the distance from feature B to feature A, \n that distance is considered only once, i.e. all pairwise distances \n between features are used. Depending on the selected vector \n  type , distances are calculated as follows:\n    type=point : point distances are considered; \n    type=line : line to line distances are considered; \n    type=area : not supported, use  type=centroid  instead (and see\n \t v.distance  for calculating distances\n \tbetween areas) \n  EXAMPLE \n The example is based on the North Carolina sample dataset:\n g.region raster=elevation -p\n v.random output=samples npoints=100\n v.db.addtable map=samples columns=\"heights double precision\"\n v.what.rast map=samples rast=elevation column=heights\n v.db.select map=samples\n Calculate height attribute statistics:\n v.univar -e samples column=heights type=point\n     \n number of features with non NULL attribute: 100\n number of missing attributes: 0\n number of NULL attributes: 0\n minimum: 57.2799\n maximum: 148.903\n range: 91.6235\n sum: 10825.6\n mean: 108.256\n mean of absolute values: 108.256\n population standard deviation: 20.2572\n population variance: 410.356\n population coefficient of variation: 0.187123\n sample standard deviation: 20.3593\n sample variance: 414.501\n kurtosis: -0.856767\n skewness: 0.162093\n 1st quartile: 90.531\n median (even number of cells): 106.518\n 3rd quartile: 126.274\n 90th percentile: 135.023\n Compare to statistics of original raster map:\n r.univar -e elevation\n total null and non-null cells: 2025000\n total null cells: 0\n Of the non-null cells:\n ----------------------\n n: 2025000\n minimum: 55.5788\n maximum: 156.33\n range: 100.751\n mean: 110.375\n mean of absolute values: 110.375\n standard deviation: 20.3153\n variance: 412.712\n variation coefficient: 18.4057 %\n sum: 223510266.558102\n 1st quartile: 94.79\n median (even number of cells): 108.88\n 3rd quartile: 126.792\n 90th percentile: 138.66\n Calculate distance between sampling points statistics:\n v.univar -d samples column=heights type=point\n number of primitives: 100\n number of non zero distances: 4851\n number of zero distances: 0\n minimum: 69.9038\n maximum: 18727.7\n range: 18657.8\n sum: 3.51907e+07\n mean: 7254.33\n mean of absolute values: 7254.33\n population standard deviation: 3468.53\n population variance: 1.20307e+07\n population coefficient of variation: 0.478132\n sample standard deviation: 3468.89\n sample variance: 1.20332e+07\n kurtosis: -0.605406\n skewness: 0.238688\n ", "see_also": ["db.univar", "r.univar", "v.db.univar", "v.neighbors", "v.distance"], "authors": ["Radim Blazek, ITC-irst"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.univar"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.type.html", "name": "v.type", "definition": "- Changes type of vector features.", "keywords": ["vector", "geometry", "editing", "area", "line", "point"], "synopsis": "v.type input=name  [layer=string]  output=name from_type=string to_type=string  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "from_type", "flag": "from_type", "dataType": "String", "optional": false, "explanation": "Feature type to convert from", "defaultValue": "line", "alternatives": ["point", "line", "boundary", "centroid", "face", "kernel"], "isInputFile": false, "isOutputFile": false}, {"parameter": "to_type", "flag": "to_type", "dataType": "String", "optional": false, "explanation": "Feature type to convert to", "defaultValue": "boundary", "alternatives": ["point", "line", "boundary", "centroid", "face", "kernel"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.type  changes the type of geometry primitives.\n  EXAMPLES \n  Convert lines to area boundaries \n v.type input=map_l output=map_b from_type=line to_type=boundary\n ", "notes": "", "see_also": ["v.to.points"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.type"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.transform.html", "name": "v.transform", "definition": "- Performs an affine transformation (shift, scale and rotate) on vector map.", "keywords": ["vector", "transformation", "geometry", "GCP"], "synopsis": "v.transform [-twxyab] input=name  [layer=string]  output=name  [xshift=float]   [yshift=float]   [zshift=float]   [xscale=float]   [yscale=float]   [zscale=float]   [zrotation=float]   [columns=name[,name,...]]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Shift all z values to bottom=0 Swap coordinates x, y and then apply other parameters Swap coordinates x, z and then apply other parameters Swap coordinates y, z and then apply other parameters Swap coordinates after the other transformations Do not build topology Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Swap coordinates x, y and then apply other parameters Swap coordinates x, z and then apply other parameters Swap coordinates y, z and then apply other parameters Swap coordinates after the other transformations Do not build topology Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "x", "flag": "-x", "explanation": "Swap coordinates x, z and then apply other parameters Swap coordinates y, z and then apply other parameters Swap coordinates after the other transformations Do not build topology Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "y", "flag": "-y", "explanation": "Swap coordinates y, z and then apply other parameters Swap coordinates after the other transformations Do not build topology Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Swap coordinates after the other transformations Do not build topology Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "xshift", "flag": "xshift", "dataType": "String", "optional": true, "explanation": "Shifting value for x coordinates", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "yshift", "flag": "yshift", "dataType": "String", "optional": true, "explanation": "Shifting value for y coordinates", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zshift", "flag": "zshift", "dataType": "String", "optional": true, "explanation": "Shifting value for z coordinates", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "xscale", "flag": "xscale", "dataType": "String", "optional": true, "explanation": "Scaling factor for x coordinates", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "yscale", "flag": "yscale", "dataType": "String", "optional": true, "explanation": "Scaling factor for y coordinates", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Scaling factor for z coordinates", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zrotation", "flag": "zrotation", "dataType": "String", "optional": true, "explanation": "Rotation around z axis in degrees (counter-clockwise)", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": true, "explanation": "Name of attribute column(s) used as transformation parameters", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.transform  performs an affine transformation (translate and rotate) of a\n vector map. An affine transform includes one or several linear transformations\n (scaling, rotation) and translation (shifting). Several linear transformations\n can be combined in a single operation. The command can be used to georeference\n unreferenced vector maps or to modify existing geocoded maps.\n ", "notes": "\n Coordinate transformation based on Ground Control Points (GCPs) is done \n by  v.rectify  and not supported by\n  v.transform .\n  Transformation parameters (i.e.  xshift ,  yshift ,\n etc.) can be fetched from attribute table connected to the vector\n map. In this case vector objects can be transformed with different\n parameters based on their category number. If the parameter cannot be\n fetched from the table, default value is used instead.\n Note that the transformation matrix can be printed by\n  m.transform .\n  EXAMPLE \n  DXF/DWG drawings \n  Most DXF/DWG drawings are done within XY coordinate space. To transform \n them to a national grid, we can use  v.transform  together with \n  v.rectify  and a first-order transformation.\n v.transform -t in=watertowerXY out=watertower_z zscale=0.04 zshift=1320\n v.rectify in=watertower_z out=watertowerUTM points=wt.points order=1\n  Extrude 2D vector points to 3D based on attribute column values \n Spearfish example with manual table editing for vertical shift:\n # work on own map copy:\n g.copy vect=archsites@PERMANENT,myarchsites\n # add new 'zs' column to later store height of each site:\n v.db.addcolumn myarchsites col=\"zs double precision\"\n v.db.update myarchsites layer=1 column=zs value=\"cat * 1000\"\n # perform z transformation:\n v.transform -t input=archsites output=myarchsites3d column=\"zshift:zs\" table=\"archsites_t\"\n # drop table containing transformation parameters:\n echo \"drop table archsites_t\" | db.execute\n The resulting map is a 3D vector map.\n  Extrude 2D vector points to 3D based on attribute column values \n Spearfish example with automated elevation extraction for vertical shift:\n # work on own map copy:\n g.copy vect=archsites@PERMANENT,myarchsites\n # add new 'zs' column to later store height of each site:\n v.db.addcolumn myarchsites col=\"zs double precision\"\n # set region to elevation map and fetch individual heights:\n g.region raster=elevation.10m -p\n v.what.rast myarchsites rast=elevation.10m col=zs\n # verify:\n v.db.select myarchsites\n # perform transformation to 3D\n v.transform -t myarchsites output=myarchsites3d column=\"zshift:zs\" layer=1\n # drop table containing transformation parameters\n v.db.dropcolumn myarchsites3d col=zs\n The resulting map is a 3D vector map.\n ", "see_also": ["m.transform", "i.rectify", "v.rectify", "r.region"], "authors": ["Radim Blazek, ITC-irst, Trento, Italy,"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.transform"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.to.rast3.html", "name": "v.to.rast3", "definition": "- Converts a vector map (only points) into a 3D raster map.", "keywords": ["vector", "conversion", "voxel"], "synopsis": "v.to.rast3 input=name  [layer=string]  output=name column=name  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output 3D raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column (data type must be numeric)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.to.rast3  converts a GRASS 3D vector point map to a GRASS 3D raster map.\n ", "notes": "\n When converting from a 3D vector point layer to a 3D raster map\n a vector point is converted into a single 3D raster cell (voxel)\n representing the location of the vector point. As 3D raster cell\n value the database  attribute of the vector point is stored with\n floating point precision.\n  \n  This screenshot shows the result of the v.to.rast3 test. Visualized are the cube of the\n grass region, the vector points as black dots and the voxel cells as wireframe model. Only cells with\n non-null values are shown. \n ", "see_also": ["g.region"], "authors": ["Original s.to.rast3: Jaro Hofierka, Geomodel s.r.o."], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.to.rast3"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.to.rast.html", "name": "v.to.rast", "definition": "- Converts (rasterize) a vector map into a raster map.", "keywords": ["vector", "conversion", "raster", "rasterization"], "synopsis": "v.to.rast [-d] input=name  [layer=string]   [type=string[,string,...]]   [cats=range]   [where=sql_query]  output=name use=string  [attribute_column=name]   [rgb_column=name]   [label_column=name]   [value=float]   [memory=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "d", "flag": "-d", "explanation": "Create densified lines (default: thin lines) All cells touched by the line will be set, not only those on the render path Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,area", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "use", "flag": "use", "dataType": "String", "optional": false, "explanation": "Source of raster values", "defaultValue": null, "alternatives": ["attr", "cat", "val", "z", "dir"], "isInputFile": false, "isOutputFile": false}, {"parameter": "attribute_column", "flag": "attribute_column", "dataType": "String", "optional": true, "explanation": "Name of column for 'attr' parameter (data type must be numeric)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rgb_column", "flag": "rgb_column", "dataType": "String", "optional": true, "explanation": "Name of color definition column (with RRR:GGG:BBB entries)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "label_column", "flag": "label_column", "dataType": "String", "optional": true, "explanation": "Name of column used as raster category labels", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "value", "flag": "value", "dataType": "String", "optional": true, "explanation": "Raster value (for use=val)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used (in MB)", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.to.rast  transforms GRASS vector map layers into GRASS raster map\n layer format. Optionally, attributes can be converted to raster category\n labels.\n ", "notes": "\n In order to avoid unexpected results, the type of vector features \n should always be specified. The default is to convert all vector \n features, but if only e.g. areas should be converted use \n  type=area  rather than  type=point,line,area .\n  v.to.rast  will only affect data in areas lying\n inside the boundaries of the current geographic region.\n A grid cell belongs to the area where the grid cell center falls into.\n Before running  v.to.rast , the user should\n therefore ensure that the current geographic region is\n correctly set and that the region resolution is at the\n desired level.\n  Either the  column  parameter or the  value \n parameter must be specified.  The  use  option may be \n specified alone when using the  dir  option.\n  use  options are:\n  attr  - read values from attribute table (default)\n  cat   - read values from category\n  val   - use value specified by  value  option\n  z     - use z coordinate (points or contours only)\n  dir   - line direction in degrees counterclockwise from east (lines only)\n  The  column  parameter uses an existing column from the vector map\n database table as the category value in the output raster map. Existing table \n columns can be shown by using  db.describe .\n  An empty raster map layer will be created if the vector map layer has not\n been assigned category/attribute labels (e.g., through use of \n  v.category option=add ). \n  Otherwise:\n Labeled areas and/or centroids will produce filled raster coverages with edges \n that straddle the original area boundary  as long as the boundary is NOT \n labeled .\n  (Use  v.category option=del type=boundary  to remove.)\n Labeled lines and boundaries will produce lines of raster cells which touch the \n original vector line. This tends to be more aggressive than area-only conversions.\n Points and orphaned centroids will be converted into single cells on the\n resultant raster map.\n  Line directions  are given in degrees counterclockwise from east.\n  Raster category labels are supported for all of  use=  except  use=z .\n The  -d  flag applies only to lines and boundaries, the default is \n to set only those cells on the render path (thin line).\n Boundaries (usually without categories) can be rasterized with\n v.to.rast type=boundary layer=-1 use=val\n  EXAMPLES \n  Convert a vector map and use column SPEED from attribute table \n db.describe -c table=vect_map\n ncols:3\n Column 1: CAT\n Column 2: SPEED\n Column 3: WIDTH \n v.to.rast input=vect_map output=raster_map attribute_column=SPEED type=line\n  Calculate stream directions from a river vector map (Spearfish) \n v.to.rast input=streams output=streamsdir use=dir\n  Calculate slope along path \n Using slope and aspect maps, compute slope along a bus route (use full NC sample dataset):\n g.region raster=elevation -p\n r.slope.aspect elevation=elevation slope=slope aspect=aspect\n # compute direction of the bus route\n v.to.rast input=busroute11 type=line output=busroute11_dir use=dir\n # extract steepest slope values and transform them into slope along path\n r.mapcalc \"route_slope = if(busroute11, slope)\"\n r.mapcalc \"route_slope_dir = abs(atan(tan(slope) * cos(aspect - busroute11_dir)))\"\n Slope in degrees along bus route\n  Convert a vector polygon map to raster including descriptive labels (Spearfish) \n v.to.rast input=fields output=myfields use=attr attribute_column=cat label_column=label\n r.category myfields\n  Convert vector points to raster with raster cell binning \n In this example, the number of schools per raster cell are counted\n (North Carolina sample dataset):\n g.copy vector=schools_wake,myschools_wake\n # set computation region for raster binning\n g.region vector=myschools_wake res=5000 -p -a\n # add new column for counting\n v.db.addcolumn myschools_wake column=\"value integer\"\n v.db.update myschools_wake column=value value=1\n # verify attributes\n v.db.select myschools_wake column=cat,value\n v.out.ascii input=myschools_wake output=- column=value\n # export and import on the fly, use 4th column (value) as input\n v.out.ascii input=myschools_wake output=- column=value | r.in.xyz input=- \n              z=4 output=schools_wake_aggreg method=sum\n d.mon wx0\n d.rast schools_wake_aggreg\n d.vect schools_wake \n d.grid 5000\n Number of schools per raster cell\n ", "see_also": ["db.describe", "v.category"], "authors": ["Original code: Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.to.rast"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.to.points.html", "name": "v.to.points", "definition": "- Creates points along input lines in new vector map with 2 layers.", "keywords": ["vector", "geometry", "3D", "line", "node", "vertex", "point"], "synopsis": "v.to.points [-iprt] input=name  [layer=string]   [type=string[,string,...]]  output=name  [use=string]   [dmax=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "i", "flag": "-i", "explanation": "Interpolate points between line vertices (only for use=vertex) Use dmax as percentage of line length Start from the end node Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "p", "flag": "-p", "explanation": "Use dmax as percentage of line length Start from the end node Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Start from the end node Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Line layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid,face", "alternatives": ["point", "line", "boundary", "centroid", "area", "face", "kernel"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "use", "flag": "use", "dataType": "String", "optional": true, "explanation": "Use line nodes or vertices only", "defaultValue": null, "alternatives": ["node", "vertex"], "isInputFile": false, "isOutputFile": false}, {"parameter": "dmax", "flag": "dmax", "dataType": "String", "optional": true, "explanation": "Maximum distance between points in map units or percentage with -p", "defaultValue": "100", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.to.points  creates points along input 2D or 3D lines,\n boundaries and faces. Point features including centroids and kernels\n are copied from input vector map to the output. For details see notes\n about  type  parameter.\n The output is a vector map with 2 layers. Layer 1 holds the category\n of the input features; all points created along the same line have the\n same category, equal to the category of that line. In layer 2 each\n point has its unique category; other attributes stored in layer 2\n are  lcat  - the category of the input line and  along \n - the distance from line's start.\n By default only features with category are processed,\n see  layer  parameter for details.\n ", "notes": "\n The  dmax  parameter is the maximum limit but not an exact\n distance. To place points with exact distance from the beginning of\n the vector line the user should use\n  v.segment .\n Set  layer  to -1 to process features from all layers including\n features without category. Features will be assigned new unique\n categories at layer 1. Option  layer=-1  should be used to\n convert boundaries, as in most of cases boundaries lack category\n values.\n The  type  parameter is used to control which input vector\n geometry types to convert into points. Some caveats to consider about\n this parameter:\n    \n     Points and centroids can be considered as \"lines\" with only one\n     node. Consequently, the result of selecting  point  or\n      centroid  as the type parameter is that all\n     points/centroids get written into the output vector map. The\n     original category numbers of the input points/centroids get\n     written to the ' lcat ' attribute in layer 2 of the output\n     vector map. All values for  along  are zero in the output\n     vector map, as only point geometry was used for input (there is no\n     linear distance to calculate\n      along , as each point/centroid is the start  and \n     end of its own \"line\"). \n    \n     Boundaries are treated as lines, with points getting interpolated\n     along the boundary perimeter according to  dmax . If two\n     adjoining polygons share a topological boundary, the boundary only\n     gets converted to points once. \n    \n     If the  type  parameter is set to  area , the boundary of\n     each area is converted to points  regardless  of whether or not\n     there is a topological boundary between adjacent areas. In other\n     words, the common boundary of two adjoining areas, for example, gets\n     converted to points twice. The centroid is not converted to a point in\n     the output vector for  type=area . \n The  use=vertex  option is used to digitize points that fall on\n the line's vertices  only . Parameter  dmax  is ignored in\n this case. Similarly to  use=node  when only line's node are\n used.\n If the  -i  flag is used in conjunction with the  use=vertex  option,\n  v.to.points  will digitize points on the line vertices, as\n well as interpolate points between line vertices using  dmax  as\n the maximum allowable spacing.\n Use the  -p  flag to treat  dmax  as a percentage of each line\n length.  For example, to get points created for the beginning, middle and end\n only, use the  -p  flag and set  dmax  so that:\n  50 <  dmax  <= 100\n Hence, if  dmax  is between 0.5x and 1.0x the line length, you will\n always get points created at exactly the beginning, middle and end of\n the input line.\n Use the  -r  flag to create points starting from the end node.\n  EXAMPLE \n In this example, the 'railroads' vector lines map of the North Carolina\n sample dataset is used to create points along the input lines:\n # The North Carolina data are metric.\n # 200m distance for nodes (maximum limit but not an exact distance)\n v.to.points railroads output=railroads_nodes use=node dmax=200\n # verify the two layers in the resulting map\n v.category railroads_nodes option=report\n # vector info\n v.info railroads_nodes\n ", "see_also": ["v.segment", "v.split", "v.to.rast", "v.to.db"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.to.points"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.to.lines.html", "name": "v.to.lines", "definition": "- Converts vector polygons or points to lines.", "keywords": ["vector", "geometry", "area", "line", "point"], "synopsis": "v.to.lines input=name output=name  [method=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Method used for point interpolation", "defaultValue": "delaunay", "alternatives": ["delaunay"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.to.lines  converts vector polygons (boundaries) to lines as well\n as vector points to lines via triangulations.\n ", "notes": "\n  v.to.lines  is able to convert point data (via triangulation)\n and areas to lines (via boundary to line conversion).\n This script is a wrapper script to  v.category ,\n  v.delaunay , and  v.edit .\n In order to convert an ordered list of coordinates (ASCII table with\n x,y[,z] coordinates) into vector lines, use  v.in.lines .\n  EXAMPLES \n The examples are for the North Carolina sample dataset location:\n  Area to line conversion \n v.to.lines input=boundary_municp output=boundary_municp_lines\n  Point to line conversion \n v.to.lines input=geodetic_pts output=geodetic_pts_lines\n ", "see_also": ["v.category", "v.delaunay", "v.edit", "v.in.lines", "v.to.points", "v.type"], "authors": ["Luca Delucchi, Fondazione Edmund Mach"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.to.lines"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.to.db.html", "name": "v.to.db", "definition": "- Populates attribute values from vector features.", "keywords": ["vector", "attribute table", "database"], "synopsis": "v.to.db [-psc] map=name  [layer=string]   [type=string[,string,...]]  option=string columns=name[,name,...]  [units=string]   [query_layer=string]   [query_column=name]   [separator=character]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "p", "flag": "-p", "explanation": "Print only Only print SQL statements Print also totals for option length, area, or count Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "s", "flag": "-s", "explanation": "Only print SQL statements Print also totals for option length, area, or count Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Print also totals for option length, area, or count Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name (write to)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Feature type", "defaultValue": "point,line,boundary,centroid", "alternatives": ["point", "line", "boundary", "centroid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "option", "flag": "option", "dataType": "String", "optional": false, "explanation": "Value to upload", "defaultValue": null, "alternatives": ["cat", "area", "compact", "fd", "perimeter", "length", "count", "coor", "start", "end", "sides", "query", "slope", "sinuous", "azimuth", "bbox"], "isInputFile": false, "isOutputFile": false}, {"parameter": "columns", "flag": "columns", "dataType": "String", "optional": false, "explanation": "Name of attribute column(s) to populate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Units", "defaultValue": null, "alternatives": ["miles", "feet", "meters", "kilometers", "acres", "hectares", "radians", "degrees"], "isInputFile": false, "isOutputFile": false}, {"parameter": "query_layer", "flag": "query_layer", "dataType": "String", "optional": true, "explanation": "Query layer number or name (read from)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "query_column", "flag": "query_column", "dataType": "String", "optional": true, "explanation": "Name of attribute column used for 'query' option", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator for print mode", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.to.db  loads vector map features or metrics into a database\n table, or prints them (or the SQL queries used to obtain them) in a\n form of a human-readable report. For uploaded/printed category values\n '-1' is used for 'no category' and 'null'/'-' if category cannot be\n found or multiple categories were found. For line azimuths '-1' is used\n for closed lines (start equals end).\n ", "notes": "\n Measures of lengths and areas are always reported in meters, unless the\n  unit  parameter is set.\n The units  miles ,  feet ,  meters  and\n  kilometers  are square for  option=area .\n  Feet and acre units are always reported in their common versions\n (i.e. the International Foot, exactly 5280 feet in a mile), even\n when the location's standard map unit is the US Survey foot.\n  When calculating perimeters in Latitude-Longitude locations, the geodesic\n distance between the vertices is used.\n  When using  option=coor  on a vector area map, \n only coordinates of centroids with unique category will be reported.\n  When using  option=bbox  on a vector area map with more than one\n feature per category value, the results corresponds to the bounding box of \n all features of same category taken together.\n  Line azimuth is calculated as angle from the North direction to the line endnode\n direction at the line statnode. By default it's reported in decimal degrees (0-360, CW) but\n it also may be repored in radians with  unit=radians . Azimuth value\n  -1  is used to report closed line with it's startnode and endnode being in\n same place. Azimuth values make sense only if every vector line has only one\n entry in database (unique CAT value).\n  If the module is apparently slow  and  the map attributes are\n stored in an external DBMS such as PostgreSQL, it is highly recommended\n to create an index on the key (category) column.\n  Uploading the vector map attributes to a database requires a table attached to\n a given input vector  layer . The  print only  ( -p ) mode\n doesn't require a table. Use  db.execute \n or  v.db.addtable  to create a table if\n needed.\n  Updating the table has to be done column-wise. The  column  must be\n present in the table, except when using the  print only  ( -p )\n mode. Use  db.execute  or\n  v.db.addcolumn  to add new columns if\n needed.\n  EXAMPLES \n  Updating attribute tables \n Upload category numbers to attribute table (used for new map): \n v.to.db map=soils type=centroid option=cat\n  Upload polygon areas to corresponding centroid record in the attribute table: \n v.to.db map=soils type=centroid option=area columns=area_size unit=h\n  Upload line lengths (in meters) of each vector line to attribute table\n (use  v.category  in case of missing categories): \n v.to.db map=roads option=length type=line columns=linelength units=me\n  Upload x and y coordinates from vector geometry to attribute table: \n v.to.db map=pointsmap option=coor columns=x,y\n  Upload x, y and z coordinates from vector geometry to attribute table: \n v.to.db map=pointsmap option=coor columns=x,y,z\n  Transfer attributes from a character column (with numeric contents) to a new\n integer column: \n v.db.addcolumn usa_income_employment2002 col=\"FIPS_NUM integer\"\n v.to.db usa_income_employment2002 option=query columns=FIPS_NUM query_column=STATE_FIPS\n  Upload category numbers of left and right area, to an attribute table of\n boundaries common for the areas: \n # add categories for boundaries of the input vector map, in layer 2:\n v.category soils out=mysoils layer=2 type=boundary option=add\n # add a table with columns named \"left\" and \"right\" to layer 2 of the input\n # vector map:\n v.db.addtable mysoils layer=2 columns=\"left integer,right integer\"\n # upload categories of left and right areas:\n v.to.db mysoils option=sides columns=left,right layer=2\n # display the result:\n v.db.select mysoils layer=2\n  Compute D L , the Fractal Dimension (Mandelbrot, 1982), of the\n boundary defining a polygon based on the formula:\n D = 2 * (log perimeter) / (log area): \n g.copy vect=soils,mysoils\n v.db.addcolumn mysoils col=\"d double precision\"\n v.to.db mysoils option=fd column=\"d\"\n g.region vector=mysoils res=50\n v.to.rast input=mysoils output=soils_fd type=area use=attr attribute_column=d\n r.colors map=soils_fd color=gyr\n d.mon wx0\n d.rast.leg soils_fd\n d.vect mysoils type=boundary\n  Printing reports \n Report x,y,z coordinates of points in the input vector map: \n v.to.db -p bugsites option=coor type=point\n Report all area sizes of the input vector map: \n v.to.db -p soils option=area type=boundary units=h\n  Report all area sizes of the input vector map, in hectares, sorted by category\n number (requires GNU  sort  utility installed): \n v.to.db -p soils option=area type=boundary units=h | sort -n\n  Report all line lengths of the input vector map, in kilometers: \n v.to.db -p roads option=length type=line units=k\n  Report number of features for each category in the input vector map: \n v.to.db -p roads option=count type=line\n ", "see_also": ["d.what.vect", "db.execute", "v.category", "v.db.addtable", "v.db.addcolumn", "v.db.connect", "v.distance", "v.report", "v.univar", "v.what"], "authors": ["Radim Blazek, ITC-irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.to.db"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.to.3d.html", "name": "v.to.3d", "definition": "- Performs transformation of 2D vector features to 3D.", "keywords": ["vector", "geometry", "3D"], "synopsis": "v.to.3d [-rt] input=name  [layer=string]   [type=string[,string,...]]  output=name  [column=name]   [height=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Reverse transformation; 3D vector features to 2D Do not copy attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Do not copy attribute table Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid", "alternatives": ["point", "line", "boundary", "centroid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of attribute column used for height", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "height", "flag": "height", "dataType": "String", "optional": true, "explanation": "Fixed height for 3D vector features", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n The  v.to.3d  module is used to transform 2D vector features\n to 3D. Height (z-coordinate) of 3D vector features can be specified\n by  height  parameter as fixed value or by  column \n parameter.\n Flag  -r  enables to perform reverse transformation, i.e.,\n transform 3D vector to 2D by omitting z-coordinate. Height of input 3D\n features can be optionally stored in  column .\n   NOTES \n When transforming 2D vector features to 3D based on attribute, all\n NULL values are silently converted to height 0.0.\n Reverse transformation is possible for points and lines.\n In case of lines, the reverse transformation should be used\n only when all vertices of a line have the same z-coordinate\n (for example contours).\n  EXAMPLES \n  Transform 2D vector features to 3D \n # convert z-values from string to double\n v.db.addcolumn map=geodetic_pts columns=\"Z_VALUE_D double precision\"\n v.db.update map=geodetic_pts column=Z_VALUE_D qcolumn=Z_VALUE\n v.db.select map=geodetic_pts columns=cat,Z_VALUE,Z_VALUE_D\n # convert 2D vector point map to 3D based on attribute\n v.to.3d input=geodetic_pts out=geodetic_pts_3d column=Z_VALUE_D\n  Transform 3D vector features to 2D \n v.to.3d -rt input=elev_lid792_bepts output=elev_lid_2d\n ", "notes": "", "see_also": ["v.transform", "v.extrude", "v.drape"], "authors": ["Martin Landa, Czech Technical University in Prague, Czech Republic"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.to.3d"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.timestamp.html", "name": "v.timestamp", "definition": "- Modifies a timestamp for a vector map.", "keywords": ["vector", "metadata", "timestamp", "time"], "synopsis": "v.timestamp map=name  [layer=string]   [date=timestamp]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "date", "flag": "date", "dataType": "String", "optional": true, "explanation": "Datetime, datetime1/datetime2, or 'none' to remove", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n This command has 2 modes of operation. If no  date  argument is\n supplied, then the current timestamp for the vector map is printed. If\n a date argument is specified, then the timestamp for the vector map is\n set to the specified date(s). See examples below.\n See  TIMESTAMP FORMAT \n description for details.\n ", "notes": "\n Strings containing spaces should be quoted. For specifying a range of\n time, the two timestamps should be separated by a forward slash. To\n remove the timestamp from a vector map, use  date=none .\n  EXAMPLES \n Prints the timestamp for the \"lidar\" vector map. If there is no\n timestamp for \"lidar\", nothing is printed. If there is a timestamp,\n one or two time strings are printed, depending on if the timestamp for\n the map consists of a single date or two dates (ie start and end\n dates).\n v.timestamp map=lidar\n Sets the timestamp for \"lidar\" to the single date \"15 sep 1987\".\n v.timestamp map=lidar date='15 sep 1987'\n Sets the timestamp for \"lidar\" to have the start date \"15 sep 1987\"\n and the end date \"20 feb 1988\".\n v.timestamp map=lidar date='15 sep 1987/20 feb 1988'\n Removes the timestamp for the \"lidar\" vector map.\n v.timestamp map=lidar date=none\n  KNOWN ISSUES \n Spaces in the timestamp value are required.\n ", "see_also": ["v.info", "r.timestamp", "r3.timestamp"], "authors": ["Michael Shapiro, U.S.Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.timestamp"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.surf.rst.html", "name": "v.surf.rst", "definition": "- Performs surface interpolation from vector points map by splines.", "keywords": ["vector", "surface", "interpolation", "3D"], "synopsis": "v.surf.rst [-ctd] input=name  [layer=string]   [zcolumn=name]   [where=sql_query]   [elevation=name]   [slope=name]   [aspect=name]   [pcurvature=name]   [tcurvature=name]   [mcurvature=name]   [deviations=name]   [cvdev=name]   [treeseg=name]   [overwin=name]   [nprocs=integer]   [mask=name]   [tension=float]   [smooth=float]   [smooth_column=string]   [segmax=integer]   [npmin=integer]   [dmin=float]   [dmax=float]   [zscale=float]   [theta=float]   [scalex=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Perform cross-validation procedure without raster approximation Use scale dependent tension Output partial derivatives instead of topographic parameters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "t", "flag": "-t", "explanation": "Use scale dependent tension Output partial derivatives instead of topographic parameters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Output partial derivatives instead of topographic parameters Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zcolumn", "flag": "zcolumn", "dataType": "String", "optional": true, "explanation": "Name of the attribute column with values to be used for approximation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "elevation", "flag": "elevation", "dataType": "String", "optional": true, "explanation": "Name for output surface elevation raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "slope", "flag": "slope", "dataType": "String", "optional": true, "explanation": "Name for output slope raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "aspect", "flag": "aspect", "dataType": "String", "optional": true, "explanation": "Name for output aspect raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "pcurvature", "flag": "pcurvature", "dataType": "String", "optional": true, "explanation": "Name for output profile curvature raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "tcurvature", "flag": "tcurvature", "dataType": "String", "optional": true, "explanation": "Name for output tangential curvature raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "mcurvature", "flag": "mcurvature", "dataType": "String", "optional": true, "explanation": "Name for output mean curvature raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "deviations", "flag": "deviations", "dataType": "String", "optional": true, "explanation": "Name for output deviations vector point map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "cvdev", "flag": "cvdev", "dataType": "String", "optional": true, "explanation": "Name for output cross-validation errors vector point map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "treeseg", "flag": "treeseg", "dataType": "String", "optional": true, "explanation": "Name for output vector map showing quadtree segmentation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "overwin", "flag": "overwin", "dataType": "String", "optional": true, "explanation": "Name for output vector map showing overlapping windows", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "nprocs", "flag": "nprocs", "dataType": "String", "optional": true, "explanation": "Number of threads for parallel computing", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mask", "flag": "mask", "dataType": "String", "optional": true, "explanation": "Name of raster map used as mask", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "tension", "flag": "tension", "dataType": "String", "optional": true, "explanation": "Tension parameter", "defaultValue": "40.", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "smooth", "flag": "smooth", "dataType": "String", "optional": true, "explanation": "Smoothing parameter", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "smooth_column", "flag": "smooth_column", "dataType": "String", "optional": true, "explanation": "Name of the attribute column with smoothing parameters", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "segmax", "flag": "segmax", "dataType": "String", "optional": true, "explanation": "Maximum number of points in a segment", "defaultValue": "40", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "npmin", "flag": "npmin", "dataType": "String", "optional": true, "explanation": "Minimum number of points for approximation in a segment (>segmax)", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dmin", "flag": "dmin", "dataType": "String", "optional": true, "explanation": "Minimum distance between points (to remove almost identical points)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dmax", "flag": "dmax", "dataType": "String", "optional": true, "explanation": "Maximum distance between points on isoline (to insert additional points)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Conversion factor for values used for approximation", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "theta", "flag": "theta", "dataType": "String", "optional": true, "explanation": "Anisotropy angle (in degrees counterclockwise from East)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "scalex", "flag": "scalex", "dataType": "String", "optional": true, "explanation": "Anisotropy scaling factor", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.surf.rst  program performs spatial approximation based on\n  z-values  (input vector map is 3D and  zcolumn  parameter\n is not given),  categories  (input vector map is 2D\n and  zcolumn  parameter is not given), or  attributes \n ( zcolumn  parameter is given) of point or isoline data given in\n a vector map named  input  to grid cells in the output raster\n map  elevation  representing a surface.\n As an option, simultaneously with approximation, topographic\n parameters slope, aspect, profile curvature (measured in the direction\n of the steepest slope), tangential curvature (measured in the\n direction of a tangent to contour line) or mean curvature are computed\n and saved as raster maps specified by the options  slope, aspect,\n pcurv, tcurv, mcurv  respectively. If  -d  flag is\n set,  v.surf.rst  outputs partial derivatives\n f x ,f y ,f xx ,\n f yy ,f xy  instead of slope, aspect, profile,\n tangential and mean curvatures respectively. If the input vector map\n have time stamp, the program creates time stamp for all output maps.\n User can either use  r.mask  to set a mask\n or specify a raster map in  mask  option, which will be used\n as a mask. The approximation is skipped for cells which have zero or\n NULL value in mask. NULL values will be assigned to these cells in all\n output raster maps. Data points are checked for identical points and\n points that are closer to each other than the given  dmin  are\n removed.  If sparsely digitized contours or isolines are used as\n input, additional points are computed between each 2 points on a line\n if the distance between them is greater than\n specified  dmax . Parameter\n  zmult  allows user to rescale the values used for approximation\n  (useful e.g. for transformation of\n elevations given in feet to meters, so that the proper values of slopes\n and curvatures can be computed).\n Regularized spline with tension is used for the approximation. The\n  tension  parameter tunes the character of the resulting surface\n from thin plate to membrane. Smoothing parameter  smooth \n controls the deviation between the given points and the resulting\n surface and it can be very effective in smoothing noisy data while\n preserving the geometrical properties of the surface.  With the\n smoothing parameter set to zero ( smooth=0 ) the resulting\n surface passes exactly through the data points (spatial interpolation\n is performed). When smoothing parameter is used, it is also possible\n to output a vector point map  deviations  containing deviations of the\n resulting surface from the given data.\n If the number of given points is greater than  segmax , segmented\n processing is used. The region is split into quadtree-based\n rectangular segments, each having less than  segmax  points and\n approximation is performed on each segment of the region. To ensure\n smooth connection of segments the approximation function for each\n segment is computed using the points in the given segment and the\n points in its neighborhood which are in the rectangular window\n surrounding the given segment. The number of points taken for\n approximation is controlled by  npmin , the value of which must\n be larger than  segmax .  User can choose to output vector\n maps  treeseg  and  overwin  which represent the quad tree\n used for segmentation and overlapping neighborhoods from which\n additional points for approximation on each segment were taken.\n Predictive error of surface approximation for given parameters can be\n computed using the  -c  flag. A crossvalidation procedure is then\n performed using the data given in the vector map  input  and the\n estimated predictive errors are stored in the vector point map\n  cvdev . When using this flag, no raster output maps are computed.\n Anisotropic surfaces can be interpolated by setting anisotropy\n angle  theta  and scaling factor  scalex .  The program\n writes values of selected input and internally computed parameters to\n the history file of raster map\n  elevation .\n The user must run  g.region  before\n the program to set the region and resolution for approximation.\n ", "notes": "\n  v.surf.rst  uses regularized spline with tension for\n approximation from vector data. The module does not require input data\n with topology, therefore both level1 (no topology) and level2 (with\n topology) vector point data are supported.  Additional points are used\n for approximation between each 2 points on a line if the distance\n between them is greater than specified  dmax . If  dmax  is\n small (less than cell size) the number of added data points can be\n vary large and slow down approximation significantly.  The\n implementation has a segmentation procedure based on quadtrees which\n enhances the efficiency for large data sets. Special color tables are\n created by the program for output raster maps.\n Topographic parameters are computed directly from the approximation\n function so that the important relationships between these parameters\n are preserved. The equations for computation of these parameters and\n their interpretation is described in\n  Mitasova and Hofierka, 1993 \n or Neteler and Mitasova, 2004).\n Slopes and aspect are computed in degrees (0-90 and 1-360 respectively).\n The aspect raster map has value 0 assigned to flat areas (with slope less\n than 0.1%) and to singular points with undefined aspect. Aspect points\n downslope and is 90 to the North, 180 to the West, 270 to the South and\n 360 to the East, the values increase counterclockwise. Curvatures are positive\n for convex and negative for concave areas. Singular points with undefined\n curvatures have assigned zero values.\n Tension and smoothing allow user to tune the surface character.\n For most landscape scale applications the default values should\n provide adequate results.  The program gives warning when significant\n overshoots appear in the resulting surface and higher tension or\n smoothing should be used.\n To select parameters that will produce a surface with desired\n properties, it is useful to know that the method is scale dependent\n and the tension works as a rescaling parameter (high tension\n \"increases the distances between the points\" and reduces the\n range of impact of each point, low tension \"decreases the\n distance\" and the points influence each other over longer\n range). Surface with tension set too high behaves like a membrane\n (rubber sheet stretched over the data points) with peak or pit\n (\"crater\") in each given point and everywhere else the\n surface goes rapidly to trend. If digitized contours are used as input\n data, high tension can cause artificial waves along contours. Lower\n tension and higher smoothing is suggested for such a case.\n Surface with  tension  set too low behaves like a stiff steel\n plate and overshoots can appear in areas with rapid change of gradient\n and segmentation can be visible. Increase in tension should solve the\n problems.\n There are two options how  tension  can be applied in relation\n to  dnorm  (dnorm rescales the coordinates depending on the\n average data density so that the size of segments\n with  segmax= 40 points is around 1 - this ensures the numerical\n stability of the computation):\n    Default: the given  tension  is applied to normalized data\n     ( x/dnorm ), that means that the distances are multiplied\n     (rescaled) by  tension/dnorm . If density of points is\n     changed, e.g., by using higher  dmin , the  dnorm \n     changes and  tension  needs to be changed too to get the same\n     result.  Because the  tension  is applied to normalized data\n     its suitable value is usually within the 10-100 range and does not\n     depend on the actual scale (distances) of the original data (which\n     can be km for regional applications or cm for field\n     experiments). \n    Flag -t : The given  tension  is applied to\n     un-normalized data (rescaled  tension = tension*dnorm/1000 \n     is applied to normalized data ( x/dnorm ) and\n     therefore  dnorm  cancels out) so here  tension  truly\n     works as a rescaling parameter.  For regional applications with\n     distances between points in km the suitable tension can be 500 or\n     higher, for detailed field scale analysis it can be 0.1. To help\n     select how much the data need to be rescaled the program\n     writes  dnorm  and rescaled tension\n      fi=tension*dnorm/1000  at the beginning of the program\n     run. This rescaled  tension  should be around 20-30. If it is\n     lower or higher, the given  tension  parameter should be\n     changed accordingly. \n The default is a recommended choice, however for the applications\n where the user needs to change density of data and preserve the\n approximation character the  -t  flag can be helpful.\n Anisotropic data (e.g. geologic phenomena) can be interpolated\n using  theta  and  scalex  defining orientation and ratio of\n the perpendicular axes put on the longest/shortest side of the\n feature, respectively.  Theta  is measured in degrees from East,\n counterclockwise.  Scalex  is a ratio of axes sizes.\n Setting  scalex  in the range 0-1, results in a pattern prolonged\n in the direction defined by  theta .  Scalex  value 0.5\n means that modeled feature is approximately 2 times longer in the\n direction of  theta  than in the perpendicular direction.\n  Scalex  value 2 means that axes ratio is reverse resulting in a\n pattern perpendicular to the previous example. Please note that\n anisotropy option has not been extensively tested and may include bugs\n (for example, topographic parameters may not be computed correctly) -\n if there are problems, please report to GRASS bugtracker (accessible\n from  http://grass.osgeo.org/ ). \n For data with values changing over several magnitudes (sometimes the\n concentration or density data) it is suggested to interpolate the log\n of the values rather than the original ones.\n  v.surf.rst  checks the numerical stability of the algorithm by\n computing the values in given points, and prints the root mean square\n deviation (rms) found into the history file of raster\n map  elevation . For computation with smoothing set to 0, rms\n should be 0. Significant increase in  tension  is suggested if\n the rms is unexpectedly high for this case. With smoothing parameter\n greater than zero the surface will not pass exactly through the data\n points and the higher the parameter the closer the surface will be to\n the trend. The rms then represents a measure of smoothing effect on\n data. More detailed analysis of smoothing effects can be performed\n using the output deviations option.\n  v.surf.rst  also writes the values of parameters used in\n computation into the comment part of history file  elevation  as\n well as the following values which help to evaluate the results and\n choose the suitable parameters: minimum and maximum z values in the\n data file (zmin_data, zmax_data) and in the interpolated raster map\n (zmin_int, zmax_int), rescaling parameter used for normalization\n (dnorm), which influences the tension.\n If visible connection of segments appears, the program should be rerun\n with higher  npmin  to get more points from the neighborhood of\n given segment and/or with higher tension.\n When the number of points in a vector map is not too large (less than\n 800), the user can skip segmentation by setting  segmax  to the\n number of data points or  segmax=700 .\n  v.surf.rst  gives warning when user wants to interpolate\n outside the rectangle given by minimum and maximum coordinates in the\n vector map, zoom into the area where the given data are is suggested\n in this case.\n When a  mask  is used, the program takes all points in the given\n region for approximation, including those in the area which is masked\n out, to ensure proper approximation along the border of the mask. It\n therefore does not mask out the data points, if this is desirable, it\n must be done outside  v.surf.rst .\n  Cross validation procedure \n The \"optimal\" approximation parameters for given data can be\n found using a cross-validation (CV) procedure ( -c  flag).  The\n CV procedure is based on removing one input data point at a time,\n performing the approximation for the location of the removed point\n using the remaining data points and calculating the difference between\n the actual and approximated value for the removed data point. The\n procedure is repeated until every data point has been, in turn,\n removed. This form of CV is also known as the\n \"leave-one-out\" or \"jack-knife\" method (Hofierka\n et al., 2002; Hofierka, 2005). The differences (residuals) are then\n stored in the  cvdev  output vector map. Please note that during\n the CV procedure no other output maps can be set, the approximation is\n performed only for locations defined by input data.  To find\n \"optimal parameters\", the CV procedure must be iteratively\n performed for all reasonable combinations of the approximation\n parameters with small incremental steps (e.g. tension, smoothing) in\n order to find a combination with minimal statistical error (also\n called predictive error) defined by root mean squared error (RMSE),\n mean absolute error (MAE) or other error characteristics.  A script\n with loops for tested RST parameters can do the job, necessary\n statistics can be calculated using\n e.g.  v.univar . It should be noted\n that crossvalidation is a time-consuming procedure, usually reasonable\n for up to several thousands of points. For larger data sets, CV should\n be applied to a representative subset of the data. The\n cross-validation procedure works well only for well-sampled phenomena\n and when minimizing the predictive error is the goal.  The parameters\n found by minimizing the predictive (CV) error may not not be the best\n for for poorly sampled phenomena (result could be strongly smoothed\n with lost details and fluctuations) or when significant noise is\n present that needs to be smoothed out.\n  EXAMPLE \n Using the  where  parameter, the interpolation can be limited to\n use only a subset of the input vectors.\n Spearfish example (we simulate randomly distributed elevation\n measures):\n g.region raster=elevation.10m -p\n # random elevation extraction\n r.random elevation.10m vector_output=elevrand n=200\n v.info -c elevrand\n v.db.select elevrand\n # interpolation based on all points\n v.surf.rst elevrand zcol=value elevation=elev_full\n r.colors elev_full rast=elevation.10m\n d.rast elev_full\n d.vect elevrand\n # interpolation based on subset of points (only those over 1300m/asl)\n v.surf.rst elevrand zcol=value elevation=elev_partial where=\"value > 1300\"\n r.colors elev_partial rast=elevation.10m\n d.rast elev_partial\n d.vect elevrand where=\"value > 1300\"\n   REFERENCES \n    \n       Mitasova, H., Mitas, L. and Harmon, R.S., 2005,  \n     Simultaneous spline approximation and topographic analysis for\n     lidar elevation data in open source GIS, IEEE GRSL 2 (4), 375- 379. \n    Hofierka, J., 2005, Interpolation of Radioactivity Data Using Regularized Spline with Tension. Applied GIS, Vol. 1, No. 2, pp. 16-01 to 16-13. DOI: 10.2104/ag050016 \n    \n       Hofierka J., Parajka J., Mitasova H., Mitas L., 2002,  Multivariate\n     Interpolation of Precipitation Using Regularized Spline with Tension.\n     Transactions in GIS 6(2), pp. 135-150. \n    H. Mitasova, L. Mitas, B.M. Brown, D.P. Gerdes, I. Kosinovsky, 1995, Modeling\n     spatially and temporally distributed phenomena: New methods and tools for\n     GRASS GIS. International Journal of GIS, 9 (4), special issue on Integrating\n     GIS and Environmental modeling, 433-446. \n    \n       Mitasova, H. and Mitas, L., 1993 : \n     Interpolation by Regularized Spline with Tension: \n     I. Theory and Implementation, Mathematical Geology ,25, 641-655. \n    \n       Mitasova, H. and Hofierka, J., 1993 : Interpolation\n     by Regularized Spline with Tension: II. Application to Terrain Modeling\n     and Surface Geometry Analysis, Mathematical Geology 25, 657-667. \n    \n       Mitas, L., and Mitasova H., 1988,   General variational approach to the approximation\n     problem, Computers and Mathematics with Applications, v.16, p. 983-992. \n    \n       Neteler, M. and Mitasova, H., 2008, Open Source GIS: A GRASS GIS Approach, 3rd Edition,   \n     Springer, New York, 406 pages. \n    Talmi, A. and Gilat, G., 1977 : Method for Smooth Approximation of Data,\n     Journal of Computational Physics, 23, p.93-123. \n    Wahba, G., 1990, : Spline Models for Observational Data, CNMS-NSF Regional\n     Conference series in applied mathematics, 59, SIAM, Philadelphia, Pennsylvania. \n ", "see_also": ["v.vol.rst", "v.surf.idw", "v.surf.bspline", "r.fillnulls", "g.region"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.surf.rst"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.surf.idw.html", "name": "v.surf.idw", "definition": "- Provides surface interpolation from vector point data by Inverse Distance Squared Weighting.", "keywords": ["vector", "surface", "interpolation", "IDW"], "synopsis": "v.surf.idw [-n] input=name  [layer=string]   [column=name]  output=name  [npoints=count]   [power=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Don't index points by raster cell Slower but uses less memory and includes points from outside region in the interpolation Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of attribute column with values to interpolate", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "npoints", "flag": "npoints", "dataType": "String", "optional": true, "explanation": "Number of interpolation points", "defaultValue": "12", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "power", "flag": "power", "dataType": "String", "optional": true, "explanation": "Power parameter", "defaultValue": "2.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.surf.idw  fills a raster matrix with interpolated values\n generated from a set of irregularly spaced vector data points using\n numerical approximation (weighted averaging) techniques. The\n interpolated value of a cell is determined by values of nearby data\n points and the distance of the cell from those input points.  In\n comparison with other methods, numerical approximation allows\n representation of more complex surfaces (particularly those with\n anomalous features), restricts the spatial influence of any errors,\n and generates the interpolated surface from the data points.\n  Values to interpolate are read from  column  option. If this\n option is not given than the program uses  categories  as values\n to interpolate or  z-coordinates  if the input vector map is 3D.\n ", "notes": "\n  The amount of memory used by this program is related to the number\n of vector points in the current region.  If the vector point map is \n very dense (i.e., contains many data points), the program may\n not be able to get all the memory it needs from the\n system.  The time required to execute is related to the \n resolution of the current region, after an initial delay \n determined by the time taken to read the input vector points map.\n Note that vector features without category in given  layer  are\n  skipped .\n  If the user has a mask set, then interpolation is only done\n for those cells that fall within the mask. The module has two separate\n modes of operation for selecting the vector points that are used in the\n interpolation: \n  Simple, non-indexed mode (activated by  -n  flag) \n  When the  -n  flag is specified, all vector points in the\n input vector map are searched through in order to find the\n  npoints  closest points to the centre of each cell in the output\n raster map. This mode of operation can be slow in the case of a very\n large number of vector points. \n  Default, indexed mode \n  By default (i.e. if  -n  flag is  not  specified), prior to\n the interpolation, input vector points are indexed according to which\n output raster cell they fall into. This means that only cells nearby\n the one being interpolated need to be searched to find the\n  npoints  closest input points, and the module can run many times\n faster on dense input maps. It should be noted that:\n  Only vector points that lie within the current region are used in\n the interpolation. If there are points outside the current region,\n this may have an effect on the interpolated value of cells near the\n edges of the region, and this effect will be more pronounced the fewer\n points there are. If you wish to also include points outside the\n region in the interpolation, then either use the  -n  flag, or\n set the region to a larger extent (covering all input points) and use\n a mask to limit interpolation to a smaller area. \n  If more than  npoints  points fall within a given cell then,\n rather than interpolating, these points are aggregated by taking the\n mean. This avoids the situation where some vector points can be\n discarded and not used in the interpolation, for very dense input\n maps. Again, use the  -n  flag if you wish to use only the\n  npoints  closest points to the cell centre under all\n circumstances. \n  \n The  power  parameter defines an exponential distance weight.\n Greater values assign greater influence to values closer to the\n point to be interpolated. The interpolation function peaks sharply over\n the given data points for 0 <  p  < 1 and more smoothly for\n larger values. The default value for the power parameter is 2.  \n By setting  npoints =1, the module can be used to calculate\n raster Voronoi diagrams (Thiessen polygons).\n ", "see_also": ["g.region", "r.surf.contour", "r.surf.idw", "r.surf.gauss", "r.surf.fractal", "r.surf.random", "v.surf.rst"], "authors": ["Michael Shapiro, U.S. Army Construction Engineering Research Laboratory"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.surf.idw"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.surf.bspline.html", "name": "v.surf.bspline", "definition": "- Performs bicubic or bilinear spline interpolation with Tykhonov regularization.", "keywords": ["vector", "surface", "interpolation", "LIDAR"], "synopsis": "v.surf.bspline [-ce] input=name  [layer=string]   [column=name]   [sparse_input=name]   [output=name]   [raster_output=name]   [mask=name]   [ew_step=float]   [ns_step=float]   [method=string]   [lambda_i=float]   [solver=name]   [maxit=integer]   [error=float]   [memory=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Find the best Tykhonov regularizing parameter using a \"leave-one-out\" cross validation method Estimate point density and distance Estimate point density and distance in map units for the input vector points within the current region extents and quit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "e", "flag": "-e", "explanation": "Estimate point density and distance Estimate point density and distance in map units for the input vector points within the current region extents and quit Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector point map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of the attribute column with values to be used for approximation", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "sparse_input", "flag": "sparse_input", "dataType": "String", "optional": true, "explanation": "Name of input vector map with sparse points", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "raster_output", "flag": "raster_output", "dataType": "String", "optional": true, "explanation": "Name for output raster map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "mask", "flag": "mask", "dataType": "String", "optional": true, "explanation": "Raster map to use for masking (applies to raster output only)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ew_step", "flag": "ew_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the east-west direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "ns_step", "flag": "ns_step", "dataType": "String", "optional": true, "explanation": "Length of each spline step in the north-south direction", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Spline interpolation algorithm", "defaultValue": "bilinear", "alternatives": ["bilinear", "bicubic"], "isInputFile": false, "isOutputFile": false}, {"parameter": "lambda_i", "flag": "lambda_i", "dataType": "String", "optional": true, "explanation": "Tykhonov regularization parameter (affects smoothing)", "defaultValue": "0.01", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "solver", "flag": "solver", "dataType": "String", "optional": true, "explanation": "The type of solver which should solve the symmetric linear equation system", "defaultValue": "cholesky", "alternatives": ["cholesky", "cg"], "isInputFile": false, "isOutputFile": false}, {"parameter": "maxit", "flag": "maxit", "dataType": "String", "optional": true, "explanation": "Maximum number of iteration used to solve the linear equation system", "defaultValue": "10000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "error", "flag": "error", "dataType": "String", "optional": true, "explanation": "Error break criteria for iterative solver", "defaultValue": "0.000001", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "memory", "flag": "memory", "dataType": "String", "optional": true, "explanation": "Maximum memory to be used (in MB)", "defaultValue": "300", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.surf.bspline  performs a bilinear/bicubic spline\n interpolation with Tykhonov regularization. The  input  is a 2D\n or 3D vector  points  map. Values to interpolate can be the z\n values of 3D points or the values in a user-specified attribute column\n in a 2D or 3D vector map. Output can be a raster\n ( raster_output ) or vector ( output ) map.  Optionally, a\n \"sparse point\" vector map can be input which indicates the location\n of  output  vector points.\n ", "notes": "\n  From a theoretical perspective, the interpolating procedure takes \n place in two parts: the first is an estimate of the linear coefficients \n of a spline function is derived from the observation points using a \n least squares regression; the second is the computation of the \n interpolated surface (or interpolated vector points). As used here, the \n splines are 2D piece-wise non-zero polynomial functions calculated \n within a limited, 2D area. The length (in mapping units) of each spline \n step is defined by  ew_step  for the east-west direction and \n  ns_step  for the north-south direction. For optimal performance, \n the length of spline step should be no less than the distance between \n observation points. Each vector point observation is modeled as a \n linear function of the non-zero splines in the area around the \n observation. The least squares regression predicts the the coefficients \n of these linear functions. Regularization, avoids the need to have one \n observation and one coefficient for each spline (in order to avoid \n instability). \n  With regularly distributed data points, a spline step corresponding\n to the maximum distance between two points in both the east and north\n directions is sufficient. But often data points are not regularly\n distributed and require statistial regularization or estimation. In\n such cases, v.surf.bspline will attempt to minimize the gradient of\n bilinear splines or the curvature of bicubic splines in areas lacking\n point observations. As a general rule, spline step length should be\n greater than the mean distance between observation points (twice the\n distance between points is a good starting point). Separate east-west\n and north-south spline step length arguments allows the user to\n account for some degree of anisotropy in the distribution of\n observation points. Short spline step lengths - especially spline step\n lengths that are less than the distance between observation points -\n can greatly increase the processing time.\n  Moreover, the maximum number of splines for each direction at each\n time is fixed, regardless of the spline step length. As the total\n number of splines used increases (i.e., with small spline step\n lengths), the region is automatically split into subregions for\n interpolation. Each subregion can contain no more than 150x150\n splines. To avoid subregion boundary problems, subregions are created\n to partially overlap each other. A weighted mean of observations,\n based on point locations, is calculated within each subregion.\n  The Tykhonov regularization parameter ( lambda_i ) acts to\n smooth the interpolation. With a small  lambda_i , the\n interpolated surface closely follows observation points; a larger\n value will produce a smoother interpolation.\n  The input can be a 2D or 3D vector points map. If input is 3D\n and  column  is not given than z-coordinates are used for\n interpolation. Parameter  column  is required when input is 2D\n vector map.\n  v.surf.bspline  can produce a  raster_output  OR\n a  output  (but NOT simultaneously). Note that topology is not\n build for output vector point map. The topology can be built if\n required by  v.build .\n  If output is a vector points map and a  sparse  vector points\n map is not specified, the output vector map will contain points at the\n same locations as observation points in the input map, but the values\n of the output points are interpolated values. If instead\n a  sparse  vector points map is specified, the output vector map\n will contain points at the same locations as the sparse vector map\n points, and values will be those of the interpolated raster surface at\n those points.\n  A cross validation \"leave-one-out\" analysis is available to help to\n determine the optimal  lambda_i  value that produces an\n interpolation that best fits the original observation data. The more\n points used for cross-validation, the longer the time needed for\n computation. Empirical testing indicates a threshold of a maximum of\n 100 points is recommended. Note that cross validation can run very\n slowly if more than 100 observations are used. The cross-validation\n output reports  mean  and  rms  of the residuals from the\n true point value and the estimated from the interpolation for a fixed\n series of  lambda_i  values. No vector nor raster output will be\n created when cross-validation is selected.\n  EXAMPLES \n  Basic interpolation \n v.surf.bspline input=point_vector output=interpolate_surface method=bicubic\n A bicubic spline interpolation will be done and a vector points map\n with estimated (i.e., interpolated) values will be created.\n  Basic interpolation and raster output with a longer spline step \n v.surf.bspline input=point_vector raster=interpolate_surface ew_step=25 ns_step=25\n A bilinear spline interpolation will be done with a spline step length\n of 25 map units. An interpolated raster map will be created at the\n current region resolution.\n  Estimation of lambda_i parameter with a cross validation process \n v.surf.bspline -c input=point_vector \n  Estimation on sparse points \n v.surf.bspline input=point_vector sparse=sparse_points output=interpolate_surface\n An output map of vector points will be created, corresponding to the\n sparse vector map, with interpolated values.\n  Using attribute values instead z-coordinates \n v.surf.bspline input=point_vector raster=interpolate_surface layer=1 \n    column=attrib_column\n The interpolation will be done using the values\n in  attrib_column , in the table associated with layer 1.\n  North carolina location example using z-coordinates for interpolation \n g.region region=rural_1m res=2 -p\n v.surf.bspline input=elev_lid792_bepts raster=elev_lid792_rast \n    ew_step=5 ns_step=5 method=bicubic lambda_i=0.1\n  KNOWN ISSUES \n Known issues:\n In order to avoid RAM memory problems, an auxiliary table is needed\n for recording some intermediate calculations. This requires\n the  GROUP BY  SQL function is used, which is not supported by\n the DBF driver. For this reason, vector map output\n ( output ) is not permitted with the DBF driver. There are\n no problems with the raster map output from the DBF driver.\n  REFERENCES \n    Brovelli M. A., Cannata M., and Longoni U.M., 2004, LIDAR Data\n     Filtering and DTM Interpolation Within GRASS, Transactions in GIS,\n     April 2004, vol. 8, iss. 2, pp. 155-174(20), Blackwell Publishing Ltd \n    Brovelli M. A. and Cannata M., 2004, Digital Terrain model\n     reconstruction in urban areas from airborne laser scanning data: the\n     method and an example for Pavia (Northern Italy). Computers and\n     Geosciences 30, pp.325-331 \n    Brovelli M. A e Longoni U.M., 2003, Software per il filtraggio di\n     dati LIDAR, Rivista dell'Agenzia del Territorio, n. 3-2003, pp. 11-22\n     (ISSN 1593-2192) \n    Antolin R. and Brovelli M.A., 2007, LiDAR data Filtering with GRASS GIS for the \n     Determination of Digital Terrain Models. Proceedings of Jornadas de SIG Libre,\n     Girona, Espa\u00f1a. CD ISBN: 978-84-690-3886-9 \n ", "see_also": ["v.surf.idw", "v.surf.rst"], "authors": ["Original version (s.bspline.reg) in GRASS 5.4: Maria Antonia Brovelli, Massimiliano Cannata, Ulisse Longoni, Mirko Reguzzoni"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.surf.bspline"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.support.html", "name": "v.support", "definition": "- Updates vector map metadata.", "keywords": ["vector", "metadata"], "synopsis": "v.support [-rh] map=name  [organization=phrase]   [date=datestring]   [person=phrase]   [map_name=phrase]   [map_date=datestring]   [scale=integer]   [zone=integer]   [threshold=float]   [comment=phrase]   [cmdhist=command]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "r", "flag": "-r", "explanation": "Replace comment instead of appending it Replace command line instead of appending it Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "h", "flag": "-h", "explanation": "Replace command line instead of appending it Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "organization", "flag": "organization", "dataType": "String", "optional": true, "explanation": "Organization where vector map was created", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "date", "flag": "date", "dataType": "String", "optional": true, "explanation": "Date of vector map digitization (e.g., \"15 Mar 2007\")", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "person", "flag": "person", "dataType": "String", "optional": true, "explanation": "Person who created vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "map_name", "flag": "map_name", "dataType": "String", "optional": true, "explanation": "Vector map title", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "map_date", "flag": "map_date", "dataType": "String", "optional": true, "explanation": "Date when the source map was originally produced", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "scale", "flag": "scale", "dataType": "String", "optional": true, "explanation": "Vector map scale number (e.g., 24000)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zone", "flag": "zone", "dataType": "String", "optional": true, "explanation": "Vector map projection zone", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "threshold", "flag": "threshold", "dataType": "String", "optional": true, "explanation": "Vector map digitizing threshold number (e.g., 0.5)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "comment", "flag": "comment", "dataType": "String", "optional": true, "explanation": "Text to append to the comment line of the map's metadata file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cmdhist", "flag": "cmdhist", "dataType": "String", "optional": true, "explanation": "Command line to store into vector map history file (used for vector scripts)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.support  is used to set/update vector map metadata.\n  EXAMPLE \n # update scale to 1:24000\n v.support myvectmap scale=24000\n # update organization\n v.support myvectmap organization=\"OSGeo labs\"\n v.info myvectmap\n ", "notes": "", "see_also": ["v.build", "v.info"], "authors": ["Markus Neteler, Trento"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.support"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.split.html", "name": "v.split", "definition": "- Splits vector lines to shorter segments.", "keywords": ["vector", "geometry", "densification", "node", "segment", "vertex"], "synopsis": "v.split [-nf] input=name  [layer=string]  output=name  [length=float]   [units=string]   [vertices=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "n", "flag": "-n", "explanation": "Add new vertices, but do not split Applies only to 'length' option Force segments to be exactly of given length, except for last one Applies only to 'length' option Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "f", "flag": "-f", "explanation": "Force segments to be exactly of given length, except for last one Applies only to 'length' option Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "length", "flag": "length", "dataType": "String", "optional": true, "explanation": "Maximum segment length", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Length units", "defaultValue": "map", "alternatives": ["map", "meters", "kilometers", "feet", "surveyfeet", "miles", "nautmiles"], "isInputFile": false, "isOutputFile": false}, {"parameter": "vertices", "flag": "vertices", "dataType": "String", "optional": true, "explanation": "Maximum number of vertices in segment", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.split  splits vector lines into shorter segments using \n a maximal distance between nodes. The resulting length of all segments\n is expected to be equal and not higher than the given  length  \n parameter.\n  EXAMPLES \n The examples are based on the North Carolina sample data location.\n  Example 1: Inserting nodes to railroad lines map \n # extract one railroad line for this example\n v.extract input=railroads output=myrr cats=1\n # show line, category, direction (to find the beginning)\n g.region vector=myrr\n d.erase\n d.vect myrr display=shape,cat,dir\n # insert nodes at a distance not longer than 1000m\n v.split input=myrr output=myrr_split_1km length=1000\n d.vect myrr_split_1km display=shape,topo\n Note: In case that the vector line data are not polylines,\n generate first polylines as the second step, eg.:\n # join segments into polyline\n v.build.polylines input=myrr output=myrr_polylines\n # regenerate categories\n v.category input=myrr_polylines output=myrailroads option=add\n  Example 2: Inserting vertices to railroad lines map \n Note: first run the two steps from example 1.\n # insert vertices at a distance not longer than 1000m\n v.split -n input=myrr output=myrr_split length=1000\n d.vect myrr_split display=shape,topo\n ", "notes": "", "see_also": ["v.edit", "v.build.polylines", "v.to.points", "v.segment"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.split"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.select.html", "name": "v.select", "definition": "- Selects features from vector map (A) by features from other vector map (B).", "keywords": ["vector", "geometry", "spatial query"], "synopsis": "v.select [-tcr] ainput=name  [alayer=string]   [atype=string[,string,...]]  binput=name  [blayer=string]   [btype=string[,string,...]]  output=name operator=string  [relate=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "t", "flag": "-t", "explanation": "Do not create attribute table Do not skip features without category Reverse selection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "c", "flag": "-c", "explanation": "Do not skip features without category Reverse selection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Reverse selection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "ainput", "flag": "ainput", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "alayer", "flag": "alayer", "dataType": "String", "optional": true, "explanation": "Layer number (vector map A)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "atype", "flag": "atype", "dataType": "String", "optional": true, "explanation": "Feature type (vector map A)", "defaultValue": "point,line,area", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "binput", "flag": "binput", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "blayer", "flag": "blayer", "dataType": "String", "optional": true, "explanation": "Layer number (vector map B)", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "btype", "flag": "btype", "dataType": "String", "optional": true, "explanation": "Feature type (vector map B)", "defaultValue": "point,line,area", "alternatives": ["point", "line", "boundary", "centroid", "area"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "operator", "flag": "operator", "dataType": "String", "optional": false, "explanation": "Operator defines required relation between features", "defaultValue": "overlap", "alternatives": ["overlap", "equals", "disjoint", "intersects", "touches", "crosses", "within", "contains", "overlaps", "relate"], "isInputFile": false, "isOutputFile": false}, {"parameter": "relate", "flag": "relate", "dataType": "String", "optional": true, "explanation": "Intersection Matrix Pattern used for 'relate' operator", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.select  allows the user to select features from a vector \n map by features from another one.\n  Supported operators (without GEOS; using GRASS' own algorithm):\n    overlap  - features partially or completely overlap (GEOS equivalent: intersects)\n Supported operators (internally using\n  GEOS  - Geometry Engine, Open Source):\n    equals  - features are spatially equals \n    disjoint  - features do not spatially intersect \n    intersects  - features spatially intersect (equivalent to native 'overlap') \n    touches  - features spatially touches \n    crosses  - features spatially crosses \n    within  - feature A is completely inside feature B \n    contains  - feature B is completely inside feature A \n    overlaps  - features spatially overlap \n    relate  - feature A is spatially related to feature B \n ", "notes": "\n Only features with category numbers will be considered. If required\n the  v.category  module can be\n used to add them. Typically boundaries do not need to be given a\n category number, as an area's attributes are inherited from the\n centroid. Typically points, lines, and centroids will always want to\n have a cat number. E.g. take a road which separates two farms. It is\n ambiguous as to which farm an attribute that is attached to the road\n belongs to. The boundary only needs a cat number if it will hold its\n own attributes, such as road name or pavement form. A centroid in each\n paddock holds the information with respect to ownership, area, etc.\n  EXAMPLES \n Preparation of example data (North Carolina sample dataset):\n # Create an grid for overlaying to ZIP code vector map\n v.mkgrid map=boxgrid grid=10,10 position=coor \n           coordinates=583600,201500 box=5000,5000\n # set region to ZIP codes and boxgrid vector maps\n g.region vector=zipcodes_wake,boxgrid -p res=100 -a\n # enlarge region a bit for \"white border\" around map in monitor\n g.region n=n+1000 s=s-1000 w=w-1000 e=e+1000 -p\n d.mon wx0\n  OVERLAP: features partially or completely overlap (using GRASS) \n Select grid boxes (North Carolina sample dataset):\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=boxgrid fill_color=85:130:176\n v.select ainput=boxgrid binput=zipcodes_wake output=v_select_OVERLAP operator=overlap\n d.vect map=v_select_OVERLAP\n d.vect map=zipcodes_wake type=boundary color=50:50:50\n v.select with OVERLAP operator: selected grid boxes shown in grey\n  OVERLAPS features spatially overlap (using GEOS) \n Select grid boxes (North Carolina sample dataset):\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=boxgrid fill_color=85:130:176\n v.select ainput=boxgrid binput=zipcodes_wake output=v_select_OVERLAPS operator=overlaps\n d.vect map=v_select_OVERLAPS\n d.vect map=zipcodes_wake type=boundary color=50:50:50\n v.select with OVERLAPS operator: selected grid boxes shown in grey\n  DISJOINT: features do not spatially intersect (using GEOS) \n Select grid boxes (North Carolina sample dataset):\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=boxgrid fill_color=85:130:176\n v.select ainput=boxgrid binput=zipcodes_wake output=v_select_DISJOINT operator=disjoint\n d.vect map=v_select_DISJOINT\n d.vect map=zipcodes_wake type=boundary color=50:50:50\n v.select with DISJOINT operator: selected grid boxes shown in grey\n  EQUALS: features are spatially equals (using GEOS) \n Select zipcode polygon (North Carolina sample dataset):\n d.vect map=zipcodes_wake fill_color=0:128:0\n v.extract input=zipcodes_wake where=ZIPCODE_ID=35 output=zipcodeID35\n v.select ainput=zipcodes_wake binput=zipcodeID35 output=v_select_EQUALS operator=equals\n d.vect map=v_select_EQUALS\n d.vect map=zipcodes_wake type=boundary color=50:50:50\n v.select with EQUALS operator: selected grid boxes shown in grey\n  INTERSECTS: features spatially intersect (using GEOS) \n Select zipcode polygons (North Carolina sample dataset):\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=boxgrid fill_color=85:130:176\n v.select ainput=zipcodes_wake binput=boxgrid output=v_select_INTERSECTS operator=intersects\n d.vect map=v_select_INTERSECTS\n d.vect map=boxgrid type=boundary color=50:50:50\n v.select with INTERSECTS operator: selected grid boxes shown in grey\n  TOUCHES: features spatially touches (using GEOS) \n Select polygons (North Carolina sample dataset):\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=zipcodeID35 fill_color=85:130:176\n v.select ainput=zipcodes_wake binput=zipcodeID35 output=v_select_TOUCHES operator=touches\n d.vect map=v_select_TOUCHES\n d.vect map=zipcodes_wake type=boundary color=50:50:50\n v.select with TOUCHES operator: selected polygons shown in grey (blue: input polygon)\n  CROSSES: features spatially crosses (using GEOS) \n Select zipcode polygons by lines (North Carolina sample dataset):\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=busroute1 color=200:27:27 width=3\n v.select ainput=zipcodes_wake binput=busroute1 output=v_select_CROSSES operator=crosses\n d.vect map=v_select_CROSSES\n d.vect map=zipcodes_wake type=boundary color=50:50:50\n d.vect map=busroute1 color=200:27:27 width=3\n v.select with CROSSES operator: selected polygons shown in grey (red: input lines)\n  WITHIN feature A is completely inside feature B (using GEOS) \n Select zipcode polygons (North Carolina sample dataset):\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=boundary_county fill_color=85:130:176\n v.select ainput=zipcodes_wake binput=boundary_county output=v_select_WITHIN operator=within\n d.vect map=v_select_WITHIN\n v.select with WITHIN operator: selected polygons shown in grey (blue: input polygons)\n  CONTAINS feature B is completely inside feature A (using GEOS) \n Select zipcode polygon (North Carolina sample dataset):\n  CONTAINS with polygons \n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=zipcodeID35 fill_color=85:130:176\n v.select ainput=zipcodes_wake binput=zipcodeID35 \n           output=v_select_CONTAINS_pol operator=contains\n d.vect map=v_select_CONTAINS\n v.select with CONTAINS operator: selected polygon shown in grey (blue: input polygon, not visible)\n  CONTAINS with points \n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=hospitals fill_color=195:31:31 icon=basic/cross3 size=10\n v.select ainput=zipcodes_wake binput=hospitals \n           output=v_select_CONTAINS_pnts operator=contains\n d.vect map=v_select_CONTAINS_pnts\n d.vect map=hospitals fill_color=195:31:31 icon=basic/cross3 size=10\n v.select with CONTAINS operator: selected polygons shown in grey (red: input points)\n  RELATE feature A is spatially related to feature B (using GEOS) \n This operator additionally requires the  relate  parameter (in other\n GIS called 'ST_Relate').\n This operator allows calculating the\n  Dimensionally Extended nine-Intersection Model (DE-9IM) .\n In the following one example: Select polygon with 'TOUCHES' operator\n (North Carolina sample dataset):\n d.vect map=zipcodes_wake fill_color=0:128:0\n d.vect map=zipcodeID35 fill_color=85:130:176\n v.select ainput=zipcodeID35 binput=zipcodes_wake \n           output=v_select_TOUCHES_relate operator=relate relate='T********'\n d.vect map=v_select_TOUCHES\n The result of  relate='T********'  is the same as seen\n above in the example 'TOUCHES'.\n See the  DE-9IM  page\n for related operators and their definition.\n  Extraction of points falling into a polygon \n Extract fire stations (points) falling into urban area (polygon) - North Carolina\n data set (point in polygon test):\n v.select ainput=firestations binput=urbanarea output=urban_firestations \n           operator=overlap\n  Extraction of lines overlapping with a polygon \n Extract railroad lines from zip code map overlapping with the urban area\n (line in polygon test):\n v.select ainput=railroads binput=urbanarea \n           output=railroads_in_urbanarea operator=overlap\n  Extraction of areas overlapping with a line \n Extract those areas from zip code map which overlap with railroads\n (polygon on line test):\n # first add a tiny buffer around railroad lines:\n v.buffer input=railroads output=railroads_buf20m \n    distance=20\n v.select ainput=zipcodes_wake binput=railroads_buf20m \n    output=zipcodes_wake_railroads operator=overlap\n ", "see_also": ["v.category", "v.clip", "v.overlay", "v.extract"], "authors": ["Radim Blazek"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.select"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.segment.html", "name": "v.segment", "definition": "- Creates points/segments from input vector lines and positions.", "keywords": ["vector", "geometry", "node", "point", "segment", "vertex"], "synopsis": "v.segment input=name  [layer=string]  output=name  [rules=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector lines map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Name of file containing segment rules", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.segment  generates segments or points from input lines and from\n positions read from a text file or ' stdin '. It includes the creation \n of parallel lines or points in given destination from the line.\n  The format is:\n P <point id>   <line cat> <offset> [<side offset>]\n L <segment id> <line cat> <start offset> <end offset> [<side offset>]\n The offsets can be percent values of the line length. If the offsets are\n negative, they start from the end node of the line. -0 means the end of the\n line.\n  EXAMPLE \n The user could send to  stdin  something like:\n P 1 356 24.56\n P 2 495 12.31\n P 3 500 -12.31\n P 4 510 -20%\n ...\n (pipe or redirect from file into the command). \n ", "notes": "\n A segment is only created for the first line found of the specified category.\n  Points are generated along the lines at the given distance(s) or percent(s)\n of the line length from the beginning or end, if offsets are negative, of the\n vector line.\n  The side offset is the orthogonal distance from the line. Positive side\n offsets are to the right side of the line going forward, negative offsets\n are to the left ( d.vect  with  display=shape,dir  shows\n the direction of vector lines). As the segment distance is measured along the\n original line, side-offset lines will be longer than the start-end segment distance\n for outside corners of curving lines, and shorter for inside corners.\n  All offsets are measured in map units (see \" g.proj -p \") or percents\n of the line length, if followed by a % character.\n  To place a point in the middle of a line, 50% offset can be used or the\n  v.to.db  module may be used to find the line's length. Then half of\n that distance can be used as the along-line offset.\n  EXAMPLES \n The examples may be used in the North Carolina sample location.\n Example: Extract line segment from 400m to 5000m from beginning \n of line 1:\n # extract lines from railroad map:\n v.extract railroads out=myrr cats=1\n # join segments into polyline and reassign category numbers\n v.build.polylines myrr out=myrr_pol\n v.category myrr_pol out=myrailroads option=add\n # zoom to an area of interest\n g.region vector=myrailroads -p\n # show line, category, direction (to find the beginning)\n d.mon wx0\n d.vect myrailroads disp=shape,cat,dir lsize=12\n # extract line segment from 400m to 5000m from beginning of line 1\n echo \"L 1 1 400 5000\" | v.segment myrailroads out=myrailroads_segl\n d.erase\n d.vect myrailroads\n d.vect myrailroads_segl col=green width=2\n # set node at 5000m from beginning of line 1\n echo \"P 1 1 5000\" | v.segment myrailroads out=myrailroads_segp\n d.vect myrailroads_segp icon=basic/circle color=red fcolor=red size=5\n Extract line segment from 400m to 5000m from beginning\n of line 1\n Example: Create parallel 1km long line segments along first 8km of \n track, offset 500m to the left of the tracks.\n v.segment myrailroads out=myrailroads_segl_side << EOF\n L 1 1 1000 2000 -500\n L 2 1 3000 4000 -500\n L 3 1 5000 6000 -500\n L 4 1 7000 8000 -500\n EOF\n d.erase\n d.vect myrailroads disp=shape,dir\n d.vect -c myrailroads_segl_side width=2\n Example: A series of points, spaced every 2km along the tracks\n v.segment myrailroads out=myrailroads_pt2km << EOF\n P 1 1 1000\n P 2 1 3000\n P 3 1 5000\n P 4 1 7000\n EOF\n d.erase\n d.vect myrailroads disp=shape,dir\n d.vect myrailroads_pt2km icon=basic/circle color=blue fcolor=blue size=5\n A series of points, spaced every 2km along the tracks\n Example: A series of points, spaced every 2km along the tracks, offset 500m to the right\n v.segment myrailroads out=myrailroads_pt2kmO500m << EOF\n P 1 1 1000 500\n P 2 1 3000 500\n P 3 1 5000 500\n P 4 1 7000 500\n EOF\n d.erase\n d.vect myrailroads disp=shape,dir\n d.vect myrailroads_pt2kmO500m icon=basic/circle color=aqua fcolor=aqua size=5\n A series of points, spaced every 2km along the tracks, offset 500m to the right\n Example: A series of points, spaced every 10% of the line's length along the\n tracks from the end of the line up to the middle point, offset 500m to the right\n v.segment myrailroads out=myrailroads_pt10pctO500m << EOF\n P 1 1  -0% 500\n P 2 1 -10% 500\n P 3 1 -20% 500\n P 4 1 -30% 500\n P 5 1 -40% 500\n P 6 1 -50% 500\n EOF\n d.erase\n d.vect myrailroads disp=shape,dir\n d.vect myrailroads_pt10pctO500m icon=basic/circle color=red fcolor=black size=5\n A series of points, spaced every 10% of the line's length along the\n tracks from the end of the line up to the middle point, offset 500m to the right\n  KNOWN ISSUES \n There is a problem with side-offset parallel line generation for inside corners.\n ", "see_also": ["LRS tutorial", "d.vect", "v.build.polylines", "v.lrs.segment", "v.parallel", "v.split", "v.to.db", "v.to.points"], "authors": ["Radim Blazek, ITC-Irst, Trento, Italy"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.segment"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.sample.html", "name": "v.sample", "definition": "- Samples a raster map at vector point locations.", "keywords": ["vector", "sampling", "raster"], "synopsis": "v.sample input=name  [layer=string]  column=name output=name raster=name  [method=string]   [zscale=float]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector point map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column to use for comparison", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map to store differences", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": false, "explanation": "Name of raster map to be sampled", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "Sampling interpolation method", "defaultValue": "nearest", "alternatives": ["nearest", "bilinear", "bicubic"], "isInputFile": false, "isOutputFile": false}, {"parameter": "zscale", "flag": "zscale", "dataType": "String", "optional": true, "explanation": "Scaling factor for values read from raster map", "defaultValue": "1.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.sample  samples a GRASS raster map at the point\n locations in the input file by either cubic convolution\n interpolation, bilinear interpolation, or nearest neighbor\n sampling (default).\n  This program may be especially useful when sampling for\n cross validation of interpolations whose output is a raster\n map.\n ", "notes": "\n The output points will have the easting and northing of the input points.\n The input category value is used. The input attribute, raster value \n and difference is written to output.\n  When NULL values are encountered for a cell, zero value is used\n instead.  In these cases, more acurrate results may be obtained\n by using the default nearest neighbor comparisons.\n  This program may not work properly with lat-long data when\n the  -bc  flags are used.\n  When interpolation is done (i.e., the  -bc  flags are\n used), values are assumed to be located at the centroid of\n grid cells.  Therefore, current resolution settings are\n important.\n  EXAMPLE \n Comparison of \"elev_ned_30m\" and \"elev_srtm_30m\" North Carolina\n sample dataset elevation models at random positions:\n # set computational region:\n  g.region raster=elev_srtm_30m -p\n # generate random points:\n  v.random output=random n=100\n # add table with one column:\n  v.db.addtable random col=\"elev_srtm30 double precision\"\n # transfer elevations at random points into table:\n  v.what.rast map=random rast=elev_srtm_30m col=elev_srtm30\n # verify:\n  v.db.select random\n # perform sampling on other elevation map:\n  v.sample in=random col=elev_srtm30 rast=elev_ned_30m out=elev_samples\n #verify:\n  v.db.select elev_samples\n #univariate statistics of differences between elevation maps:\n  v.univar elev_samples column=diff type=point\n ", "see_also": ["g.region", "v.random", "v.what.rast"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.sample"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.report.html", "name": "v.report", "definition": "- Reports geometry statistics for vector maps.", "keywords": ["vector", "geometry", "statistics"], "synopsis": "v.report map=name  [layer=string]  option=string  [units=string]   [sort=string]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "option", "flag": "option", "dataType": "String", "optional": false, "explanation": "Value to calculate", "defaultValue": null, "alternatives": ["area", "length", "coor"], "isInputFile": false, "isOutputFile": false}, {"parameter": "units", "flag": "units", "dataType": "String", "optional": true, "explanation": "Units", "defaultValue": null, "alternatives": ["miles", "feet", "meters", "kilometers", "acres", "hectares", "percent"], "isInputFile": false, "isOutputFile": false}, {"parameter": "sort", "flag": "sort", "dataType": "String", "optional": true, "explanation": "Sort the result", "defaultValue": null, "alternatives": ["asc", "desc"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.report  generates a table showing the area present in \n each of the categories of a user-selected data layer.\n  Area is given in hectares, square meters, and square kilometers.\n If the units option is used, area is given in acres, square feet,\n and square miles.\n  Feet and acre units are always reported in their common versions\n (i.e. the International Foot, exactly 5280 feet in a mile), even\n when the location's standard map unit is the US Survey foot.\n  v.report  works on the full map data; therefore, the current\n region is ignored. If you wish to spatially limit the statistics,\n a map subset must be created with  v.in.region  and \n  v.overlay , and then run  v.report  on the new map.\n  EXAMPLE \n North Carolina sample dataset:\n v.report zipcodes_wake option=area units=hectares\n In the output, there is an extra column added containing the results.\n ", "notes": "", "see_also": ["v.in.region", "v.to.db", "v.overlay"], "authors": ["Markus Neteler, GDF Hannover"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.report"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.rectify.html", "name": "v.rectify", "definition": "- Rectifies a vector by computing a coordinate transformation for each object in the vector based on the control points.", "keywords": ["vector", "rectify", "level1"], "synopsis": "v.rectify [-3orb] input=name output=name  [group=name]   [points=name]   [rmsfile=name]   [order=integer]   [separator=character]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "3", "flag": "-3", "explanation": "Perform 3D transformation Perform orthogonal 3D transformation Print RMS errors Print RMS errors and exit without rectifying the input map Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "o", "flag": "-o", "explanation": "Perform orthogonal 3D transformation Print RMS errors Print RMS errors and exit without rectifying the input map Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "r", "flag": "-r", "explanation": "Print RMS errors Print RMS errors and exit without rectifying the input map Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "group", "flag": "group", "dataType": "String", "optional": true, "explanation": "Name of input imagery group", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "points", "flag": "points", "dataType": "String", "optional": true, "explanation": "Name of input file with control points", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "rmsfile", "flag": "rmsfile", "dataType": "String", "optional": true, "explanation": "Name of output file with RMS errors (if omitted or '-' output to stdout", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "order", "flag": "order", "dataType": "String", "optional": true, "explanation": "Rectification polynomial order (1-3)", "defaultValue": "1", "alternatives": ["1-3"], "isInputFile": false, "isOutputFile": false}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator for RMS report", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.rectify  uses control points to calculate a 2D or 3D \n transformation matrix based on a first, second, or third order \n polynomial and then converts x,y(, z) coordinates to standard map \n coordinates for each object in the vector map. The result is a vector \n map with a transformed coordinate system (i.e., a different coordinate\n system than before it was rectified).\n The  -o  flag enforces orthogonal rotation (currently for 3D only) \n where the axes remain orthogonal to each other, e.g. a cube with right \n angles remains a cube with right angles after transformation. This is not \n guaranteed even with affine (1 st  order) 3D transformation.\n Great care should be taken with the placement of Ground Control Points. \n For 2D transformation, the control points must not lie on a line, instead \n 3 of the control points must form a triangle. For 3D transformation, the \n control points must not lie on a plane, instead 4 of the control points \n must form a triangular pyramid. It is recommended to investigate RMS \n errors and deviations of the Ground Control Points prior to transformation.\n 2D Ground Control Points can be identified in \n  g.gui.gcp .\n 3D Ground Control Points must be provided in a text file with the \n  points  option. The 3D format is equivalent to the format for 2D \n ground control points with an additional third coordinate:\n  x y z east north height status\n where  x, y, z  are source coordinates,  east, north, height  \n are target coordinates and status (0 or 1) indicates whether a given \n point should be used. Numbers must be separated by space and must use a \n point (.) as decimal separator.\n If no  group  is given, the rectified vector will be written to \n the current mapset. If a  group  is given and a target has been \n set for this group with  i.target , \n the rectified vector will be written to the target location and mapset.\n  Coordinate transformation and RMSE \n  The desired order of transformation (1, 2, or 3) is selected with the\n  order  option.\n  v.rectify  will calculate the RMSE if the  -r  flag is \n given and print out statistcs in tabular format. The last row gives a \n summary with the first column holding the number of active points, \n followed by average deviations for each dimension and both forward and \n backward transformation and finally forward and backward overall RMSE.\n  2D linear affine transformation (1st order transformation) \n \t  x' = a1 + b1 * x + c1 * y\n \t  y' = a2 + b2 * x + c2 * y\n  3D linear affine transformation (1st order transformation) \n \t  x' = a1 + b1 * x + c1 * y + d1 * z\n \t  y' = a2 + b2 * x + c2 * y + d2 * z\n \t  z' = a3 + b3 * x + c3 * y + d3 * z\n The a,b,c,d coefficients are determined by least squares regression\n based on the control points entered.  This transformation\n applies scaling, translation and rotation. It is NOT a\n general purpose rubber-sheeting, nor is it ortho-photo\n rectification using a DEM, not second order polynomial,\n etc. It can be used if (1) you have geometrically correct\n data, and (2) the terrain or camera distortion effect can\n be ignored.\n  Polynomial Transformation Matrix (2nd, 3d order transformation) \n  v.rectify  uses a first, second, or third order transformation\n matrix to calculate the registration coefficients. The minimum number\n of control points required for a 2D transformation of the selected order\n (represented by n) is\n  ((n + 1) * (n + 2) / 2) \n or 3, 6, and 10 respectively. For a 3D transformation of first, second, \n or third order, the minimum number of required control points is 4, 10, \n and 20, respectively. It is strongly recommended that more than the \n minimum number of points be identified to allow for an overly-determined \n transformation calculation which will generate the Root Mean Square (RMS) \n error values for each included point. The polynomial equations are \n determined using a modified Gaussian elimination method.\n ", "notes": "", "see_also": ["Image Processing manual"], "authors": ["Markus Metz"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.rectify"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.reclass.html", "name": "v.reclass", "definition": "- Changes vector category values for an existing vector map according to results of SQL queries or a value in attribute table column.", "keywords": ["vector", "reclassification", "attributes"], "synopsis": "v.reclass input=name  [layer=string]   [type=string[,string,...]]  output=name  [column=name]   [rules=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line,boundary,centroid", "alternatives": ["point", "line", "boundary", "centroid"], "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "The name of the column whose values are to be used as new categories", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "rules", "flag": "rules", "dataType": "String", "optional": true, "explanation": "Full path to the reclass rule file", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.reclass  allows user to create a new vector map based on\n the reclassification of an existing vector map. It also allows the user\n to change the  key column  away from the default of \" cat \" with\n the  column  option.\n  Rules file may contain on each row either pair:\n keyword\u00a0value\n (separated by space) or comment beginning with '#' (hash). \n Definition of new category begins with keyword  cat  followed\n by the new category value.\n Keyword  where  specifies SQL where condition.\n ", "notes": "\n No table is created for the reclassed map if the  column  option is\n used and the column type is integer (as the result could contain ambiguities).\n If the  column  option is used and the column type is string, a new\n table is created containing the newly generated cat numbers and a single\n column containing the unique string column values, sorted in alphabetical\n order.\n  For dissolving common boundaries, see \n  v.dissolve .\n  EXAMPLES \n  Example 1: Reclass by rules \n v.reclass input=land output=land_u type=boundary rules=land.rcl\n the rules file contains :\n # land reclass file\n cat 1\n where use = 'E13' and owner = 'Jara Cimrman'\n cat 2\n where use = 'E14'\n Produces a new vector area map  land_u  containing boundaries from\n  land  with area category values selected from database by SQL\n select statement:\n  select id from tland where use = 'E13' and owner = 'Jara Cimrman' \n changed to category 1;\n values selected from database by SQL select statement: \n  select id from tland where use = 'E14'  changed to category 2.\n  Example 2: Reclass by attribute column \n (North Carolina sample dataset) \n v.reclass in=streams out=streams_by_type column=I_vs_P\n v.db.select streams_by_type\n cat|I_vs_P\n 1|intermittent\n 2|perennial\n  KNOWN ISSUES \n No table is created for reclassed layer if  rules  option is used.\n ", "see_also": ["v.dissolve", "v.extract"], "authors": ["R.L. Glenn, USDA, SCS, NHQ-CGIS"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.reclass"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.rast.stats.html", "name": "v.rast.stats", "definition": "- Calculates univariate statistics from a raster map based on a vector map and uploads statistics to new attribute columns.", "keywords": ["vector", "statistics", "raster", "univariate statistics", "zonal statistics", "sampling", "querying"], "synopsis": "v.rast.stats [-cd] map=name  [layer=string]  raster=name column_prefix=string  [method=string[,string,...]]   [percentile=integer]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Continue if upload column(s) already exist Create densified lines (default: thin lines) All cells touched by the line will be set, not only those on the render path Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "d", "flag": "-d", "explanation": "Create densified lines (default: thin lines) All cells touched by the line will be set, not only those on the render path Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster", "flag": "raster", "dataType": "String", "optional": false, "explanation": "Name of input raster map to calculate statistics from", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "column_prefix", "flag": "column_prefix", "dataType": "String", "optional": false, "explanation": "Column prefix for new attribute columns", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "method", "flag": "method", "dataType": "String", "optional": true, "explanation": "The methods to use", "defaultValue": "number,minimum,maximum,range,average,stddev,variance,coeff_var,sum,first_quartile,median,third_quartile,percentile", "alternatives": ["number", "minimum", "maximum", "range", "average", "stddev", "variance", "coeff_var", "sum", "first_quartile", "median", "third_quartile", "percentile"], "isInputFile": false, "isOutputFile": false}, {"parameter": "percentile", "flag": "percentile", "dataType": "String", "optional": true, "explanation": "Percentile to calculate", "defaultValue": "90", "alternatives": ["0-100"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.rast.stats  calculates basic univariate statistics from\n a raster map only for the parts covered by the specified vector map.\n The vector map will be rasterized according to the raster map resolution.\n Then univariate statistics are calculated per vector category (cat) from\n the raster map and the results uploaded to the vector map attribute table.\n A new column is generated in the attribute table for each statistic requested \n in  method  (if not already present).\n The univariate statistics include the number of raster cells counted, minimum\n and maximum cell values, range, average,  \n standard deviation, variance, coefficient of variation, sum, first quartile,\n median, third quartile, and percentile.\n ", "notes": "\n  v.rast.stats  is only meaningful for lines or polygons.\n   \n The module may take a long time to run if the raster region contains a large\n number of cells. In this case the  --verbose  flag may be used to track\n progress.\n  The script stops if a (prefixed) upload column is already present in the\n vector map attribute table, unless otherwise instructed with the  -c \n continue flag. The column prefix will be separated from the statistic name\n with an underscore. For example with a prefix of \" elev \" the sum\n column will be named  elev_sum .\n  If a DBF database is being used, note that column names are restricted by the\n DBF specification to 10 characters. Therefore it is advised to be economical\n in the use of the column prefix when using DBF as any additional characters\n will be chopped off.\n  If a MASK is present, it will be restored after the script finished.\n The script changes temporarily to the resolution of the given raster map.\n Large amounts of system memory can be used when extended statistics \n ( first_quartile,median,third_quartile,percentile  ) are being requested \n with a very large region setting. If the region is too large the module \n should display memory allocation errors. Basic statistics can be calculated \n using any size input region.\n  EXAMPLES \n Example to upload DEM statistics to ZIP codes vector map\n (North Carolina sample dataset):\n g.copy vect=zipcodes_wake,myzipcodes_wake\n # set computational region to DEM:\n g.region raster=elevation -p\n # calculate DEM statistics, upload to vector map table:\n v.rast.stats myzipcodes_wake raster=elevation \n    column_prefix=elev method=minimum,maximum,average,range,stddev,percentile \n    percentile=95\n # verify results:\n v.info -c myzipcodes_wake\n v.db.select myzipcodes_wake\n v.univar myzipcodes_wake column=elev_range type=centroid\n ", "see_also": ["r.univar", "v.univar", "v.vect.stats", "v.what.rast", "v.what.rast3", "v.what.vect"], "authors": ["Markus Neteler, CEA (for the"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.rast.stats"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.random.html", "name": "v.random", "definition": "- Generates random 2D/3D vector points.", "keywords": ["vector", "sampling", "statistics", "random", "point pattern", "stratified random sampling", "level1"], "synopsis": "v.random [-zab] output=name npoints=integer  [restrict=name]   [layer=string]   [cats=range]   [where=sql_query]   [zmin=float]   [zmax=float]   [seed=integer]   [column=name]   [column_type=string]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "z", "flag": "-z", "explanation": "Create 3D output Generate n points for each individual area (requires restrict parameter) Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "a", "flag": "-a", "explanation": "Generate n points for each individual area (requires restrict parameter) Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "npoints", "flag": "npoints", "dataType": "String", "optional": false, "explanation": "Number of points to be created", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "restrict", "flag": "restrict", "dataType": "String", "optional": true, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "cats", "flag": "cats", "dataType": "String", "optional": true, "explanation": "Category values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zmin", "flag": "zmin", "dataType": "String", "optional": true, "explanation": "Minimum z height (needs -z flag or column name)", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "zmax", "flag": "zmax", "dataType": "String", "optional": true, "explanation": "Maximum z height (needs -z flag or column name)", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "seed", "flag": "seed", "dataType": "String", "optional": true, "explanation": "The seed to initialize the random generator. If not set the process ID is used", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": true, "explanation": "Name of column for z values", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column_type", "flag": "column_type", "dataType": "String", "optional": true, "explanation": "Type of column for z values", "defaultValue": "double precision", "alternatives": ["integer", "double precision"], "isInputFile": false, "isOutputFile": false}], "description": "\n  v.random  randomly generates vector points within the\n current region using the selected random number generator.\n  v.random  can generate also 3D vector points or\n write random value to attribute table. Point height range or\n attribute value range is controlled by specifying zmin and zmax values.\n Both z values are included in range ( zmin <= z <= zmax ).\n Generated random attribute value type can be controlled by column\n data type. Use  INTEGER  column type for integers and \n  DOUBLE PRECISION  for floating point numbers. Integer values are\n calculated by rounding random floating point number.\n  To produce repeatable results a random seed can be set using the\n option  seed .\n  Restriction to vector areas \n If an  input  vector map with areas is specified, the location of \n random points is restricted to the selected areas. By default, the \n requested number of points are distributed across all areas.\n If the  -a  flag is given, the requested number of points is \n generated for each individual area. For example, if 20 points should be \n generated and the input map has 100 individual areas, 2000 points will \n be generated in total.\n  EXAMPLES \n All examples are based on the North Carolina sample dataset.\n  Generating random points in 2D \n Generate 20 random points with binary attributes (only 0 or 1):\n v.random output=binary_random npoints=20 zmin=0 zmax=1 column='binary'\n v.db.select binary_random\n cat|binary\n 1|0.63495\n 2|0.233421\n 3|0.489302\n 4|0.748264\n 5|0.505556\n 6|0.32975\n [...]\n v.univar -d binary_random\n Calculating geometric distances between 20 primitives...\n [...]\n minimum: 148.515\n maximum: 16572.8\n [...]\n  Generating random points in 2D with binary attributes \n Generate 20 random points with binary attributes (only 0 or 1):\n v.random output=binary_random npoints=20 zmin=0 zmax=1 \n           column='binary' column_type=integer\n v.db.select binary_random\n cat|binary\n 1|0\n 2|0\n 3|0\n 4|0\n 5|1\n 6|0\n [...]\n  Generating random points in 3D \n Generate 20 random 3D points using a specific random seed:\n v.random seed=52 output=height_random npoints=40 zmin=110 zmax=170 -z\n v.univar -d height_random\n Calculating geometric distances between 40 primitives...\n [...]\n minimum: 334.889\n maximum: 18351.9\n range: 18017\n sum: 5.38425e+06\n mean: 7266.2\n mean of absolute values: 7266.2\n population standard deviation: 3563.95\n [...]\n skewness: 0.34703\n Random points with different X, Y, and Z coordinates\n  Generating random points in selected polygons \n Generate 3 random points only in selected polygons (\"RALEIGH\" related ZIP\n code areas):\n v.random restrict=zipcodes_wake output=zipcodes_local_random_n3 npoints=3 \n    where=\"ZIPNAME = 'RALEIGH'\" -a \n # visualization\n d.mon wx0\n d.vect zipcodes_wake\n d.vect zipcodes_wake fcolor=yellow where=\"ZIPNAME = 'RALEIGH'\"\n d.vect zipcodes_local_random_n3 color=red icon=basic/circle\n  Fixd number of random points generated in selected polygons \n  Generating random adjacent polygons \n To generate random adjacent polygons, first the centroids are generated as\n points, then a triangulation is run (North Carolina sample dataset:\n g.region vector=nc_state\n v.random output=randpoints6k npoints=6000\n v.voronoi input=randpoints6k output=randareas6k\n v.info -t randareas6k\n v.category randareas6k option=print\n # plot vector polygons\n d.mon wx0\n d.vect randareas6k -c\n  \n Random adjacent polygons from random points (here: used as centroids)\n To eventually obtain isolated polygons, selected polygons can be extracted with\n  v.extract .\n These vector polygons can also be rasterized:\n # rasterize polygons\n # note: rastermaps must result in at least 6k pixel in this example\n g.region vector=nc_state res=500 -p -a\n v.to.rast randareas6k out=randareas6k use=cat\n r.colors randareas6k color=random\n d.rast randareas6k\n  Random sampling from raster map \n Generate 20 random samples from a raster map:\n g.region -p raster=elevation\n v.random output=random_samples npoints=20\n v.db.addtable map=random_samples columns='cat INTEGER, sample DOUBLE PRECISION'\n v.what.rast map=random_samples raster=elevation column=sample\n v.db.select random_samples\n cat|sample\n 1|103.9935\n 2|129.1266\n 3|96.01388\n [...]\n  Random sampling from vector map \n Generate 20 random points and sample attribute data from geology (vector) map:\n g.region -p vector=geology\n v.random output=random_samples npoints=20\n v.db.addtable map=random_samples columns='cat integer, geology varchar(100)'\n v.what.vect map=random_samples column=geology \n    query_map=geology query_layer=1 query_column=GEO_NAME \n v.db.select random_samples\n cat|geology\n 1|PzZm\n 2|\n 3|Zatm\n [...]\n  Stratified random sampling: Random sampling from vector map by attribute \n Generate 20 random points restricted to forested areas:\n g.region -p raster=landclass96\n r.to.vect -v input=landclass96 output=landclass96 type=area\n v.random restrict=landclass96 output=random_samples npoints=20 \n    where=\"label = 'forest'\" layer=1\n Random points only sampled in forested areas (stratified random sampling)\n  Stratified random sampling: Random sampling from vector map with spatial constraints \n Generating n points for each individual area: in this example two random\n points in each water body:\n g.region -p raster=landclass96\n r.to.vect -v input=landclass96 output=landclass96 type=area\n v.random restrict=landclass96 output=random_samples npoints=2 \n    where=\"label = 'water'\" layer=1 -a\n Two random points sampled in each individual water body (stratified\n random sampling)\n ", "notes": "", "see_also": ["g.region", "r.random", "v.db.addtable", "v.perturb", "v.sample", "v.univar", "v.what.rast", "v.what.vect"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.random"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.qcount.html", "name": "v.qcount", "definition": "- Indices for quadrat counts of vector point lists.", "keywords": ["vector", "statistics", "point pattern"], "synopsis": "v.qcount [-g] input=name  [layer=string]   [output=name]  nquadrats=integer radius=float  [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "g", "flag": "-g", "explanation": "Print results in shell script style Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output quadrat centers map (number of points is written as category)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "nquadrats", "flag": "nquadrats", "dataType": "String", "optional": false, "explanation": "Number of quadrats", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "radius", "flag": "radius", "dataType": "String", "optional": false, "explanation": "Quadrat radius", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.qcount  computes six different quadrat count statistics that provide\n a measure of how much an user defined point pattern departs from a complete\n spatial random point pattern.\n  Points are distributed following a complete spatial randomness (CSR) pattern\n if events are equally likely to occur anywhere within an area. There are two\n types departure from a CSR: regularity and clustering. Figure 1 gives an example\n of a complete random, regular and a clustered pattern.\n  Figure 1: Realization of two-dimensional Poisson processes of 50 points on\n the unit square exhibiting (a) complete spatial randomness, (b) regularity, and\n (c) clustering. \n  Various indices and statistics measure departure from CSR. The\n  v.qcount  function implements six different  quadrat count \n indices that are described in Cressie (1991; p. 590-591)[1] and in Ripley (1981;\n p. 102-106)[2] and summarized in Table 1.\n  Table 1: Indices for Quadrat Count Data. Adapted from\n Cressie [1], this table shows the statistics computed for the\n quadrats in Figure 2. \n  These indices are computed as follows:  v.qcount  chooses\n  nquadrads  circular quadrats of radius  radius  such that they are\n completely within the bounds of the current region and no two quadrats overlap.\n The number of points falling within each quadrat are counted and indices are\n calculated to estimate the departure of point locations from complete spatial\n randomness. This is illustrated in Figure 2.\n  Figure 2: Randomly placed quadrats (n = 100) with 584 sample points. \n ", "notes": "\n This program may not work properly with lat-long data. It uses\n  hypot()  in two files:  count.c  and\n  findquads.c .\n ", "see_also": ["v.random"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.qcount"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.proj.html", "name": "v.proj", "definition": "- Re-projects a vector map from one location to the current location.", "keywords": ["vector", "projection", "transformation", "import"], "synopsis": "v.proj [-lzwb] location=name  [mapset=name]   [input=name]   [dbase=path]   [smax=float]   [output=name]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "l", "flag": "-l", "explanation": "List vector maps in input mapset and exit Assume z coordinate is ellipsoidal height and transform if possible 3D vector maps only Disable wrapping to -180,180 for latlon output Latlon output only, default is -180,180 Do not build vector topology Recommended for massive point projection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Assume z coordinate is ellipsoidal height and transform if possible 3D vector maps only Disable wrapping to -180,180 for latlon output Latlon output only, default is -180,180 Do not build vector topology Recommended for massive point projection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "w", "flag": "-w", "explanation": "Disable wrapping to -180,180 for latlon output Latlon output only, default is -180,180 Do not build vector topology Recommended for massive point projection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "b", "flag": "-b", "explanation": "Do not build vector topology Recommended for massive point projection Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "location", "flag": "location", "dataType": "String", "optional": false, "explanation": "Location containing input vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "mapset", "flag": "mapset", "dataType": "String", "optional": true, "explanation": "Mapset containing input vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": true, "explanation": "Name of input vector map to re-project", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "dbase", "flag": "dbase", "dataType": "String", "optional": true, "explanation": "Path to GRASS database of input location", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "smax", "flag": "smax", "dataType": "String", "optional": true, "explanation": "Maximum segment length in meters in output vector map", "defaultValue": "10000", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map (default: input)", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}], "description": "\n  v.proj  allows a user to convert a vector map in a specified mapset\n of a specified location (different from current) with projection of input\n location to the vector map in a current mapset of current location with\n projection of current location (both projections are defined by\n corresponding PROJ_INFO files). The projection information is taken from the\n current PROJ_INFO files, as set and viewed with\n  g.proj .\n ", "notes": "\n If  output  is not specified it is set to be the same as input map\n name.\n If  mapset  is not specified, its name is assumed to be the same\n as the current mapset's name.\n If  dbase  is not specified it is assumed to be the current\n database. The user only has to specify  dbase  if the source\n location is stored in another separate GRASS database.\n If  smax  is set to  0  the automated vertex densification is\n disabled (not recommended).\n  v.proj  supports general datum transformations, making use of the\n  PROJ.4  co-ordinate system translation library.\n  When projecting into a latlon location, east coordinates are wrapped \n by the proj4 library to fit into the range -180,180. This is in most cases \n appropriate, but can cause errors the input vector crosses the datum line \n at 180E/W. In this case wrapping of east coordinates to -180,180 needs \n to be disabled with the  -w  flag.\n  When reprojecting massive point clouds for which topology is not necessary,\n the user can set the  -b  flag to suppress the building of topology of\n the output map.\n In order to preserve spatial detail,  v.proj  performs automated\n vertex densification (as an alternative,  v.split \n could be used before reprojecting. Without vertex densification, depending on\n the source and target CRS (Coordinate Reference System), geometries can be\n substantially deformed (straight lines become curves, squares become\n trapezoids, etc). The densification of linear features can help to avoid \n topological errors.\n  EXAMPLES \n v.proj in=mymap location=latlong mapset=user1\n  REFERENCES \n     Evenden, G.I.  (1990)  Cartographic\n       projection procedures for the UNIX environment - a user's manual. \n     USGS Open-File Report 90-284 (OF90-284.pdf)\n     See also there: Interim Report and 2nd Interim Report on Release 4, Evenden 1994).\n     Richards, John A. (1993), Remote Sensing Digital Image Analysis,\n     Springer-Verlag, Berlin, 2nd edition.\n  PROJ 4 : Projection/datum support library.\n  Further reading \n      ASPRS Grids and Datum \n      Projections Transform List  (PROJ.4)\n      MapRef -\n       The Collection of Map Projections and Reference Systems for Europe  \n      Information and Service System for European Coordinate Reference Systems - CRS \n      Cartographical Map Projections  by Carlos A. Furuti\n ", "see_also": ["g.proj", "m.proj", "r.proj", "i.rectify", "r.stats", "v.sample", "v.split", "v.surf.idw", "v.surf.rst"], "authors": ["Irina Kosinovsky, US ARMY CERL"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.proj"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.profile.html", "name": "v.profile", "definition": "- Vector map profiling tool", "keywords": ["vector", "profile", "transect"], "synopsis": "v.profile [-cz] input=name  [type=string[,string,...]]   [where=sql_query]   [layer=string]   [output=string]   [separator=character]   [dp=integer]  buffer=float  [map_output=name]   [coordinates=east,north[,east,north,...]]   [profile_map=name]   [profile_where=sql_query]   [profile_layer=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "c", "flag": "-c", "explanation": "Do not print column names Do not print 3D vector data (z values) Only affects 3D vectors Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "z", "flag": "-z", "explanation": "Do not print 3D vector data (z values) Only affects 3D vectors Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "type", "flag": "type", "dataType": "String", "optional": true, "explanation": "Input feature type", "defaultValue": "point,line", "alternatives": ["point", "line"], "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Path to output text file or - for stdout", "defaultValue": "-", "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "separator", "flag": "separator", "dataType": "String", "optional": true, "explanation": "Field separator", "defaultValue": "pipe", "alternatives": ["pipe", "comma", "space", "tab", "newline"], "isInputFile": false, "isOutputFile": false}, {"parameter": "dp", "flag": "dp", "dataType": "String", "optional": true, "explanation": "Number of significant digits", "defaultValue": "2", "alternatives": ["0-32"], "isInputFile": false, "isOutputFile": false}, {"parameter": "buffer", "flag": "buffer", "dataType": "String", "optional": false, "explanation": "Buffer (tolerance) for points in map units", "defaultValue": "10", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "map_output", "flag": "map_output", "dataType": "String", "optional": true, "explanation": "Name for profile line and buffer output map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "coordinates", "flag": "coordinates", "dataType": "String", "optional": true, "explanation": "Coordinates for profiling line nodes", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "profile_map", "flag": "profile_map", "dataType": "String", "optional": true, "explanation": "Profiling line map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "profile_where", "flag": "profile_where", "dataType": "String", "optional": true, "explanation": "WHERE conditions for input profile line map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "profile_layer", "flag": "profile_layer", "dataType": "String", "optional": true, "explanation": "Profiling line map layer", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.profile  prints out distance and attributes of points/lines\n along a profiling line. Distance is calculated from the first profiling line\n coordinate pair or from the beginning of vector line. \n The  buffer  (tolerance) parameter sets how far point can be\n located from a profiling line and still be included in the output data set. \n The  output  map option can be used to visually check which points are\n profiled. The  buffer  (tolerance) setting does not affect lines.\n Lines are sampled at their crossing point with profiling line.\n By default Z values are printed if input vector is a 3D map. It can be\n disabled with the  -z  flag. \n The profiling line can be provided as N,E coordinate pairs or from an\n input vector map. As a profiling line must be a single line, the user\n should use the  profile_where  parameter to select a single line\n from a profile input map if it contains multiple vector features.\n ", "notes": "\n Currently the module can profile only points and lines (including 3D ones).\n Areas and other complex features are not supported. If in future users can\n provide reasonable examples how area sampling should work and why it is\n important, area (or any other feature type) sampling can be added.\n Due to bugs in GRASS native buffering algorithms, this module for now\n depends on GEOS and will not function if GRASS is compiled without GEOS.\n This restriction will be removed as soon as GRASS native buffer generation\n is fixed.\n  EXAMPLES \n List all geonames along part of road NC-96 (NC Basic dataset).\n The output will be stored in a file for later usage.\n We will use comma as delimiter and three numbers after decimal\n separator for distance. Output file will contain data for all points,\n that are within 500 m range to profiling line.\n v.profile input=geonames@PERMANENT output=/home/user/NC_96_geonames.csv\n    separator=comma dp=3 buffer=500 profile_map=roadsmajor@PERMANENT profile_where=cat=56\n # Now lets see the output:\n cat NC_96_geonames.csv\n Number,Distance,cat,GEONAMEID,NAME,ASCIINAME,ALTERNATEN,FEATURECLA,FEATURECOD,COUNTRYCOD,CC2,ADMIN1,POPULATION,ELEVATION,GTOPO30,TIMEZONE,MODIFICATI,PPLKEY,SRC_ID,MAINT_ID\n 1,360.719,26881,4482019,\"New Zebulon Elementary School\",\"New Zebulon Elementary School\",\"\",\"S\",\"SCH\",\"US\",\"\",\"NC\",0,106,91,\"America/Iqaluit\",\"2006-01-15 00:00:00\",0,0,0\n 2,846.806,22026,4476596,\"Little River, Township of\",\"Little River, Township of\",\"\",\"A\",\"ADMD\",\"US\",\"\",\"NC\",0,0,91,\"America/Iqaluit\",\"2006-01-15 00:00:00\",0,0,0\n 3,2027.918,16681,4470608,\"Hendricks Pond\",\"Hendricks Pond\",\"\",\"H\",\"RSV\",\"US\",\"\",\"NC\",0,0,91,\"America/Iqaluit\",\"2006-01-15 00:00:00\",0,0,0\n 4,2027.918,16690,4470622,\"Hendricks Dam\",\"Hendricks Dam\",\"\",\"S\",\"DAM\",\"US\",\"\",\"NC\",0,0,91,\"America/Iqaluit\",\"2006-01-15 00:00:00\",0,0,0\n 5,2999.214,39338,4496159,\"Union Chapel\",\"Union Chapel\",\"\",\"\",\"\",\"US\",\"\",\"NC\",0,0,96,\"America/Iqaluit\",\"2006-01-15 00:00:00\",0,0,0\n 6,3784.992,43034,4500325,\"Zebulon Airport\",\"Zebulon Airport\",\"\",\"S\",\"AIRP\",\"US\",\"\",\"NC\",0,108,98,\"America/Iqaluit\",\"2006-01-15 00:00:00\",0,0,0\n Create river valley crossection and provide river marker (Spearfish dataset):\n # Take elevation samples\n r.profile input=elevation.dem@PERMANENT output=/home/user/elevation.profile \n    profile=600570.27364,4920613.41838,600348.034348,4920840.38617\n # Now get distance to place where river marker should be set\n v.profile input=streams@PERMANENT output=/home/user/river_profile.csv \n    east_north=600570.27364,4920613.41838,600348.034348,4920840.38617\n  BUGS \n Strings are enclosed in double quotes \", still quotes within string are\n not escaped.\n Output does not contain Vector CAT values. Only way how to get CAT value is from\n the attribute table.\n If sampled feature (point, line) contains multiple attribute entries\n (has multiple CAT values), only the first one is reported. If this is a\n limitation in some practical use case, a feature request in GRASS GIS\n issue tracker should be opened.\n ", "see_also": ["r.profile", "Linear Referencing System"], "authors": ["Maris Nartiss"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.profile"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.perturb.html", "name": "v.perturb", "definition": "- Random location perturbations of vector points.", "keywords": ["vector", "geometry", "statistics", "random", "point pattern", "level1"], "synopsis": "v.perturb [-b] input=name  [layer=string]  output=name  [distribution=string]  parameters=float[,float,...]  [minimum=float]   [seed=integer]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "b", "flag": "-b", "explanation": "Do not build topology Advantageous when handling a large number of points Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name ('-1' for all layers)", "defaultValue": "-1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": false, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "distribution", "flag": "distribution", "dataType": "String", "optional": true, "explanation": "Distribution of perturbation", "defaultValue": "uniform", "alternatives": ["uniform", "normal"], "isInputFile": false, "isOutputFile": false}, {"parameter": "parameters", "flag": "parameters", "dataType": "String", "optional": false, "explanation": "Parameter(s) of distribution", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "minimum", "flag": "minimum", "dataType": "String", "optional": true, "explanation": "Minimum deviation in map units", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "seed", "flag": "seed", "dataType": "String", "optional": true, "explanation": "Seed for random number generation", "defaultValue": "0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.perturb \n reads a vector map of points and writes the same points but\n  perturbs  the eastings and northings by adding either a uniform\n or normal delta value. Perturbation means that a variating spatial\n deviation is added to the coordinates.\n ", "notes": "\n The uniform distribution is always centered about zero.\n The associated  parameter  is constrained to be positive and\n specifies the maximum of the distribution; the minimum is\n the negation of that parameter. Do perturb into a ring around the\n center, the  minimum  parameter can be used.\n Usually, the mean (first parameter) of the normal\n distribution is zero (i.e., the distribution is centered at\n zero). The standard deviation (second parameter) is\n naturally constrained to be positive.\n Output vector points are not guaranteed to be contained within the\n current geographic region.\n  EXAMPLES \n  Random, uniformly distributed selection \n To create a random, uniformly distributed selection of possible new points\n with a radius of 100,000 map units, use the following command:\n v.perturb input=comm_colleges output=uniform_perturb parameters=100000\n Your map should look similar to this figure:\n  Figure: Map showing the actual community college points and uniformly\n    random chosen points. \n  Normal distributed selection \n For a normal distribution with a mean of 5000 and standard deviation of\n 2000, use the following command:\n v.perturb input=comm_colleges output=normal_perturb distribution=normal parameters=5000,2000\n  \n  Figure: Map showing the actual community college points and normally\n    random chosen and colored points. Notice that each point is closer\n    to the original point. \n  Normal distributed selection with a minimum value \n In order to include a minimum value of 500, use the following command:\n v.perturb input=comm_colleges output=min_perturb distribution=normal parameters=100000,1000 minimum=500\n ", "see_also": ["v.random", "v.univar"], "authors": [""], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.perturb"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.what.vect.html", "name": "v.what.vect", "definition": "- Uploads vector values at positions of vector points to the table.", "keywords": ["vector", "sampling", "database", "position", "querying", "attribute table"], "synopsis": "v.what.vect map=name  [layer=string]  column=name query_map=name  [query_layer=string]  query_column=name  [dmax=float]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector points map for which to edit attributes", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column to be updated with the query result", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "query_map", "flag": "query_map", "dataType": "String", "optional": false, "explanation": "Name of vector map to be queried", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "query_layer", "flag": "query_layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "query_column", "flag": "query_column", "dataType": "String", "optional": false, "explanation": "Name of attribute column to be queried", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "dmax", "flag": "dmax", "dataType": "String", "optional": true, "explanation": "Maximum query distance in map units", "defaultValue": "0.0", "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.what.vect  transfers attributes from the  query_map 's map\n attribute table into the attribute table of  points  present in the\n  map  map. The script is based on  v.distance .\n ", "notes": "\n The upload  column , into which the query results are stored, must be\n present in the  map  map. Use  v.db.addcolumn  to add one if needed.\n  Use dmax parameter to control query distance tolerance (how far points/centroids\n can be from  query_map  features). For more options, use\n  v.distance  instead.\n  In case of a multipoint input  map  map, with several points having the\n same category number, it can happen, that the query result is NULL, if the same\n category number falls into different  query_map  polygons.\n  When transferring attributes from a point map to a polygon map, usually  dmax \n has to be larger than zero (determined by distance between query points and\n polygon centroids).\n  In case that one or both input vector maps are 3D, features need to touch also\n in the 3rd dimension (z coordinate) in order to transfer attributes.\n  EXAMPLES \n In this example, the 'hospitals' point map in the North Carolina location is\n copied to the current mapset, a new attribute column is added and the urban\n names from the 'urbanarea' polygon map are transferred to the 'myhospitals'\n map at the hospital points' locations:\n g.copy vect=hospitals,myhospitals\n v.db.addcolumn myhospitals column=\"urb_name varchar(25)\"\n v.what.vect myhospitals query_map=urbanarea column=urb_name query_column=NAME\n # verification:\n v.db.select myhospitals\n In this example, city names, population data and more from\n  Geonames.org country files  are\n transferred to selected EU CORINE landuse/landcover classes\n (\"Continuous urban fabric\", 111, and \"Discontinuous urban fabric\", 112).\n Note: Example in UTM projection to which the input maps have been projected\n beforehand to have metric distances support:\n # extract populated places from geonames\n v.extract geonames_IT where=\"featurecla='P'\" output=geonames_IT_cities\n # add new column \n v.db.addcol corine_code111_112_cities column=\"gnameid double precision\"\n # transfer geonameid (3000m maximal distance between points and centroids)\n v.what.vect corine_code111_112_cities query_map=geonames_IT_cities column=gnameid \n              query_column=geonameid dmax=3000\n # now gnameid can be used for v.db.join to join further\n # attributes in from geonames.org\n ", "see_also": ["v.db.addcolumn", "v.db.select", "v.distance", "v.rast.stats", "v.what.rast", "v.what.rast3", "v.vect.stats"], "authors": ["Markus Neteler"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.what.vect"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.what.strds.html", "name": "v.what.strds", "definition": "- Uploads space time raster dataset values at positions of vector points to the table.", "keywords": ["vector", "temporal", "sampling", "position", "querying", "attribute table", "time"], "synopsis": "v.what.strds [-u] input=name strds=name[,name,...]  [output=name]   [where=sql_query]   [t_where=sql_query]   [--overwrite]  [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "u", "flag": "-u", "explanation": "Update attribute table of input vector map Instead of creating a new vector map update the attribute table with value(s) Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "overwrite", "flag": "--overwrite", "explanation": "Allow output files to overwrite existing files Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "input", "flag": "input", "dataType": "String", "optional": false, "explanation": "Name of input vector map", "defaultValue": null, "alternatives": null, "isInputFile": true, "isOutputFile": false}, {"parameter": "strds", "flag": "strds", "dataType": "String", "optional": false, "explanation": "Name of the input space time raster datasets", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "output", "flag": "output", "dataType": "String", "optional": true, "explanation": "Name for output vector map", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": true}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "t_where", "flag": "t_where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword used in the temporal GIS framework", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.what.strds  retrieves raster values from a given space-time raster datasets\n (STRDS) using a point vector map.\n ", "notes": "\n TBD.\n  EXAMPLES \n v.what.strds input=mypoints strds=mystrds output=newvector\n ", "see_also": ["v.what.rast", "t.vect.observe.strds"], "authors": ["Luca Delucchi"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/scripts/v.what.strds"},
{"manual_url": "https://grass.osgeo.org/grass77/manuals/v.what.rast3.html", "name": "v.what.rast3", "definition": "- Uploads 3D raster values at positions of vector points to the table.", "keywords": ["vector", "sampling", "raster", "position", "querying", "attribute table", "surface information"], "synopsis": "v.what.rast3 map=name  [layer=string]  raster_3d=name column=name  [where=sql_query]   [--help]  [--verbose]  [--quiet]  [--ui]", "parameters": [{"parameter": "help", "flag": "--help", "explanation": "Print usage summary Verbose module output Quiet module output", "optional": true}, {"parameter": "verbose", "flag": "--verbose", "explanation": "Verbose module output Quiet module output", "optional": true}, {"parameter": "quiet", "flag": "--quiet", "explanation": "Quiet module output", "optional": true}, {"parameter": "ui", "flag": "--ui", "explanation": "", "optional": true}, {"parameter": "map", "flag": "map", "dataType": "String", "optional": false, "explanation": "Name of vector points map for which to edit attributes", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "layer", "flag": "layer", "dataType": "String", "optional": true, "explanation": "Layer number or name", "defaultValue": "1", "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "raster_3d", "flag": "raster_3d", "dataType": "String", "optional": false, "explanation": "Name of existing 3D raster map to be queried", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "column", "flag": "column", "dataType": "String", "optional": false, "explanation": "Name of attribute column to be updated with the query result", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}, {"parameter": "where", "flag": "where", "dataType": "String", "optional": true, "explanation": "WHERE conditions of SQL statement without 'where' keyword", "defaultValue": null, "alternatives": null, "isInputFile": false, "isOutputFile": false}], "description": "\n  v.what.rast3  reads 3D raster value for each point in the vector and updates  col  \n column in vector attribute table by this value. The column should be type double. This module is based on \n  v.what.rast .\n If more points have the same category, attribute value is set to NULL.\n If 3D raster values is NULL, attribute value is set to NULL.\n ", "notes": "\n  EXAMPLES \n A) Reading values from 3D raster map at position of vector points, writing these values\n    into a column of the attribute table connected to the vector map:\n v.what.rast3 map=pnts raster3d=plume column=concentration\n B) In case of a vector map without attached attribute table, first add\n a new attribute table. This table is then populated with values\n queried from the raster map:\n # create new random 3d vector points map\n v.random -z output=pnts npoints=100 zmin=0  zmax=50\n # add new table, link to map\n v.db.addtable map=pnts column=\"concentration double precision\"\n # query raster map and upload values to vector table into specified column\n g.region raster3d=plume -p\n v.what.rast3 map=pnts raster3d=plume column=concentration\n # verify new attribute table:\n v.db.select map=pnts\n # verify statistics of uploaded values:\n v.univar map=pnts column=concentration type=point\n ", "see_also": ["v.db.addtable", "v.db.select", "v.what.rast", "v.what.vect", "v.univar"], "authors": ["Soeren Gebbert, heavily based on v.what.rast by Radim Blazed"], "source_code": "https://trac.osgeo.org/grass/browser/grass/trunk/vector/v.what.rast3"}
]